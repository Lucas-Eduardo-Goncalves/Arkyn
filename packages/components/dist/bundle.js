import * as Ve from "react";
import Ce, { createContext as Ze, useContext as Oe, Children as Ft, forwardRef as Hs, memo as Me, useState as P, useRef as qe, useEffect as y, useMemo as Mn, isValidElement as Ei, cloneElement as Oi, Component as xf, PureComponent as Ee, createRef as mr, useId as qP, useCallback as Lt, useReducer as GP, useLayoutEffect as ZP, useSyncExternalStore as YP } from "react";
import { Info as TE, AlertTriangle as XP, XCircle as BE, CheckCircle2 as jE, Loader2 as Mr, Pause as KP, Play as JP, RefreshCw as _E, Check as Df, ChevronDown as IE, X as Lf, Search as FE, Image as QP, Heading1 as eS, Heading2 as tS, Quote as nS, Bold as rS, Italic as oS, Underline as iS, Code as sS, AlignLeft as aS, AlignRight as lS, AlignCenter as uS, AlignJustify as cS, ChevronRight as cp, ChevronLeft as dS, Ellipsis as xg, MapPinned as pS } from "lucide-react";
import { useActionData as Pf, useNavigation as RE, useFetchers as NE, useLocation as Sf, Link as fS, useNavigate as zE } from "@remix-run/react";
import { InputMask as hS } from "@react-input/mask";
import * as xi from "react-dom";
import xu, { createPortal as vr } from "react-dom";
import { AnimatePresence as $E, motion as xs } from "framer-motion";
var jt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Du(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var dp = { exports: {} }, zi = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dg;
function gS() {
  if (Dg) return zi;
  Dg = 1;
  var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, d = {}, p = null, m = null;
    u !== void 0 && (p = "" + u), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (d[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) d[c] === void 0 && (d[c] = l[c]);
    return { $$typeof: t, type: a, key: p, ref: m, props: d, _owner: o.current };
  }
  return zi.Fragment = n, zi.jsx = s, zi.jsxs = s, zi;
}
var $i = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lg;
function mS() {
  return Lg || (Lg = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), f = Symbol.iterator, g = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var H = f && b[f] || b[g];
      return typeof H == "function" ? H : null;
    }
    var C = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var H = arguments.length, ee = new Array(H > 1 ? H - 1 : 0), oe = 1; oe < H; oe++)
          ee[oe - 1] = arguments[oe];
        k("error", b, ee);
      }
    }
    function k(b, H, ee) {
      {
        var oe = C.ReactDebugCurrentFrame, ve = oe.getStackAddendum();
        ve !== "" && (H += "%s", ee = ee.concat([ve]));
        var we = ee.map(function(he) {
          return String(he);
        });
        we.unshift("Warning: " + H), Function.prototype.apply.call(console[b], console, we);
      }
    }
    var E = !1, v = !1, O = !1, L = !1, W = !1, D;
    D = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || W || b === o || b === u || b === c || L || b === m || E || v || O || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === d || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === D || b.getModuleId !== void 0));
    }
    function _(b, H, ee) {
      var oe = b.displayName;
      if (oe)
        return oe;
      var ve = H.displayName || H.name || "";
      return ve !== "" ? ee + "(" + ve + ")" : ee;
    }
    function R(b) {
      return b.displayName || "Context";
    }
    function U(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var H = b;
            return R(H) + ".Consumer";
          case s:
            var ee = b;
            return R(ee._context) + ".Provider";
          case l:
            return _(b, b.render, "ForwardRef");
          case d:
            var oe = b.displayName || null;
            return oe !== null ? oe : U(b.type) || "Memo";
          case p: {
            var ve = b, we = ve._payload, he = ve._init;
            try {
              return U(he(we));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, K, X, ne, Q, S, I, Z;
    function T() {
    }
    T.__reactDisabledLog = !0;
    function Y() {
      {
        if (q === 0) {
          K = console.log, X = console.info, ne = console.warn, Q = console.error, S = console.group, I = console.groupCollapsed, Z = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: T,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function x() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: X
            }),
            warn: z({}, b, {
              value: ne
            }),
            error: z({}, b, {
              value: Q
            }),
            group: z({}, b, {
              value: S
            }),
            groupCollapsed: z({}, b, {
              value: I
            }),
            groupEnd: z({}, b, {
              value: Z
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = C.ReactCurrentDispatcher, $;
    function B(b, H, ee) {
      {
        if ($ === void 0)
          try {
            throw Error();
          } catch (ve) {
            var oe = ve.stack.trim().match(/\n( *(at )?)/);
            $ = oe && oe[1] || "";
          }
        return `
` + $ + b;
      }
    }
    var V = !1, F;
    {
      var J = typeof WeakMap == "function" ? WeakMap : Map;
      F = new J();
    }
    function G(b, H) {
      if (!b || V)
        return "";
      {
        var ee = F.get(b);
        if (ee !== void 0)
          return ee;
      }
      var oe;
      V = !0;
      var ve = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var we;
      we = M.current, M.current = null, Y();
      try {
        if (H) {
          var he = function() {
            throw Error();
          };
          if (Object.defineProperty(he.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(he, []);
            } catch ($e) {
              oe = $e;
            }
            Reflect.construct(b, [], he);
          } else {
            try {
              he.call();
            } catch ($e) {
              oe = $e;
            }
            b.call(he.prototype);
          }
        } else {
          try {
            throw Error();
          } catch ($e) {
            oe = $e;
          }
          b();
        }
      } catch ($e) {
        if ($e && oe && typeof $e.stack == "string") {
          for (var de = $e.stack.split(`
`), Fe = oe.stack.split(`
`), Le = de.length - 1, Se = Fe.length - 1; Le >= 1 && Se >= 0 && de[Le] !== Fe[Se]; )
            Se--;
          for (; Le >= 1 && Se >= 0; Le--, Se--)
            if (de[Le] !== Fe[Se]) {
              if (Le !== 1 || Se !== 1)
                do
                  if (Le--, Se--, Se < 0 || de[Le] !== Fe[Se]) {
                    var rt = `
` + de[Le].replace(" at new ", " at ");
                    return b.displayName && rt.includes("<anonymous>") && (rt = rt.replace("<anonymous>", b.displayName)), typeof b == "function" && F.set(b, rt), rt;
                  }
                while (Le >= 1 && Se >= 0);
              break;
            }
        }
      } finally {
        V = !1, M.current = we, x(), Error.prepareStackTrace = ve;
      }
      var En = b ? b.displayName || b.name : "", nn = En ? B(En) : "";
      return typeof b == "function" && F.set(b, nn), nn;
    }
    function fe(b, H, ee) {
      return G(b, !1);
    }
    function be(b) {
      var H = b.prototype;
      return !!(H && H.isReactComponent);
    }
    function re(b, H, ee) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return G(b, be(b));
      if (typeof b == "string")
        return B(b);
      switch (b) {
        case u:
          return B("Suspense");
        case c:
          return B("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return fe(b.render);
          case d:
            return re(b.type, H, ee);
          case p: {
            var oe = b, ve = oe._payload, we = oe._init;
            try {
              return re(we(ve), H, ee);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ie = {}, je = C.ReactDebugCurrentFrame;
    function _e(b) {
      if (b) {
        var H = b._owner, ee = re(b.type, b._source, H ? H.type : null);
        je.setExtraStackFrame(ee);
      } else
        je.setExtraStackFrame(null);
    }
    function tt(b, H, ee, oe, ve) {
      {
        var we = Function.call.bind(Ae);
        for (var he in b)
          if (we(b, he)) {
            var de = void 0;
            try {
              if (typeof b[he] != "function") {
                var Fe = Error((oe || "React class") + ": " + ee + " type `" + he + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[he] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Fe.name = "Invariant Violation", Fe;
              }
              de = b[he](H, he, oe, ee, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Le) {
              de = Le;
            }
            de && !(de instanceof Error) && (_e(ve), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", oe || "React class", ee, he, typeof de), _e(null)), de instanceof Error && !(de.message in Ie) && (Ie[de.message] = !0, _e(ve), w("Failed %s type: %s", ee, de.message), _e(null));
          }
      }
    }
    var Ke = Array.isArray;
    function ke(b) {
      return Ke(b);
    }
    function nt(b) {
      {
        var H = typeof Symbol == "function" && Symbol.toStringTag, ee = H && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return ee;
      }
    }
    function gt(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Te(b) {
      if (gt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", nt(b)), Pe(b);
    }
    var Re = C.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ze, wt, Be;
    Be = {};
    function dn(b) {
      if (Ae.call(b, "ref")) {
        var H = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (H && H.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Ct(b) {
      if (Ae.call(b, "key")) {
        var H = Object.getOwnPropertyDescriptor(b, "key").get;
        if (H && H.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function Pt(b, H) {
      if (typeof b.ref == "string" && Re.current && H && Re.current.stateNode !== H) {
        var ee = U(Re.current.type);
        Be[ee] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', U(Re.current.type), b.ref), Be[ee] = !0);
      }
    }
    function Rt(b, H) {
      {
        var ee = function() {
          ze || (ze = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", H));
        };
        ee.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: ee,
          configurable: !0
        });
      }
    }
    function vn(b, H) {
      {
        var ee = function() {
          wt || (wt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", H));
        };
        ee.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: ee,
          configurable: !0
        });
      }
    }
    var Nt = function(b, H, ee, oe, ve, we, he) {
      var de = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: H,
        ref: ee,
        props: he,
        // Record the component responsible for creating this element.
        _owner: we
      };
      return de._store = {}, Object.defineProperty(de._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(de, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: oe
      }), Object.defineProperty(de, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ve
      }), Object.freeze && (Object.freeze(de.props), Object.freeze(de)), de;
    };
    function yn(b, H, ee, oe, ve) {
      {
        var we, he = {}, de = null, Fe = null;
        ee !== void 0 && (Te(ee), de = "" + ee), Ct(H) && (Te(H.key), de = "" + H.key), dn(H) && (Fe = H.ref, Pt(H, ve));
        for (we in H)
          Ae.call(H, we) && !He.hasOwnProperty(we) && (he[we] = H[we]);
        if (b && b.defaultProps) {
          var Le = b.defaultProps;
          for (we in Le)
            he[we] === void 0 && (he[we] = Le[we]);
        }
        if (de || Fe) {
          var Se = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          de && Rt(he, Se), Fe && vn(he, Se);
        }
        return Nt(b, de, Fe, ve, oe, Re.current, he);
      }
    }
    var mt = C.ReactCurrentOwner, en = C.ReactDebugCurrentFrame;
    function St(b) {
      if (b) {
        var H = b._owner, ee = re(b.type, b._source, H ? H.type : null);
        en.setExtraStackFrame(ee);
      } else
        en.setExtraStackFrame(null);
    }
    var bn;
    bn = !1;
    function zt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Pn() {
      {
        if (mt.current) {
          var b = U(mt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function wn(b) {
      return "";
    }
    var Sn = {};
    function Cn(b) {
      {
        var H = Pn();
        if (!H) {
          var ee = typeof b == "string" ? b : b.displayName || b.name;
          ee && (H = `

Check the top-level render call using <` + ee + ">.");
        }
        return H;
      }
    }
    function kn(b, H) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var ee = Cn(H);
        if (Sn[ee])
          return;
        Sn[ee] = !0;
        var oe = "";
        b && b._owner && b._owner !== mt.current && (oe = " It was passed a child from " + U(b._owner.type) + "."), St(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ee, oe), St(null);
      }
    }
    function Wn(b, H) {
      {
        if (typeof b != "object")
          return;
        if (ke(b))
          for (var ee = 0; ee < b.length; ee++) {
            var oe = b[ee];
            zt(oe) && kn(oe, H);
          }
        else if (zt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ve = h(b);
          if (typeof ve == "function" && ve !== b.entries)
            for (var we = ve.call(b), he; !(he = we.next()).done; )
              zt(he.value) && kn(he.value, H);
        }
      }
    }
    function tn(b) {
      {
        var H = b.type;
        if (H == null || typeof H == "string")
          return;
        var ee;
        if (typeof H == "function")
          ee = H.propTypes;
        else if (typeof H == "object" && (H.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        H.$$typeof === d))
          ee = H.propTypes;
        else
          return;
        if (ee) {
          var oe = U(H);
          tt(ee, b.props, "prop", oe, b);
        } else if (H.PropTypes !== void 0 && !bn) {
          bn = !0;
          var ve = U(H);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ve || "Unknown");
        }
        typeof H.getDefaultProps == "function" && !H.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function se(b) {
      {
        for (var H = Object.keys(b.props), ee = 0; ee < H.length; ee++) {
          var oe = H[ee];
          if (oe !== "children" && oe !== "key") {
            St(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", oe), St(null);
            break;
          }
        }
        b.ref !== null && (St(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), St(null));
      }
    }
    var Xr = {};
    function Kr(b, H, ee, oe, ve, we) {
      {
        var he = N(b);
        if (!he) {
          var de = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (de += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Fe = wn();
          Fe ? de += Fe : de += Pn();
          var Le;
          b === null ? Le = "null" : ke(b) ? Le = "array" : b !== void 0 && b.$$typeof === t ? (Le = "<" + (U(b.type) || "Unknown") + " />", de = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, de);
        }
        var Se = yn(b, H, ee, ve, we);
        if (Se == null)
          return Se;
        if (he) {
          var rt = H.children;
          if (rt !== void 0)
            if (oe)
              if (ke(rt)) {
                for (var En = 0; En < rt.length; En++)
                  Wn(rt[En], b);
                Object.freeze && Object.freeze(rt);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Wn(rt, b);
        }
        if (Ae.call(H, "key")) {
          var nn = U(b), $e = Object.keys(H).filter(function(Ni) {
            return Ni !== "key";
          }), yr = $e.length > 0 ? "{key: someKey, " + $e.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Xr[nn + yr]) {
            var Ri = $e.length > 0 ? "{" + $e.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, yr, nn, Ri, nn), Xr[nn + yr] = !0;
          }
        }
        return b === r ? se(Se) : tn(Se), Se;
      }
    }
    function ji(b, H, ee) {
      return Kr(b, H, ee, !0);
    }
    function _i(b, H, ee) {
      return Kr(b, H, ee, !1);
    }
    var Ii = _i, Fi = ji;
    $i.Fragment = r, $i.jsx = Ii, $i.jsxs = Fi;
  }()), $i;
}
process.env.NODE_ENV === "production" ? dp.exports = gS() : dp.exports = mS();
var j = dp.exports;
function vS(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ j.jsx("div", { className: r.trim(), ...n });
}
const UE = Ze({});
function yS() {
  return Oe(UE);
}
function Xq(e) {
  const { schema: t, children: n, className: r, ...o } = e, a = !((u) => {
    let c = !1;
    const d = (p) => {
      Array.isArray(p) ? p.forEach(d) : p && typeof p == "object" && "type" in p && (p.type === vS ? c = !0 : p.props && p.props.children && d(p.props.children));
    };
    return d(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${a} ${r}`;
  return /* @__PURE__ */ j.jsx(UE.Provider, { value: e, children: /* @__PURE__ */ j.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function Kq(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ j.jsx("div", { className: r.trim(), ...n });
}
function Jq(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ j.jsx("div", { className: r.trim(), ...n });
}
function Qq(e) {
  const { className: t, ...n } = e, { schema: r } = yS(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ j.jsx(jE, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ j.jsx(BE, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ j.jsx(XP, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ j.jsx(TE, { className: o, ...n });
  }
}
function Ll(e, t) {
  return t ? /* @__PURE__ */ j.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ j.jsx(j.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Pg(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function jn(e) {
  var t, n;
  return Pg(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Pg(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var WE = Symbol.for("immer-nothing"), Sg = Symbol.for("immer-draftable"), ir = Symbol.for("immer-state"), bS = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Hn(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = bS[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var vi = Object.getPrototypeOf;
function Qo(e) {
  return !!e && !!e[ir];
}
function ei(e) {
  var t;
  return e ? VE(e) || Array.isArray(e) || !!e[Sg] || !!((t = e.constructor) != null && t[Sg]) || Pu(e) || Su(e) : !1;
}
var wS = Object.prototype.constructor.toString();
function VE(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = vi(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === wS;
}
function Pl(e, t) {
  Lu(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Lu(e) {
  const t = e[ir];
  return t ? t.type_ : Array.isArray(e) ? 1 : Pu(e) ? 2 : Su(e) ? 3 : 0;
}
function pp(e, t) {
  return Lu(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function HE(e, t, n) {
  const r = Lu(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function CS(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Pu(e) {
  return e instanceof Map;
}
function Su(e) {
  return e instanceof Set;
}
function Ro(e) {
  return e.copy_ || e.base_;
}
function fp(e, t) {
  if (Pu(e))
    return new Map(e);
  if (Su(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = VE(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ir];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(vi(e), r);
  } else {
    const r = vi(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function kf(e, t = !1) {
  return ku(e) || Qo(e) || !ei(e) || (Lu(e) > 1 && (e.set = e.add = e.clear = e.delete = ES), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => kf(r, !0))), e;
}
function ES() {
  Hn(2);
}
function ku(e) {
  return Object.isFrozen(e);
}
var OS = {};
function ti(e) {
  const t = OS[e];
  return t || Hn(0, e), t;
}
var Ds;
function qE() {
  return Ds;
}
function xS(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function kg(e, t) {
  t && (ti("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function hp(e) {
  gp(e), e.drafts_.forEach(DS), e.drafts_ = null;
}
function gp(e) {
  e === Ds && (Ds = e.parent_);
}
function Mg(e) {
  return Ds = xS(Ds, e);
}
function DS(e) {
  const t = e[ir];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Ag(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ir].modified_ && (hp(t), Hn(4)), ei(e) && (e = Sl(t, e), t.parent_ || kl(t, e)), t.patches_ && ti("Patches").generateReplacementPatches_(
    n[ir].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Sl(t, n, []), hp(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== WE ? e : void 0;
}
function Sl(e, t, n) {
  if (ku(t))
    return t;
  const r = t[ir];
  if (!r)
    return Pl(
      t,
      (o, i) => Tg(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return kl(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Pl(
      i,
      (a, l) => Tg(e, r, o, a, l, n, s)
    ), kl(e, o, !1), n && e.patches_ && ti("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Tg(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Hn(5), Qo(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !pp(t.assigned_, r) ? i.concat(r) : void 0, l = Sl(e, o, a);
    if (HE(n, r, l), Qo(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (ei(o) && !ku(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Sl(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && kl(e, o);
  }
}
function kl(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && kf(t, n);
}
function LS(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : qE(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Mf;
  n && (o = [r], i = Ls);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var Mf = {
  get(e, t) {
    if (t === ir)
      return e;
    const n = Ro(e);
    if (!pp(n, t))
      return PS(e, n, t);
    const r = n[t];
    return e.finalized_ || !ei(r) ? r : r === Rc(e.base_, t) ? (Nc(e), e.copy_[t] = vp(r, e)) : r;
  },
  has(e, t) {
    return t in Ro(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ro(e));
  },
  set(e, t, n) {
    const r = GE(Ro(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Rc(Ro(e), t), i = o == null ? void 0 : o[ir];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (CS(n, o) && (n !== void 0 || pp(e.base_, t)))
        return !0;
      Nc(e), mp(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Rc(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Nc(e), mp(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ro(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Hn(11);
  },
  getPrototypeOf(e) {
    return vi(e.base_);
  },
  setPrototypeOf() {
    Hn(12);
  }
}, Ls = {};
Pl(Mf, (e, t) => {
  Ls[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Ls.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Hn(13), Ls.set.call(this, e, t, void 0);
};
Ls.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Hn(14), Mf.set.call(this, e[0], t, n, e[0]);
};
function Rc(e, t) {
  const n = e[ir];
  return (n ? Ro(n) : e)[t];
}
function PS(e, t, n) {
  var o;
  const r = GE(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function GE(e, t) {
  if (!(t in e))
    return;
  let n = vi(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = vi(n);
  }
}
function mp(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && mp(e.parent_));
}
function Nc(e) {
  e.copy_ || (e.copy_ = fp(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var SS = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(l = i, ...u) {
          return s.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && Hn(6), r !== void 0 && typeof r != "function" && Hn(7);
      let o;
      if (ei(t)) {
        const i = Mg(this), s = vp(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? hp(i) : gp(i);
        }
        return kg(i, r), Ag(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === WE && (o = void 0), this.autoFreeze_ && kf(o, !0), r) {
          const i = [], s = [];
          ti("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Hn(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (s, ...a) => this.produceWithPatches(s, (l) => t(l, ...a));
      let r, o;
      return [this.produce(t, n, (s, a) => {
        r = s, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ei(e) || Hn(8), Qo(e) && (e = kS(e));
    const t = Mg(this), n = vp(e, void 0);
    return n[ir].isManual_ = !0, gp(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ir];
    (!n || !n.isManual_) && Hn(9);
    const { scope_: r } = n;
    return kg(r, t), Ag(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = ti("Patches").applyPatches_;
    return Qo(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function vp(e, t) {
  const n = Pu(e) ? ti("MapSet").proxyMap_(e, t) : Su(e) ? ti("MapSet").proxySet_(e, t) : LS(e, t);
  return (t ? t.scope_ : qE()).drafts_.push(n), n;
}
function kS(e) {
  return Qo(e) || Hn(10, e), ZE(e);
}
function ZE(e) {
  if (!ei(e) || ku(e))
    return e;
  const t = e[ir];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = fp(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = fp(e, !0);
  return Pl(n, (r, o) => {
    HE(n, r, ZE(o));
  }), t && (t.finalized_ = !1), n;
}
var sr = new SS(), Af = sr.produce;
sr.produceWithPatches.bind(
  sr
);
sr.setAutoFreeze.bind(sr);
sr.setUseStrictShallowCopy.bind(sr);
sr.applyPatches.bind(sr);
var Bg = sr.createDraft.bind(sr), jg = sr.finishDraft.bind(sr), MS = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = te.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, AS = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = Je.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, TS = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ie.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Ml = /* @__PURE__ */ new WeakMap(), Al = /* @__PURE__ */ new WeakMap(), us = /* @__PURE__ */ new WeakMap(), YE = /* @__PURE__ */ new WeakMap(), _g = /* @__PURE__ */ new WeakMap(), Ig = /* @__PURE__ */ new WeakMap(), Fg = /* @__PURE__ */ new WeakMap(), te = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = te.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return te.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return te.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return te.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return te.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && te.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return te.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && te.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && te.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && te.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && te.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && te.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!te.isAncestor(t, e) && !te.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (te.equals(i, r) || te.endsBefore(i, r) || te.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (te.equals(s, r) || te.isAncestor(s, r))
          return null;
        te.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        te.equals(a, r) || te.endsBefore(a, r) ? r[a.length - 1] -= 1 : te.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (te.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else te.endsBefore(u, r) ? r[u.length - 1] += 1 : te.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: d,
          newPath: p
        } = t;
        if (te.equals(d, p))
          return r;
        if (te.isAncestor(d, r) || te.equals(d, r)) {
          var m = p.slice();
          return te.endsBefore(d, p) && d.length < p.length && (m[d.length - 1] -= 1), m.concat(r.slice(d.length));
        } else te.isSibling(d, p) && (te.isAncestor(p, r) || te.equals(p, r)) ? te.endsBefore(d, r) ? r[d.length - 1] -= 1 : r[d.length - 1] += 1 : te.endsBefore(p, r) || te.equals(p, r) || te.isAncestor(p, r) ? (te.endsBefore(d, r) && (r[d.length - 1] -= 1), r[p.length - 1] += 1) : te.endsBefore(d, r) && (te.equals(p, r) && (r[p.length - 1] += 1), r[d.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Ps(e) {
  "@babel/helpers - typeof";
  return Ps = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ps(e);
}
function BS(e, t) {
  if (Ps(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ps(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function jS(e) {
  var t = BS(e, "string");
  return Ps(t) === "symbol" ? t : String(t);
}
function Nn(e, t, n) {
  return t = jS(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Rg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ui(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Rg(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _S = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = ye.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of ie.points(t))
          t[l] = Je.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: d
      } = n;
      if (d.length === 0) break;
      var p = ye.leaf(e, u), m = p.text.slice(0, c), f = p.text.slice(c);
      if (p.text = m + d + f, t)
        for (var [g, h] of ie.points(t))
          t[h] = Je.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: C
      } = n, w = ye.get(e, C), k = te.previous(C), E = ye.get(e, k), v = ye.parent(e, C), O = C[C.length - 1];
      if (De.isText(w) && De.isText(E))
        E.text += w.text;
      else if (!De.isText(w) && !De.isText(E))
        E.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(C, "] to nodes of different interfaces: ").concat(Ln.stringify(w), " ").concat(Ln.stringify(E)));
      if (v.children.splice(O, 1), t)
        for (var [L, W] of ie.points(t))
          t[W] = Je.transform(L, n);
      break;
    }
    case "move_node": {
      var {
        path: D,
        newPath: N
      } = n;
      if (te.isAncestor(D, N))
        throw new Error("Cannot move a path [".concat(D, "] to new path [").concat(N, "] because the destination is inside itself."));
      var _ = ye.get(e, D), R = ye.parent(e, D), U = D[D.length - 1];
      R.children.splice(U, 1);
      var z = te.transform(D, n), q = ye.get(e, te.parent(z)), K = z[z.length - 1];
      if (q.children.splice(K, 0, _), t)
        for (var [X, ne] of ie.points(t))
          t[ne] = Je.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: Q
      } = n, S = Q[Q.length - 1], I = ye.parent(e, Q);
      if (I.children.splice(S, 1), t)
        for (var [Z, T] of ie.points(t)) {
          var Y = Je.transform(Z, n);
          if (t != null && Y != null)
            t[T] = Y;
          else {
            var x = void 0, M = void 0;
            for (var [$, B] of ye.texts(e))
              if (te.compare(B, Q) === -1)
                x = [$, B];
              else {
                M = [$, B];
                break;
              }
            var V = !1;
            x && M && (te.equals(M[1], Q) ? V = !te.hasPrevious(M[1]) : V = te.common(x[1], Q).length < te.common(M[1], Q).length), x && !V ? (Z.path = x[1], Z.offset = x[0].text.length) : M ? (Z.path = M[1], Z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: F,
        offset: J,
        text: G
      } = n;
      if (G.length === 0) break;
      var fe = ye.leaf(e, F), be = fe.text.slice(0, J), re = fe.text.slice(J + G.length);
      if (fe.text = be + re, t)
        for (var [Ae, Ie] of ie.points(t))
          t[Ie] = Je.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: je,
        properties: _e,
        newProperties: tt
      } = n;
      if (je.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ke = ye.get(e, je);
      for (var ke in tt) {
        if (ke === "children" || ke === "text")
          throw new Error('Cannot set the "'.concat(ke, '" property of nodes!'));
        var nt = tt[ke];
        nt == null ? delete Ke[ke] : Ke[ke] = nt;
      }
      for (var gt in _e)
        tt.hasOwnProperty(gt) || delete Ke[gt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!ie.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Ln.stringify(Pe), " when there is no current selection."));
          t = Ui({}, Pe);
        }
        for (var Te in Pe) {
          var Re = Pe[Te];
          if (Re == null) {
            if (Te === "anchor" || Te === "focus")
              throw new Error('Cannot remove the "'.concat(Te, '" selection property'));
            delete t[Te];
          } else
            t[Te] = Re;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: He,
        position: ze,
        properties: wt
      } = n;
      if (He.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(He, "] because the root node cannot be split."));
      var Be = ye.get(e, He), dn = ye.parent(e, He), Ct = He[He.length - 1], Pt;
      if (De.isText(Be)) {
        var Rt = Be.text.slice(0, ze), vn = Be.text.slice(ze);
        Be.text = Rt, Pt = Ui(Ui({}, wt), {}, {
          text: vn
        });
      } else {
        var Nt = Be.children.slice(0, ze), yn = Be.children.slice(ze);
        Be.children = Nt, Pt = Ui(Ui({}, wt), {}, {
          children: yn
        });
      }
      if (dn.children.splice(Ct + 1, 0, Pt), t)
        for (var [mt, en] of ie.points(t))
          t[en] = Je.transform(mt, n);
      break;
    }
  }
  return t;
}, IS = {
  transform(e, t) {
    e.children = Bg(e.children);
    var n = e.selection && Bg(e.selection);
    try {
      n = _S(e, n, t);
    } finally {
      e.children = jg(e.children), n ? e.selection = Qo(n) ? jg(n) : n : e.selection = null;
    }
  }
}, FS = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, RS = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, XE = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (jn(r) && jn(o)) {
      if (!XE(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function NS(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Wr(e, t) {
  if (e == null) return {};
  var n = NS(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var zS = ["anchor", "focus"];
function Ng(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $S(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ng(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ng(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ie = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return ie.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = ie.edges(e);
    return t;
  },
  equals(e, t) {
    return Je.equals(e.anchor, t.anchor) && Je.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (ie.isRange(t)) {
      if (ie.includes(e, t.anchor) || ie.includes(e, t.focus))
        return !0;
      var [n, r] = ie.edges(e), [o, i] = ie.edges(t);
      return Je.isBefore(n, o) && Je.isAfter(r, i);
    }
    var [s, a] = ie.edges(e), l = !1, u = !1;
    return Je.isPoint(t) ? (l = Je.compare(t, s) >= 0, u = Je.compare(t, a) <= 0) : (l = te.compare(t, s.path) >= 0, u = te.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Wr(e, zS), [r, o] = ie.edges(e), [i, s] = ie.edges(t), a = Je.isBefore(r, i) ? i : r, l = Je.isBefore(o, s) ? o : s;
    return Je.isBefore(l, a) ? null : $S({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Je.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Je.equals(t, n);
  },
  isExpanded(e) {
    return !ie.isCollapsed(e);
  },
  isForward(e) {
    return !ie.isBackward(e);
  },
  isRange(e) {
    return jn(e) && Je.isPoint(e.anchor) && Je.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = ie.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Af(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = ie.isCollapsed(r);
        ie.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? ie.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = Je.transform(r.anchor, t, {
        affinity: i
      }), u = Je.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, zg = (e) => jn(e) && ye.isNodeList(e.children) && !A.isEditor(e), xe = {
  isAncestor(e) {
    return jn(e) && ye.isNodeList(e.children);
  },
  isElement: zg,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => xe.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return zg(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, US = ["children"], WS = ["text"], $g = /* @__PURE__ */ new WeakMap(), ye = {
  ancestor(e, t) {
    var n = ye.get(e, t);
    if (De.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Ln.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of te.ancestors(t, n)) {
        var o = ye.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (De.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Ln.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Ln.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = ye.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = ye.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = te.common(t, n), o = ye.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = ye.get(e, t);
    if (A.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Ln.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ye.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ye.nodes(e, t))
        xe.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (xe.isAncestor(e)) {
      var t = Wr(e, US);
      return t;
    } else {
      var t = Wr(e, WS);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = ye.get(e, n); r && !(De.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (De.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Ln.stringify(e)));
    var n = Af({
      children: e.children
    }, (r) => {
      var [o, i] = ie.edges(t), s = ye.nodes(r, {
        reverse: !0,
        pass: (p) => {
          var [, m] = p;
          return !ie.includes(t, m);
        }
      });
      for (var [, a] of s) {
        if (!ie.includes(t, a)) {
          var l = ye.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (te.equals(a, i.path)) {
          var c = ye.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (te.equals(a, o.path)) {
          var d = ye.leaf(r, a);
          d.text = d.text.slice(o.offset);
        }
      }
      A.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (De.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Ln.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (De.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return De.isText(e) || xe.isElement(e) || A.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = $g.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => ye.isNode(r));
    return $g.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = ye.get(e, n); r && !(De.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = ye.get(e, t);
    if (!De.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Ln.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of te.levels(t, n)) {
        var o = ye.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return xe.isElement(e) && xe.isElementProps(t) && xe.matches(e, t) || De.isText(e) && De.isTextProps(t) && De.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? te.isBefore(a, i) : te.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !De.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          te.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = ye.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = te.next(a);
          if (ye.has(e, c)) {
            a = c, l = ye.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var d = te.previous(a);
          a = d, l = ye.get(e, a);
          continue;
        }
        a = te.parent(a), l = ye.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = te.parent(t), r = ye.get(e, n);
    if (De.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return De.isText(e) ? e.text : e.children.map(ye.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of ye.nodes(e, t))
        De.isText(n) && (yield [n, r]);
    }();
  }
};
function Ug(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ht(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ug(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ug(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vo = {
  isNodeOperation(e) {
    return vo.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!jn(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return te.isPath(e.path) && ye.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && te.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && te.isPath(e.path) && jn(e.properties);
      case "move_node":
        return te.isPath(e.path) && te.isPath(e.newPath);
      case "remove_node":
        return te.isPath(e.path) && ye.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && te.isPath(e.path);
      case "set_node":
        return te.isPath(e.path) && jn(e.properties) && jn(e.newProperties);
      case "set_selection":
        return e.properties === null && ie.isRange(e.newProperties) || e.newProperties === null && ie.isRange(e.properties) || jn(e.properties) && jn(e.newProperties);
      case "split_node":
        return te.isPath(e.path) && typeof e.position == "number" && jn(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => vo.isOperation(t));
  },
  isSelectionOperation(e) {
    return vo.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return vo.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Ht(Ht({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Ht(Ht({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Ht(Ht({}, e), {}, {
          type: "split_node",
          path: te.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (te.equals(t, n))
          return e;
        if (te.isSibling(n, t))
          return Ht(Ht({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = te.transform(n, e), o = te.transform(te.next(n), e);
        return Ht(Ht({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Ht(Ht({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Ht(Ht({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Ht(Ht({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? Ht(Ht({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Ht(Ht({}, e), {}, {
          properties: null,
          newProperties: a
        }) : Ht(Ht({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return Ht(Ht({}, e), {}, {
          type: "merge_node",
          path: te.next(e.path)
        });
    }
  }
}, Wg = /* @__PURE__ */ new WeakMap(), VS = (e) => {
  var t = Wg.get(e);
  if (t !== void 0)
    return t;
  if (!jn(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || jn(e.marks)) && (e.selection === null || ie.isRange(e.selection)) && ye.isNodeList(e.children) && vo.isOperationList(e.operations);
  return Wg.set(e, n), n;
}, A = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return VS(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, HS = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(te.isPath);
  }
};
function Vg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Vg(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Je = {
  compare(e, t) {
    var n = te.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Je.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Je.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && te.equals(e.path, t.path);
  },
  isPoint(e) {
    return jn(e) && typeof e.offset == "number" && te.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Af(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = te.transform(i, t, n);
          break;
        }
        case "insert_text": {
          te.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          te.equals(t.path, i) && (r.offset += t.position), r.path = te.transform(i, t, n);
          break;
        }
        case "remove_text": {
          te.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (te.equals(t.path, i) || te.isAncestor(t.path, i))
            return null;
          r.path = te.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (te.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = te.transform(i, t, Hg(Hg({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = te.transform(i, t, n);
          break;
        }
      }
    });
  }
}, qg = void 0, Ln = {
  setScrubber(e) {
    qg = e;
  },
  stringify(e) {
    return JSON.stringify(e, qg);
  }
}, qS = ["text"], GS = ["anchor", "focus"];
function Gg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Gg(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Gg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var De = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = Wr(i, qS);
      return s;
    }
    return XE(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return jn(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => De.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [jr({}, e)];
    for (var r of t) {
      var o = Wr(r, GS), [i, s] = ie.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var d of n) {
        var {
          length: p
        } = d.text, m = l;
        if (l += p, u <= m && l <= c) {
          Object.assign(d, o), a.push(d);
          continue;
        }
        if (u !== c && (u === l || c === m) || u > l || c < m || c === m && m !== 0) {
          a.push(d);
          continue;
        }
        var f = d, g = void 0, h = void 0;
        if (c < l) {
          var C = c - m;
          h = jr(jr({}, f), {}, {
            text: f.text.slice(C)
          }), f = jr(jr({}, f), {}, {
            text: f.text.slice(0, C)
          });
        }
        if (u > m) {
          var w = u - m;
          g = jr(jr({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = jr(jr({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), g && a.push(g), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, Tf = (e) => e.selection ? e.selection : e.children.length > 0 ? A.end(e, []) : [0], Di = (e, t) => {
  var [n] = A.node(e, t);
  return (r) => r === n;
}, Bf = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? QS(t) : t, i = Ne.None, s = Ne.None, a = 0, l = null, u = null;
  for (var c of o) {
    var d = c.codePointAt(0);
    if (!d) break;
    var p = dk(c, d);
    if ([i, s] = r ? [s, p] : [p, i], ci(i, Ne.ZWJ) && ci(s, Ne.ExtPict) && (r ? l = Zg(t.substring(0, a)) : l = Zg(t.substring(0, t.length - a)), !l) || ci(i, Ne.RI) && ci(s, Ne.RI) && (u !== null ? u = !u : r ? u = !0 : u = mk(t.substring(0, t.length - a)), !u) || i !== Ne.None && s !== Ne.None && fk(i, s))
      break;
    a += c.length;
  }
  return a || 1;
}, ZS = /\s/, YS = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, XS = /['\u2018\u2019]/, KS = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = Bf(t, n), [s, a] = jf(t, i, n);
    if (JS(s, a, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = a;
  }
  return r;
}, jf = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, JS = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (ZS.test(t))
    return !1;
  if (XS.test(t)) {
    var o = Bf(n, r), [i, s] = jf(n, o, r);
    if (e(i, s, r))
      return !0;
  }
  return !YS.test(t);
}, QS = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (tk(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (ek(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, ek = (e) => e >= 55296 && e <= 56319, tk = (e) => e >= 56320 && e <= 57343, Ne;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Ne || (Ne = {}));
var nk = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, rk = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, ok = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, ik = /^[\u1100-\u115F\uA960-\uA97C]$/, sk = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, ak = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, lk = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, uk = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, ck = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, dk = (e, t) => {
  var n = Ne.Any;
  return e.search(nk) !== -1 && (n |= Ne.Extend), t === 8205 && (n |= Ne.ZWJ), t >= 127462 && t <= 127487 && (n |= Ne.RI), e.search(rk) !== -1 && (n |= Ne.Prepend), e.search(ok) !== -1 && (n |= Ne.SpacingMark), e.search(ik) !== -1 && (n |= Ne.L), e.search(sk) !== -1 && (n |= Ne.V), e.search(ak) !== -1 && (n |= Ne.T), e.search(lk) !== -1 && (n |= Ne.LV), e.search(uk) !== -1 && (n |= Ne.LVT), e.search(ck) !== -1 && (n |= Ne.ExtPict), n;
};
function ci(e, t) {
  return (e & t) !== 0;
}
var pk = [
  // GB6
  [Ne.L, Ne.L | Ne.V | Ne.LV | Ne.LVT],
  // GB7
  [Ne.LV | Ne.V, Ne.V | Ne.T],
  // GB8
  [Ne.LVT | Ne.T, Ne.T],
  // GB9
  [Ne.Any, Ne.Extend | Ne.ZWJ],
  // GB9a
  [Ne.Any, Ne.SpacingMark],
  // GB9b
  [Ne.Prepend, Ne.Any],
  // GB11
  [Ne.ZWJ, Ne.ExtPict],
  // GB12 and GB13
  [Ne.RI, Ne.RI]
];
function fk(e, t) {
  return pk.findIndex((n) => ci(e, n[0]) && ci(t, n[1])) === -1;
}
var hk = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, Zg = (e) => e.search(hk) !== -1, gk = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, mk = (e) => {
  var t = e.match(gk);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, vk = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    A.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Tf(e)
      } = n;
      if (te.isPath(o) && (o = A.range(e, o)), ie.isRange(o))
        if (ie.isCollapsed(o))
          o = o.anchor;
        else {
          var i = ie.end(o);
          if (!r && A.void(e, {
            at: i
          }))
            return;
          var s = ie.start(o), a = A.pointRef(e, s), l = A.pointRef(e, i);
          pe.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, pe.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && A.void(e, {
        at: o
      }) || A.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: d,
          offset: p
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: d,
          offset: p,
          text: t
        });
      }
    });
  }
};
function Yg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ha(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Yg(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Yg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pe = ha(ha(ha(ha({}, IS), FS), RS), vk), gl = /* @__PURE__ */ new WeakMap(), yk = (e) => gl.get(e) || !1, bk = (e, t, n) => {
  var r = gl.get(e) || !1;
  gl.set(e, !0);
  try {
    t(), n();
  } finally {
    gl.set(e, r);
  }
};
function KE(e, t, n) {
  var r = Ml.get(e) || [], o = Al.get(e) || /* @__PURE__ */ new Set(), i, s, a = (d) => {
    if (d) {
      var p = d.join(",");
      s.has(p) || (s.add(p), i.push(d));
    }
  };
  if (n) {
    i = [], s = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      a(u);
    }
  } else
    i = r, s = o;
  for (var c of t)
    a(c);
  Ml.set(e, i), Al.set(e, s);
}
var wk = (e, t) => {
  for (var n of A.pathRefs(e))
    MS.transform(n, t);
  for (var r of A.pointRefs(e))
    AS.transform(r, t);
  for (var o of A.rangeRefs(e))
    TS.transform(o, t);
  if (!yk(e)) {
    var i = te.operationCanTransformPath(t) ? (s) => te.transform(s, t) : void 0;
    KE(e, e.getDirtyPaths(t), i);
  }
  pe.transform(e, t), e.operations.push(t), A.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), us.get(e) || (us.set(e, !0), Promise.resolve().then(() => {
    us.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, Ck = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return te.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = te.levels(o), s = De.isText(r) ? [] : Array.from(ye.nodes(r), (N) => {
        var [, _] = N;
        return o.concat(_);
      });
      return [...i, ...s];
    }
    case "merge_node": {
      var {
        path: a
      } = t, l = te.ancestors(a), u = te.previous(a);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: d
      } = t;
      if (te.equals(c, d))
        return [];
      var p = [], m = [];
      for (var f of te.ancestors(c)) {
        var g = te.transform(f, t);
        p.push(g);
      }
      for (var h of te.ancestors(d)) {
        var C = te.transform(h, t);
        m.push(C);
      }
      var w = m[m.length - 1], k = d[d.length - 1], E = w.concat(k);
      return [...p, ...m, E];
    }
    case "remove_node": {
      var {
        path: v
      } = t, O = te.ancestors(v);
      return [...O];
    }
    case "split_node": {
      var {
        path: L
      } = t, W = te.levels(L), D = te.next(L);
      return [...W, D];
    }
    default:
      return [];
  }
}, Ek = (e) => {
  var {
    selection: t
  } = e;
  return t ? ye.fragment(e, t) : [];
}, Ok = (e, t) => {
  var [n, r] = t;
  if (!De.isText(n)) {
    if (xe.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      pe.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = A.isEditor(n) ? !1 : xe.isElement(n) && (e.isInline(n) || n.children.length === 0 || De.isText(n.children[0]) || e.isInline(n.children[0])), s = 0, a = 0; a < n.children.length; a++, s++) {
      var l = ye.get(e, r);
      if (!De.isText(l)) {
        var u = l.children[s], c = l.children[s - 1], d = a === n.children.length - 1, p = De.isText(u) || xe.isElement(u) && e.isInline(u);
        if (p !== i)
          pe.removeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--;
        else if (xe.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !De.isText(c)) {
              var m = {
                text: ""
              };
              pe.insertNodes(e, m, {
                at: r.concat(s),
                voids: !0
              }), s++;
            } else if (d) {
              var f = {
                text: ""
              };
              pe.insertNodes(e, f, {
                at: r.concat(s + 1),
                voids: !0
              }), s++;
            }
          }
        } else {
          if (!De.isText(u) && !("children" in u)) {
            var g = u;
            g.children = [];
          }
          c != null && De.isText(c) && (De.equals(u, c, {
            loose: !0
          }) ? (pe.mergeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--) : c.text === "" ? (pe.removeNodes(e, {
            at: r.concat(s - 1),
            voids: !0
          }), s--) : u.text === "" && (pe.removeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--));
        }
      }
    }
  }
}, xk = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, Dk = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: s
  } = n;
  if (i) {
    var a = A.path(t, i), l = o === "lowest";
    for (var [u, c] of A.levels(t, {
      at: a,
      voids: r,
      match: s,
      reverse: l
    }))
      if (!De.isText(u)) {
        if (ie.isRange(i)) {
          if (te.isAncestor(c, i.anchor.path) && te.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!te.equals(a, c))
          return [u, c];
      }
  }
};
function Xg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Xg(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Xg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Lk = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (d, p) => {
      if (!De.isText(d))
        return !1;
      var [m, f] = A.parent(e, p);
      return !e.isVoid(m) || e.markableVoid(m);
    }, i = ie.isExpanded(r), s = !1;
    if (!i) {
      var [a, l] = A.node(e, r);
      if (a && o(a, l)) {
        var [u] = A.parent(e, l);
        s = u && e.markableVoid(u);
      }
    }
    if (i || s)
      pe.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = Kg(Kg({}, A.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, us.get(e) || e.onChange();
    }
  }
};
function Jg(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Jg(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Jg(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Pk = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = A.point(t, n, {
    edge: "end"
  }), i = A.end(t, []), s = {
    anchor: o,
    focus: i
  }, {
    distance: a = 1
  } = r, l = 0, u;
  for (var c of A.positions(t, Qg(Qg({}, r), {}, {
    at: s
  }))) {
    if (l > a)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function em(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? em(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : em(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Sk = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = A.start(t, []), i = A.point(t, n, {
    edge: "start"
  }), s = {
    anchor: o,
    focus: i
  }, {
    distance: a = 1
  } = r, l = 0, u;
  for (var c of A.positions(t, tm(tm({}, r), {}, {
    at: s,
    reverse: !0
  }))) {
    if (l > a)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, kk = (e, t) => {
  var {
    selection: n
  } = e;
  n && ie.isCollapsed(n) && pe.delete(e, {
    unit: t,
    reverse: !0
  });
}, Mk = (e, t) => {
  var {
    selection: n
  } = e;
  n && ie.isCollapsed(n) && pe.delete(e, {
    unit: t
  });
}, Ak = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && ie.isExpanded(r) && pe.delete(t, {
    reverse: n === "backward"
  });
}, Tk = (e, t) => [A.start(e, t), A.end(e, t)];
function nm(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nm(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nm(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bk = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return A.above(t, rm(rm({}, n), {}, {
    match: (r) => xe.isElement(r) && A.isElementReadOnly(t, r)
  }));
}, jk = (e, t) => A.point(e, t, {
  edge: "end"
}), _k = (e, t) => {
  var n = A.path(e, t, {
    edge: "start"
  });
  return A.node(e, n);
}, Ik = (e, t) => {
  var n = A.range(e, t);
  return ye.fragment(e, n);
};
function om(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function im(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? om(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : om(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fk = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return A.above(t, im(im({}, n), {}, {
    match: (r) => xe.isElement(r) && A.isVoid(t, r)
  }));
}, Rk = (e, t) => t.children.some((n) => xe.isElement(n) && A.isBlock(e, n)), Nk = (e, t) => t.children.some((n) => De.isText(n) || A.isInline(e, n)), zk = (e, t) => ye.has(e, t), $k = (e, t) => t.children.every((n) => De.isText(n)), Uk = (e) => {
  pe.splitNodes(e, {
    always: !0
  });
}, Wk = (e, t, n) => {
  pe.insertNodes(e, t, n);
}, Vk = (e) => {
  pe.splitNodes(e, {
    always: !0
  });
};
function sm(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hk(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sm(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sm(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qk = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var s = Hk({
        text: n
      }, i);
      pe.insertNodes(t, s, {
        at: r.at,
        voids: r.voids
      });
    } else
      pe.insertText(t, n, r);
    t.marks = null;
  }
}, Gk = (e, t) => !e.isInline(t), Zk = (e, t, n) => A.isStart(e, t, n) || A.isEnd(e, t, n), Yk = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && De.isText(r) && r.text === "" && !e.isVoid(t);
}, Xk = (e, t, n) => {
  var r = A.end(e, n);
  return Je.equals(t, r);
}, Kk = (e) => {
  var t = YE.get(e);
  return t === void 0 ? !0 : t;
}, Jk = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = A.start(e, n);
  return Je.equals(t, r);
}, Qk = (e, t) => {
  var n = A.path(e, t, {
    edge: "end"
  });
  return A.node(e, n);
}, eM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = A.path(t, n, r), i = ye.leaf(t, o);
  return [i, o];
};
function tM(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var s = [], a = A.path(e, n);
      for (var [l, u] of ye.levels(e, a))
        if (i(l, u) && (s.push([l, u]), !o && xe.isElement(l) && A.isVoid(e, l)))
          break;
      r && s.reverse(), yield* s;
    }
  }();
}
var nM = ["text"], rM = ["text"], oM = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (ie.isExpanded(r)) {
    var s = A.isEnd(t, o, o.path);
    if (s) {
      var a = A.after(t, o);
      a && (o = a);
    }
    var [l] = A.nodes(t, {
      match: De.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = Wr(u, nM);
      return c;
    } else
      return {};
  }
  var {
    path: d
  } = o, [p] = A.leaf(t, d);
  if (o.offset === 0) {
    var m = A.previous(t, {
      at: d,
      match: De.isText
    }), f = A.above(t, {
      match: (E) => xe.isElement(E) && A.isVoid(t, E) && t.markableVoid(E)
    });
    if (!f) {
      var g = A.above(t, {
        match: (E) => xe.isElement(E) && A.isBlock(t, E)
      });
      if (m && g) {
        var [h, C] = m, [, w] = g;
        te.isAncestor(w, C) && (p = h);
      }
    }
  }
  var k = Wr(p, rM);
  return k;
}, iM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: s = t.selection
  } = n;
  if (s) {
    var a = A.after(t, s, {
      voids: o
    });
    if (a) {
      var [, l] = A.last(t, []), u = [a.path, l];
      if (te.isPath(s) && s.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (te.isPath(s)) {
          var [c] = A.parent(t, s);
          i = (p) => c.children.includes(p);
        } else
          i = () => !0;
      var [d] = A.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return d;
    }
  }
}, sM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = A.path(t, n, r), i = ye.get(t, o);
  return [i, o];
};
function aM(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: s = !1,
      ignoreNonSelectable: a = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (HS.isSpan(n))
        u = n[0], c = n[1];
      else {
        var d = A.path(e, n, {
          edge: "start"
        }), p = A.path(e, n, {
          edge: "end"
        });
        u = i ? p : d, c = i ? d : p;
      }
      var m = ye.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (E) => {
          var [v] = E;
          return xe.isElement(v) ? !!(!s && (A.isVoid(e, v) || A.isElementReadOnly(e, v)) || a && !A.isSelectable(e, v)) : !1;
        }
      }), f = [], g;
      for (var [h, C] of m)
        if (!(a && xe.isElement(h) && !A.isSelectable(e, h))) {
          var w = g && te.compare(C, g[1]) === 0;
          if (!(r === "highest" && w)) {
            if (!l(h, C)) {
              if (o && !w && De.isText(h))
                return;
              continue;
            }
            if (r === "lowest" && w) {
              g = [h, C];
              continue;
            }
            var k = r === "lowest" ? g : [h, C];
            k && (o ? f.push(k) : yield k), g = [h, C];
          }
        }
      r === "lowest" && g && (o ? f.push(g) : yield g), o && (yield* f);
    }
  }();
}
var lM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => Ml.get(c) || [], s = (c) => Al.get(c) || /* @__PURE__ */ new Set(), a = (c) => {
    var d = i(c).pop(), p = d.join(",");
    return s(c).delete(p), d;
  };
  if (A.isNormalizing(t)) {
    if (r) {
      var l = Array.from(ye.nodes(t), (c) => {
        var [, d] = c;
        return d;
      }), u = new Set(l.map((c) => c.join(",")));
      Ml.set(t, l), Al.set(t, u);
    }
    i(t).length !== 0 && A.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (ye.has(t, c)) {
          var d = A.node(t, c), [p, m] = d;
          xe.isElement(p) && p.children.length === 0 && t.normalizeNode(d, {
            operation: o
          });
        }
      for (var f = i(t), g = f.length, h = 0; f.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: f,
          iteration: h,
          initialDirtyPathsLength: g,
          operation: o
        }))
          return;
        var C = a(t);
        if (ye.has(t, C)) {
          var w = A.node(t, C);
          t.normalizeNode(w, {
            operation: o
          });
        }
        h++, f = i(t);
      }
    });
  }
}, uM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = A.path(t, n, r), i = te.parent(o), s = A.node(t, i);
  return s;
}, cM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = A.pathRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = A.pathRefs(t);
  return s.add(i), i;
}, dM = (e) => {
  var t = _g.get(e);
  return t || (t = /* @__PURE__ */ new Set(), _g.set(e, t)), t;
}, pM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (te.isPath(n)) {
    if (i === "start") {
      var [, s] = ye.first(t, n);
      n = s;
    } else if (i === "end") {
      var [, a] = ye.last(t, n);
      n = a;
    }
  }
  return ie.isRange(n) && (i === "start" ? n = ie.start(n) : i === "end" ? n = ie.end(n) : n = te.common(n.anchor.path, n.focus.path)), Je.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, fM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = A.pointRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = A.pointRefs(t);
  return s.add(i), i;
}, hM = (e) => {
  var t = Ig.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Ig.set(e, t)), t;
}, gM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (te.isPath(n)) {
    var i;
    if (o === "end") {
      var [, s] = ye.last(t, n);
      i = s;
    } else {
      var [, a] = ye.first(t, n);
      i = a;
    }
    var l = ye.get(t, i);
    if (!De.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (ie.isRange(n)) {
    var [u, c] = ie.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function mM(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: s = !1
    } = t;
    if (!n)
      return;
    var a = A.range(e, n), [l, u] = ie.edges(a), c = o ? u : l, d = !1, p = "", m = 0, f = 0, g = 0;
    for (var [h, C] of A.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: s
    })) {
      if (xe.isElement(h)) {
        if (!i && (e.isVoid(h) || e.isElementReadOnly(h))) {
          yield A.start(e, C);
          continue;
        }
        if (e.isInline(h)) continue;
        if (A.hasInlines(e, h)) {
          var w = te.isAncestor(C, u.path) ? u : A.end(e, C), k = te.isAncestor(C, l.path) ? l : A.start(e, C);
          p = A.string(e, {
            anchor: k,
            focus: w
          }, {
            voids: i
          }), d = !0;
        }
      }
      if (De.isText(h)) {
        var E = te.equals(C, c.path);
        for (E ? (f = o ? c.offset : h.text.length - c.offset, g = c.offset) : (f = h.text.length, g = o ? f : 0), (E || d || r === "offset") && (yield {
          path: C,
          offset: g
        }, d = !1); ; ) {
          if (m === 0) {
            if (p === "") break;
            m = v(p, r, o), p = jf(p, m, o)[1];
          }
          if (g = o ? g - m : g + m, f = f - m, f < 0) {
            m = -f;
            break;
          }
          m = 0, yield {
            path: C,
            offset: g
          };
        }
      }
    }
    function v(O, L, W) {
      return L === "character" ? Bf(O, W) : L === "word" ? KS(O, W) : L === "line" || L === "block" ? O.length : 1;
    }
  }();
}
var vM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: s = t.selection
  } = n;
  if (s) {
    var a = A.before(t, s, {
      voids: o
    });
    if (a) {
      var [, l] = A.first(t, []), u = [a.path, l];
      if (te.isPath(s) && s.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (te.isPath(s)) {
          var [c] = A.parent(t, s);
          i = (p) => c.children.includes(p);
        } else
          i = () => !0;
      var [d] = A.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return d;
    }
  }
}, yM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = A.rangeRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = A.rangeRefs(t);
  return s.add(i), i;
}, bM = (e) => {
  var t = Fg.get(e);
  return t || (t = /* @__PURE__ */ new Set(), Fg.set(e, t)), t;
}, wM = (e, t, n) => {
  if (ie.isRange(t) && !n)
    return t;
  var r = A.start(e, t), o = A.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function am(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function CM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? am(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : am(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var EM = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, d) => {
      if (!De.isText(c))
        return !1;
      var [p, m] = A.parent(e, d);
      return !e.isVoid(p) || e.markableVoid(p);
    }, o = ie.isExpanded(n), i = !1;
    if (!o) {
      var [s, a] = A.node(e, n);
      if (s && r(s, a)) {
        var [l] = A.parent(e, a);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      pe.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = CM({}, A.marks(e) || {});
      delete u[t], e.marks = u, us.get(e) || e.onChange();
    }
  }
}, OM = (e, t) => {
  YE.set(e, t);
}, xM = (e, t) => A.point(e, t, {
  edge: "start"
}), DM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = A.range(t, n), [s, a] = ie.edges(i), l = "";
  for (var [u, c] of A.nodes(t, {
    at: i,
    match: De.isText,
    voids: o
  })) {
    var d = u.text;
    te.equals(c, a.path) && (d = d.slice(0, a.offset)), te.equals(c, s.path) && (d = d.slice(s.offset)), l += d;
  }
  return l;
}, LM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, s] = ie.edges(n);
  if (i.offset !== 0 || s.offset !== 0 || ie.isCollapsed(n) || te.hasPrevious(s.path))
    return n;
  var a = A.above(t, {
    at: s,
    match: (f) => xe.isElement(f) && A.isBlock(t, f),
    voids: o
  }), l = a ? a[1] : [], u = A.start(t, i), c = {
    anchor: u,
    focus: s
  }, d = !0;
  for (var [p, m] of A.nodes(t, {
    at: c,
    match: De.isText,
    reverse: !0,
    voids: o
  })) {
    if (d) {
      d = !1;
      continue;
    }
    if (p.text !== "" || te.isBefore(m, l)) {
      s = {
        path: m,
        offset: p.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: s
  };
}, PM = (e, t) => {
  var n = A.isNormalizing(e);
  A.setNormalizing(e, !1);
  try {
    t();
  } finally {
    A.setNormalizing(e, n);
  }
  A.normalize(e);
}, SM = (e, t, n) => {
  var [r, o] = t;
  return xe.isElement(r) && A.isEmpty(e, r) || De.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, kM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  A.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: s = "character",
      distance: a = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var d = !1;
      if (ie.isRange(u) && ie.isCollapsed(u) && (d = !0, u = u.anchor), Je.isPoint(u)) {
        var p = A.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && p) {
          var [, m] = p;
          u = m;
        } else {
          var f = {
            unit: s,
            distance: a
          }, g = i ? A.before(t, u, f) || A.start(t, []) : A.after(t, u, f) || A.end(t, []);
          u = {
            anchor: u,
            focus: g
          }, c = !0;
        }
      }
      if (te.isPath(u)) {
        pe.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!ie.isCollapsed(u)) {
        if (!c) {
          var [, h] = ie.edges(u), C = A.end(t, []);
          Je.equals(h, C) || (u = A.unhangRange(t, u, {
            voids: l
          }));
        }
        var [w, k] = ie.edges(u), E = A.above(t, {
          match: (be) => xe.isElement(be) && A.isBlock(t, be),
          at: w,
          voids: l
        }), v = A.above(t, {
          match: (be) => xe.isElement(be) && A.isBlock(t, be),
          at: k,
          voids: l
        }), O = E && v && !te.equals(E[1], v[1]), L = te.equals(w.path, k.path), W = l ? null : (r = A.void(t, {
          at: w,
          mode: "highest"
        })) !== null && r !== void 0 ? r : A.elementReadOnly(t, {
          at: w,
          mode: "highest"
        }), D = l ? null : (o = A.void(t, {
          at: k,
          mode: "highest"
        })) !== null && o !== void 0 ? o : A.elementReadOnly(t, {
          at: k,
          mode: "highest"
        });
        if (W) {
          var N = A.before(t, w);
          N && E && te.isAncestor(E[1], N.path) && (w = N);
        }
        if (D) {
          var _ = A.after(t, k);
          _ && v && te.isAncestor(v[1], _.path) && (k = _);
        }
        var R = [], U;
        for (var z of A.nodes(t, {
          at: u,
          voids: l
        })) {
          var [q, K] = z;
          U && te.compare(K, U) === 0 || (!l && xe.isElement(q) && (A.isVoid(t, q) || A.isElementReadOnly(t, q)) || !te.isCommon(K, w.path) && !te.isCommon(K, k.path)) && (R.push(z), U = K);
        }
        var X = Array.from(R, (be) => {
          var [, re] = be;
          return A.pathRef(t, re);
        }), ne = A.pointRef(t, w), Q = A.pointRef(t, k), S = "";
        if (!L && !W) {
          var I = ne.current, [Z] = A.leaf(t, I), {
            path: T
          } = I, {
            offset: Y
          } = w, x = Z.text.slice(Y);
          x.length > 0 && (t.apply({
            type: "remove_text",
            path: T,
            offset: Y,
            text: x
          }), S = x);
        }
        if (X.reverse().map((be) => be.unref()).filter((be) => be !== null).forEach((be) => pe.removeNodes(t, {
          at: be,
          voids: l
        })), !D) {
          var M = Q.current, [$] = A.leaf(t, M), {
            path: B
          } = M, V = L ? w.offset : 0, F = $.text.slice(V, k.offset);
          F.length > 0 && (t.apply({
            type: "remove_text",
            path: B,
            offset: V,
            text: F
          }), S = F);
        }
        !L && O && Q.current && ne.current && pe.mergeNodes(t, {
          at: Q.current,
          hanging: !0,
          voids: l
        }), d && i && s === "character" && S.length > 1 && S.match(/[\u0E00-\u0E7F]+/) && pe.insertText(t, S.slice(0, S.length - a));
        var J = ne.unref(), G = Q.unref(), fe = i ? J || G : G || J;
        n.at == null && fe && pe.select(t, fe);
      }
    }
  });
}, MM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  A.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: s = Tf(t),
      batchDirty: a = !0
    } = r;
    if (n.length) {
      if (ie.isRange(s))
        if (o || (s = A.unhangRange(t, s, {
          voids: i
        })), ie.isCollapsed(s))
          s = s.anchor;
        else {
          var [, l] = ie.edges(s);
          if (!i && A.void(t, {
            at: l
          }))
            return;
          var u = A.pointRef(t, l);
          pe.delete(t, {
            at: s
          }), s = u.unref();
        }
      else te.isPath(s) && (s = A.start(t, s));
      if (!(!i && A.void(t, {
        at: s
      }))) {
        var c = A.above(t, {
          at: s,
          match: (x) => xe.isElement(x) && A.isInline(t, x),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, d] = c;
          if (A.isEnd(t, s, d)) {
            var p = A.after(t, d);
            s = p;
          } else if (A.isStart(t, s, d)) {
            var m = A.before(t, d);
            s = m;
          }
        }
        var f = A.above(t, {
          match: (x) => xe.isElement(x) && A.isBlock(t, x),
          at: s,
          voids: i
        }), [, g] = f, h = A.isStart(t, s, g), C = A.isEnd(t, s, g), w = h && C, k = !h || h && C, E = !C, [, v] = ye.first({
          children: n
        }, []), [, O] = ye.last({
          children: n
        }, []), L = [], W = (x) => {
          var [M, $] = x, B = $.length === 0;
          return B ? !1 : w ? !0 : !(k && te.isAncestor($, v) && xe.isElement(M) && !t.isVoid(M) && !t.isInline(M) || E && te.isAncestor($, O) && xe.isElement(M) && !t.isVoid(M) && !t.isInline(M));
        };
        for (var D of ye.nodes({
          children: n
        }, {
          pass: W
        }))
          W(D) && L.push(D);
        var N = [], _ = [], R = [], U = !0, z = !1;
        for (var [q] of L)
          xe.isElement(q) && !t.isInline(q) ? (U = !1, z = !0, _.push(q)) : U ? N.push(q) : R.push(q);
        var [K] = A.nodes(t, {
          at: s,
          match: (x) => De.isText(x) || A.isInline(t, x),
          mode: "highest",
          voids: i
        }), [, X] = K, ne = A.isStart(t, s, X), Q = A.isEnd(t, s, X), S = A.pathRef(t, C && !R.length ? te.next(g) : g), I = A.pathRef(t, Q ? te.next(X) : X);
        pe.splitNodes(t, {
          at: s,
          match: (x) => z ? xe.isElement(x) && A.isBlock(t, x) : De.isText(x) || A.isInline(t, x),
          mode: z ? "lowest" : "highest",
          always: z && (!h || N.length > 0) && (!C || R.length > 0),
          voids: i
        });
        var Z = A.pathRef(t, !ne || ne && Q ? te.next(X) : X);
        if (pe.insertNodes(t, N, {
          at: Z.current,
          match: (x) => De.isText(x) || A.isInline(t, x),
          mode: "highest",
          voids: i,
          batchDirty: a
        }), w && !N.length && _.length && !R.length && pe.delete(t, {
          at: g,
          voids: i
        }), pe.insertNodes(t, _, {
          at: S.current,
          match: (x) => xe.isElement(x) && A.isBlock(t, x),
          mode: "lowest",
          voids: i,
          batchDirty: a
        }), pe.insertNodes(t, R, {
          at: I.current,
          match: (x) => De.isText(x) || A.isInline(t, x),
          mode: "highest",
          voids: i,
          batchDirty: a
        }), !r.at) {
          var T;
          if (R.length > 0 && I.current ? T = te.previous(I.current) : _.length > 0 && S.current ? T = te.previous(S.current) : Z.current && (T = te.previous(Z.current)), T) {
            var Y = A.end(t, T);
            pe.select(t, Y);
          }
        }
        Z.unref(), S.unref(), I.unref();
      }
    }
  });
}, AM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      pe.select(t, o.anchor);
    else if (r === "focus")
      pe.select(t, o.focus);
    else if (r === "start") {
      var [i] = ie.edges(o);
      pe.select(t, i);
    } else if (r === "end") {
      var [, s] = ie.edges(o);
      pe.select(t, s);
    }
  } else return;
}, TM = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, BM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: s = !1
  } = n, {
    edge: a = null
  } = n;
  if (r) {
    a === "start" && (a = ie.isBackward(r) ? "focus" : "anchor"), a === "end" && (a = ie.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, d = {};
    if (a == null || a === "anchor") {
      var p = s ? A.before(t, l, c) : A.after(t, l, c);
      p && (d.anchor = p);
    }
    if (a == null || a === "focus") {
      var m = s ? A.before(t, u, c) : A.after(t, u, c);
      m && (d.focus = m);
    }
    pe.setSelection(t, d);
  }
}, jM = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = A.range(e, t), n) {
    pe.setSelection(e, t);
    return;
  }
  if (!ie.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Ln.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function lm(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function um(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lm(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lm(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _M = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = ie.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = ie.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: s,
      focus: a
    } = o, l = i === "anchor" ? s : a;
    pe.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: um(um({}, l), n)
    });
  }
}, IM = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !Je.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !Je.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, FM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  A.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: s = "lowest",
      batchDirty: a = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (ye.isNode(n) && (n = [n]), n.length !== 0) {
      var [d] = n;
      if (l || (l = Tf(t), c !== !1 && (c = !0)), c == null && (c = !1), ie.isRange(l))
        if (o || (l = A.unhangRange(t, l, {
          voids: i
        })), ie.isCollapsed(l))
          l = l.anchor;
        else {
          var [, p] = ie.edges(l), m = A.pointRef(t, p);
          pe.delete(t, {
            at: l
          }), l = m.unref();
        }
      if (Je.isPoint(l)) {
        u == null && (De.isText(d) ? u = (N) => De.isText(N) : t.isInline(d) ? u = (N) => De.isText(N) || A.isInline(t, N) : u = (N) => xe.isElement(N) && A.isBlock(t, N));
        var [f] = A.nodes(t, {
          at: l.path,
          match: u,
          mode: s,
          voids: i
        });
        if (f) {
          var [, g] = f, h = A.pathRef(t, g), C = A.isEnd(t, l, g);
          pe.splitNodes(t, {
            at: l,
            match: u,
            mode: s,
            voids: i
          });
          var w = h.unref();
          l = C ? te.next(w) : w;
        } else
          return;
      }
      var k = te.parent(l), E = l[l.length - 1];
      if (!(!i && A.void(t, {
        at: k
      }))) {
        if (a) {
          var v = [], O = te.levels(k);
          bk(t, () => {
            var N = function() {
              var U = k.concat(E);
              E++;
              var z = {
                type: "insert_node",
                path: U,
                node: _
              };
              t.apply(z), l = te.next(l), v.push(z), De.isText ? O.push(...Array.from(ye.nodes(_), (q) => {
                var [, K] = q;
                return U.concat(K);
              })) : O.push(U);
            };
            for (var _ of n)
              N();
          }, () => {
            KE(t, O, (N) => {
              var _ = N;
              for (var R of v)
                if (te.operationCanTransformPath(R) && (_ = te.transform(_, R), !_))
                  return null;
              return _;
            });
          });
        } else
          for (var L of n) {
            var W = k.concat(E);
            E++, t.apply({
              type: "insert_node",
              path: W,
              node: L
            }), l = te.next(l);
          }
        if (l = te.previous(l), c) {
          var D = A.end(t, l);
          D && pe.select(t, D);
        }
      }
    }
  });
}, RM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  A.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: s
    } = n;
    if (s == null && (s = te.isPath(r) ? Di(t, r) : (E) => xe.isElement(E) && A.isBlock(t, E)), !!r) {
      var a = A.nodes(t, {
        at: r,
        match: s,
        mode: o,
        voids: i
      }), l = Array.from(a, (E) => {
        var [, v] = E;
        return A.pathRef(t, v);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var d = A.node(t, te.parent(c)), [p, m] = d, f = c[c.length - 1], {
          length: g
        } = p.children;
        if (g === 1) {
          var h = te.next(m);
          pe.moveNodes(t, {
            at: c,
            to: h,
            voids: i
          }), pe.removeNodes(t, {
            at: m,
            voids: i
          });
        } else if (f === 0)
          pe.moveNodes(t, {
            at: c,
            to: m,
            voids: i
          });
        else if (f === g - 1) {
          var C = te.next(m);
          pe.moveNodes(t, {
            at: c,
            to: C,
            voids: i
          });
        } else {
          var w = te.next(c), k = te.next(m);
          pe.splitNodes(t, {
            at: w,
            voids: i
          }), pe.moveNodes(t, {
            at: c,
            to: k,
            voids: i
          });
        }
      }
    }
  });
}, NM = ["text"], zM = ["children"], JE = (e, t) => {
  if (xe.isElement(t)) {
    var n = t;
    return A.isVoid(e, t) ? !0 : n.children.length === 1 ? JE(e, n.children[0]) : !1;
  } else return !A.isEditor(t);
}, $M = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  A.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: s = !1,
      mode: a = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (te.isPath(o)) {
          var [l] = A.parent(t, o);
          r = (N) => l.children.includes(N);
        } else
          r = (N) => xe.isElement(N) && A.isBlock(t, N);
      if (!i && ie.isRange(o) && (o = A.unhangRange(t, o, {
        voids: s
      })), ie.isRange(o))
        if (ie.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = ie.edges(o), c = A.pointRef(t, u);
          pe.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && pe.select(t, o);
        }
      var [d] = A.nodes(t, {
        at: o,
        match: r,
        voids: s,
        mode: a
      }), p = A.previous(t, {
        at: o,
        match: r,
        voids: s,
        mode: a
      });
      if (!(!d || !p)) {
        var [m, f] = d, [g, h] = p;
        if (!(f.length === 0 || h.length === 0)) {
          var C = te.next(h), w = te.common(f, h), k = te.isSibling(f, h), E = Array.from(A.levels(t, {
            at: f
          }), (N) => {
            var [_] = N;
            return _;
          }).slice(w.length).slice(0, -1), v = A.above(t, {
            at: f,
            mode: "highest",
            match: (N) => E.includes(N) && JE(t, N)
          }), O = v && A.pathRef(t, v[1]), L, W;
          if (De.isText(m) && De.isText(g)) {
            var D = Wr(m, NM);
            W = g.text.length, L = D;
          } else if (xe.isElement(m) && xe.isElement(g)) {
            var D = Wr(m, zM);
            W = g.children.length, L = D;
          } else
            throw new Error("Cannot merge the node at path [".concat(f, "] with the previous sibling because it is not the same kind: ").concat(Ln.stringify(m), " ").concat(Ln.stringify(g)));
          k || pe.moveNodes(t, {
            at: f,
            to: C,
            voids: s
          }), O && pe.removeNodes(t, {
            at: O.current,
            voids: s
          }), A.shouldMergeNodesRemovePrevNode(t, p, d) ? pe.removeNodes(t, {
            at: h,
            voids: s
          }) : t.apply({
            type: "merge_node",
            path: C,
            position: W,
            properties: L
          }), O && O.unref();
        }
      }
    }
  });
}, UM = (e, t) => {
  A.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: s
    } = t;
    if (r) {
      s == null && (s = te.isPath(r) ? Di(e, r) : (m) => xe.isElement(m) && A.isBlock(e, m));
      var a = A.pathRef(e, n), l = A.nodes(e, {
        at: r,
        match: s,
        mode: o,
        voids: i
      }), u = Array.from(l, (m) => {
        var [, f] = m;
        return A.pathRef(e, f);
      });
      for (var c of u) {
        var d = c.unref(), p = a.current;
        d.length !== 0 && e.apply({
          type: "move_node",
          path: d,
          newPath: p
        }), a.current && te.isSibling(p, d) && te.isAfter(p, d) && (a.current = te.next(a.current));
      }
      a.unref();
    }
  });
}, WM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  A.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: s = t.selection,
      match: a
    } = n;
    if (s) {
      a == null && (a = te.isPath(s) ? Di(t, s) : (m) => xe.isElement(m) && A.isBlock(t, m)), !r && ie.isRange(s) && (s = A.unhangRange(t, s, {
        voids: o
      }));
      var l = A.nodes(t, {
        at: s,
        match: a,
        mode: i,
        voids: o
      }), u = Array.from(l, (m) => {
        var [, f] = m;
        return A.pathRef(t, f);
      });
      for (var c of u) {
        var d = c.unref();
        if (d) {
          var [p] = A.node(t, d);
          t.apply({
            type: "remove_node",
            path: d,
            node: p
          });
        }
      }
    }
  });
}, VM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  A.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: s,
      merge: a
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: d = !1
    } = r;
    if (i) {
      if (o == null && (o = te.isPath(i) ? Di(t, i) : (W) => xe.isElement(W) && A.isBlock(t, W)), !l && ie.isRange(i) && (i = A.unhangRange(t, i, {
        voids: d
      })), c && ie.isRange(i)) {
        if (ie.isCollapsed(i) && A.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var p = A.rangeRef(t, i, {
          affinity: "inward"
        }), [m, f] = ie.edges(i), g = u === "lowest" ? "lowest" : "highest", h = A.isEnd(t, f, f.path);
        pe.splitNodes(t, {
          at: f,
          match: o,
          mode: g,
          voids: d,
          always: !h
        });
        var C = A.isStart(t, m, m.path);
        pe.splitNodes(t, {
          at: m,
          match: o,
          mode: g,
          voids: d,
          always: !C
        }), i = p.unref(), r.at == null && pe.select(t, i);
      }
      s || (s = (W, D) => W !== D);
      for (var [w, k] of A.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: d
      })) {
        var E = {}, v = {};
        if (k.length !== 0) {
          var O = !1;
          for (var L in n)
            L === "children" || L === "text" || s(n[L], w[L]) && (O = !0, w.hasOwnProperty(L) && (E[L] = w[L]), a ? n[L] != null && (v[L] = a(w[L], n[L])) : n[L] != null && (v[L] = n[L]));
          O && t.apply({
            type: "set_node",
            path: k,
            properties: E,
            newProperties: v
          });
        }
      }
    }
  });
}, HM = (e, t) => {
  if (ie.isCollapsed(t))
    return t.anchor;
  var [, n] = ie.edges(t), r = A.pointRef(e, n);
  return pe.delete(e, {
    at: t
  }), r.unref();
}, qM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  A.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: s = t.selection,
      height: a = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (Q) => xe.isElement(Q) && A.isBlock(t, Q)), ie.isRange(s) && (s = HM(t, s)), te.isPath(s)) {
      var u = s, c = A.point(t, u), [d] = A.parent(t, u);
      i = (Q) => Q === d, a = c.path.length - u.length + 1, s = c, l = !0;
    }
    if (s) {
      var p = A.pointRef(t, s, {
        affinity: "backward"
      }), m;
      try {
        var [f] = A.nodes(t, {
          at: s,
          match: i,
          mode: r,
          voids: o
        });
        if (!f)
          return;
        var g = A.void(t, {
          at: s,
          mode: "highest"
        }), h = 0;
        if (!o && g) {
          var [C, w] = g;
          if (xe.isElement(C) && t.isInline(C)) {
            var k = A.after(t, w);
            if (!k) {
              var E = {
                text: ""
              }, v = te.next(w);
              pe.insertNodes(t, E, {
                at: v,
                voids: o
              }), k = A.point(t, v);
            }
            s = k, l = !0;
          }
          var O = s.path.length - w.length;
          a = O + 1, l = !0;
        }
        m = A.pointRef(t, s);
        var L = s.path.length - a, [, W] = f, D = s.path.slice(0, L), N = a === 0 ? s.offset : s.path[L] + h;
        for (var [_, R] of A.levels(t, {
          at: D,
          reverse: !0,
          voids: o
        })) {
          var U = !1;
          if (R.length < W.length || R.length === 0 || !o && xe.isElement(_) && A.isVoid(t, _))
            break;
          var z = p.current, q = A.isEnd(t, z, R);
          if (l || !p || !A.isEdge(t, z, R)) {
            U = !0;
            var K = ye.extractProps(_);
            t.apply({
              type: "split_node",
              path: R,
              position: N,
              properties: K
            });
          }
          N = R[R.length - 1] + (U || q ? 1 : 0);
        }
        if (n.at == null) {
          var X = m.current || A.end(t, []);
          pe.select(t, X);
        }
      } finally {
        var ne;
        p.unref(), (ne = m) === null || ne === void 0 || ne.unref();
      }
    }
  });
}, GM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  pe.setNodes(t, o, r);
}, ZM = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  A.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: s = t.selection,
      match: a
    } = n;
    if (s) {
      a == null && (a = te.isPath(s) ? Di(t, s) : (m) => xe.isElement(m) && A.isBlock(t, m)), te.isPath(s) && (s = A.range(t, s));
      var l = ie.isRange(s) ? A.rangeRef(t, s) : null, u = A.nodes(t, {
        at: s,
        match: a,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (m) => {
          var [, f] = m;
          return A.pathRef(t, f);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), d = function() {
        var f = p.unref(), [g] = A.node(t, f), h = A.range(t, f);
        o && l && (h = ie.intersection(l.current, h)), pe.liftNodes(t, {
          at: h,
          match: (C) => xe.isAncestor(g) && g.children.includes(C),
          voids: i
        });
      };
      for (var p of c)
        d();
      l && l.unref();
    }
  });
};
function cm(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cm(Object(n), !0).forEach(function(r) {
      Nn(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cm(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YM = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  A.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: s = !1
    } = r, {
      match: a,
      at: l = t.selection
    } = r;
    if (l) {
      if (a == null && (te.isPath(l) ? a = Di(t, l) : t.isInline(n) ? a = (h) => xe.isElement(h) && A.isInline(t, h) || De.isText(h) : a = (h) => xe.isElement(h) && A.isBlock(t, h)), i && ie.isRange(l)) {
        var [u, c] = ie.edges(l), d = A.rangeRef(t, l, {
          affinity: "inward"
        });
        pe.splitNodes(t, {
          at: c,
          match: a,
          voids: s
        }), pe.splitNodes(t, {
          at: u,
          match: a,
          voids: s
        }), l = d.unref(), r.at == null && pe.select(t, l);
      }
      var p = Array.from(A.nodes(t, {
        at: l,
        match: t.isInline(n) ? (h) => xe.isElement(h) && A.isBlock(t, h) : (h) => A.isEditor(h),
        mode: "lowest",
        voids: s
      })), m = function() {
        var C = ie.isRange(l) ? ie.intersection(l, A.range(t, g)) : l;
        if (!C)
          return 0;
        var w = Array.from(A.nodes(t, {
          at: C,
          match: a,
          mode: o,
          voids: s
        }));
        if (w.length > 0) {
          var [k] = w, E = w[w.length - 1], [, v] = k, [, O] = E;
          if (v.length === 0 && O.length === 0)
            return 0;
          var L = te.equals(v, O) ? te.parent(v) : te.common(v, O), W = A.range(t, v, O), D = A.node(t, L), [N] = D, _ = L.length + 1, R = te.next(O.slice(0, _)), U = dm(dm({}, n), {}, {
            children: []
          });
          pe.insertNodes(t, U, {
            at: R,
            voids: s
          }), pe.moveNodes(t, {
            at: W,
            match: (z) => xe.isAncestor(N) && N.children.includes(z),
            to: R.concat(0),
            voids: s
          });
        }
      }, f;
      for (var [, g] of p)
        f = m();
    }
  });
}, XM = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wk(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Lk(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kk(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mk(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ak(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ek(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Uk(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vk(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return MM(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wk(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qk(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ok(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return EM(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ck(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xk(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dk(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Pk(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Sk(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return AM(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kM(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return TM(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tk(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bk(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jk(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _k(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ik(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return oM(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Rk(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nk(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zk(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $k(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return FM(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gk(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zk(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Yk(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Xk(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Kk(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jk(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qk(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eM(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tM(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return RM(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $M(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return BM(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return UM(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iM(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sM(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return aM(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lM(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uM(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pM(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cM(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dM(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gM(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fM(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hM(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mM(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vM(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wM(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yM(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bM(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return WM(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jM(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return VM(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return OM(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _M(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return IM(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qM(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xM(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DM(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LM(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return GM(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ZM(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fk(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PM(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return YM(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SM(e, ...r);
    }
  };
  return e;
};
const QE = (e) => {
  if (De.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (xe.isElement(e)) {
    const t = e.children.map((r) => QE(r)).join(""), n = e.align || "left";
    switch (e.type) {
      case "image":
        return `<img src="${e.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${t}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${t}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${t}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${t}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${t}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${t}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, eG = (e) => e.map((t) => QE(t)).join("");
var eO = {}, _f = {}, If = {};
Object.defineProperty(If, "__esModule", { value: !0 });
If.default = eA;
var pm = "html", fm = "head", ga = "body", KM = /<([a-zA-Z]+[0-9]?)/, hm = /<head[^]*>/i, gm = /<body[^]*>/i, Tl = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, yp = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, mm = typeof window == "object" && window.DOMParser;
if (typeof mm == "function") {
  var JM = new mm(), QM = "text/html";
  yp = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), JM.parseFromString(e, QM);
  }, Tl = yp;
}
if (typeof document == "object" && document.implementation) {
  var ma = document.implementation.createHTMLDocument();
  Tl = function(e, t) {
    if (t) {
      var n = ma.documentElement.querySelector(t);
      return n && (n.innerHTML = e), ma;
    }
    return ma.documentElement.innerHTML = e, ma;
  };
}
var va = typeof document == "object" && document.createElement("template"), bp;
va && va.content && (bp = function(e) {
  return va.innerHTML = e, va.content.childNodes;
});
function eA(e) {
  var t, n, r = e.match(KM), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case pm: {
      var i = yp(e);
      if (!hm.test(e)) {
        var s = i.querySelector(fm);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!gm.test(e)) {
        var s = i.querySelector(ga);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(pm);
    }
    case fm:
    case ga: {
      var a = Tl(e).querySelectorAll(o);
      return gm.test(e) && hm.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (bp)
        return bp(e);
      var s = Tl(e, ga).querySelector(ga);
      return s.childNodes;
    }
  }
}
var Mu = {}, Ff = {}, Rf = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Rf);
var it = {}, Co = jt && jt.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), cs = jt && jt.__assign || function() {
  return cs = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, cs.apply(this, arguments);
};
Object.defineProperty(it, "__esModule", { value: !0 });
it.cloneNode = it.hasChildren = it.isDocument = it.isDirective = it.isComment = it.isText = it.isCDATA = it.isTag = it.Element = it.Document = it.CDATA = it.NodeWithChildren = it.ProcessingInstruction = it.Comment = it.Text = it.DataNode = it.Node = void 0;
var Yn = Rf, Nf = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), zf(this, t);
    }, e;
  }()
);
it.Node = Nf;
var Au = (
  /** @class */
  function(e) {
    Co(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Nf)
);
it.DataNode = Au;
var tO = (
  /** @class */
  function(e) {
    Co(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Yn.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Au)
);
it.Text = tO;
var nO = (
  /** @class */
  function(e) {
    Co(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Yn.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Au)
);
it.Comment = nO;
var rO = (
  /** @class */
  function(e) {
    Co(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Yn.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Au)
);
it.ProcessingInstruction = rO;
var Tu = (
  /** @class */
  function(e) {
    Co(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Nf)
);
it.NodeWithChildren = Tu;
var oO = (
  /** @class */
  function(e) {
    Co(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Yn.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tu)
);
it.CDATA = oO;
var iO = (
  /** @class */
  function(e) {
    Co(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Yn.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tu)
);
it.Document = iO;
var sO = (
  /** @class */
  function(e) {
    Co(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Yn.ElementType.Script : n === "style" ? Yn.ElementType.Style : Yn.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Tu)
);
it.Element = sO;
function aO(e) {
  return (0, Yn.isTag)(e);
}
it.isTag = aO;
function lO(e) {
  return e.type === Yn.ElementType.CDATA;
}
it.isCDATA = lO;
function uO(e) {
  return e.type === Yn.ElementType.Text;
}
it.isText = uO;
function cO(e) {
  return e.type === Yn.ElementType.Comment;
}
it.isComment = cO;
function dO(e) {
  return e.type === Yn.ElementType.Directive;
}
it.isDirective = dO;
function pO(e) {
  return e.type === Yn.ElementType.Root;
}
it.isDocument = pO;
function tA(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
it.hasChildren = tA;
function zf(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (uO(e))
    n = new tO(e.data);
  else if (cO(e))
    n = new nO(e.data);
  else if (aO(e)) {
    var r = t ? zc(e.children) : [], o = new sO(e.name, cs({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = cs({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = cs({}, e["x-attribsPrefix"])), n = o;
  } else if (lO(e)) {
    var r = t ? zc(e.children) : [], i = new oO(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (pO(e)) {
    var r = t ? zc(e.children) : [], s = new iO(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (dO(e)) {
    var a = new rO(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
it.cloneNode = zf;
function zc(e) {
  for (var t = e.map(function(r) {
    return zf(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = jt && jt.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var d = Object.getOwnPropertyDescriptor(l, u);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, d);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = jt && jt.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Rf, o = it;
  n(it, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, d = new o.Element(l, u, void 0, c);
        this.addNode(d), this.tagStack.push(d);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Ff);
var fO = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(fO);
Object.defineProperty(Mu, "__esModule", { value: !0 });
Mu.formatAttributes = hO;
Mu.formatDOM = gO;
var ya = Ff, nA = fO;
function rA(e) {
  return nA.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function hO(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function oA(e) {
  e = e.toLowerCase();
  var t = rA(e);
  return t || e;
}
function gO(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = oA(a.nodeName);
        o = new ya.Element(l, hO(a.attributes)), o.children = gO(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new ya.Text(a.nodeValue);
        break;
      case 8:
        o = new ya.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new ya.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var iA = jt && jt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(_f, "__esModule", { value: !0 });
_f.default = uA;
var sA = iA(If), aA = Mu, lA = /<(![a-zA-Z\s]+)>/;
function uA(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(lA), n = t ? t[1] : void 0;
  return (0, aA.formatDOM)((0, sA.default)(e), null, n);
}
var Bu = {}, wr = {}, ju = {}, cA = 0;
ju.SAME = cA;
var dA = 1;
ju.CAMELCASE = dA;
ju.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const mO = 0, Eo = 1, _u = 2, Iu = 3, $f = 4, vO = 5, yO = 6;
function pA(e) {
  return An.hasOwnProperty(e) ? An[e] : null;
}
function zn(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === _u || t === Iu || t === $f, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const An = {}, fA = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
fA.forEach((e) => {
  An[e] = new zn(
    e,
    mO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  An[e] = new zn(
    e,
    Eo,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  An[e] = new zn(
    e,
    _u,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  An[e] = new zn(
    e,
    _u,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  An[e] = new zn(
    e,
    Iu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  An[e] = new zn(
    e,
    Iu,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  An[e] = new zn(
    e,
    $f,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  An[e] = new zn(
    e,
    yO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  An[e] = new zn(
    e,
    vO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Uf = /[\-\:]([a-z])/g, Wf = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Uf, Wf);
  An[t] = new zn(
    t,
    Eo,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Uf, Wf);
  An[t] = new zn(
    t,
    Eo,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Uf, Wf);
  An[t] = new zn(
    t,
    Eo,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  An[e] = new zn(
    e,
    Eo,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const hA = "xlinkHref";
An[hA] = new zn(
  "xlinkHref",
  Eo,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  An[e] = new zn(
    e,
    Eo,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: gA,
  SAME: mA,
  possibleStandardNames: vm
} = ju, vA = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", yA = vA + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", bA = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + yA + "]*$")
), wA = Object.keys(
  vm
).reduce((e, t) => {
  const n = vm[t];
  return n === mA ? e[t] = t : n === gA ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
wr.BOOLEAN = Iu;
wr.BOOLEANISH_STRING = _u;
wr.NUMERIC = vO;
wr.OVERLOADED_BOOLEAN = $f;
wr.POSITIVE_NUMERIC = yO;
wr.RESERVED = mO;
wr.STRING = Eo;
wr.getPropertyInfo = pA;
wr.isCustomAttribute = bA;
wr.possibleStandardNames = wA;
var Vf = {}, Hf = {}, ym = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, CA = /\n/g, EA = /^\s*/, OA = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, xA = /^:\s*/, DA = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, LA = /^[;\s]*/, PA = /^\s+|\s+$/g, SA = `
`, bm = "/", wm = "*", Uo = "", kA = "comment", MA = "declaration", AA = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var g = f.match(CA);
    g && (n += g.length);
    var h = f.lastIndexOf(SA);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(g) {
      return g.position = new s(f), u(), g;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var g = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (g.reason = f, g.filename = t.source, g.line = n, g.column = r, g.source = e, !t.silent) throw g;
  }
  function l(f) {
    var g = f.exec(e);
    if (g) {
      var h = g[0];
      return o(h), e = e.slice(h.length), g;
    }
  }
  function u() {
    l(EA);
  }
  function c(f) {
    var g;
    for (f = f || []; g = d(); )
      g !== !1 && f.push(g);
    return f;
  }
  function d() {
    var f = i();
    if (!(bm != e.charAt(0) || wm != e.charAt(1))) {
      for (var g = 2; Uo != e.charAt(g) && (wm != e.charAt(g) || bm != e.charAt(g + 1)); )
        ++g;
      if (g += 2, Uo === e.charAt(g - 1))
        return a("End of comment missing");
      var h = e.slice(2, g - 2);
      return r += 2, o(h), e = e.slice(g), r += 2, f({
        type: kA,
        comment: h
      });
    }
  }
  function p() {
    var f = i(), g = l(OA);
    if (g) {
      if (d(), !l(xA)) return a("property missing ':'");
      var h = l(DA), C = f({
        type: MA,
        property: Cm(g[0].replace(ym, Uo)),
        value: h ? Cm(h[0].replace(ym, Uo)) : Uo
      });
      return l(LA), C;
    }
  }
  function m() {
    var f = [];
    c(f);
    for (var g; g = p(); )
      g !== !1 && (f.push(g), c(f));
    return f;
  }
  return u(), m();
};
function Cm(e) {
  return e ? e.replace(PA, Uo) : Uo;
}
var TA = jt && jt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Hf, "__esModule", { value: !0 });
Hf.default = jA;
var BA = TA(AA);
function jA(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, BA.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Fu = {};
Object.defineProperty(Fu, "__esModule", { value: !0 });
Fu.camelCase = void 0;
var _A = /^--[a-zA-Z0-9_-]+$/, IA = /-([a-z])/g, FA = /^[^-]+$/, RA = /^-(webkit|moz|ms|o|khtml)-/, NA = /^-(ms)-/, zA = function(e) {
  return !e || FA.test(e) || _A.test(e);
}, $A = function(e, t) {
  return t.toUpperCase();
}, Em = function(e, t) {
  return "".concat(t, "-");
}, UA = function(e, t) {
  return t === void 0 && (t = {}), zA(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(NA, Em) : e = e.replace(RA, Em), e.replace(IA, $A));
};
Fu.camelCase = UA;
var WA = jt && jt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, VA = WA(Hf), HA = Fu;
function wp(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, VA.default)(e, function(r, o) {
    r && o && (n[(0, HA.camelCase)(r, t)] = o);
  }), n;
}
wp.default = wp;
var qA = wp;
(function(e) {
  var t = jt && jt.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ce, r = t(qA), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, d) {
    return c.includes("-") ? !o.has(c) : !!(d && typeof d.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, d) {
    if (typeof c == "string") {
      if (!c.trim()) {
        d.style = {};
        return;
      }
      try {
        d.style = (0, r.default)(c, s);
      } catch {
        d.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(Vf);
Object.defineProperty(Bu, "__esModule", { value: !0 });
Bu.default = XA;
var os = wr, Om = Vf, GA = ["checked", "value"], ZA = ["input", "select", "textarea"], YA = {
  reset: !0,
  submit: !0
};
function XA(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && YA[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, os.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = xm(s);
    if (a) {
      var l = (0, os.getPropertyInfo)(a);
      switch (GA.includes(a) && ZA.includes(t) && !r && (a = xm("default" + s)), n[a] = i, l && l.type) {
        case os.BOOLEAN:
          n[a] = !0;
          break;
        case os.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    Om.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, Om.setStyleProp)(e.style, n), n;
}
function xm(e) {
  return os.possibleStandardNames[e];
}
var qf = {}, KA = jt && jt.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(qf, "__esModule", { value: !0 });
qf.default = bO;
var $c = Ce, JA = KA(Bu), ds = Vf, QA = {
  cloneElement: $c.cloneElement,
  createElement: $c.createElement,
  isValidElement: $c.isValidElement
};
function bO(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || ds.returnFirstArg, i = t.library || QA, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var d = e[c];
    if (r) {
      var p = t.replace(d, c);
      if (l(p)) {
        u > 1 && (p = s(p, {
          key: p.key || c
        })), n.push(o(p, d, c));
        continue;
      }
    }
    if (d.type === "text") {
      var m = !d.data.trim().length;
      if (m && d.parent && !(0, ds.canTextBeChildOfNode)(d.parent) || t.trim && m)
        continue;
      n.push(o(d.data, d, c));
      continue;
    }
    var f = d, g = {};
    eT(f) ? ((0, ds.setStyleProp)(f.attribs.style, f.attribs), g = f.attribs) : f.attribs && (g = (0, JA.default)(f.attribs, f.name));
    var h = void 0;
    switch (d.type) {
      case "script":
      case "style":
        d.children[0] && (g.dangerouslySetInnerHTML = {
          __html: d.children[0].data
        });
        break;
      case "tag":
        d.name === "textarea" && d.children[0] ? g.defaultValue = d.children[0].data : d.children && d.children.length && (h = bO(d.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(a(d.name, g, h), d, c));
  }
  return n.length === 1 ? n[0] : n;
}
function eT(e) {
  return ds.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, ds.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = jt && jt.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(_f);
  e.htmlToDOM = n.default;
  var r = t(Bu);
  e.attributesToProps = r.default;
  var o = t(qf);
  e.domToReact = o.default;
  var i = Ff;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(eO);
const Dm = /* @__PURE__ */ Du(eO), tT = Dm.default || Dm, Cp = (e) => {
  var r;
  if (typeof e == "string")
    return { text: e };
  const t = Array.isArray(e.props.children) ? e.props.children.map((o) => Cp(o)) : [{ text: e.props.children || "" }], n = (r = e.props.className) == null ? void 0 : r.replace("align_", "");
  switch (e.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: e.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: t };
    case "blockquote":
      return { type: "blockQuote", align: n, children: t };
    case "ul":
      return { type: "bulletedList", align: n, children: t };
    case "ol":
      return { type: "numberedList", align: n, children: t };
    case "li":
      return { type: "listItem", align: n, children: t };
    case "h1":
      return { type: "headingOne", align: n, children: t };
    case "h2":
      return { type: "headingTwo", align: n, children: t };
    case "strong":
      return { text: e.props.children, bold: !0 };
    case "code":
      return { text: e.props.children, code: !0 };
    case "em":
      return { text: e.props.children, italic: !0 };
    case "u":
      return { text: e.props.children, underline: !0 };
    default:
      return { text: e.props.children || "" };
  }
}, tG = (e) => {
  const t = tT(e);
  return Array.isArray(t) ? t.map((n) => typeof n == "string" ? { text: n } : Cp(n)) : typeof t == "string" ? [{ text: t }] : [Cp(t)];
}, nG = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function wO(e, t, n) {
  if (!e) return /* @__PURE__ */ j.jsx(j.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ j.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ j.jsx("p", { className: n, children: /* @__PURE__ */ j.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function rG(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: s = "",
    children: a,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], d = `arkynBadge ${t} ${n} ${r} ${s}`;
  return /* @__PURE__ */ j.jsxs("div", { className: d.trim(), ...l, children: [
    Ll(c, o),
    a,
    Ll(c, o)
  ] });
}
function oG(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ j.jsx("div", { className: r.trim(), ...n });
}
function iG(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ j.jsx("div", { className: o.trim(), ...r });
}
function sG(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ j.jsx("aside", { className: r.trim(), ...n });
}
function aG(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, s = Ft.count(r) === 0;
  return /* @__PURE__ */ j.jsx("tbody", { className: i.trim(), ...o, children: s ? /* @__PURE__ */ j.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ j.jsx("td", { colSpan: 100, children: /* @__PURE__ */ j.jsx("div", { children: t }) }) }) : r });
}
function lG(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ j.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ j.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function uG(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ j.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ j.jsx("table", { children: t }) });
}
function cG(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ j.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ j.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ j.jsx("tr", { children: /* @__PURE__ */ j.jsx("th", { colSpan: 100, children: /* @__PURE__ */ j.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function dG(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ j.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ j.jsx("tr", { children: n }),
    /* @__PURE__ */ j.jsx("tr", { className: "spacingRow" })
  ] });
}
var _t = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function nT(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ep = { exports: {} }, Wi = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lm;
function rT() {
  if (Lm) return Wi;
  Lm = 1;
  var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, d = {}, p = null, m = null;
    u !== void 0 && (p = "" + u), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (d[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) d[c] === void 0 && (d[c] = l[c]);
    return { $$typeof: t, type: a, key: p, ref: m, props: d, _owner: o.current };
  }
  return Wi.Fragment = n, Wi.jsx = s, Wi.jsxs = s, Wi;
}
var ba = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Pm;
function oT() {
  return Pm || (Pm = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), f = Symbol.iterator, g = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var H = f && b[f] || b[g];
      return typeof H == "function" ? H : null;
    }
    var C = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var H = arguments.length, ee = new Array(H > 1 ? H - 1 : 0), oe = 1; oe < H; oe++)
          ee[oe - 1] = arguments[oe];
        k("error", b, ee);
      }
    }
    function k(b, H, ee) {
      {
        var oe = C.ReactDebugCurrentFrame, ve = oe.getStackAddendum();
        ve !== "" && (H += "%s", ee = ee.concat([ve]));
        var we = ee.map(function(he) {
          return String(he);
        });
        we.unshift("Warning: " + H), Function.prototype.apply.call(console[b], console, we);
      }
    }
    var E = !1, v = !1, O = !1, L = !1, W = !1, D;
    D = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || W || b === o || b === u || b === c || L || b === m || E || v || O || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === d || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === D || b.getModuleId !== void 0));
    }
    function _(b, H, ee) {
      var oe = b.displayName;
      if (oe)
        return oe;
      var ve = H.displayName || H.name || "";
      return ve !== "" ? ee + "(" + ve + ")" : ee;
    }
    function R(b) {
      return b.displayName || "Context";
    }
    function U(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var H = b;
            return R(H) + ".Consumer";
          case s:
            var ee = b;
            return R(ee._context) + ".Provider";
          case l:
            return _(b, b.render, "ForwardRef");
          case d:
            var oe = b.displayName || null;
            return oe !== null ? oe : U(b.type) || "Memo";
          case p: {
            var ve = b, we = ve._payload, he = ve._init;
            try {
              return U(he(we));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, K, X, ne, Q, S, I, Z;
    function T() {
    }
    T.__reactDisabledLog = !0;
    function Y() {
      {
        if (q === 0) {
          K = console.log, X = console.info, ne = console.warn, Q = console.error, S = console.group, I = console.groupCollapsed, Z = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: T,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function x() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: X
            }),
            warn: z({}, b, {
              value: ne
            }),
            error: z({}, b, {
              value: Q
            }),
            group: z({}, b, {
              value: S
            }),
            groupCollapsed: z({}, b, {
              value: I
            }),
            groupEnd: z({}, b, {
              value: Z
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = C.ReactCurrentDispatcher, $;
    function B(b, H, ee) {
      {
        if ($ === void 0)
          try {
            throw Error();
          } catch (ve) {
            var oe = ve.stack.trim().match(/\n( *(at )?)/);
            $ = oe && oe[1] || "";
          }
        return `
` + $ + b;
      }
    }
    var V = !1, F;
    {
      var J = typeof WeakMap == "function" ? WeakMap : Map;
      F = new J();
    }
    function G(b, H) {
      if (!b || V)
        return "";
      {
        var ee = F.get(b);
        if (ee !== void 0)
          return ee;
      }
      var oe;
      V = !0;
      var ve = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var we;
      we = M.current, M.current = null, Y();
      try {
        if (H) {
          var he = function() {
            throw Error();
          };
          if (Object.defineProperty(he.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(he, []);
            } catch ($e) {
              oe = $e;
            }
            Reflect.construct(b, [], he);
          } else {
            try {
              he.call();
            } catch ($e) {
              oe = $e;
            }
            b.call(he.prototype);
          }
        } else {
          try {
            throw Error();
          } catch ($e) {
            oe = $e;
          }
          b();
        }
      } catch ($e) {
        if ($e && oe && typeof $e.stack == "string") {
          for (var de = $e.stack.split(`
`), Fe = oe.stack.split(`
`), Le = de.length - 1, Se = Fe.length - 1; Le >= 1 && Se >= 0 && de[Le] !== Fe[Se]; )
            Se--;
          for (; Le >= 1 && Se >= 0; Le--, Se--)
            if (de[Le] !== Fe[Se]) {
              if (Le !== 1 || Se !== 1)
                do
                  if (Le--, Se--, Se < 0 || de[Le] !== Fe[Se]) {
                    var rt = `
` + de[Le].replace(" at new ", " at ");
                    return b.displayName && rt.includes("<anonymous>") && (rt = rt.replace("<anonymous>", b.displayName)), typeof b == "function" && F.set(b, rt), rt;
                  }
                while (Le >= 1 && Se >= 0);
              break;
            }
        }
      } finally {
        V = !1, M.current = we, x(), Error.prepareStackTrace = ve;
      }
      var En = b ? b.displayName || b.name : "", nn = En ? B(En) : "";
      return typeof b == "function" && F.set(b, nn), nn;
    }
    function fe(b, H, ee) {
      return G(b, !1);
    }
    function be(b) {
      var H = b.prototype;
      return !!(H && H.isReactComponent);
    }
    function re(b, H, ee) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return G(b, be(b));
      if (typeof b == "string")
        return B(b);
      switch (b) {
        case u:
          return B("Suspense");
        case c:
          return B("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return fe(b.render);
          case d:
            return re(b.type, H, ee);
          case p: {
            var oe = b, ve = oe._payload, we = oe._init;
            try {
              return re(we(ve), H, ee);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ie = {}, je = C.ReactDebugCurrentFrame;
    function _e(b) {
      if (b) {
        var H = b._owner, ee = re(b.type, b._source, H ? H.type : null);
        je.setExtraStackFrame(ee);
      } else
        je.setExtraStackFrame(null);
    }
    function tt(b, H, ee, oe, ve) {
      {
        var we = Function.call.bind(Ae);
        for (var he in b)
          if (we(b, he)) {
            var de = void 0;
            try {
              if (typeof b[he] != "function") {
                var Fe = Error((oe || "React class") + ": " + ee + " type `" + he + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[he] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Fe.name = "Invariant Violation", Fe;
              }
              de = b[he](H, he, oe, ee, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Le) {
              de = Le;
            }
            de && !(de instanceof Error) && (_e(ve), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", oe || "React class", ee, he, typeof de), _e(null)), de instanceof Error && !(de.message in Ie) && (Ie[de.message] = !0, _e(ve), w("Failed %s type: %s", ee, de.message), _e(null));
          }
      }
    }
    var Ke = Array.isArray;
    function ke(b) {
      return Ke(b);
    }
    function nt(b) {
      {
        var H = typeof Symbol == "function" && Symbol.toStringTag, ee = H && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return ee;
      }
    }
    function gt(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Te(b) {
      if (gt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", nt(b)), Pe(b);
    }
    var Re = C.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ze, wt, Be;
    Be = {};
    function dn(b) {
      if (Ae.call(b, "ref")) {
        var H = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (H && H.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Ct(b) {
      if (Ae.call(b, "key")) {
        var H = Object.getOwnPropertyDescriptor(b, "key").get;
        if (H && H.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function Pt(b, H) {
      if (typeof b.ref == "string" && Re.current && H && Re.current.stateNode !== H) {
        var ee = U(Re.current.type);
        Be[ee] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', U(Re.current.type), b.ref), Be[ee] = !0);
      }
    }
    function Rt(b, H) {
      {
        var ee = function() {
          ze || (ze = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", H));
        };
        ee.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: ee,
          configurable: !0
        });
      }
    }
    function vn(b, H) {
      {
        var ee = function() {
          wt || (wt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", H));
        };
        ee.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: ee,
          configurable: !0
        });
      }
    }
    var Nt = function(b, H, ee, oe, ve, we, he) {
      var de = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: H,
        ref: ee,
        props: he,
        // Record the component responsible for creating this element.
        _owner: we
      };
      return de._store = {}, Object.defineProperty(de._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(de, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: oe
      }), Object.defineProperty(de, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ve
      }), Object.freeze && (Object.freeze(de.props), Object.freeze(de)), de;
    };
    function yn(b, H, ee, oe, ve) {
      {
        var we, he = {}, de = null, Fe = null;
        ee !== void 0 && (Te(ee), de = "" + ee), Ct(H) && (Te(H.key), de = "" + H.key), dn(H) && (Fe = H.ref, Pt(H, ve));
        for (we in H)
          Ae.call(H, we) && !He.hasOwnProperty(we) && (he[we] = H[we]);
        if (b && b.defaultProps) {
          var Le = b.defaultProps;
          for (we in Le)
            he[we] === void 0 && (he[we] = Le[we]);
        }
        if (de || Fe) {
          var Se = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          de && Rt(he, Se), Fe && vn(he, Se);
        }
        return Nt(b, de, Fe, ve, oe, Re.current, he);
      }
    }
    var mt = C.ReactCurrentOwner, en = C.ReactDebugCurrentFrame;
    function St(b) {
      if (b) {
        var H = b._owner, ee = re(b.type, b._source, H ? H.type : null);
        en.setExtraStackFrame(ee);
      } else
        en.setExtraStackFrame(null);
    }
    var bn;
    bn = !1;
    function zt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Pn() {
      {
        if (mt.current) {
          var b = U(mt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function wn(b) {
      return "";
    }
    var Sn = {};
    function Cn(b) {
      {
        var H = Pn();
        if (!H) {
          var ee = typeof b == "string" ? b : b.displayName || b.name;
          ee && (H = `

Check the top-level render call using <` + ee + ">.");
        }
        return H;
      }
    }
    function kn(b, H) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var ee = Cn(H);
        if (Sn[ee])
          return;
        Sn[ee] = !0;
        var oe = "";
        b && b._owner && b._owner !== mt.current && (oe = " It was passed a child from " + U(b._owner.type) + "."), St(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ee, oe), St(null);
      }
    }
    function Wn(b, H) {
      {
        if (typeof b != "object")
          return;
        if (ke(b))
          for (var ee = 0; ee < b.length; ee++) {
            var oe = b[ee];
            zt(oe) && kn(oe, H);
          }
        else if (zt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ve = h(b);
          if (typeof ve == "function" && ve !== b.entries)
            for (var we = ve.call(b), he; !(he = we.next()).done; )
              zt(he.value) && kn(he.value, H);
        }
      }
    }
    function tn(b) {
      {
        var H = b.type;
        if (H == null || typeof H == "string")
          return;
        var ee;
        if (typeof H == "function")
          ee = H.propTypes;
        else if (typeof H == "object" && (H.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        H.$$typeof === d))
          ee = H.propTypes;
        else
          return;
        if (ee) {
          var oe = U(H);
          tt(ee, b.props, "prop", oe, b);
        } else if (H.PropTypes !== void 0 && !bn) {
          bn = !0;
          var ve = U(H);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ve || "Unknown");
        }
        typeof H.getDefaultProps == "function" && !H.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function se(b) {
      {
        for (var H = Object.keys(b.props), ee = 0; ee < H.length; ee++) {
          var oe = H[ee];
          if (oe !== "children" && oe !== "key") {
            St(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", oe), St(null);
            break;
          }
        }
        b.ref !== null && (St(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), St(null));
      }
    }
    var Xr = {};
    function Kr(b, H, ee, oe, ve, we) {
      {
        var he = N(b);
        if (!he) {
          var de = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (de += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Fe = wn();
          Fe ? de += Fe : de += Pn();
          var Le;
          b === null ? Le = "null" : ke(b) ? Le = "array" : b !== void 0 && b.$$typeof === t ? (Le = "<" + (U(b.type) || "Unknown") + " />", de = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, de);
        }
        var Se = yn(b, H, ee, ve, we);
        if (Se == null)
          return Se;
        if (he) {
          var rt = H.children;
          if (rt !== void 0)
            if (oe)
              if (ke(rt)) {
                for (var En = 0; En < rt.length; En++)
                  Wn(rt[En], b);
                Object.freeze && Object.freeze(rt);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Wn(rt, b);
        }
        if (Ae.call(H, "key")) {
          var nn = U(b), $e = Object.keys(H).filter(function(Ni) {
            return Ni !== "key";
          }), yr = $e.length > 0 ? "{key: someKey, " + $e.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Xr[nn + yr]) {
            var Ri = $e.length > 0 ? "{" + $e.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, yr, nn, Ri, nn), Xr[nn + yr] = !0;
          }
        }
        return b === r ? se(Se) : tn(Se), Se;
      }
    }
    function ji(b, H, ee) {
      return Kr(b, H, ee, !0);
    }
    function _i(b, H, ee) {
      return Kr(b, H, ee, !1);
    }
    var Ii = _i, Fi = ji;
    ba.Fragment = r, ba.jsx = Ii, ba.jsxs = Fi;
  }()), ba;
}
process.env.NODE_ENV === "production" ? Ep.exports = rT() : Ep.exports = oT();
var At = Ep.exports;
Ze({});
function Sm(e, t) {
  return t ? /* @__PURE__ */ At.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ At.jsx(At.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function km(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function _n(e) {
  var t, n;
  return km(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(km(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var CO = Symbol.for("immer-nothing"), Mm = Symbol.for("immer-draftable"), ar = Symbol.for("immer-state"), iT = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function qn(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = iT[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var yi = Object.getPrototypeOf;
function ni(e) {
  return !!e && !!e[ar];
}
function ri(e) {
  var t;
  return e ? EO(e) || Array.isArray(e) || !!e[Mm] || !!((t = e.constructor) != null && t[Mm]) || Nu(e) || zu(e) : !1;
}
var sT = Object.prototype.constructor.toString();
function EO(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = yi(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === sT;
}
function Bl(e, t) {
  Ru(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Ru(e) {
  const t = e[ar];
  return t ? t.type_ : Array.isArray(e) ? 1 : Nu(e) ? 2 : zu(e) ? 3 : 0;
}
function Op(e, t) {
  return Ru(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function OO(e, t, n) {
  const r = Ru(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function aT(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Nu(e) {
  return e instanceof Map;
}
function zu(e) {
  return e instanceof Set;
}
function No(e) {
  return e.copy_ || e.base_;
}
function xp(e, t) {
  if (Nu(e))
    return new Map(e);
  if (zu(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = EO(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ar];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(yi(e), r);
  } else {
    const r = yi(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Gf(e, t = !1) {
  return $u(e) || ni(e) || !ri(e) || (Ru(e) > 1 && (e.set = e.add = e.clear = e.delete = lT), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Gf(r, !0))), e;
}
function lT() {
  qn(2);
}
function $u(e) {
  return Object.isFrozen(e);
}
var uT = {};
function oi(e) {
  const t = uT[e];
  return t || qn(0, e), t;
}
var Ss;
function xO() {
  return Ss;
}
function cT(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Am(e, t) {
  t && (oi("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Dp(e) {
  Lp(e), e.drafts_.forEach(dT), e.drafts_ = null;
}
function Lp(e) {
  e === Ss && (Ss = e.parent_);
}
function Tm(e) {
  return Ss = cT(Ss, e);
}
function dT(e) {
  const t = e[ar];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function Bm(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ar].modified_ && (Dp(t), qn(4)), ri(e) && (e = jl(t, e), t.parent_ || _l(t, e)), t.patches_ && oi("Patches").generateReplacementPatches_(
    n[ar].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = jl(t, n, []), Dp(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== CO ? e : void 0;
}
function jl(e, t, n) {
  if ($u(t))
    return t;
  const r = t[ar];
  if (!r)
    return Bl(
      t,
      (o, i) => jm(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return _l(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Bl(
      i,
      (a, l) => jm(e, r, o, a, l, n, s)
    ), _l(e, o, !1), n && e.patches_ && oi("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function jm(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && qn(5), ni(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Op(t.assigned_, r) ? i.concat(r) : void 0, l = jl(e, o, a);
    if (OO(n, r, l), ni(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (ri(o) && !$u(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    jl(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && _l(e, o);
  }
}
function _l(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Gf(t, n);
}
function pT(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : xO(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Zf;
  n && (o = [r], i = ks);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var Zf = {
  get(e, t) {
    if (t === ar)
      return e;
    const n = No(e);
    if (!Op(n, t))
      return fT(e, n, t);
    const r = n[t];
    return e.finalized_ || !ri(r) ? r : r === Uc(e.base_, t) ? (Wc(e), e.copy_[t] = Sp(r, e)) : r;
  },
  has(e, t) {
    return t in No(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(No(e));
  },
  set(e, t, n) {
    const r = DO(No(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Uc(No(e), t), i = o == null ? void 0 : o[ar];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (aT(n, o) && (n !== void 0 || Op(e.base_, t)))
        return !0;
      Wc(e), Pp(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Uc(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Wc(e), Pp(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = No(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    qn(11);
  },
  getPrototypeOf(e) {
    return yi(e.base_);
  },
  setPrototypeOf() {
    qn(12);
  }
}, ks = {};
Bl(Zf, (e, t) => {
  ks[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
ks.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && qn(13), ks.set.call(this, e, t, void 0);
};
ks.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && qn(14), Zf.set.call(this, e[0], t, n, e[0]);
};
function Uc(e, t) {
  const n = e[ar];
  return (n ? No(n) : e)[t];
}
function fT(e, t, n) {
  var r;
  const o = DO(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function DO(e, t) {
  if (!(t in e))
    return;
  let n = yi(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = yi(n);
  }
}
function Pp(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Pp(e.parent_));
}
function Wc(e) {
  e.copy_ || (e.copy_ = xp(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var hT = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && qn(6), r !== void 0 && typeof r != "function" && qn(7);
      let o;
      if (ri(t)) {
        const i = Tm(this), s = Sp(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? Dp(i) : Lp(i);
        }
        return Am(i, r), Bm(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === CO && (o = void 0), this.autoFreeze_ && Gf(o, !0), r) {
          const i = [], s = [];
          oi("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        qn(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ri(e) || qn(8), ni(e) && (e = gT(e));
    const t = Tm(this), n = Sp(e, void 0);
    return n[ar].isManual_ = !0, Lp(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ar];
    (!n || !n.isManual_) && qn(9);
    const { scope_: r } = n;
    return Am(r, t), Bm(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = oi("Patches").applyPatches_;
    return ni(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Sp(e, t) {
  const n = Nu(e) ? oi("MapSet").proxyMap_(e, t) : zu(e) ? oi("MapSet").proxySet_(e, t) : pT(e, t);
  return (t ? t.scope_ : xO()).drafts_.push(n), n;
}
function gT(e) {
  return ni(e) || qn(10, e), LO(e);
}
function LO(e) {
  if (!ri(e) || $u(e))
    return e;
  const t = e[ar];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = xp(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = xp(e, !0);
  return Bl(n, (r, o) => {
    OO(n, r, LO(o));
  }), t && (t.finalized_ = !1), n;
}
var lr = new hT(), Yf = lr.produce;
lr.produceWithPatches.bind(
  lr
);
lr.setAutoFreeze.bind(lr);
lr.setUseStrictShallowCopy.bind(lr);
lr.applyPatches.bind(lr);
var _m = lr.createDraft.bind(lr), Im = lr.finishDraft.bind(lr), ge = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ge.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return ge.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ge.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return ge.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ge.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ge.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ge.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ge.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ge.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ge.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ge.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ge.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ge.isAncestor(t, e) && !ge.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ge.equals(i, r) || ge.endsBefore(i, r) || ge.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (ge.equals(s, r) || ge.isAncestor(s, r))
          return null;
        ge.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        ge.equals(a, r) || ge.endsBefore(a, r) ? r[a.length - 1] -= 1 : ge.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ge.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ge.endsBefore(u, r) ? r[u.length - 1] += 1 : ge.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: d,
          newPath: p
        } = t;
        if (ge.equals(d, p))
          return r;
        if (ge.isAncestor(d, r) || ge.equals(d, r)) {
          var m = p.slice();
          return ge.endsBefore(d, p) && d.length < p.length && (m[d.length - 1] -= 1), m.concat(r.slice(d.length));
        } else ge.isSibling(d, p) && (ge.isAncestor(p, r) || ge.equals(p, r)) ? ge.endsBefore(d, r) ? r[d.length - 1] -= 1 : r[d.length - 1] += 1 : ge.endsBefore(p, r) || ge.equals(p, r) || ge.isAncestor(p, r) ? (ge.endsBefore(d, r) && (r[d.length - 1] -= 1), r[p.length - 1] += 1) : ge.endsBefore(d, r) && (ge.equals(p, r) && (r[p.length - 1] += 1), r[d.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Ms(e) {
  "@babel/helpers - typeof";
  return Ms = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ms(e);
}
function mT(e, t) {
  if (Ms(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ms(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function vT(e) {
  var t = mT(e, "string");
  return Ms(t) === "symbol" ? t : String(t);
}
function Li(e, t, n) {
  return t = vT(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Fm(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Fm(Object(n), !0).forEach(function(r) {
      Li(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fm(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yT = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Ue.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of Qe.points(t))
          t[l] = Wt.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: d
      } = n;
      if (d.length === 0) break;
      var p = Ue.leaf(e, u), m = p.text.slice(0, c), f = p.text.slice(c);
      if (p.text = m + d + f, t)
        for (var [g, h] of Qe.points(t))
          t[h] = Wt.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: C
      } = n, w = Ue.get(e, C), k = ge.previous(C), E = Ue.get(e, k), v = Ue.parent(e, C), O = C[C.length - 1];
      if (pn.isText(w) && pn.isText(E))
        E.text += w.text;
      else if (!pn.isText(w) && !pn.isText(E))
        E.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(C, "] to nodes of different interfaces: ").concat(Qn.stringify(w), " ").concat(Qn.stringify(E)));
      if (v.children.splice(O, 1), t)
        for (var [L, W] of Qe.points(t))
          t[W] = Wt.transform(L, n);
      break;
    }
    case "move_node": {
      var {
        path: D,
        newPath: N
      } = n;
      if (ge.isAncestor(D, N))
        throw new Error("Cannot move a path [".concat(D, "] to new path [").concat(N, "] because the destination is inside itself."));
      var _ = Ue.get(e, D), R = Ue.parent(e, D), U = D[D.length - 1];
      R.children.splice(U, 1);
      var z = ge.transform(D, n), q = Ue.get(e, ge.parent(z)), K = z[z.length - 1];
      if (q.children.splice(K, 0, _), t)
        for (var [X, ne] of Qe.points(t))
          t[ne] = Wt.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: Q
      } = n, S = Q[Q.length - 1], I = Ue.parent(e, Q);
      if (I.children.splice(S, 1), t)
        for (var [Z, T] of Qe.points(t)) {
          var Y = Wt.transform(Z, n);
          if (t != null && Y != null)
            t[T] = Y;
          else {
            var x = void 0, M = void 0;
            for (var [$, B] of Ue.texts(e))
              if (ge.compare(B, Q) === -1)
                x = [$, B];
              else {
                M = [$, B];
                break;
              }
            var V = !1;
            x && M && (ge.equals(M[1], Q) ? V = !ge.hasPrevious(M[1]) : V = ge.common(x[1], Q).length < ge.common(M[1], Q).length), x && !V ? (Z.path = x[1], Z.offset = x[0].text.length) : M ? (Z.path = M[1], Z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: F,
        offset: J,
        text: G
      } = n;
      if (G.length === 0) break;
      var fe = Ue.leaf(e, F), be = fe.text.slice(0, J), re = fe.text.slice(J + G.length);
      if (fe.text = be + re, t)
        for (var [Ae, Ie] of Qe.points(t))
          t[Ie] = Wt.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: je,
        properties: _e,
        newProperties: tt
      } = n;
      if (je.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ke = Ue.get(e, je);
      for (var ke in tt) {
        if (ke === "children" || ke === "text")
          throw new Error('Cannot set the "'.concat(ke, '" property of nodes!'));
        var nt = tt[ke];
        nt == null ? delete Ke[ke] : Ke[ke] = nt;
      }
      for (var gt in _e)
        tt.hasOwnProperty(gt) || delete Ke[gt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!Qe.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Qn.stringify(Pe), " when there is no current selection."));
          t = Vi({}, Pe);
        }
        for (var Te in Pe) {
          var Re = Pe[Te];
          if (Re == null) {
            if (Te === "anchor" || Te === "focus")
              throw new Error('Cannot remove the "'.concat(Te, '" selection property'));
            delete t[Te];
          } else
            t[Te] = Re;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: He,
        position: ze,
        properties: wt
      } = n;
      if (He.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(He, "] because the root node cannot be split."));
      var Be = Ue.get(e, He), dn = Ue.parent(e, He), Ct = He[He.length - 1], Pt;
      if (pn.isText(Be)) {
        var Rt = Be.text.slice(0, ze), vn = Be.text.slice(ze);
        Be.text = Rt, Pt = Vi(Vi({}, wt), {}, {
          text: vn
        });
      } else {
        var Nt = Be.children.slice(0, ze), yn = Be.children.slice(ze);
        Be.children = Nt, Pt = Vi(Vi({}, wt), {}, {
          children: yn
        });
      }
      if (dn.children.splice(Ct + 1, 0, Pt), t)
        for (var [mt, en] of Qe.points(t))
          t[en] = Wt.transform(mt, n);
      break;
    }
  }
  return t;
}, bT = {
  transform(e, t) {
    e.children = _m(e.children);
    var n = e.selection && _m(e.selection);
    try {
      n = yT(e, n, t);
    } finally {
      e.children = Im(e.children), n ? e.selection = ni(n) ? Im(n) : n : e.selection = null;
    }
  }
}, wT = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, CT = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, PO = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (_n(r) && _n(o)) {
      if (!PO(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function ET(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function As(e, t) {
  if (e == null) return {};
  var n = ET(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var OT = ["anchor", "focus"];
function Rm(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Rm(Object(n), !0).forEach(function(r) {
      Li(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Rm(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qe = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Qe.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Qe.edges(e);
    return t;
  },
  equals(e, t) {
    return Wt.equals(e.anchor, t.anchor) && Wt.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Qe.isRange(t)) {
      if (Qe.includes(e, t.anchor) || Qe.includes(e, t.focus))
        return !0;
      var [n, r] = Qe.edges(e), [o, i] = Qe.edges(t);
      return Wt.isBefore(n, o) && Wt.isAfter(r, i);
    }
    var [s, a] = Qe.edges(e), l = !1, u = !1;
    return Wt.isPoint(t) ? (l = Wt.compare(t, s) >= 0, u = Wt.compare(t, a) <= 0) : (l = ge.compare(t, s.path) >= 0, u = ge.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = As(e, OT), [r, o] = Qe.edges(e), [i, s] = Qe.edges(t), a = Wt.isBefore(r, i) ? i : r, l = Wt.isBefore(o, s) ? o : s;
    return Wt.isBefore(l, a) ? null : xT({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Wt.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Wt.equals(t, n);
  },
  isExpanded(e) {
    return !Qe.isCollapsed(e);
  },
  isForward(e) {
    return !Qe.isBackward(e);
  },
  isRange(e) {
    return _n(e) && Wt.isPoint(e.anchor) && Wt.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Qe.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Yf(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = Qe.isCollapsed(r);
        Qe.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? Qe.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = Wt.transform(r.anchor, t, {
        affinity: i
      }), u = Wt.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, Nm = (e) => _n(e) && Ue.isNodeList(e.children) && !Tt.isEditor(e), zr = {
  isAncestor(e) {
    return _n(e) && Ue.isNodeList(e.children);
  },
  isElement: Nm,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => zr.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Nm(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, DT = ["children"], LT = ["text"], zm = /* @__PURE__ */ new WeakMap(), Ue = {
  ancestor(e, t) {
    var n = Ue.get(e, t);
    if (pn.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Qn.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ge.ancestors(t, n)) {
        var o = Ue.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (pn.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Qn.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Qn.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Ue.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = Ue.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ge.common(t, n), o = Ue.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Ue.get(e, t);
    if (Tt.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Qn.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ue.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ue.nodes(e, t))
        zr.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (zr.isAncestor(e)) {
      var t = As(e, DT);
      return t;
    } else {
      var t = As(e, LT);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Ue.get(e, n); r && !(pn.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (pn.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Qn.stringify(e)));
    var n = Yf({
      children: e.children
    }, (r) => {
      var [o, i] = Qe.edges(t), s = Ue.nodes(r, {
        reverse: !0,
        pass: (p) => {
          var [, m] = p;
          return !Qe.includes(t, m);
        }
      });
      for (var [, a] of s) {
        if (!Qe.includes(t, a)) {
          var l = Ue.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (ge.equals(a, i.path)) {
          var c = Ue.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (ge.equals(a, o.path)) {
          var d = Ue.leaf(r, a);
          d.text = d.text.slice(o.offset);
        }
      }
      Tt.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (pn.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Qn.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (pn.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return pn.isText(e) || zr.isElement(e) || Tt.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = zm.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Ue.isNode(r));
    return zm.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Ue.get(e, n); r && !(pn.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Ue.get(e, t);
    if (!pn.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Qn.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ge.levels(t, n)) {
        var o = Ue.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return zr.isElement(e) && zr.isElementProps(t) && zr.matches(e, t) || pn.isText(e) && pn.isTextProps(t) && pn.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? ge.isBefore(a, i) : ge.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !pn.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          ge.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = Ue.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = ge.next(a);
          if (Ue.has(e, c)) {
            a = c, l = Ue.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var d = ge.previous(a);
          a = d, l = Ue.get(e, a);
          continue;
        }
        a = ge.parent(a), l = Ue.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ge.parent(t), r = Ue.get(e, n);
    if (pn.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return pn.isText(e) ? e.text : e.children.map(Ue.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ue.nodes(e, t))
        pn.isText(n) && (yield [n, r]);
    }();
  }
};
function $m(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $m(Object(n), !0).forEach(function(r) {
      Li(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $m(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var is = {
  isNodeOperation(e) {
    return is.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!_n(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ge.isPath(e.path) && Ue.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ge.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ge.isPath(e.path) && _n(e.properties);
      case "move_node":
        return ge.isPath(e.path) && ge.isPath(e.newPath);
      case "remove_node":
        return ge.isPath(e.path) && Ue.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ge.isPath(e.path);
      case "set_node":
        return ge.isPath(e.path) && _n(e.properties) && _n(e.newProperties);
      case "set_selection":
        return e.properties === null && Qe.isRange(e.newProperties) || e.newProperties === null && Qe.isRange(e.properties) || _n(e.properties) && _n(e.newProperties);
      case "split_node":
        return ge.isPath(e.path) && typeof e.position == "number" && _n(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => is.isOperation(t));
  },
  isSelectionOperation(e) {
    return is.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return is.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return qt(qt({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return qt(qt({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return qt(qt({}, e), {}, {
          type: "split_node",
          path: ge.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ge.equals(t, n))
          return e;
        if (ge.isSibling(n, t))
          return qt(qt({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ge.transform(n, e), o = ge.transform(ge.next(n), e);
        return qt(qt({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return qt(qt({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return qt(qt({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return qt(qt({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? qt(qt({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? qt(qt({}, e), {}, {
          properties: null,
          newProperties: a
        }) : qt(qt({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return qt(qt({}, e), {}, {
          type: "merge_node",
          path: ge.next(e.path)
        });
    }
  }
}, Um = /* @__PURE__ */ new WeakMap(), PT = (e) => {
  var t = Um.get(e);
  if (t !== void 0)
    return t;
  if (!_n(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || _n(e.marks)) && (e.selection === null || Qe.isRange(e.selection)) && Ue.isNodeList(e.children) && is.isOperationList(e.operations);
  return Um.set(e, n), n;
}, Tt = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return PT(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function Wm(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vm(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Wm(Object(n), !0).forEach(function(r) {
      Li(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Wm(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wt = {
  compare(e, t) {
    var n = ge.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Wt.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Wt.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ge.equals(e.path, t.path);
  },
  isPoint(e) {
    return _n(e) && typeof e.offset == "number" && ge.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Yf(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ge.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ge.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ge.equals(t.path, i) && (r.offset += t.position), r.path = ge.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ge.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ge.equals(t.path, i) || ge.isAncestor(t.path, i))
            return null;
          r.path = ge.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ge.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = ge.transform(i, t, Vm(Vm({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ge.transform(i, t, n);
          break;
        }
      }
    });
  }
}, Hm = void 0, Qn = {
  setScrubber(e) {
    Hm = e;
  },
  stringify(e) {
    return JSON.stringify(e, Hm);
  }
}, ST = ["text"], kT = ["anchor", "focus"];
function qm(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _r(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qm(Object(n), !0).forEach(function(r) {
      Li(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qm(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pn = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = As(i, ST);
      return s;
    }
    return PO(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return _n(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => pn.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [_r({}, e)];
    for (var r of t) {
      var o = As(r, kT), [i, s] = Qe.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var d of n) {
        var {
          length: p
        } = d.text, m = l;
        if (l += p, u <= m && l <= c) {
          Object.assign(d, o), a.push(d);
          continue;
        }
        if (u !== c && (u === l || c === m) || u > l || c < m || c === m && m !== 0) {
          a.push(d);
          continue;
        }
        var f = d, g = void 0, h = void 0;
        if (c < l) {
          var C = c - m;
          h = _r(_r({}, f), {}, {
            text: f.text.slice(C)
          }), f = _r(_r({}, f), {}, {
            text: f.text.slice(0, C)
          });
        }
        if (u > m) {
          var w = u - m;
          g = _r(_r({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = _r(_r({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), g && a.push(g), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, MT = (e) => e.selection ? e.selection : e.children.length > 0 ? Tt.end(e, []) : [0], $t;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})($t || ($t = {}));
$t.L, $t.L | $t.V | $t.LV | $t.LVT, $t.LV | $t.V, $t.V | $t.T, $t.LVT | $t.T, $t.T, $t.Any, $t.Extend | $t.ZWJ, $t.Any, $t.SpacingMark, $t.Prepend, $t.Any, $t.ZWJ, $t.ExtPict, $t.RI, $t.RI;
var AT = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Tt.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = MT(e)
      } = n;
      if (ge.isPath(o) && (o = Tt.range(e, o)), Qe.isRange(o))
        if (Qe.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Qe.end(o);
          if (!r && Tt.void(e, {
            at: i
          }))
            return;
          var s = Qe.start(o), a = Tt.pointRef(e, s), l = Tt.pointRef(e, i);
          Il.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Il.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Tt.void(e, {
        at: o
      }) || Tt.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: d,
          offset: p
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: d,
          offset: p,
          text: t
        });
      }
    });
  }
};
function Gm(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wa(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Gm(Object(n), !0).forEach(function(r) {
      Li(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Gm(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Il = wa(wa(wa(wa({}, bT), wT), CT), AT), SO = {}, Xf = {}, Kf = {};
Object.defineProperty(Kf, "__esModule", { value: !0 });
Kf.default = _T;
var Zm = "html", Ym = "head", Ca = "body", TT = /<([a-zA-Z]+[0-9]?)/, Xm = /<head[^]*>/i, Km = /<body[^]*>/i, Fl = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, kp = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, Jm = typeof window == "object" && window.DOMParser;
if (typeof Jm == "function") {
  var BT = new Jm(), jT = "text/html";
  kp = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), BT.parseFromString(e, jT);
  }, Fl = kp;
}
if (typeof document == "object" && document.implementation) {
  var Ea = document.implementation.createHTMLDocument();
  Fl = function(e, t) {
    if (t) {
      var n = Ea.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Ea;
    }
    return Ea.documentElement.innerHTML = e, Ea;
  };
}
var Oa = typeof document == "object" && document.createElement("template"), Mp;
Oa && Oa.content && (Mp = function(e) {
  return Oa.innerHTML = e, Oa.content.childNodes;
});
function _T(e) {
  var t, n, r = e.match(TT), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case Zm: {
      var i = kp(e);
      if (!Xm.test(e)) {
        var s = i.querySelector(Ym);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!Km.test(e)) {
        var s = i.querySelector(Ca);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(Zm);
    }
    case Ym:
    case Ca: {
      var a = Fl(e).querySelectorAll(o);
      return Km.test(e) && Xm.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (Mp)
        return Mp(e);
      var s = Fl(e, Ca).querySelector(Ca);
      return s.childNodes;
    }
  }
}
var Uu = {}, Jf = {}, Qf = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Qf);
var st = {}, Oo = _t && _t.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), ps = _t && _t.__assign || function() {
  return ps = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, ps.apply(this, arguments);
};
Object.defineProperty(st, "__esModule", { value: !0 });
st.cloneNode = st.hasChildren = st.isDocument = st.isDirective = st.isComment = st.isText = st.isCDATA = st.isTag = st.Element = st.Document = st.CDATA = st.NodeWithChildren = st.ProcessingInstruction = st.Comment = st.Text = st.DataNode = st.Node = void 0;
var Xn = Qf, eh = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), th(this, t);
    }, e;
  }()
);
st.Node = eh;
var Wu = (
  /** @class */
  function(e) {
    Oo(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(eh)
);
st.DataNode = Wu;
var kO = (
  /** @class */
  function(e) {
    Oo(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Xn.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Wu)
);
st.Text = kO;
var MO = (
  /** @class */
  function(e) {
    Oo(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Xn.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Wu)
);
st.Comment = MO;
var AO = (
  /** @class */
  function(e) {
    Oo(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Xn.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Wu)
);
st.ProcessingInstruction = AO;
var Vu = (
  /** @class */
  function(e) {
    Oo(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(eh)
);
st.NodeWithChildren = Vu;
var TO = (
  /** @class */
  function(e) {
    Oo(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Xn.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Vu)
);
st.CDATA = TO;
var BO = (
  /** @class */
  function(e) {
    Oo(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Xn.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Vu)
);
st.Document = BO;
var jO = (
  /** @class */
  function(e) {
    Oo(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Xn.ElementType.Script : n === "style" ? Xn.ElementType.Style : Xn.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Vu)
);
st.Element = jO;
function _O(e) {
  return (0, Xn.isTag)(e);
}
st.isTag = _O;
function IO(e) {
  return e.type === Xn.ElementType.CDATA;
}
st.isCDATA = IO;
function FO(e) {
  return e.type === Xn.ElementType.Text;
}
st.isText = FO;
function RO(e) {
  return e.type === Xn.ElementType.Comment;
}
st.isComment = RO;
function NO(e) {
  return e.type === Xn.ElementType.Directive;
}
st.isDirective = NO;
function zO(e) {
  return e.type === Xn.ElementType.Root;
}
st.isDocument = zO;
function IT(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
st.hasChildren = IT;
function th(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (FO(e))
    n = new kO(e.data);
  else if (RO(e))
    n = new MO(e.data);
  else if (_O(e)) {
    var r = t ? Vc(e.children) : [], o = new jO(e.name, ps({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = ps({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = ps({}, e["x-attribsPrefix"])), n = o;
  } else if (IO(e)) {
    var r = t ? Vc(e.children) : [], i = new TO(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (zO(e)) {
    var r = t ? Vc(e.children) : [], s = new BO(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (NO(e)) {
    var a = new AO(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
st.cloneNode = th;
function Vc(e) {
  for (var t = e.map(function(r) {
    return th(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = _t && _t.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var d = Object.getOwnPropertyDescriptor(l, u);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, d);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = _t && _t.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Qf, o = st;
  n(st, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, d = new o.Element(l, u, void 0, c);
        this.addNode(d), this.tagStack.push(d);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Jf);
var $O = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})($O);
Object.defineProperty(Uu, "__esModule", { value: !0 });
Uu.formatAttributes = UO;
Uu.formatDOM = WO;
var xa = Jf, FT = $O;
function RT(e) {
  return FT.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function UO(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function NT(e) {
  e = e.toLowerCase();
  var t = RT(e);
  return t || e;
}
function WO(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = NT(a.nodeName);
        o = new xa.Element(l, UO(a.attributes)), o.children = WO(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new xa.Text(a.nodeValue);
        break;
      case 8:
        o = new xa.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new xa.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var zT = _t && _t.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Xf, "__esModule", { value: !0 });
Xf.default = VT;
var $T = zT(Kf), UT = Uu, WT = /<(![a-zA-Z\s]+)>/;
function VT(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(WT), n = t ? t[1] : void 0;
  return (0, UT.formatDOM)((0, $T.default)(e), null, n);
}
var Hu = {}, Cr = {}, qu = {}, HT = 0;
qu.SAME = HT;
var qT = 1;
qu.CAMELCASE = qT;
qu.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const VO = 0, xo = 1, Gu = 2, Zu = 3, nh = 4, HO = 5, qO = 6;
function GT(e) {
  return Tn.hasOwnProperty(e) ? Tn[e] : null;
}
function $n(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === Gu || t === Zu || t === nh, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const Tn = {}, ZT = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
ZT.forEach((e) => {
  Tn[e] = new $n(
    e,
    VO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Tn[e] = new $n(
    e,
    xo,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Tn[e] = new $n(
    e,
    Gu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Tn[e] = new $n(
    e,
    Gu,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Tn[e] = new $n(
    e,
    Zu,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Tn[e] = new $n(
    e,
    Zu,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Tn[e] = new $n(
    e,
    nh,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Tn[e] = new $n(
    e,
    qO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Tn[e] = new $n(
    e,
    HO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const rh = /[\-\:]([a-z])/g, oh = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(rh, oh);
  Tn[t] = new $n(
    t,
    xo,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(rh, oh);
  Tn[t] = new $n(
    t,
    xo,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(rh, oh);
  Tn[t] = new $n(
    t,
    xo,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Tn[e] = new $n(
    e,
    xo,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const YT = "xlinkHref";
Tn[YT] = new $n(
  "xlinkHref",
  xo,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Tn[e] = new $n(
    e,
    xo,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: XT,
  SAME: KT,
  possibleStandardNames: Qm
} = qu, JT = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", QT = JT + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", eB = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + QT + "]*$")
), tB = Object.keys(
  Qm
).reduce((e, t) => {
  const n = Qm[t];
  return n === KT ? e[t] = t : n === XT ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Cr.BOOLEAN = Zu;
Cr.BOOLEANISH_STRING = Gu;
Cr.NUMERIC = HO;
Cr.OVERLOADED_BOOLEAN = nh;
Cr.POSITIVE_NUMERIC = qO;
Cr.RESERVED = VO;
Cr.STRING = xo;
Cr.getPropertyInfo = GT;
Cr.isCustomAttribute = eB;
Cr.possibleStandardNames = tB;
var ih = {}, sh = {}, ev = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, nB = /\n/g, rB = /^\s*/, oB = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, iB = /^:\s*/, sB = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, aB = /^[;\s]*/, lB = /^\s+|\s+$/g, uB = `
`, tv = "/", nv = "*", Wo = "", cB = "comment", dB = "declaration", pB = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var g = f.match(nB);
    g && (n += g.length);
    var h = f.lastIndexOf(uB);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(g) {
      return g.position = new s(f), u(), g;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var g = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (g.reason = f, g.filename = t.source, g.line = n, g.column = r, g.source = e, !t.silent) throw g;
  }
  function l(f) {
    var g = f.exec(e);
    if (g) {
      var h = g[0];
      return o(h), e = e.slice(h.length), g;
    }
  }
  function u() {
    l(rB);
  }
  function c(f) {
    var g;
    for (f = f || []; g = d(); )
      g !== !1 && f.push(g);
    return f;
  }
  function d() {
    var f = i();
    if (!(tv != e.charAt(0) || nv != e.charAt(1))) {
      for (var g = 2; Wo != e.charAt(g) && (nv != e.charAt(g) || tv != e.charAt(g + 1)); )
        ++g;
      if (g += 2, Wo === e.charAt(g - 1))
        return a("End of comment missing");
      var h = e.slice(2, g - 2);
      return r += 2, o(h), e = e.slice(g), r += 2, f({
        type: cB,
        comment: h
      });
    }
  }
  function p() {
    var f = i(), g = l(oB);
    if (g) {
      if (d(), !l(iB)) return a("property missing ':'");
      var h = l(sB), C = f({
        type: dB,
        property: rv(g[0].replace(ev, Wo)),
        value: h ? rv(h[0].replace(ev, Wo)) : Wo
      });
      return l(aB), C;
    }
  }
  function m() {
    var f = [];
    c(f);
    for (var g; g = p(); )
      g !== !1 && (f.push(g), c(f));
    return f;
  }
  return u(), m();
};
function rv(e) {
  return e ? e.replace(lB, Wo) : Wo;
}
var fB = _t && _t.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(sh, "__esModule", { value: !0 });
sh.default = gB;
var hB = fB(pB);
function gB(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, hB.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Yu = {};
Object.defineProperty(Yu, "__esModule", { value: !0 });
Yu.camelCase = void 0;
var mB = /^--[a-zA-Z0-9_-]+$/, vB = /-([a-z])/g, yB = /^[^-]+$/, bB = /^-(webkit|moz|ms|o|khtml)-/, wB = /^-(ms)-/, CB = function(e) {
  return !e || yB.test(e) || mB.test(e);
}, EB = function(e, t) {
  return t.toUpperCase();
}, ov = function(e, t) {
  return "".concat(t, "-");
}, OB = function(e, t) {
  return t === void 0 && (t = {}), CB(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(wB, ov) : e = e.replace(bB, ov), e.replace(vB, EB));
};
Yu.camelCase = OB;
var xB = _t && _t.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, DB = xB(sh), LB = Yu;
function Ap(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, DB.default)(e, function(r, o) {
    r && o && (n[(0, LB.camelCase)(r, t)] = o);
  }), n;
}
Ap.default = Ap;
var PB = Ap;
(function(e) {
  var t = _t && _t.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ce, r = t(PB), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, d) {
    return c.includes("-") ? !o.has(c) : !!(d && typeof d.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, d) {
    if (typeof c == "string") {
      if (!c.trim()) {
        d.style = {};
        return;
      }
      try {
        d.style = (0, r.default)(c, s);
      } catch {
        d.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(ih);
Object.defineProperty(Hu, "__esModule", { value: !0 });
Hu.default = AB;
var ss = Cr, iv = ih, SB = ["checked", "value"], kB = ["input", "select", "textarea"], MB = {
  reset: !0,
  submit: !0
};
function AB(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && MB[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, ss.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = sv(s);
    if (a) {
      var l = (0, ss.getPropertyInfo)(a);
      switch (SB.includes(a) && kB.includes(t) && !r && (a = sv("default" + s)), n[a] = i, l && l.type) {
        case ss.BOOLEAN:
          n[a] = !0;
          break;
        case ss.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    iv.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, iv.setStyleProp)(e.style, n), n;
}
function sv(e) {
  return ss.possibleStandardNames[e];
}
var ah = {}, TB = _t && _t.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ah, "__esModule", { value: !0 });
ah.default = GO;
var Hc = Ce, BB = TB(Hu), fs = ih, jB = {
  cloneElement: Hc.cloneElement,
  createElement: Hc.createElement,
  isValidElement: Hc.isValidElement
};
function GO(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || fs.returnFirstArg, i = t.library || jB, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var d = e[c];
    if (r) {
      var p = t.replace(d, c);
      if (l(p)) {
        u > 1 && (p = s(p, {
          key: p.key || c
        })), n.push(o(p, d, c));
        continue;
      }
    }
    if (d.type === "text") {
      var m = !d.data.trim().length;
      if (m && d.parent && !(0, fs.canTextBeChildOfNode)(d.parent) || t.trim && m)
        continue;
      n.push(o(d.data, d, c));
      continue;
    }
    var f = d, g = {};
    _B(f) ? ((0, fs.setStyleProp)(f.attribs.style, f.attribs), g = f.attribs) : f.attribs && (g = (0, BB.default)(f.attribs, f.name));
    var h = void 0;
    switch (d.type) {
      case "script":
      case "style":
        d.children[0] && (g.dangerouslySetInnerHTML = {
          __html: d.children[0].data
        });
        break;
      case "tag":
        d.name === "textarea" && d.children[0] ? g.defaultValue = d.children[0].data : d.children && d.children.length && (h = GO(d.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(a(d.name, g, h), d, c));
  }
  return n.length === 1 ? n[0] : n;
}
function _B(e) {
  return fs.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, fs.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = _t && _t.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(Xf);
  e.htmlToDOM = n.default;
  var r = t(Hu);
  e.attributesToProps = r.default;
  var o = t(ah);
  e.domToReact = o.default;
  var i = Jf;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(SO);
const av = /* @__PURE__ */ nT(SO);
av.default;
function IB(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ At.jsx("div", { className: o.trim(), ...r });
}
var It = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function FB(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Tp = { exports: {} }, Hi = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lv;
function RB() {
  if (lv) return Hi;
  lv = 1;
  var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, d = {}, p = null, m = null;
    u !== void 0 && (p = "" + u), l.key !== void 0 && (p = "" + l.key), l.ref !== void 0 && (m = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (d[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) d[c] === void 0 && (d[c] = l[c]);
    return { $$typeof: t, type: a, key: p, ref: m, props: d, _owner: o.current };
  }
  return Hi.Fragment = n, Hi.jsx = s, Hi.jsxs = s, Hi;
}
var Da = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uv;
function NB() {
  return uv || (uv = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), p = Symbol.for("react.lazy"), m = Symbol.for("react.offscreen"), f = Symbol.iterator, g = "@@iterator";
    function h(b) {
      if (b === null || typeof b != "object")
        return null;
      var H = f && b[f] || b[g];
      return typeof H == "function" ? H : null;
    }
    var C = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var H = arguments.length, ee = new Array(H > 1 ? H - 1 : 0), oe = 1; oe < H; oe++)
          ee[oe - 1] = arguments[oe];
        k("error", b, ee);
      }
    }
    function k(b, H, ee) {
      {
        var oe = C.ReactDebugCurrentFrame, ve = oe.getStackAddendum();
        ve !== "" && (H += "%s", ee = ee.concat([ve]));
        var we = ee.map(function(he) {
          return String(he);
        });
        we.unshift("Warning: " + H), Function.prototype.apply.call(console[b], console, we);
      }
    }
    var E = !1, v = !1, O = !1, L = !1, W = !1, D;
    D = Symbol.for("react.module.reference");
    function N(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || W || b === o || b === u || b === c || L || b === m || E || v || O || typeof b == "object" && b !== null && (b.$$typeof === p || b.$$typeof === d || b.$$typeof === s || b.$$typeof === a || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === D || b.getModuleId !== void 0));
    }
    function _(b, H, ee) {
      var oe = b.displayName;
      if (oe)
        return oe;
      var ve = H.displayName || H.name || "";
      return ve !== "" ? ee + "(" + ve + ")" : ee;
    }
    function R(b) {
      return b.displayName || "Context";
    }
    function U(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case a:
            var H = b;
            return R(H) + ".Consumer";
          case s:
            var ee = b;
            return R(ee._context) + ".Provider";
          case l:
            return _(b, b.render, "ForwardRef");
          case d:
            var oe = b.displayName || null;
            return oe !== null ? oe : U(b.type) || "Memo";
          case p: {
            var ve = b, we = ve._payload, he = ve._init;
            try {
              return U(he(we));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var z = Object.assign, q = 0, K, X, ne, Q, S, I, Z;
    function T() {
    }
    T.__reactDisabledLog = !0;
    function Y() {
      {
        if (q === 0) {
          K = console.log, X = console.info, ne = console.warn, Q = console.error, S = console.group, I = console.groupCollapsed, Z = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: T,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function x() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: z({}, b, {
              value: K
            }),
            info: z({}, b, {
              value: X
            }),
            warn: z({}, b, {
              value: ne
            }),
            error: z({}, b, {
              value: Q
            }),
            group: z({}, b, {
              value: S
            }),
            groupCollapsed: z({}, b, {
              value: I
            }),
            groupEnd: z({}, b, {
              value: Z
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = C.ReactCurrentDispatcher, $;
    function B(b, H, ee) {
      {
        if ($ === void 0)
          try {
            throw Error();
          } catch (ve) {
            var oe = ve.stack.trim().match(/\n( *(at )?)/);
            $ = oe && oe[1] || "";
          }
        return `
` + $ + b;
      }
    }
    var V = !1, F;
    {
      var J = typeof WeakMap == "function" ? WeakMap : Map;
      F = new J();
    }
    function G(b, H) {
      if (!b || V)
        return "";
      {
        var ee = F.get(b);
        if (ee !== void 0)
          return ee;
      }
      var oe;
      V = !0;
      var ve = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var we;
      we = M.current, M.current = null, Y();
      try {
        if (H) {
          var he = function() {
            throw Error();
          };
          if (Object.defineProperty(he.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(he, []);
            } catch ($e) {
              oe = $e;
            }
            Reflect.construct(b, [], he);
          } else {
            try {
              he.call();
            } catch ($e) {
              oe = $e;
            }
            b.call(he.prototype);
          }
        } else {
          try {
            throw Error();
          } catch ($e) {
            oe = $e;
          }
          b();
        }
      } catch ($e) {
        if ($e && oe && typeof $e.stack == "string") {
          for (var de = $e.stack.split(`
`), Fe = oe.stack.split(`
`), Le = de.length - 1, Se = Fe.length - 1; Le >= 1 && Se >= 0 && de[Le] !== Fe[Se]; )
            Se--;
          for (; Le >= 1 && Se >= 0; Le--, Se--)
            if (de[Le] !== Fe[Se]) {
              if (Le !== 1 || Se !== 1)
                do
                  if (Le--, Se--, Se < 0 || de[Le] !== Fe[Se]) {
                    var rt = `
` + de[Le].replace(" at new ", " at ");
                    return b.displayName && rt.includes("<anonymous>") && (rt = rt.replace("<anonymous>", b.displayName)), typeof b == "function" && F.set(b, rt), rt;
                  }
                while (Le >= 1 && Se >= 0);
              break;
            }
        }
      } finally {
        V = !1, M.current = we, x(), Error.prepareStackTrace = ve;
      }
      var En = b ? b.displayName || b.name : "", nn = En ? B(En) : "";
      return typeof b == "function" && F.set(b, nn), nn;
    }
    function fe(b, H, ee) {
      return G(b, !1);
    }
    function be(b) {
      var H = b.prototype;
      return !!(H && H.isReactComponent);
    }
    function re(b, H, ee) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return G(b, be(b));
      if (typeof b == "string")
        return B(b);
      switch (b) {
        case u:
          return B("Suspense");
        case c:
          return B("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return fe(b.render);
          case d:
            return re(b.type, H, ee);
          case p: {
            var oe = b, ve = oe._payload, we = oe._init;
            try {
              return re(we(ve), H, ee);
            } catch {
            }
          }
        }
      return "";
    }
    var Ae = Object.prototype.hasOwnProperty, Ie = {}, je = C.ReactDebugCurrentFrame;
    function _e(b) {
      if (b) {
        var H = b._owner, ee = re(b.type, b._source, H ? H.type : null);
        je.setExtraStackFrame(ee);
      } else
        je.setExtraStackFrame(null);
    }
    function tt(b, H, ee, oe, ve) {
      {
        var we = Function.call.bind(Ae);
        for (var he in b)
          if (we(b, he)) {
            var de = void 0;
            try {
              if (typeof b[he] != "function") {
                var Fe = Error((oe || "React class") + ": " + ee + " type `" + he + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[he] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Fe.name = "Invariant Violation", Fe;
              }
              de = b[he](H, he, oe, ee, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Le) {
              de = Le;
            }
            de && !(de instanceof Error) && (_e(ve), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", oe || "React class", ee, he, typeof de), _e(null)), de instanceof Error && !(de.message in Ie) && (Ie[de.message] = !0, _e(ve), w("Failed %s type: %s", ee, de.message), _e(null));
          }
      }
    }
    var Ke = Array.isArray;
    function ke(b) {
      return Ke(b);
    }
    function nt(b) {
      {
        var H = typeof Symbol == "function" && Symbol.toStringTag, ee = H && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return ee;
      }
    }
    function gt(b) {
      try {
        return Pe(b), !1;
      } catch {
        return !0;
      }
    }
    function Pe(b) {
      return "" + b;
    }
    function Te(b) {
      if (gt(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", nt(b)), Pe(b);
    }
    var Re = C.ReactCurrentOwner, He = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, ze, wt, Be;
    Be = {};
    function dn(b) {
      if (Ae.call(b, "ref")) {
        var H = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (H && H.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function Ct(b) {
      if (Ae.call(b, "key")) {
        var H = Object.getOwnPropertyDescriptor(b, "key").get;
        if (H && H.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function Pt(b, H) {
      if (typeof b.ref == "string" && Re.current && H && Re.current.stateNode !== H) {
        var ee = U(Re.current.type);
        Be[ee] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', U(Re.current.type), b.ref), Be[ee] = !0);
      }
    }
    function Rt(b, H) {
      {
        var ee = function() {
          ze || (ze = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", H));
        };
        ee.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: ee,
          configurable: !0
        });
      }
    }
    function vn(b, H) {
      {
        var ee = function() {
          wt || (wt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", H));
        };
        ee.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: ee,
          configurable: !0
        });
      }
    }
    var Nt = function(b, H, ee, oe, ve, we, he) {
      var de = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: H,
        ref: ee,
        props: he,
        // Record the component responsible for creating this element.
        _owner: we
      };
      return de._store = {}, Object.defineProperty(de._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(de, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: oe
      }), Object.defineProperty(de, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ve
      }), Object.freeze && (Object.freeze(de.props), Object.freeze(de)), de;
    };
    function yn(b, H, ee, oe, ve) {
      {
        var we, he = {}, de = null, Fe = null;
        ee !== void 0 && (Te(ee), de = "" + ee), Ct(H) && (Te(H.key), de = "" + H.key), dn(H) && (Fe = H.ref, Pt(H, ve));
        for (we in H)
          Ae.call(H, we) && !He.hasOwnProperty(we) && (he[we] = H[we]);
        if (b && b.defaultProps) {
          var Le = b.defaultProps;
          for (we in Le)
            he[we] === void 0 && (he[we] = Le[we]);
        }
        if (de || Fe) {
          var Se = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          de && Rt(he, Se), Fe && vn(he, Se);
        }
        return Nt(b, de, Fe, ve, oe, Re.current, he);
      }
    }
    var mt = C.ReactCurrentOwner, en = C.ReactDebugCurrentFrame;
    function St(b) {
      if (b) {
        var H = b._owner, ee = re(b.type, b._source, H ? H.type : null);
        en.setExtraStackFrame(ee);
      } else
        en.setExtraStackFrame(null);
    }
    var bn;
    bn = !1;
    function zt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Pn() {
      {
        if (mt.current) {
          var b = U(mt.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function wn(b) {
      return "";
    }
    var Sn = {};
    function Cn(b) {
      {
        var H = Pn();
        if (!H) {
          var ee = typeof b == "string" ? b : b.displayName || b.name;
          ee && (H = `

Check the top-level render call using <` + ee + ">.");
        }
        return H;
      }
    }
    function kn(b, H) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var ee = Cn(H);
        if (Sn[ee])
          return;
        Sn[ee] = !0;
        var oe = "";
        b && b._owner && b._owner !== mt.current && (oe = " It was passed a child from " + U(b._owner.type) + "."), St(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ee, oe), St(null);
      }
    }
    function Wn(b, H) {
      {
        if (typeof b != "object")
          return;
        if (ke(b))
          for (var ee = 0; ee < b.length; ee++) {
            var oe = b[ee];
            zt(oe) && kn(oe, H);
          }
        else if (zt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ve = h(b);
          if (typeof ve == "function" && ve !== b.entries)
            for (var we = ve.call(b), he; !(he = we.next()).done; )
              zt(he.value) && kn(he.value, H);
        }
      }
    }
    function tn(b) {
      {
        var H = b.type;
        if (H == null || typeof H == "string")
          return;
        var ee;
        if (typeof H == "function")
          ee = H.propTypes;
        else if (typeof H == "object" && (H.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        H.$$typeof === d))
          ee = H.propTypes;
        else
          return;
        if (ee) {
          var oe = U(H);
          tt(ee, b.props, "prop", oe, b);
        } else if (H.PropTypes !== void 0 && !bn) {
          bn = !0;
          var ve = U(H);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ve || "Unknown");
        }
        typeof H.getDefaultProps == "function" && !H.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function se(b) {
      {
        for (var H = Object.keys(b.props), ee = 0; ee < H.length; ee++) {
          var oe = H[ee];
          if (oe !== "children" && oe !== "key") {
            St(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", oe), St(null);
            break;
          }
        }
        b.ref !== null && (St(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), St(null));
      }
    }
    var Xr = {};
    function Kr(b, H, ee, oe, ve, we) {
      {
        var he = N(b);
        if (!he) {
          var de = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (de += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Fe = wn();
          Fe ? de += Fe : de += Pn();
          var Le;
          b === null ? Le = "null" : ke(b) ? Le = "array" : b !== void 0 && b.$$typeof === t ? (Le = "<" + (U(b.type) || "Unknown") + " />", de = " Did you accidentally export a JSX literal instead of a component?") : Le = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Le, de);
        }
        var Se = yn(b, H, ee, ve, we);
        if (Se == null)
          return Se;
        if (he) {
          var rt = H.children;
          if (rt !== void 0)
            if (oe)
              if (ke(rt)) {
                for (var En = 0; En < rt.length; En++)
                  Wn(rt[En], b);
                Object.freeze && Object.freeze(rt);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Wn(rt, b);
        }
        if (Ae.call(H, "key")) {
          var nn = U(b), $e = Object.keys(H).filter(function(Ni) {
            return Ni !== "key";
          }), yr = $e.length > 0 ? "{key: someKey, " + $e.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Xr[nn + yr]) {
            var Ri = $e.length > 0 ? "{" + $e.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, yr, nn, Ri, nn), Xr[nn + yr] = !0;
          }
        }
        return b === r ? se(Se) : tn(Se), Se;
      }
    }
    function ji(b, H, ee) {
      return Kr(b, H, ee, !0);
    }
    function _i(b, H, ee) {
      return Kr(b, H, ee, !1);
    }
    var Ii = _i, Fi = ji;
    Da.Fragment = r, Da.jsx = Ii, Da.jsxs = Fi;
  }()), Da;
}
process.env.NODE_ENV === "production" ? Tp.exports = RB() : Tp.exports = NB();
var Zn = Tp.exports;
Ze({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function cv(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function In(e) {
  var t, n;
  return cv(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(cv(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var ZO = Symbol.for("immer-nothing"), dv = Symbol.for("immer-draftable"), ur = Symbol.for("immer-state"), zB = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Gn(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = zB[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var bi = Object.getPrototypeOf;
function ii(e) {
  return !!e && !!e[ur];
}
function si(e) {
  var t;
  return e ? YO(e) || Array.isArray(e) || !!e[dv] || !!((t = e.constructor) != null && t[dv]) || Ku(e) || Ju(e) : !1;
}
var $B = Object.prototype.constructor.toString();
function YO(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = bi(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === $B;
}
function Rl(e, t) {
  Xu(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Xu(e) {
  const t = e[ur];
  return t ? t.type_ : Array.isArray(e) ? 1 : Ku(e) ? 2 : Ju(e) ? 3 : 0;
}
function Bp(e, t) {
  return Xu(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function XO(e, t, n) {
  const r = Xu(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function UB(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Ku(e) {
  return e instanceof Map;
}
function Ju(e) {
  return e instanceof Set;
}
function zo(e) {
  return e.copy_ || e.base_;
}
function jp(e, t) {
  if (Ku(e))
    return new Map(e);
  if (Ju(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = YO(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[ur];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(bi(e), r);
  } else {
    const r = bi(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function lh(e, t = !1) {
  return Qu(e) || ii(e) || !si(e) || (Xu(e) > 1 && (e.set = e.add = e.clear = e.delete = WB), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => lh(r, !0))), e;
}
function WB() {
  Gn(2);
}
function Qu(e) {
  return Object.isFrozen(e);
}
var VB = {};
function ai(e) {
  const t = VB[e];
  return t || Gn(0, e), t;
}
var Ts;
function KO() {
  return Ts;
}
function HB(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function pv(e, t) {
  t && (ai("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function _p(e) {
  Ip(e), e.drafts_.forEach(qB), e.drafts_ = null;
}
function Ip(e) {
  e === Ts && (Ts = e.parent_);
}
function fv(e) {
  return Ts = HB(Ts, e);
}
function qB(e) {
  const t = e[ur];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function hv(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[ur].modified_ && (_p(t), Gn(4)), si(e) && (e = Nl(t, e), t.parent_ || zl(t, e)), t.patches_ && ai("Patches").generateReplacementPatches_(
    n[ur].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Nl(t, n, []), _p(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== ZO ? e : void 0;
}
function Nl(e, t, n) {
  if (Qu(t))
    return t;
  const r = t[ur];
  if (!r)
    return Rl(
      t,
      (o, i) => gv(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return zl(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Rl(
      i,
      (a, l) => gv(e, r, o, a, l, n, s)
    ), zl(e, o, !1), n && e.patches_ && ai("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function gv(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Gn(5), ii(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Bp(t.assigned_, r) ? i.concat(r) : void 0, l = Nl(e, o, a);
    if (XO(n, r, l), ii(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (si(o) && !Qu(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Nl(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && zl(e, o);
  }
}
function zl(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && lh(t, n);
}
function GB(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : KO(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = uh;
  n && (o = [r], i = Bs);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var uh = {
  get(e, t) {
    if (t === ur)
      return e;
    const n = zo(e);
    if (!Bp(n, t))
      return ZB(e, n, t);
    const r = n[t];
    return e.finalized_ || !si(r) ? r : r === qc(e.base_, t) ? (Gc(e), e.copy_[t] = Rp(r, e)) : r;
  },
  has(e, t) {
    return t in zo(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(zo(e));
  },
  set(e, t, n) {
    const r = JO(zo(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = qc(zo(e), t), i = o == null ? void 0 : o[ur];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (UB(n, o) && (n !== void 0 || Bp(e.base_, t)))
        return !0;
      Gc(e), Fp(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return qc(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Gc(e), Fp(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = zo(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Gn(11);
  },
  getPrototypeOf(e) {
    return bi(e.base_);
  },
  setPrototypeOf() {
    Gn(12);
  }
}, Bs = {};
Rl(uh, (e, t) => {
  Bs[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Bs.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Gn(13), Bs.set.call(this, e, t, void 0);
};
Bs.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Gn(14), uh.set.call(this, e[0], t, n, e[0]);
};
function qc(e, t) {
  const n = e[ur];
  return (n ? zo(n) : e)[t];
}
function ZB(e, t, n) {
  var r;
  const o = JO(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function JO(e, t) {
  if (!(t in e))
    return;
  let n = bi(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = bi(n);
  }
}
function Fp(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Fp(e.parent_));
}
function Gc(e) {
  e.copy_ || (e.copy_ = jp(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var YB = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Gn(6), r !== void 0 && typeof r != "function" && Gn(7);
      let o;
      if (si(t)) {
        const i = fv(this), s = Rp(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? _p(i) : Ip(i);
        }
        return pv(i, r), hv(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === ZO && (o = void 0), this.autoFreeze_ && lh(o, !0), r) {
          const i = [], s = [];
          ai("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Gn(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    si(e) || Gn(8), ii(e) && (e = XB(e));
    const t = fv(this), n = Rp(e, void 0);
    return n[ur].isManual_ = !0, Ip(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[ur];
    (!n || !n.isManual_) && Gn(9);
    const { scope_: r } = n;
    return pv(r, t), hv(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = ai("Patches").applyPatches_;
    return ii(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Rp(e, t) {
  const n = Ku(e) ? ai("MapSet").proxyMap_(e, t) : Ju(e) ? ai("MapSet").proxySet_(e, t) : GB(e, t);
  return (t ? t.scope_ : KO()).drafts_.push(n), n;
}
function XB(e) {
  return ii(e) || Gn(10, e), QO(e);
}
function QO(e) {
  if (!si(e) || Qu(e))
    return e;
  const t = e[ur];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = jp(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = jp(e, !0);
  return Rl(n, (r, o) => {
    XO(n, r, QO(o));
  }), t && (t.finalized_ = !1), n;
}
var cr = new YB(), ch = cr.produce;
cr.produceWithPatches.bind(
  cr
);
cr.setAutoFreeze.bind(cr);
cr.setUseStrictShallowCopy.bind(cr);
cr.applyPatches.bind(cr);
var mv = cr.createDraft.bind(cr), vv = cr.finishDraft.bind(cr), me = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = me.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return me.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return me.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return me.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return me.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && me.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return me.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && me.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && me.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && me.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && me.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && me.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!me.isAncestor(t, e) && !me.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (me.equals(i, r) || me.endsBefore(i, r) || me.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (me.equals(s, r) || me.isAncestor(s, r))
          return null;
        me.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        me.equals(a, r) || me.endsBefore(a, r) ? r[a.length - 1] -= 1 : me.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (me.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else me.endsBefore(u, r) ? r[u.length - 1] += 1 : me.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: d,
          newPath: p
        } = t;
        if (me.equals(d, p))
          return r;
        if (me.isAncestor(d, r) || me.equals(d, r)) {
          var m = p.slice();
          return me.endsBefore(d, p) && d.length < p.length && (m[d.length - 1] -= 1), m.concat(r.slice(d.length));
        } else me.isSibling(d, p) && (me.isAncestor(p, r) || me.equals(p, r)) ? me.endsBefore(d, r) ? r[d.length - 1] -= 1 : r[d.length - 1] += 1 : me.endsBefore(p, r) || me.equals(p, r) || me.isAncestor(p, r) ? (me.endsBefore(d, r) && (r[d.length - 1] -= 1), r[p.length - 1] += 1) : me.endsBefore(d, r) && (me.equals(p, r) && (r[p.length - 1] += 1), r[d.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function js(e) {
  "@babel/helpers - typeof";
  return js = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, js(e);
}
function KB(e, t) {
  if (js(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (js(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function JB(e) {
  var t = KB(e, "string");
  return js(t) === "symbol" ? t : String(t);
}
function Pi(e, t, n) {
  return t = JB(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function yv(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yv(Object(n), !0).forEach(function(r) {
      Pi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yv(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var QB = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = We.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of et.points(t))
          t[l] = Vt.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: d
      } = n;
      if (d.length === 0) break;
      var p = We.leaf(e, u), m = p.text.slice(0, c), f = p.text.slice(c);
      if (p.text = m + d + f, t)
        for (var [g, h] of et.points(t))
          t[h] = Vt.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: C
      } = n, w = We.get(e, C), k = me.previous(C), E = We.get(e, k), v = We.parent(e, C), O = C[C.length - 1];
      if (fn.isText(w) && fn.isText(E))
        E.text += w.text;
      else if (!fn.isText(w) && !fn.isText(E))
        E.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(C, "] to nodes of different interfaces: ").concat(er.stringify(w), " ").concat(er.stringify(E)));
      if (v.children.splice(O, 1), t)
        for (var [L, W] of et.points(t))
          t[W] = Vt.transform(L, n);
      break;
    }
    case "move_node": {
      var {
        path: D,
        newPath: N
      } = n;
      if (me.isAncestor(D, N))
        throw new Error("Cannot move a path [".concat(D, "] to new path [").concat(N, "] because the destination is inside itself."));
      var _ = We.get(e, D), R = We.parent(e, D), U = D[D.length - 1];
      R.children.splice(U, 1);
      var z = me.transform(D, n), q = We.get(e, me.parent(z)), K = z[z.length - 1];
      if (q.children.splice(K, 0, _), t)
        for (var [X, ne] of et.points(t))
          t[ne] = Vt.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: Q
      } = n, S = Q[Q.length - 1], I = We.parent(e, Q);
      if (I.children.splice(S, 1), t)
        for (var [Z, T] of et.points(t)) {
          var Y = Vt.transform(Z, n);
          if (t != null && Y != null)
            t[T] = Y;
          else {
            var x = void 0, M = void 0;
            for (var [$, B] of We.texts(e))
              if (me.compare(B, Q) === -1)
                x = [$, B];
              else {
                M = [$, B];
                break;
              }
            var V = !1;
            x && M && (me.equals(M[1], Q) ? V = !me.hasPrevious(M[1]) : V = me.common(x[1], Q).length < me.common(M[1], Q).length), x && !V ? (Z.path = x[1], Z.offset = x[0].text.length) : M ? (Z.path = M[1], Z.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: F,
        offset: J,
        text: G
      } = n;
      if (G.length === 0) break;
      var fe = We.leaf(e, F), be = fe.text.slice(0, J), re = fe.text.slice(J + G.length);
      if (fe.text = be + re, t)
        for (var [Ae, Ie] of et.points(t))
          t[Ie] = Vt.transform(Ae, n);
      break;
    }
    case "set_node": {
      var {
        path: je,
        properties: _e,
        newProperties: tt
      } = n;
      if (je.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Ke = We.get(e, je);
      for (var ke in tt) {
        if (ke === "children" || ke === "text")
          throw new Error('Cannot set the "'.concat(ke, '" property of nodes!'));
        var nt = tt[ke];
        nt == null ? delete Ke[ke] : Ke[ke] = nt;
      }
      for (var gt in _e)
        tt.hasOwnProperty(gt) || delete Ke[gt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Pe
      } = n;
      if (Pe == null)
        t = Pe;
      else {
        if (t == null) {
          if (!et.isRange(Pe))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(er.stringify(Pe), " when there is no current selection."));
          t = qi({}, Pe);
        }
        for (var Te in Pe) {
          var Re = Pe[Te];
          if (Re == null) {
            if (Te === "anchor" || Te === "focus")
              throw new Error('Cannot remove the "'.concat(Te, '" selection property'));
            delete t[Te];
          } else
            t[Te] = Re;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: He,
        position: ze,
        properties: wt
      } = n;
      if (He.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(He, "] because the root node cannot be split."));
      var Be = We.get(e, He), dn = We.parent(e, He), Ct = He[He.length - 1], Pt;
      if (fn.isText(Be)) {
        var Rt = Be.text.slice(0, ze), vn = Be.text.slice(ze);
        Be.text = Rt, Pt = qi(qi({}, wt), {}, {
          text: vn
        });
      } else {
        var Nt = Be.children.slice(0, ze), yn = Be.children.slice(ze);
        Be.children = Nt, Pt = qi(qi({}, wt), {}, {
          children: yn
        });
      }
      if (dn.children.splice(Ct + 1, 0, Pt), t)
        for (var [mt, en] of et.points(t))
          t[en] = Vt.transform(mt, n);
      break;
    }
  }
  return t;
}, ej = {
  transform(e, t) {
    e.children = mv(e.children);
    var n = e.selection && mv(e.selection);
    try {
      n = QB(e, n, t);
    } finally {
      e.children = vv(e.children), n ? e.selection = ii(n) ? vv(n) : n : e.selection = null;
    }
  }
}, tj = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, nj = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, ex = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (In(r) && In(o)) {
      if (!ex(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function rj(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function _s(e, t) {
  if (e == null) return {};
  var n = rj(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var oj = ["anchor", "focus"];
function bv(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ij(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bv(Object(n), !0).forEach(function(r) {
      Pi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bv(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var et = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return et.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = et.edges(e);
    return t;
  },
  equals(e, t) {
    return Vt.equals(e.anchor, t.anchor) && Vt.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (et.isRange(t)) {
      if (et.includes(e, t.anchor) || et.includes(e, t.focus))
        return !0;
      var [n, r] = et.edges(e), [o, i] = et.edges(t);
      return Vt.isBefore(n, o) && Vt.isAfter(r, i);
    }
    var [s, a] = et.edges(e), l = !1, u = !1;
    return Vt.isPoint(t) ? (l = Vt.compare(t, s) >= 0, u = Vt.compare(t, a) <= 0) : (l = me.compare(t, s.path) >= 0, u = me.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = _s(e, oj), [r, o] = et.edges(e), [i, s] = et.edges(t), a = Vt.isBefore(r, i) ? i : r, l = Vt.isBefore(o, s) ? o : s;
    return Vt.isBefore(l, a) ? null : ij({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Vt.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Vt.equals(t, n);
  },
  isExpanded(e) {
    return !et.isCollapsed(e);
  },
  isForward(e) {
    return !et.isBackward(e);
  },
  isRange(e) {
    return In(e) && Vt.isPoint(e.anchor) && Vt.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = et.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ch(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = et.isCollapsed(r);
        et.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? et.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = Vt.transform(r.anchor, t, {
        affinity: i
      }), u = Vt.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, wv = (e) => In(e) && We.isNodeList(e.children) && !Bt.isEditor(e), $r = {
  isAncestor(e) {
    return In(e) && We.isNodeList(e.children);
  },
  isElement: wv,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => $r.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return wv(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, sj = ["children"], aj = ["text"], Cv = /* @__PURE__ */ new WeakMap(), We = {
  ancestor(e, t) {
    var n = We.get(e, t);
    if (fn.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(er.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of me.ancestors(t, n)) {
        var o = We.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (fn.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(er.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(er.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = We.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = We.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = me.common(t, n), o = We.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = We.get(e, t);
    if (Bt.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(er.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of We.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of We.nodes(e, t))
        $r.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if ($r.isAncestor(e)) {
      var t = _s(e, sj);
      return t;
    } else {
      var t = _s(e, aj);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = We.get(e, n); r && !(fn.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (fn.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(er.stringify(e)));
    var n = ch({
      children: e.children
    }, (r) => {
      var [o, i] = et.edges(t), s = We.nodes(r, {
        reverse: !0,
        pass: (p) => {
          var [, m] = p;
          return !et.includes(t, m);
        }
      });
      for (var [, a] of s) {
        if (!et.includes(t, a)) {
          var l = We.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (me.equals(a, i.path)) {
          var c = We.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (me.equals(a, o.path)) {
          var d = We.leaf(r, a);
          d.text = d.text.slice(o.offset);
        }
      }
      Bt.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (fn.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(er.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (fn.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return fn.isText(e) || $r.isElement(e) || Bt.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = Cv.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => We.isNode(r));
    return Cv.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = We.get(e, n); r && !(fn.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = We.get(e, t);
    if (!fn.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(er.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of me.levels(t, n)) {
        var o = We.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return $r.isElement(e) && $r.isElementProps(t) && $r.matches(e, t) || fn.isText(e) && fn.isTextProps(t) && fn.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? me.isBefore(a, i) : me.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !fn.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          me.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = We.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = me.next(a);
          if (We.has(e, c)) {
            a = c, l = We.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var d = me.previous(a);
          a = d, l = We.get(e, a);
          continue;
        }
        a = me.parent(a), l = We.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = me.parent(t), r = We.get(e, n);
    if (fn.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return fn.isText(e) ? e.text : e.children.map(We.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of We.nodes(e, t))
        fn.isText(n) && (yield [n, r]);
    }();
  }
};
function Ev(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gt(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ev(Object(n), !0).forEach(function(r) {
      Pi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ev(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var as = {
  isNodeOperation(e) {
    return as.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!In(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return me.isPath(e.path) && We.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && me.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && me.isPath(e.path) && In(e.properties);
      case "move_node":
        return me.isPath(e.path) && me.isPath(e.newPath);
      case "remove_node":
        return me.isPath(e.path) && We.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && me.isPath(e.path);
      case "set_node":
        return me.isPath(e.path) && In(e.properties) && In(e.newProperties);
      case "set_selection":
        return e.properties === null && et.isRange(e.newProperties) || e.newProperties === null && et.isRange(e.properties) || In(e.properties) && In(e.newProperties);
      case "split_node":
        return me.isPath(e.path) && typeof e.position == "number" && In(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => as.isOperation(t));
  },
  isSelectionOperation(e) {
    return as.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return as.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Gt(Gt({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Gt(Gt({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Gt(Gt({}, e), {}, {
          type: "split_node",
          path: me.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (me.equals(t, n))
          return e;
        if (me.isSibling(n, t))
          return Gt(Gt({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = me.transform(n, e), o = me.transform(me.next(n), e);
        return Gt(Gt({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Gt(Gt({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Gt(Gt({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Gt(Gt({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? Gt(Gt({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Gt(Gt({}, e), {}, {
          properties: null,
          newProperties: a
        }) : Gt(Gt({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return Gt(Gt({}, e), {}, {
          type: "merge_node",
          path: me.next(e.path)
        });
    }
  }
}, Ov = /* @__PURE__ */ new WeakMap(), lj = (e) => {
  var t = Ov.get(e);
  if (t !== void 0)
    return t;
  if (!In(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || In(e.marks)) && (e.selection === null || et.isRange(e.selection)) && We.isNodeList(e.children) && as.isOperationList(e.operations);
  return Ov.set(e, n), n;
}, Bt = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return lj(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function xv(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Dv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xv(Object(n), !0).forEach(function(r) {
      Pi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xv(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Vt = {
  compare(e, t) {
    var n = me.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Vt.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Vt.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && me.equals(e.path, t.path);
  },
  isPoint(e) {
    return In(e) && typeof e.offset == "number" && me.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ch(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = me.transform(i, t, n);
          break;
        }
        case "insert_text": {
          me.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          me.equals(t.path, i) && (r.offset += t.position), r.path = me.transform(i, t, n);
          break;
        }
        case "remove_text": {
          me.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (me.equals(t.path, i) || me.isAncestor(t.path, i))
            return null;
          r.path = me.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (me.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = me.transform(i, t, Dv(Dv({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = me.transform(i, t, n);
          break;
        }
      }
    });
  }
}, Lv = void 0, er = {
  setScrubber(e) {
    Lv = e;
  },
  stringify(e) {
    return JSON.stringify(e, Lv);
  }
}, uj = ["text"], cj = ["anchor", "focus"];
function Pv(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ir(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Pv(Object(n), !0).forEach(function(r) {
      Pi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Pv(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fn = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = _s(i, uj);
      return s;
    }
    return ex(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return In(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => fn.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Ir({}, e)];
    for (var r of t) {
      var o = _s(r, cj), [i, s] = et.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var d of n) {
        var {
          length: p
        } = d.text, m = l;
        if (l += p, u <= m && l <= c) {
          Object.assign(d, o), a.push(d);
          continue;
        }
        if (u !== c && (u === l || c === m) || u > l || c < m || c === m && m !== 0) {
          a.push(d);
          continue;
        }
        var f = d, g = void 0, h = void 0;
        if (c < l) {
          var C = c - m;
          h = Ir(Ir({}, f), {}, {
            text: f.text.slice(C)
          }), f = Ir(Ir({}, f), {}, {
            text: f.text.slice(0, C)
          });
        }
        if (u > m) {
          var w = u - m;
          g = Ir(Ir({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Ir(Ir({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), g && a.push(g), a.push(f), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, dj = (e) => e.selection ? e.selection : e.children.length > 0 ? Bt.end(e, []) : [0], Ut;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Ut || (Ut = {}));
Ut.L, Ut.L | Ut.V | Ut.LV | Ut.LVT, Ut.LV | Ut.V, Ut.V | Ut.T, Ut.LVT | Ut.T, Ut.T, Ut.Any, Ut.Extend | Ut.ZWJ, Ut.Any, Ut.SpacingMark, Ut.Prepend, Ut.Any, Ut.ZWJ, Ut.ExtPict, Ut.RI, Ut.RI;
var pj = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Bt.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = dj(e)
      } = n;
      if (me.isPath(o) && (o = Bt.range(e, o)), et.isRange(o))
        if (et.isCollapsed(o))
          o = o.anchor;
        else {
          var i = et.end(o);
          if (!r && Bt.void(e, {
            at: i
          }))
            return;
          var s = et.start(o), a = Bt.pointRef(e, s), l = Bt.pointRef(e, i);
          $l.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, $l.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Bt.void(e, {
        at: o
      }) || Bt.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: d,
          offset: p
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: d,
          offset: p,
          text: t
        });
      }
    });
  }
};
function Sv(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function La(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sv(Object(n), !0).forEach(function(r) {
      Pi(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sv(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $l = La(La(La(La({}, ej), tj), nj), pj), tx = {}, dh = {}, ph = {};
Object.defineProperty(ph, "__esModule", { value: !0 });
ph.default = mj;
var kv = "html", Mv = "head", Pa = "body", fj = /<([a-zA-Z]+[0-9]?)/, Av = /<head[^]*>/i, Tv = /<body[^]*>/i, Ul = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Np = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, Bv = typeof window == "object" && window.DOMParser;
if (typeof Bv == "function") {
  var hj = new Bv(), gj = "text/html";
  Np = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), hj.parseFromString(e, gj);
  }, Ul = Np;
}
if (typeof document == "object" && document.implementation) {
  var Sa = document.implementation.createHTMLDocument();
  Ul = function(e, t) {
    if (t) {
      var n = Sa.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Sa;
    }
    return Sa.documentElement.innerHTML = e, Sa;
  };
}
var ka = typeof document == "object" && document.createElement("template"), zp;
ka && ka.content && (zp = function(e) {
  return ka.innerHTML = e, ka.content.childNodes;
});
function mj(e) {
  var t, n, r = e.match(fj), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case kv: {
      var i = Np(e);
      if (!Av.test(e)) {
        var s = i.querySelector(Mv);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!Tv.test(e)) {
        var s = i.querySelector(Pa);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(kv);
    }
    case Mv:
    case Pa: {
      var a = Ul(e).querySelectorAll(o);
      return Tv.test(e) && Av.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (zp)
        return zp(e);
      var s = Ul(e, Pa).querySelector(Pa);
      return s.childNodes;
    }
  }
}
var ec = {}, fh = {}, hh = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(hh);
var at = {}, Do = It && It.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), hs = It && It.__assign || function() {
  return hs = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, hs.apply(this, arguments);
};
Object.defineProperty(at, "__esModule", { value: !0 });
at.cloneNode = at.hasChildren = at.isDocument = at.isDirective = at.isComment = at.isText = at.isCDATA = at.isTag = at.Element = at.Document = at.CDATA = at.NodeWithChildren = at.ProcessingInstruction = at.Comment = at.Text = at.DataNode = at.Node = void 0;
var Kn = hh, gh = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), mh(this, t);
    }, e;
  }()
);
at.Node = gh;
var tc = (
  /** @class */
  function(e) {
    Do(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gh)
);
at.DataNode = tc;
var nx = (
  /** @class */
  function(e) {
    Do(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Kn.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(tc)
);
at.Text = nx;
var rx = (
  /** @class */
  function(e) {
    Do(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Kn.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(tc)
);
at.Comment = rx;
var ox = (
  /** @class */
  function(e) {
    Do(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Kn.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(tc)
);
at.ProcessingInstruction = ox;
var nc = (
  /** @class */
  function(e) {
    Do(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gh)
);
at.NodeWithChildren = nc;
var ix = (
  /** @class */
  function(e) {
    Do(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Kn.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(nc)
);
at.CDATA = ix;
var sx = (
  /** @class */
  function(e) {
    Do(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Kn.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(nc)
);
at.Document = sx;
var ax = (
  /** @class */
  function(e) {
    Do(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Kn.ElementType.Script : n === "style" ? Kn.ElementType.Style : Kn.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(nc)
);
at.Element = ax;
function lx(e) {
  return (0, Kn.isTag)(e);
}
at.isTag = lx;
function ux(e) {
  return e.type === Kn.ElementType.CDATA;
}
at.isCDATA = ux;
function cx(e) {
  return e.type === Kn.ElementType.Text;
}
at.isText = cx;
function dx(e) {
  return e.type === Kn.ElementType.Comment;
}
at.isComment = dx;
function px(e) {
  return e.type === Kn.ElementType.Directive;
}
at.isDirective = px;
function fx(e) {
  return e.type === Kn.ElementType.Root;
}
at.isDocument = fx;
function vj(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
at.hasChildren = vj;
function mh(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (cx(e))
    n = new nx(e.data);
  else if (dx(e))
    n = new rx(e.data);
  else if (lx(e)) {
    var r = t ? Zc(e.children) : [], o = new ax(e.name, hs({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = hs({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = hs({}, e["x-attribsPrefix"])), n = o;
  } else if (ux(e)) {
    var r = t ? Zc(e.children) : [], i = new ix(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (fx(e)) {
    var r = t ? Zc(e.children) : [], s = new sx(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (px(e)) {
    var a = new ox(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
at.cloneNode = mh;
function Zc(e) {
  for (var t = e.map(function(r) {
    return mh(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = It && It.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var d = Object.getOwnPropertyDescriptor(l, u);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, d);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = It && It.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = hh, o = at;
  n(at, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, d = new o.Element(l, u, void 0, c);
        this.addNode(d), this.tagStack.push(d);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(fh);
var hx = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(hx);
Object.defineProperty(ec, "__esModule", { value: !0 });
ec.formatAttributes = gx;
ec.formatDOM = mx;
var Ma = fh, yj = hx;
function bj(e) {
  return yj.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function gx(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function wj(e) {
  e = e.toLowerCase();
  var t = bj(e);
  return t || e;
}
function mx(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = wj(a.nodeName);
        o = new Ma.Element(l, gx(a.attributes)), o.children = mx(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Ma.Text(a.nodeValue);
        break;
      case 8:
        o = new Ma.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Ma.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var Cj = It && It.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(dh, "__esModule", { value: !0 });
dh.default = Dj;
var Ej = Cj(ph), Oj = ec, xj = /<(![a-zA-Z\s]+)>/;
function Dj(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(xj), n = t ? t[1] : void 0;
  return (0, Oj.formatDOM)((0, Ej.default)(e), null, n);
}
var rc = {}, Er = {}, oc = {}, Lj = 0;
oc.SAME = Lj;
var Pj = 1;
oc.CAMELCASE = Pj;
oc.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const vx = 0, Lo = 1, ic = 2, sc = 3, vh = 4, yx = 5, bx = 6;
function Sj(e) {
  return Bn.hasOwnProperty(e) ? Bn[e] : null;
}
function Un(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === ic || t === sc || t === vh, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const Bn = {}, kj = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
kj.forEach((e) => {
  Bn[e] = new Un(
    e,
    vx,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Bn[e] = new Un(
    e,
    Lo,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Bn[e] = new Un(
    e,
    ic,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Bn[e] = new Un(
    e,
    ic,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Bn[e] = new Un(
    e,
    sc,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Bn[e] = new Un(
    e,
    sc,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Bn[e] = new Un(
    e,
    vh,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Bn[e] = new Un(
    e,
    bx,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Bn[e] = new Un(
    e,
    yx,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const yh = /[\-\:]([a-z])/g, bh = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(yh, bh);
  Bn[t] = new Un(
    t,
    Lo,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(yh, bh);
  Bn[t] = new Un(
    t,
    Lo,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(yh, bh);
  Bn[t] = new Un(
    t,
    Lo,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Bn[e] = new Un(
    e,
    Lo,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Mj = "xlinkHref";
Bn[Mj] = new Un(
  "xlinkHref",
  Lo,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Bn[e] = new Un(
    e,
    Lo,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Aj,
  SAME: Tj,
  possibleStandardNames: jv
} = oc, Bj = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", jj = Bj + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", _j = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + jj + "]*$")
), Ij = Object.keys(
  jv
).reduce((e, t) => {
  const n = jv[t];
  return n === Tj ? e[t] = t : n === Aj ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
Er.BOOLEAN = sc;
Er.BOOLEANISH_STRING = ic;
Er.NUMERIC = yx;
Er.OVERLOADED_BOOLEAN = vh;
Er.POSITIVE_NUMERIC = bx;
Er.RESERVED = vx;
Er.STRING = Lo;
Er.getPropertyInfo = Sj;
Er.isCustomAttribute = _j;
Er.possibleStandardNames = Ij;
var wh = {}, Ch = {}, _v = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Fj = /\n/g, Rj = /^\s*/, Nj = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, zj = /^:\s*/, $j = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Uj = /^[;\s]*/, Wj = /^\s+|\s+$/g, Vj = `
`, Iv = "/", Fv = "*", Vo = "", Hj = "comment", qj = "declaration", Gj = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var g = f.match(Fj);
    g && (n += g.length);
    var h = f.lastIndexOf(Vj);
    r = ~h ? f.length - h : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(g) {
      return g.position = new s(f), u(), g;
    };
  }
  function s(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(f) {
    var g = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (g.reason = f, g.filename = t.source, g.line = n, g.column = r, g.source = e, !t.silent) throw g;
  }
  function l(f) {
    var g = f.exec(e);
    if (g) {
      var h = g[0];
      return o(h), e = e.slice(h.length), g;
    }
  }
  function u() {
    l(Rj);
  }
  function c(f) {
    var g;
    for (f = f || []; g = d(); )
      g !== !1 && f.push(g);
    return f;
  }
  function d() {
    var f = i();
    if (!(Iv != e.charAt(0) || Fv != e.charAt(1))) {
      for (var g = 2; Vo != e.charAt(g) && (Fv != e.charAt(g) || Iv != e.charAt(g + 1)); )
        ++g;
      if (g += 2, Vo === e.charAt(g - 1))
        return a("End of comment missing");
      var h = e.slice(2, g - 2);
      return r += 2, o(h), e = e.slice(g), r += 2, f({
        type: Hj,
        comment: h
      });
    }
  }
  function p() {
    var f = i(), g = l(Nj);
    if (g) {
      if (d(), !l(zj)) return a("property missing ':'");
      var h = l($j), C = f({
        type: qj,
        property: Rv(g[0].replace(_v, Vo)),
        value: h ? Rv(h[0].replace(_v, Vo)) : Vo
      });
      return l(Uj), C;
    }
  }
  function m() {
    var f = [];
    c(f);
    for (var g; g = p(); )
      g !== !1 && (f.push(g), c(f));
    return f;
  }
  return u(), m();
};
function Rv(e) {
  return e ? e.replace(Wj, Vo) : Vo;
}
var Zj = It && It.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Ch, "__esModule", { value: !0 });
Ch.default = Xj;
var Yj = Zj(Gj);
function Xj(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Yj.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var ac = {};
Object.defineProperty(ac, "__esModule", { value: !0 });
ac.camelCase = void 0;
var Kj = /^--[a-zA-Z0-9_-]+$/, Jj = /-([a-z])/g, Qj = /^[^-]+$/, e_ = /^-(webkit|moz|ms|o|khtml)-/, t_ = /^-(ms)-/, n_ = function(e) {
  return !e || Qj.test(e) || Kj.test(e);
}, r_ = function(e, t) {
  return t.toUpperCase();
}, Nv = function(e, t) {
  return "".concat(t, "-");
}, o_ = function(e, t) {
  return t === void 0 && (t = {}), n_(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(t_, Nv) : e = e.replace(e_, Nv), e.replace(Jj, r_));
};
ac.camelCase = o_;
var i_ = It && It.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, s_ = i_(Ch), a_ = ac;
function $p(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, s_.default)(e, function(r, o) {
    r && o && (n[(0, a_.camelCase)(r, t)] = o);
  }), n;
}
$p.default = $p;
var l_ = $p;
(function(e) {
  var t = It && It.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Ce, r = t(l_), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, d) {
    return c.includes("-") ? !o.has(c) : !!(d && typeof d.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, d) {
    if (typeof c == "string") {
      if (!c.trim()) {
        d.style = {};
        return;
      }
      try {
        d.style = (0, r.default)(c, s);
      } catch {
        d.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(wh);
Object.defineProperty(rc, "__esModule", { value: !0 });
rc.default = p_;
var ls = Er, zv = wh, u_ = ["checked", "value"], c_ = ["input", "select", "textarea"], d_ = {
  reset: !0,
  submit: !0
};
function p_(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && d_[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, ls.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = $v(s);
    if (a) {
      var l = (0, ls.getPropertyInfo)(a);
      switch (u_.includes(a) && c_.includes(t) && !r && (a = $v("default" + s)), n[a] = i, l && l.type) {
        case ls.BOOLEAN:
          n[a] = !0;
          break;
        case ls.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    zv.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, zv.setStyleProp)(e.style, n), n;
}
function $v(e) {
  return ls.possibleStandardNames[e];
}
var Eh = {}, f_ = It && It.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Eh, "__esModule", { value: !0 });
Eh.default = wx;
var Yc = Ce, h_ = f_(rc), gs = wh, g_ = {
  cloneElement: Yc.cloneElement,
  createElement: Yc.createElement,
  isValidElement: Yc.isValidElement
};
function wx(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || gs.returnFirstArg, i = t.library || g_, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var d = e[c];
    if (r) {
      var p = t.replace(d, c);
      if (l(p)) {
        u > 1 && (p = s(p, {
          key: p.key || c
        })), n.push(o(p, d, c));
        continue;
      }
    }
    if (d.type === "text") {
      var m = !d.data.trim().length;
      if (m && d.parent && !(0, gs.canTextBeChildOfNode)(d.parent) || t.trim && m)
        continue;
      n.push(o(d.data, d, c));
      continue;
    }
    var f = d, g = {};
    m_(f) ? ((0, gs.setStyleProp)(f.attribs.style, f.attribs), g = f.attribs) : f.attribs && (g = (0, h_.default)(f.attribs, f.name));
    var h = void 0;
    switch (d.type) {
      case "script":
      case "style":
        d.children[0] && (g.dangerouslySetInnerHTML = {
          __html: d.children[0].data
        });
        break;
      case "tag":
        d.name === "textarea" && d.children[0] ? g.defaultValue = d.children[0].data : d.children && d.children.length && (h = wx(d.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(a(d.name, g, h), d, c));
  }
  return n.length === 1 ? n[0] : n;
}
function m_(e) {
  return gs.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, gs.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = It && It.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(dh);
  e.htmlToDOM = n.default;
  var r = t(rc);
  e.attributesToProps = r.default;
  var o = t(Eh);
  e.domToReact = o.default;
  var i = fh;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(tx);
const v_ = /* @__PURE__ */ FB(tx);
v_.default;
Ze({});
function y_(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const b_ = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
y_(b_.CNPJ).length;
Hs((e, t) => /* @__PURE__ */ Zn.jsx("input", { ref: t, ...e }));
Ze({});
var Gr = {};
Object.defineProperty(Gr, "__esModule", {
  value: !0
});
var w_ = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Xc = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, Cx = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: w_ ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, Oh = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Aa = 1; Aa < 20; Aa++)
  Oh["f" + Aa] = 111 + Aa;
function lc(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return Ex(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return Ox(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function C_(e, t) {
  return lc(e, t);
}
function E_(e, t) {
  return lc(e, { byKey: !0 }, t);
}
function Ex(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Xc)
    r[Xc[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), d; !(a = (d = c.next()).done); a = !0) {
      var p = d.value, m = p.endsWith("?") && p.length > 1;
      m && (p = p.slice(0, -1));
      var f = xh(p), g = Xc[f];
      if (p.length > 1 && !g && !Cx[p] && !Oh[f])
        throw new TypeError('Unknown modifier: "' + p + '"');
      (i === 1 || !g) && (n ? r.key = f : r.which = xx(p)), g && (r[g] = m ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Ox(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function xx(e) {
  e = xh(e);
  var t = Oh[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function xh(e) {
  return e = e.toLowerCase(), e = Cx[e] || e, e;
}
Gr.default = lc;
var Kc = Gr.isHotkey = lc;
Gr.isCodeHotkey = C_;
Gr.isKeyHotkey = E_;
Gr.parseHotkey = Ex;
Gr.compareHotkey = Ox;
Gr.toKeyCode = xx;
Gr.toKeyName = xh;
var O_ = typeof It == "object" && It && It.Object === Object && It, x_ = O_, D_ = x_, L_ = typeof self == "object" && self && self.Object === Object && self, P_ = D_ || L_ || Function("return this")(), S_ = P_, k_ = S_, M_ = k_.Symbol, Dx = M_, Uv = Dx;
Uv && Uv.toStringTag;
var Wv = Dx;
Wv && Wv.toStringTag;
var Vv;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(Vv || (Vv = {}));
var Dh = function(e) {
  return Object.freeze(e);
}, A_ = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Dh(this);
  }
  return e;
}(), T_ = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Dh(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), Hv = typeof window < "u" ? window : {};
/msie|trident/i.test(Hv.navigator && Hv.navigator.userAgent);
var Jc = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new A_((n ? t : e) || 0, (n ? e : t) || 0);
};
Dh({
  devicePixelContentBoxSize: Jc(),
  borderBoxSize: Jc(),
  contentBoxSize: Jc(),
  contentRect: new T_(0, 0, 0, 0)
});
function Is(e) {
  "@babel/helpers - typeof";
  return Is = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Is(e);
}
function B_(e, t) {
  if (Is(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Is(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function j_(e) {
  var t = B_(e, "string");
  return Is(t) === "symbol" ? t : String(t);
}
function ms(e, t, n) {
  return t = j_(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var __ = /* @__PURE__ */ Ze(null), Qc, ed;
parseInt(Ce.version.split(".")[0], 10);
var qv = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), td = typeof navigator < "u" && /Android/.test(navigator.userAgent), Ta = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), I_ = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Qc = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Qc !== void 0 && Qc[1] && parseInt((ed = navigator.userAgent.match(/Version\/(\d+)/)) === null || ed === void 0 ? void 0 : ed[1], 10) < 17;
var F_ = /* @__PURE__ */ new WeakMap(), R_ = /* @__PURE__ */ new WeakMap(), N_ = /* @__PURE__ */ new WeakMap(), z_ = /* @__PURE__ */ new WeakMap(), $_ = /* @__PURE__ */ new WeakMap(), Gv = /* @__PURE__ */ new WeakMap(), U_ = /* @__PURE__ */ new WeakMap(), Zv = /* @__PURE__ */ new WeakMap(), Ba = /* @__PURE__ */ new WeakMap(), W_ = /* @__PURE__ */ new WeakMap(), V_ = /* @__PURE__ */ new WeakMap(), H_ = /* @__PURE__ */ new WeakMap(), Lx = globalThis.Node, q_ = globalThis.Text, Px = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, G_ = (e) => Wl(e) && e.nodeType === 8, Sr = (e) => Wl(e) && e.nodeType === 1, Wl = (e) => {
  var t = Px(e);
  return !!t && e instanceof t.Node;
}, Yv = (e) => {
  var t = e && e.anchorNode && Px(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Z_ = (e) => {
  var [t, n] = e;
  if (Sr(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Sx(t, o, r ? "backward" : "forward"), r = o < n; Sr(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = X_(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Y_ = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Sx = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (G_(o) || Sr(o) && o.childNodes.length === 0 || Sr(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, X_ = (e, t, n) => {
  var [r] = Sx(e, t, n);
  return r;
}, Xv = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), kx = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Sr(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = ut.getWindow(e);
  if (o.contains(r))
    return ut.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : kx(e, i, n);
}, Kv = (e, t) => !!(e.compareDocumentPosition(t) & Lx.DOCUMENT_POSITION_PRECEDING), K_ = (e, t) => !!(e.compareDocumentPosition(t) & Lx.DOCUMENT_POSITION_FOLLOWING), J_ = 0;
class Q_ {
  constructor() {
    ms(this, "id", void 0), this.id = "".concat(J_++);
  }
}
var ut = {
  androidPendingDiffs: (e) => H_.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = V_.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = ut.toDOMNode(e, e), n = ut.findDocumentOrShadowRoot(e);
    Ba.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = ut.findDocumentOrShadowRoot(e), r = Xv(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && $l.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = ut.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = ut.toSlateNode(e, t.target), s = ut.findPath(e, i);
    if ($r.isElement(i) && Bt.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = Bt.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? Bt.before(e, u) : Bt.after(e, u);
      if (c) {
        var d = Bt.range(e, c);
        return d;
      }
    }
    var p, {
      document: m
    } = ut.getWindow(e);
    if (m.caretRangeFromPoint)
      p = m.caretRangeFromPoint(n, r);
    else {
      var f = m.caretPositionFromPoint(n, r);
      f && (p = m.createRange(), p.setStart(f.offsetNode, f.offset), p.setEnd(f.offsetNode, f.offset));
    }
    if (!p)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var g = ut.toSlateRange(e, p, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (e, t) => {
    var n = Gv.get(t);
    return n || (n = new Q_(), Gv.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = R_.get(r);
      if (o == null) {
        if (Bt.isEditor(r))
          return n;
        break;
      }
      var i = F_.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(er.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Ba.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          ut.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = ut.toDOMNode(e, e), r = ut.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = Xv(r), i = ut.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || $l.select(e, Bt.start(e, [])), Ba.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = N_.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = ut.toDOMNode(e, e), i;
    try {
      i = Sr(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Wl(t) && ut.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Bt.hasPath(e, n.path) && Bt.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => ut.hasEditableTarget(e, t) || ut.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Wl(t) && ut.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!W_.get(e),
  isFocused: (e) => !!Ba.get(e),
  isReadOnly: (e) => !!Zv.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (Zv.get(e)) return !1;
    var n = ut.hasTarget(e, t) && ut.toSlateNode(e, t);
    return $r.isElement(n) && Bt.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = U_.get(e), r = Bt.isEditor(t) ? z_.get(e) : n == null ? void 0 : n.get(ut.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(er.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Bt.node(e, t.path), r = ut.toDOMNode(e, n), o;
    Bt.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: d
        } = c.textContent, p = u.getAttribute("data-slate-length"), m = p == null ? d : parseInt(p, 10), f = a + m, g = s[l + 1];
        if (t.offset === f && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var h, C = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            C instanceof q_ ? C : g,
            (h = g.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(d, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(er.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = et.isBackward(t), i = ut.toDOMPoint(e, n), s = et.isCollapsed(t) ? i : ut.toDOMPoint(e, r), a = ut.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [d, p] = o ? i : s, m = Sr(u) ? u : u.parentElement, f = !!m.getAttribute("data-slate-zero-width"), g = Sr(d) ? d : d.parentElement, h = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(d, h ? 1 : p), l;
  },
  toSlateNode: (e, t) => {
    var n = Sr(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? $_.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : Z_(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var d, p, m = ut.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), g = f && m.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), C = h && m.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), k = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var E = ut.getWindow(e), v = E.document.createRange();
          v.setStart(u, 0), v.setEnd(s, a);
          var O = v.cloneContents(), L = [...Array.prototype.slice.call(O.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(O.querySelectorAll("[contenteditable=false]"))];
          L.forEach((T) => {
            if (td && !r && T.hasAttribute("data-slate-zero-width") && T.textContent.length > 0 && T.textContext !== "\uFEFF") {
              T.textContent.startsWith("\uFEFF") && (T.textContent = T.textContent.slice(1));
              return;
            }
            T.parentNode.removeChild(T);
          }), c = O.textContent.length, k = u;
        }
      } else if (g) {
        for (var W = g.querySelectorAll("[data-slate-leaf]"), D = 0; D < W.length; D++) {
          var N = W[D];
          if (ut.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), k = w, c = k.textContent.length, k.querySelectorAll("[data-slate-zero-width]").forEach((T) => {
          c -= T.textContent.length;
        })) : c = 1;
      } else if (C) {
        var _ = (T) => T ? T.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], R = C.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var U, z = [..._(R), ..._(R == null ? void 0 : R.nextElementSibling)];
          w = (U = z.find((T) => K_(C, T))) !== null && U !== void 0 ? U : null;
        } else {
          var q, K = [..._(R == null ? void 0 : R.previousElementSibling), ..._(R)];
          w = (q = K.findLast((T) => Kv(C, T))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), k = w, i === "forward" ? c = 0 : (c = k.textContent.length, k.querySelectorAll("[data-slate-zero-width]").forEach((T) => {
          c -= T.textContent.length;
        })));
      }
      k && c === k.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      td && k.getAttribute("data-slate-zero-width") === "z" && (d = k.textContent) !== null && d !== void 0 && d.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Ta && (p = k.textContent) !== null && p !== void 0 && p.endsWith(`

`)) && c--;
    }
    if (td && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && ut.hasDOMNode(e, X, {
        editable: !0
      })) {
        var ne = ut.toSlateNode(e, X), {
          path: Q,
          offset: S
        } = Bt.start(e, ut.findPath(e, ne));
        return X.querySelector("[data-slate-leaf]") || (S = a), {
          path: Q,
          offset: S
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var I = ut.toSlateNode(e, u), Z = ut.findPath(e, I);
    return {
      path: Z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = Yv(t) ? t.anchorNode : t.startContainer, a, l, u, c, d;
    if (s)
      if (Yv(t)) {
        if (Ta && t.rangeCount > 1) {
          u = t.focusNode;
          var p = t.getRangeAt(0), m = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && p.startContainer instanceof HTMLTableRowElement && m.startContainer instanceof HTMLTableRowElement) {
            let O = function(L) {
              return L.childElementCount > 0 ? O(L.children[0]) : L;
            };
            var f = p.startContainer, g = m.startContainer, h = O(f.children[p.startOffset]), C = O(g.children[m.startOffset]);
            c = 0, C.childNodes.length > 0 ? a = C.childNodes[0] : a = C, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, C instanceof HTMLElement ? l = C.innerHTML.length : l = 0;
          } else
            p.startContainer === u ? (a = m.endContainer, l = m.endOffset, c = p.startOffset) : (a = p.startContainer, l = p.endOffset, c = m.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        I_ && Y_(a) || Ta ? d = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : d = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, d = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Ta && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = ut.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var k = Kv(a, u) || a === u && c < l, E = d ? w : ut.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: k ? "forward" : "backward"
    });
    if (!E)
      return null;
    var v = {
      anchor: w,
      focus: E
    };
    return et.isExpanded(v) && et.isForward(v) && Sr(u) && Bt.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = Bt.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, eI = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, tI = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, nI = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Zt = (e) => {
  var t = eI[e], n = tI[e], r = nI[e], o = t && Kc(t), i = n && Kc(n), s = r && Kc(r);
  return (a) => !!(o && o(a) || qv && i && i(a) || !qv && s && s(a));
};
Zt("bold"), Zt("compose"), Zt("moveBackward"), Zt("moveForward"), Zt("deleteBackward"), Zt("deleteForward"), Zt("deleteLineBackward"), Zt("deleteLineForward"), Zt("deleteWordBackward"), Zt("deleteWordForward"), Zt("extendBackward"), Zt("extendForward"), Zt("extendLineBackward"), Zt("extendLineForward"), Zt("italic"), Zt("moveLineBackward"), Zt("moveLineForward"), Zt("moveWordBackward"), Zt("moveWordForward"), Zt("redo"), Zt("insertSoftBreak"), Zt("splitBlock"), Zt("transposeCharacter"), Zt("undo");
var rI = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => kx(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, oI = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class iI extends xf {
  constructor() {
    super(...arguments), ms(this, "context", null), ms(this, "manager", null), ms(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, oI);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = rI(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
ms(iI, "contextType", __);
Ze({});
Ze({});
Ze({});
var hn = {}, Lh = {}, qs = {}, Gs = {}, Mx = "Expected a function", Jv = NaN, sI = "[object Symbol]", aI = /^\s+|\s+$/g, lI = /^[-+]0x[0-9a-f]+$/i, uI = /^0b[01]+$/i, cI = /^0o[0-7]+$/i, dI = parseInt, pI = typeof It == "object" && It && It.Object === Object && It, fI = typeof self == "object" && self && self.Object === Object && self, hI = pI || fI || Function("return this")(), gI = Object.prototype, mI = gI.toString, vI = Math.max, yI = Math.min, nd = function() {
  return hI.Date.now();
};
function bI(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, d = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError(Mx);
  t = Qv(t) || 0, Vl(n) && (c = !!n.leading, d = "maxWait" in n, i = d ? vI(Qv(n.maxWait) || 0, t) : i, p = "trailing" in n ? !!n.trailing : p);
  function m(O) {
    var L = r, W = o;
    return r = o = void 0, u = O, s = e.apply(W, L), s;
  }
  function f(O) {
    return u = O, a = setTimeout(C, t), c ? m(O) : s;
  }
  function g(O) {
    var L = O - l, W = O - u, D = t - L;
    return d ? yI(D, i - W) : D;
  }
  function h(O) {
    var L = O - l, W = O - u;
    return l === void 0 || L >= t || L < 0 || d && W >= i;
  }
  function C() {
    var O = nd();
    if (h(O))
      return w(O);
    a = setTimeout(C, g(O));
  }
  function w(O) {
    return a = void 0, p && r ? m(O) : (r = o = void 0, s);
  }
  function k() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(nd());
  }
  function v() {
    var O = nd(), L = h(O);
    if (r = arguments, o = this, l = O, L) {
      if (a === void 0)
        return f(l);
      if (d)
        return a = setTimeout(C, t), m(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = k, v.flush = E, v;
}
function wI(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Mx);
  return Vl(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), bI(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Vl(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function CI(e) {
  return !!e && typeof e == "object";
}
function EI(e) {
  return typeof e == "symbol" || CI(e) && mI.call(e) == sI;
}
function Qv(e) {
  if (typeof e == "number")
    return e;
  if (EI(e))
    return Jv;
  if (Vl(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Vl(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(aI, "");
  var n = uI.test(e);
  return n || cI.test(e) ? dI(e.slice(2), n ? 2 : 8) : lI.test(e) ? Jv : +e;
}
var OI = wI, Zs = {};
Object.defineProperty(Zs, "__esModule", {
  value: !0
});
Zs.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), ml.has(t) || ml.set(t, /* @__PURE__ */ new Set());
  var o = ml.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Zs.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), ml.get(t).delete(n.name || t);
};
var ml = /* @__PURE__ */ new Map();
Object.defineProperty(Gs, "__esModule", {
  value: !0
});
var xI = OI, DI = PI(xI), LI = Zs;
function PI(e) {
  return e && e.__esModule ? e : { default: e };
}
var SI = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, DI.default)(e, t);
}, on = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = SI(function(r) {
        on.scrollHandler(e);
      }, t);
      on.scrollSpyContainers.push(e), (0, LI.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return on.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = on.scrollSpyContainers[on.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(on.currentPositionX(e), on.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    on.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = on.scrollSpyContainers[on.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(on.currentPositionX(t), on.currentPositionY(t));
  },
  updateStates: function() {
    on.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    on.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), on.spySetState && on.spySetState.length && on.spySetState.indexOf(e) > -1 && on.spySetState.splice(on.spySetState.indexOf(e), 1), document.removeEventListener("scroll", on.scrollHandler);
  },
  update: function() {
    return on.scrollSpyContainers.forEach(function(e) {
      return on.scrollHandler(e);
    });
  }
};
Gs.default = on;
var Si = {}, Ys = {};
Object.defineProperty(Ys, "__esModule", {
  value: !0
});
var kI = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, MI = function() {
  return window.location.hash.replace(/^#/, "");
}, AI = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, TI = function(e) {
  return getComputedStyle(e).position !== "static";
}, rd = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, BI = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (TI(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = rd(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return rd(t, a).offsetTop - rd(e, a).offsetTop;
};
Ys.default = {
  updateHash: kI,
  getHash: MI,
  filterElementInContainer: AI,
  scrollOffset: BI
};
var uc = {}, Ph = {};
Object.defineProperty(Ph, "__esModule", {
  value: !0
});
Ph.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Sh = {};
Object.defineProperty(Sh, "__esModule", {
  value: !0
});
var jI = Zs, _I = ["mousedown", "mousewheel", "touchmove", "keydown"];
Sh.default = {
  subscribe: function(e) {
    return typeof document < "u" && _I.forEach(function(t) {
      return (0, jI.addPassiveEventListener)(document, t, e);
    });
  }
};
var Xs = {};
Object.defineProperty(Xs, "__esModule", {
  value: !0
});
var Up = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Up.registered[e] = t;
    },
    remove: function(e) {
      Up.registered[e] = null;
    }
  }
};
Xs.default = Up;
Object.defineProperty(uc, "__esModule", {
  value: !0
});
var II = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, FI = Ys;
cc(FI);
var RI = Ph, ey = cc(RI), NI = Sh, zI = cc(NI), $I = Xs, Dr = cc($I);
function cc(e) {
  return e && e.__esModule ? e : { default: e };
}
var Ax = function(e) {
  return ey.default[e.smooth] || ey.default.defaultEasing;
}, UI = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, WI = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Wp = function() {
  return WI() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Tx = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Bx = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, jx = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, VI = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, HI = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, qI = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Dr.default.registered.end && Dr.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Wp.call(window, i);
    return;
  }
  Dr.default.registered.end && Dr.default.registered.end(o.to, o.target, o.currentPosition);
}, kh = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Ks = function(e, t, n, r) {
  t.data = t.data || Tx(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (zI.default.subscribe(o), kh(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Bx(t) : jx(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Dr.default.registered.end && Dr.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = UI(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Ax(t), s = qI.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Dr.default.registered.begin && Dr.default.registered.begin(t.data.to, t.data.target), Wp.call(window, s);
    }, t.delay);
    return;
  }
  Dr.default.registered.begin && Dr.default.registered.begin(t.data.to, t.data.target), Wp.call(window, s);
}, dc = function(e) {
  return e = II({}, e), e.data = e.data || Tx(), e.absolute = !0, e;
}, GI = function(e) {
  Ks(0, dc(e));
}, ZI = function(e, t) {
  Ks(e, dc(t));
}, YI = function(e) {
  e = dc(e), kh(e), Ks(e.horizontal ? VI(e) : HI(e), e);
}, XI = function(e, t) {
  t = dc(t), kh(t);
  var n = t.horizontal ? Bx(t) : jx(t);
  Ks(e + n, t);
};
uc.default = {
  animateTopScroll: Ks,
  getAnimationType: Ax,
  scrollToTop: GI,
  scrollToBottom: YI,
  scrollTo: ZI,
  scrollMore: XI
};
Object.defineProperty(Si, "__esModule", {
  value: !0
});
var KI = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, JI = Ys, QI = Mh(JI), eF = uc, tF = Mh(eF), nF = Xs, ja = Mh(nF);
function Mh(e) {
  return e && e.__esModule ? e : { default: e };
}
var _a = {}, ty = void 0;
Si.default = {
  unmount: function() {
    _a = {};
  },
  register: function(e, t) {
    _a[e] = t;
  },
  unregister: function(e) {
    delete _a[e];
  },
  get: function(e) {
    return _a[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return ty = e;
  },
  getActiveLink: function() {
    return ty;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = KI({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = QI.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      ja.default.registered.begin && ja.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, ja.default.registered.end && ja.default.registered.end(e, n);
      return;
    }
    tF.default.animateTopScroll(a, t, e, n);
  }
};
var Vp = { exports: {} }, od = { exports: {} }, Et = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ny;
function rF() {
  if (ny) return Et;
  ny = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function k(v) {
    if (typeof v == "object" && v !== null) {
      var O = v.$$typeof;
      switch (O) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case c:
                case f:
                case m:
                case s:
                  return v;
                default:
                  return O;
              }
          }
        case n:
          return O;
      }
    }
  }
  function E(v) {
    return k(v) === u;
  }
  return Et.AsyncMode = l, Et.ConcurrentMode = u, Et.ContextConsumer = a, Et.ContextProvider = s, Et.Element = t, Et.ForwardRef = c, Et.Fragment = r, Et.Lazy = f, Et.Memo = m, Et.Portal = n, Et.Profiler = i, Et.StrictMode = o, Et.Suspense = d, Et.isAsyncMode = function(v) {
    return E(v) || k(v) === l;
  }, Et.isConcurrentMode = E, Et.isContextConsumer = function(v) {
    return k(v) === a;
  }, Et.isContextProvider = function(v) {
    return k(v) === s;
  }, Et.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Et.isForwardRef = function(v) {
    return k(v) === c;
  }, Et.isFragment = function(v) {
    return k(v) === r;
  }, Et.isLazy = function(v) {
    return k(v) === f;
  }, Et.isMemo = function(v) {
    return k(v) === m;
  }, Et.isPortal = function(v) {
    return k(v) === n;
  }, Et.isProfiler = function(v) {
    return k(v) === i;
  }, Et.isStrictMode = function(v) {
    return k(v) === o;
  }, Et.isSuspense = function(v) {
    return k(v) === d;
  }, Et.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === d || v === p || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === m || v.$$typeof === s || v.$$typeof === a || v.$$typeof === c || v.$$typeof === h || v.$$typeof === C || v.$$typeof === w || v.$$typeof === g);
  }, Et.typeOf = k, Et;
}
var kt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ry;
function oF() {
  return ry || (ry = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function k(G) {
      return typeof G == "string" || typeof G == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      G === r || G === u || G === i || G === o || G === d || G === p || typeof G == "object" && G !== null && (G.$$typeof === f || G.$$typeof === m || G.$$typeof === s || G.$$typeof === a || G.$$typeof === c || G.$$typeof === h || G.$$typeof === C || G.$$typeof === w || G.$$typeof === g);
    }
    function E(G) {
      if (typeof G == "object" && G !== null) {
        var fe = G.$$typeof;
        switch (fe) {
          case t:
            var be = G.type;
            switch (be) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case d:
                return be;
              default:
                var re = be && be.$$typeof;
                switch (re) {
                  case a:
                  case c:
                  case f:
                  case m:
                  case s:
                    return re;
                  default:
                    return fe;
                }
            }
          case n:
            return fe;
        }
      }
    }
    var v = l, O = u, L = a, W = s, D = t, N = c, _ = r, R = f, U = m, z = n, q = i, K = o, X = d, ne = !1;
    function Q(G) {
      return ne || (ne = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), S(G) || E(G) === l;
    }
    function S(G) {
      return E(G) === u;
    }
    function I(G) {
      return E(G) === a;
    }
    function Z(G) {
      return E(G) === s;
    }
    function T(G) {
      return typeof G == "object" && G !== null && G.$$typeof === t;
    }
    function Y(G) {
      return E(G) === c;
    }
    function x(G) {
      return E(G) === r;
    }
    function M(G) {
      return E(G) === f;
    }
    function $(G) {
      return E(G) === m;
    }
    function B(G) {
      return E(G) === n;
    }
    function V(G) {
      return E(G) === i;
    }
    function F(G) {
      return E(G) === o;
    }
    function J(G) {
      return E(G) === d;
    }
    kt.AsyncMode = v, kt.ConcurrentMode = O, kt.ContextConsumer = L, kt.ContextProvider = W, kt.Element = D, kt.ForwardRef = N, kt.Fragment = _, kt.Lazy = R, kt.Memo = U, kt.Portal = z, kt.Profiler = q, kt.StrictMode = K, kt.Suspense = X, kt.isAsyncMode = Q, kt.isConcurrentMode = S, kt.isContextConsumer = I, kt.isContextProvider = Z, kt.isElement = T, kt.isForwardRef = Y, kt.isFragment = x, kt.isLazy = M, kt.isMemo = $, kt.isPortal = B, kt.isProfiler = V, kt.isStrictMode = F, kt.isSuspense = J, kt.isValidElementType = k, kt.typeOf = E;
  }()), kt;
}
var oy;
function _x() {
  return oy || (oy = 1, process.env.NODE_ENV === "production" ? od.exports = rF() : od.exports = oF()), od.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var id, iy;
function iF() {
  if (iy) return id;
  iy = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return id = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var d in a)
        t.call(a, d) && (l[d] = a[d]);
      if (e) {
        u = e(a);
        for (var p = 0; p < u.length; p++)
          n.call(a, u[p]) && (l[u[p]] = a[u[p]]);
      }
    }
    return l;
  }, id;
}
var sd, sy;
function Ah() {
  if (sy) return sd;
  sy = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return sd = e, sd;
}
var ay, ly;
function Ix() {
  return ly || (ly = 1, ay = Function.call.bind(Object.prototype.hasOwnProperty)), ay;
}
var ad, uy;
function sF() {
  if (uy) return ad;
  uy = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Ah(), n = {}, r = Ix();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var d;
          try {
            if (typeof i[c] != "function") {
              var p = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = i[c](s, c, l, a, null, t);
          } catch (f) {
            d = f;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + a + " type: " + d.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, ad = o, ad;
}
var ld, cy;
function aF() {
  if (cy) return ld;
  cy = 1;
  var e = _x(), t = iF(), n = Ah(), r = Ix(), o = sF(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return ld = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(S) {
      var I = S && (u && S[u] || S[c]);
      if (typeof I == "function")
        return I;
    }
    var p = "<<anonymous>>", m = {
      array: C("array"),
      bigint: C("bigint"),
      bool: C("boolean"),
      func: C("function"),
      number: C("number"),
      object: C("object"),
      string: C("string"),
      symbol: C("symbol"),
      any: w(),
      arrayOf: k,
      element: E(),
      elementType: v(),
      instanceOf: O,
      node: N(),
      objectOf: W,
      oneOf: L,
      oneOfType: D,
      shape: R,
      exact: U
    };
    function f(S, I) {
      return S === I ? S !== 0 || 1 / S === 1 / I : S !== S && I !== I;
    }
    function g(S, I) {
      this.message = S, this.data = I && typeof I == "object" ? I : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function h(S) {
      if (process.env.NODE_ENV !== "production")
        var I = {}, Z = 0;
      function T(x, M, $, B, V, F, J) {
        if (B = B || p, F = F || $, J !== n) {
          if (l) {
            var G = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw G.name = "Invariant Violation", G;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var fe = B + ":" + $;
            !I[fe] && // Avoid spamming the console because they are often not actionable except for lib authors
            Z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + F + "` prop on `" + B + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), I[fe] = !0, Z++);
          }
        }
        return M[$] == null ? x ? M[$] === null ? new g("The " + V + " `" + F + "` is marked as required " + ("in `" + B + "`, but its value is `null`.")) : new g("The " + V + " `" + F + "` is marked as required in " + ("`" + B + "`, but its value is `undefined`.")) : null : S(M, $, B, V, F);
      }
      var Y = T.bind(null, !1);
      return Y.isRequired = T.bind(null, !0), Y;
    }
    function C(S) {
      function I(Z, T, Y, x, M, $) {
        var B = Z[T], V = K(B);
        if (V !== S) {
          var F = X(B);
          return new g(
            "Invalid " + x + " `" + M + "` of type " + ("`" + F + "` supplied to `" + Y + "`, expected ") + ("`" + S + "`."),
            { expectedType: S }
          );
        }
        return null;
      }
      return h(I);
    }
    function w() {
      return h(s);
    }
    function k(S) {
      function I(Z, T, Y, x, M) {
        if (typeof S != "function")
          return new g("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside arrayOf.");
        var $ = Z[T];
        if (!Array.isArray($)) {
          var B = K($);
          return new g("Invalid " + x + " `" + M + "` of type " + ("`" + B + "` supplied to `" + Y + "`, expected an array."));
        }
        for (var V = 0; V < $.length; V++) {
          var F = S($, V, Y, x, M + "[" + V + "]", n);
          if (F instanceof Error)
            return F;
        }
        return null;
      }
      return h(I);
    }
    function E() {
      function S(I, Z, T, Y, x) {
        var M = I[Z];
        if (!a(M)) {
          var $ = K(M);
          return new g("Invalid " + Y + " `" + x + "` of type " + ("`" + $ + "` supplied to `" + T + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(S);
    }
    function v() {
      function S(I, Z, T, Y, x) {
        var M = I[Z];
        if (!e.isValidElementType(M)) {
          var $ = K(M);
          return new g("Invalid " + Y + " `" + x + "` of type " + ("`" + $ + "` supplied to `" + T + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(S);
    }
    function O(S) {
      function I(Z, T, Y, x, M) {
        if (!(Z[T] instanceof S)) {
          var $ = S.name || p, B = Q(Z[T]);
          return new g("Invalid " + x + " `" + M + "` of type " + ("`" + B + "` supplied to `" + Y + "`, expected ") + ("instance of `" + $ + "`."));
        }
        return null;
      }
      return h(I);
    }
    function L(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function I(Z, T, Y, x, M) {
        for (var $ = Z[T], B = 0; B < S.length; B++)
          if (f($, S[B]))
            return null;
        var V = JSON.stringify(S, function(F, J) {
          var G = X(J);
          return G === "symbol" ? String(J) : J;
        });
        return new g("Invalid " + x + " `" + M + "` of value `" + String($) + "` " + ("supplied to `" + Y + "`, expected one of " + V + "."));
      }
      return h(I);
    }
    function W(S) {
      function I(Z, T, Y, x, M) {
        if (typeof S != "function")
          return new g("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside objectOf.");
        var $ = Z[T], B = K($);
        if (B !== "object")
          return new g("Invalid " + x + " `" + M + "` of type " + ("`" + B + "` supplied to `" + Y + "`, expected an object."));
        for (var V in $)
          if (r($, V)) {
            var F = S($, V, Y, x, M + "." + V, n);
            if (F instanceof Error)
              return F;
          }
        return null;
      }
      return h(I);
    }
    function D(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var I = 0; I < S.length; I++) {
        var Z = S[I];
        if (typeof Z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ne(Z) + " at index " + I + "."
          ), s;
      }
      function T(Y, x, M, $, B) {
        for (var V = [], F = 0; F < S.length; F++) {
          var J = S[F], G = J(Y, x, M, $, B, n);
          if (G == null)
            return null;
          G.data && r(G.data, "expectedType") && V.push(G.data.expectedType);
        }
        var fe = V.length > 0 ? ", expected one of type [" + V.join(", ") + "]" : "";
        return new g("Invalid " + $ + " `" + B + "` supplied to " + ("`" + M + "`" + fe + "."));
      }
      return h(T);
    }
    function N() {
      function S(I, Z, T, Y, x) {
        return z(I[Z]) ? null : new g("Invalid " + Y + " `" + x + "` supplied to " + ("`" + T + "`, expected a ReactNode."));
      }
      return h(S);
    }
    function _(S, I, Z, T, Y) {
      return new g(
        (S || "React class") + ": " + I + " type `" + Z + "." + T + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Y + "`."
      );
    }
    function R(S) {
      function I(Z, T, Y, x, M) {
        var $ = Z[T], B = K($);
        if (B !== "object")
          return new g("Invalid " + x + " `" + M + "` of type `" + B + "` " + ("supplied to `" + Y + "`, expected `object`."));
        for (var V in S) {
          var F = S[V];
          if (typeof F != "function")
            return _(Y, x, M, V, X(F));
          var J = F($, V, Y, x, M + "." + V, n);
          if (J)
            return J;
        }
        return null;
      }
      return h(I);
    }
    function U(S) {
      function I(Z, T, Y, x, M) {
        var $ = Z[T], B = K($);
        if (B !== "object")
          return new g("Invalid " + x + " `" + M + "` of type `" + B + "` " + ("supplied to `" + Y + "`, expected `object`."));
        var V = t({}, Z[T], S);
        for (var F in V) {
          var J = S[F];
          if (r(S, F) && typeof J != "function")
            return _(Y, x, M, F, X(J));
          if (!J)
            return new g(
              "Invalid " + x + " `" + M + "` key `" + F + "` supplied to `" + Y + "`.\nBad object: " + JSON.stringify(Z[T], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(S), null, "  ")
            );
          var G = J($, F, Y, x, M + "." + F, n);
          if (G)
            return G;
        }
        return null;
      }
      return h(I);
    }
    function z(S) {
      switch (typeof S) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !S;
        case "object":
          if (Array.isArray(S))
            return S.every(z);
          if (S === null || a(S))
            return !0;
          var I = d(S);
          if (I) {
            var Z = I.call(S), T;
            if (I !== S.entries) {
              for (; !(T = Z.next()).done; )
                if (!z(T.value))
                  return !1;
            } else
              for (; !(T = Z.next()).done; ) {
                var Y = T.value;
                if (Y && !z(Y[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(S, I) {
      return S === "symbol" ? !0 : I ? I["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && I instanceof Symbol : !1;
    }
    function K(S) {
      var I = typeof S;
      return Array.isArray(S) ? "array" : S instanceof RegExp ? "object" : q(I, S) ? "symbol" : I;
    }
    function X(S) {
      if (typeof S > "u" || S === null)
        return "" + S;
      var I = K(S);
      if (I === "object") {
        if (S instanceof Date)
          return "date";
        if (S instanceof RegExp)
          return "regexp";
      }
      return I;
    }
    function ne(S) {
      var I = X(S);
      switch (I) {
        case "array":
        case "object":
          return "an " + I;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + I;
        default:
          return I;
      }
    }
    function Q(S) {
      return !S.constructor || !S.constructor.name ? p : S.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, ld;
}
var ud, dy;
function lF() {
  if (dy) return ud;
  dy = 1;
  var e = Ah();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, ud = function() {
    function r(s, a, l, u, c, d) {
      if (d !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, ud;
}
if (process.env.NODE_ENV !== "production") {
  var uF = _x(), cF = !0;
  Vp.exports = aF()(uF.isElement, cF);
} else
  Vp.exports = lF()();
var pc = Vp.exports, fc = {};
Object.defineProperty(fc, "__esModule", {
  value: !0
});
var dF = Ys, cd = pF(dF);
function pF(e) {
  return e && e.__esModule ? e : { default: e };
}
var fF = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return cd.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && cd.default.getHash() !== e && cd.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
fc.default = fF;
Object.defineProperty(qs, "__esModule", {
  value: !0
});
var Ia = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, hF = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), gF = Ce, py = Js(gF), mF = Gs, Fa = Js(mF), vF = Si, yF = Js(vF), bF = pc, Yt = Js(bF), wF = fc, Jr = Js(wF);
function Js(e) {
  return e && e.__esModule ? e : { default: e };
}
function CF(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function EF(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function OF(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var fy = {
  to: Yt.default.string.isRequired,
  containerId: Yt.default.string,
  container: Yt.default.object,
  activeClass: Yt.default.string,
  activeStyle: Yt.default.object,
  spy: Yt.default.bool,
  horizontal: Yt.default.bool,
  smooth: Yt.default.oneOfType([Yt.default.bool, Yt.default.string]),
  offset: Yt.default.number,
  delay: Yt.default.number,
  isDynamic: Yt.default.bool,
  onClick: Yt.default.func,
  duration: Yt.default.oneOfType([Yt.default.number, Yt.default.func]),
  absolute: Yt.default.bool,
  onSetActive: Yt.default.func,
  onSetInactive: Yt.default.func,
  ignoreCancelEvents: Yt.default.bool,
  hashSpy: Yt.default.bool,
  saveHashHistory: Yt.default.bool,
  spyThrottle: Yt.default.number
};
qs.default = function(e, t) {
  var n = t || yF.default, r = function(i) {
    OF(s, i);
    function s(a) {
      CF(this, s);
      var l = EF(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return hF(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          Fa.default.isMounted(a) || Fa.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (Jr.default.isMounted() || Jr.default.mount(n), Jr.default.mapContainer(this.props.to, a)), Fa.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Fa.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Ia({}, this.props.style, this.props.activeStyle) : l = Ia({}, this.props.style);
        var u = Ia({}, this.props);
        for (var c in fy)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, py.default.createElement(e, u);
      }
    }]), s;
  }(py.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, Ia({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Jr.default.isMounted() && !Jr.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, d = null, p = void 0, m = void 0;
        if (u) {
          var f = 0, g = 0, h = 0;
          if (l.getBoundingClientRect) {
            var C = l.getBoundingClientRect();
            h = C.left;
          }
          if (!d || i.props.isDynamic) {
            if (d = n.get(c), !d)
              return;
            var w = d.getBoundingClientRect();
            f = w.left - h + s, g = f + w.width;
          }
          var k = s - i.props.offset;
          p = k >= Math.floor(f) && k < Math.floor(g), m = k < Math.floor(f) || k >= Math.floor(g);
        } else {
          var E = 0, v = 0, O = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            O = L.top;
          }
          if (!d || i.props.isDynamic) {
            if (d = n.get(c), !d)
              return;
            var W = d.getBoundingClientRect();
            E = W.top - O + a, v = E + W.height;
          }
          var D = a - i.props.offset;
          p = D >= Math.floor(E) && D < Math.floor(v), m = D < Math.floor(E) || D >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (m) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && Jr.default.getHash() === c) {
            var _ = i.props.saveHashHistory, R = _ === void 0 ? !1 : _;
            Jr.default.changeHash("", R);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, d));
        }
        if (p && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var U = i.props.saveHashHistory, z = U === void 0 ? !1 : U;
          i.props.hashSpy && Jr.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, d));
        }
      }
    };
  };
  return r.propTypes = fy, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Lh, "__esModule", {
  value: !0
});
var xF = Ce, hy = Fx(xF), DF = qs, LF = Fx(DF);
function Fx(e) {
  return e && e.__esModule ? e : { default: e };
}
function PF(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gy(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function SF(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var kF = function(e) {
  SF(t, e);
  function t() {
    var n, r, o, i;
    PF(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = gy(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return hy.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), gy(o, i);
  }
  return t;
}(hy.default.Component);
Lh.default = (0, LF.default)(kF);
var Th = {};
Object.defineProperty(Th, "__esModule", {
  value: !0
});
var MF = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), AF = Ce, my = Rx(AF), TF = qs, BF = Rx(TF);
function Rx(e) {
  return e && e.__esModule ? e : { default: e };
}
function jF(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _F(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function IF(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var FF = function(e) {
  IF(t, e);
  function t() {
    return jF(this, t), _F(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return MF(t, [{
    key: "render",
    value: function() {
      return my.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(my.default.Component);
Th.default = (0, BF.default)(FF);
var Bh = {}, hc = {};
Object.defineProperty(hc, "__esModule", {
  value: !0
});
var RF = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, NF = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), zF = Ce, vy = gc(zF), $F = xu;
gc($F);
var UF = Si, yy = gc(UF), WF = pc, by = gc(WF);
function gc(e) {
  return e && e.__esModule ? e : { default: e };
}
function VF(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HF(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function qF(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
hc.default = function(e) {
  var t = function(n) {
    qF(r, n);
    function r(o) {
      VF(this, r);
      var i = HF(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return NF(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        yy.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        yy.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return vy.default.createElement(e, RF({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(vy.default.Component);
  return t.propTypes = {
    name: by.default.string,
    id: by.default.string
  }, t;
};
Object.defineProperty(Bh, "__esModule", {
  value: !0
});
var wy = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, GF = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ZF = Ce, Cy = jh(ZF), YF = hc, XF = jh(YF), KF = pc, Ey = jh(KF);
function jh(e) {
  return e && e.__esModule ? e : { default: e };
}
function JF(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function QF(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function eR(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Nx = function(e) {
  eR(t, e);
  function t() {
    return JF(this, t), QF(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return GF(t, [{
    key: "render",
    value: function() {
      var n = this, r = wy({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, Cy.default.createElement(
        "div",
        wy({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(Cy.default.Component);
Nx.propTypes = {
  name: Ey.default.string,
  id: Ey.default.string
};
Bh.default = (0, XF.default)(Nx);
var dd = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Oy = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function xy(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Dy(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Ly(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Ra = Ce, Ao = Gs, pd = Si, ln = pc, Qr = fc, Py = {
  to: ln.string.isRequired,
  containerId: ln.string,
  container: ln.object,
  activeClass: ln.string,
  spy: ln.bool,
  smooth: ln.oneOfType([ln.bool, ln.string]),
  offset: ln.number,
  delay: ln.number,
  isDynamic: ln.bool,
  onClick: ln.func,
  duration: ln.oneOfType([ln.number, ln.func]),
  absolute: ln.bool,
  onSetActive: ln.func,
  onSetInactive: ln.func,
  ignoreCancelEvents: ln.bool,
  hashSpy: ln.bool,
  spyThrottle: ln.number
}, tR = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || pd, r = function(i) {
      Ly(s, i);
      function s(a) {
        xy(this, s);
        var l = Dy(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return Oy(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Ao.isMounted(a) || Ao.mount(a, this.props.spyThrottle), this.props.hashSpy && (Qr.isMounted() || Qr.mount(n), Qr.mapContainer(this.props.to, a)), this.props.spy && Ao.addStateHandler(this.stateHandler), Ao.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ao.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = dd({}, this.props);
          for (var u in Py)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Ra.createElement(e, l);
        }
      }]), s;
    }(Ra.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, dd({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Qr.isMounted() && !Qr.isInitialized())) {
          var l = i.props.to, u = null, c = 0, d = 0, p = 0;
          if (a.getBoundingClientRect) {
            var m = a.getBoundingClientRect();
            p = m.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - p + s, d = c + f.height;
          }
          var g = s - i.props.offset, h = g >= Math.floor(c) && g < Math.floor(d), C = g < Math.floor(c) || g >= Math.floor(d), w = n.getActiveLink();
          if (C)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Qr.getHash() === l && Qr.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Ao.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Qr.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Ao.updateStates();
        }
      };
    };
    return r.propTypes = Py, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      Ly(r, n);
      function r(o) {
        xy(this, r);
        var i = Dy(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return Oy(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          pd.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          pd.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Ra.createElement(e, dd({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Ra.Component);
    return t.propTypes = {
      name: ln.string,
      id: ln.string
    }, t;
  }
}, nR = tR;
Object.defineProperty(hn, "__esModule", {
  value: !0
});
hn.Helpers = hn.ScrollElement = hn.ScrollLink = hn.animateScroll = hn.scrollSpy = hn.Events = hn.scroller = hn.Element = hn.Button = hn.Link = void 0;
var rR = Lh, zx = Ar(rR), oR = Th, $x = Ar(oR), iR = Bh, Ux = Ar(iR), sR = Si, Wx = Ar(sR), aR = Xs, Vx = Ar(aR), lR = Gs, Hx = Ar(lR), uR = uc, qx = Ar(uR), cR = qs, Gx = Ar(cR), dR = hc, Zx = Ar(dR), pR = nR, Yx = Ar(pR);
function Ar(e) {
  return e && e.__esModule ? e : { default: e };
}
hn.Link = zx.default;
hn.Button = $x.default;
hn.Element = Ux.default;
hn.scroller = Wx.default;
hn.Events = Vx.default;
hn.scrollSpy = Hx.default;
hn.animateScroll = qx.default;
hn.ScrollLink = Gx.default;
hn.ScrollElement = Zx.default;
hn.Helpers = Yx.default;
hn.default = { Link: zx.default, Button: $x.default, Element: Ux.default, scroller: Wx.default, Events: Vx.default, scrollSpy: Hx.default, animateScroll: qx.default, ScrollLink: Gx.default, ScrollElement: Zx.default, Helpers: Yx.default };
Ze({});
Ze({});
Ze({});
function Fs(e) {
  "@babel/helpers - typeof";
  return Fs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Fs(e);
}
function fR(e, t) {
  if (Fs(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Fs(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function hR(e) {
  var t = fR(e, "string");
  return Fs(t) == "symbol" ? t : t + "";
}
function ue(e, t, n) {
  return (t = hR(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function Xx(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var fd, Sy;
function gR() {
  if (Sy) return fd;
  Sy = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, s, a, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [o, i, s, a, l, u], p = 0;
        c = new Error(r.replace(/%s/g, function() {
          return d[p++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return fd = t, fd;
}
var mR = gR(), On = /* @__PURE__ */ Xx(mR), Ye = Ze(null);
function vR() {
  On(!!Oe, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Oe(Ye);
  return On(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function yR(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function bR(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function wR(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return bR(e, i), o;
}
function CR(e, t, n) {
  var r = yR(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function ER(e) {
  google.maps.event.removeListener(e);
}
function ft() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(ER);
}
function dt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = CR(o, i, n);
  return wR(t, r, o, i), s;
}
function OR(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: d,
    onMouseMove: p,
    onMouseOut: m,
    onMouseOver: f,
    onMouseDown: g,
    onMouseUp: h,
    onRightClick: C,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: k,
    onUnmount: E
  } = e, [v, O] = P(null), L = qe(null), [W, D] = P(null), [N, _] = P(null), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null), [Z, T] = P(null), [Y, x] = P(null), [M, $] = P(null), [B, V] = P(null), [F, J] = P(null);
  return y(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), y(() => {
    v !== null && typeof s < "u" && v.setCenter(s);
  }, [v, s]), y(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), _(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), y(() => {
    v && c && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), y(() => {
    v && d && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(v, "dragstart", d)));
  }, [d]), y(() => {
    v && g && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", g)));
  }, [g]), y(() => {
    v && p && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(v, "mousemove", p)));
  }, [p]), y(() => {
    v && m && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(v, "mouseout", m)));
  }, [m]), y(() => {
    v && f && (Z !== null && google.maps.event.removeListener(Z), T(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), y(() => {
    v && h && (Y !== null && google.maps.event.removeListener(Y), x(google.maps.event.addListener(v, "mouseup", h)));
  }, [h]), y(() => {
    v && C && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(v, "rightclick", C)));
  }, [C]), y(() => {
    v && a && (B !== null && google.maps.event.removeListener(B), V(google.maps.event.addListener(v, "click", a)));
  }, [a]), y(() => {
    v && u && (F !== null && google.maps.event.removeListener(F), J(google.maps.event.addListener(v, "drag", u)));
  }, [u]), y(() => {
    v && w && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(v, "center_changed", w)));
  }, [a]), y(() => {
    var G = L.current === null ? null : new google.maps.Map(L.current, n);
    return O(G), G !== null && k && k(G), () => {
      G !== null && E && E(G);
    };
  }, []), Zn.jsx("div", {
    id: r,
    ref: L,
    style: o,
    className: i,
    children: Zn.jsx(Ye.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
Me(OR);
function ky(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function Kx(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        ky(i, r, o, s, a, "next", l);
      }
      function a(l) {
        ky(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function Jx(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return On(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var Ho = typeof document < "u";
function Qx(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return Ho ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(p) {
          c && c(p), i(p);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(p) {
      d.setAttribute("data-state", "error"), i(p);
    }, a.initMap = function() {
      d.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function My(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function eD() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return My(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return My(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Gi = !1;
function tD() {
  return Zn.jsx("div", {
    children: "Loading..."
  });
}
var Hp = {
  id: "script-loader",
  version: "weekly"
};
class xR extends Ee {
  constructor() {
    super(...arguments), ue(this, "check", mr()), ue(this, "state", {
      loaded: !1
    }), ue(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ue(this, "isCleaningUp", /* @__PURE__ */ Kx(function* () {
      function t(n) {
        if (!Gi)
          n();
        else if (Ho)
          var r = window.setInterval(function() {
            Gi || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ue(this, "cleanup", () => {
      Gi = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), ue(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && eD(), On(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Jx(this.props)
      };
      Qx(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (Ho) {
      if (window.google && window.google.maps && !Gi) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), Ho && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (Ho) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Gi = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Zn.jsxs(Zn.Fragment, {
      children: [Zn.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Zn.jsx(tD, {})]
    });
  }
}
ue(xR, "defaultProps", Hp);
function DR(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function _h(e, t) {
  if (e == null) return {};
  var n, r, o = DR(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var Ay;
function LR(e) {
  var {
    id: t = Hp.id,
    version: n = Hp.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  } = e, m = qe(!1), [f, g] = P(!1), [h, C] = P(void 0);
  y(function() {
    return m.current = !0, () => {
      m.current = !1;
    };
  }, []), y(function() {
    Ho && u && eD();
  }, [u]), y(function() {
    f && On(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = Jx({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  });
  y(function() {
    if (!Ho)
      return;
    function E() {
      m.current && (g(!0), Ay = w);
    }
    if (window.google && window.google.maps && Ay === w) {
      E();
      return;
    }
    Qx({
      id: t,
      url: w,
      nonce: r
    }).then(E).catch(function(v) {
      m.current && C(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var k = qe();
  return y(function() {
    k.current && l !== k.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), k.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var PR = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], SR = Zn.jsx(tD, {});
function kR(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = _h(e, PR), {
    isLoaded: a,
    loadError: l
  } = LR(s);
  return y(function() {
    a && typeof n == "function" && n();
  }, [a, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || SR;
}
Me(kR);
var Ty;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Ty || (Ty = {}));
function By(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? By(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : By(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jy = {}, _y = {
  options(e, t) {
    e.setOptions(t);
  }
};
function MR(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = Oe(Ye), [i, s] = P(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), y(() => {
    var a = new google.maps.TrafficLayer(Hl(Hl({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Me(MR);
class AR extends Ee {
  constructor() {
    super(...arguments), ue(this, "state", {
      trafficLayer: null
    }), ue(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ue(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Hl(Hl({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dt({
      updaterMap: _y,
      eventMap: jy,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: _y,
      eventMap: jy,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), ft(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ue(AR, "contextType", Ye);
function TR(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Oe(Ye), [o, i] = P(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
Me(TR);
class BR extends Ee {
  constructor() {
    super(...arguments), ue(this, "state", {
      bicyclingLayer: null
    }), ue(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ue(BR, "contextType", Ye);
function jR(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Oe(Ye), [o, i] = P(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Me(jR);
class _R extends Ee {
  constructor() {
    super(...arguments), ue(this, "state", {
      transitLayer: null
    }), ue(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ue(_R, "contextType", Ye);
function Iy(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ql(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Iy(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Iy(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fy = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, Ry = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function IR(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, d = Oe(Ye), [p, m] = P(null), [f, g] = P(null), [h, C] = P(null), [w, k] = P(null), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null);
  return y(() => {
    p !== null && p.setMap(d);
  }, [d]), y(() => {
    t && p !== null && p.setOptions(t);
  }, [p, t]), y(() => {
    p !== null && p.setDrawingMode(n ?? null);
  }, [p, n]), y(() => {
    p && r && (f !== null && google.maps.event.removeListener(f), g(google.maps.event.addListener(p, "circlecomplete", r)));
  }, [p, r]), y(() => {
    p && o && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(p, "markercomplete", o)));
  }, [p, o]), y(() => {
    p && i && (w !== null && google.maps.event.removeListener(w), k(google.maps.event.addListener(p, "overlaycomplete", i)));
  }, [p, i]), y(() => {
    p && s && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(p, "polygoncomplete", s)));
  }, [p, s]), y(() => {
    p && a && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(p, "polylinecomplete", a)));
  }, [p, a]), y(() => {
    p && l && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(p, "rectanglecomplete", l)));
  }, [p, l]), y(() => {
    On(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(ql(ql({}, t), {}, {
      map: d
    }));
    return n && N.setDrawingMode(n), r && g(google.maps.event.addListener(N, "circlecomplete", r)), o && C(google.maps.event.addListener(N, "markercomplete", o)), i && k(google.maps.event.addListener(N, "overlaycomplete", i)), s && v(google.maps.event.addListener(N, "polygoncomplete", s)), a && L(google.maps.event.addListener(N, "polylinecomplete", a)), l && D(google.maps.event.addListener(N, "rectanglecomplete", l)), m(N), u && u(N), () => {
      p !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), E && google.maps.event.removeListener(E), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), c && c(p), p.setMap(null));
    };
  }, []), null;
}
Me(IR);
class FR extends Ee {
  constructor(t) {
    super(t), ue(this, "registeredEvents", []), ue(this, "state", {
      drawingManager: null
    }), ue(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), On(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(ql(ql({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dt({
      updaterMap: Ry,
      eventMap: Fy,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: Ry,
      eventMap: Fy,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), ft(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ue(FR, "contextType", Ye);
function Ny(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ny(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ny(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zy = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, $y = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Gl = {};
function RR(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: d,
    label: p,
    opacity: m,
    shape: f,
    title: g,
    zIndex: h,
    onClick: C,
    onDblClick: w,
    onDrag: k,
    onDragEnd: E,
    onDragStart: v,
    onMouseOut: O,
    onMouseOver: L,
    onMouseUp: W,
    onMouseDown: D,
    onRightClick: N,
    onClickableChanged: _,
    onCursorChanged: R,
    onAnimationChanged: U,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: ne,
    onTitleChanged: Q,
    onVisibleChanged: S,
    onZindexChanged: I,
    onLoad: Z,
    onUnmount: T
  } = e, Y = Oe(Ye), [x, M] = P(null), [$, B] = P(null), [V, F] = P(null), [J, G] = P(null), [fe, be] = P(null), [re, Ae] = P(null), [Ie, je] = P(null), [_e, tt] = P(null), [Ke, ke] = P(null), [nt, gt] = P(null), [Pe, Te] = P(null), [Re, He] = P(null), [ze, wt] = P(null), [Be, dn] = P(null), [Ct, Pt] = P(null), [Rt, vn] = P(null), [Nt, yn] = P(null), [mt, en] = P(null), [St, bn] = P(null), [zt, Pn] = P(null), [wn, Sn] = P(null), [Cn, kn] = P(null);
  y(() => {
    x !== null && x.setMap(Y);
  }, [Y]), y(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), y(() => {
    typeof s < "u" && x !== null && x.setDraggable(s);
  }, [x, s]), y(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), y(() => {
    typeof a < "u" && x !== null && x.setVisible(a);
  }, [x, a]), y(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), y(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), y(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), y(() => {
    x && d !== void 0 && x.setIcon(d);
  }, [x, d]), y(() => {
    x && p !== void 0 && x.setLabel(p);
  }, [x, p]), y(() => {
    x && m !== void 0 && x.setOpacity(m);
  }, [x, m]), y(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), y(() => {
    x && g !== void 0 && x.setTitle(g);
  }, [x, g]), y(() => {
    x && h !== void 0 && x.setZIndex(h);
  }, [x, h]), y(() => {
    x && w && ($ !== null && google.maps.event.removeListener($), B(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), y(() => {
    x && E && (V !== null && google.maps.event.removeListener(V), F(google.maps.event.addListener(x, "dragend", E)));
  }, [E]), y(() => {
    x && v && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(x, "dragstart", v)));
  }, [v]), y(() => {
    x && D && (fe !== null && google.maps.event.removeListener(fe), be(google.maps.event.addListener(x, "mousedown", D)));
  }, [D]), y(() => {
    x && O && (re !== null && google.maps.event.removeListener(re), Ae(google.maps.event.addListener(x, "mouseout", O)));
  }, [O]), y(() => {
    x && L && (Ie !== null && google.maps.event.removeListener(Ie), je(google.maps.event.addListener(x, "mouseover", L)));
  }, [L]), y(() => {
    x && W && (_e !== null && google.maps.event.removeListener(_e), tt(google.maps.event.addListener(x, "mouseup", W)));
  }, [W]), y(() => {
    x && N && (Ke !== null && google.maps.event.removeListener(Ke), ke(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), y(() => {
    x && C && (nt !== null && google.maps.event.removeListener(nt), gt(google.maps.event.addListener(x, "click", C)));
  }, [C]), y(() => {
    x && k && (Pe !== null && google.maps.event.removeListener(Pe), Te(google.maps.event.addListener(x, "drag", k)));
  }, [k]), y(() => {
    x && _ && (Re !== null && google.maps.event.removeListener(Re), He(google.maps.event.addListener(x, "clickable_changed", _)));
  }, [_]), y(() => {
    x && R && (ze !== null && google.maps.event.removeListener(ze), wt(google.maps.event.addListener(x, "cursor_changed", R)));
  }, [R]), y(() => {
    x && U && (Be !== null && google.maps.event.removeListener(Be), dn(google.maps.event.addListener(x, "animation_changed", U)));
  }, [U]), y(() => {
    x && z && (Ct !== null && google.maps.event.removeListener(Ct), Pt(google.maps.event.addListener(x, "draggable_changed", z)));
  }, [z]), y(() => {
    x && q && (Rt !== null && google.maps.event.removeListener(Rt), vn(google.maps.event.addListener(x, "flat_changed", q)));
  }, [q]), y(() => {
    x && K && (Nt !== null && google.maps.event.removeListener(Nt), yn(google.maps.event.addListener(x, "icon_changed", K)));
  }, [K]), y(() => {
    x && X && (mt !== null && google.maps.event.removeListener(mt), en(google.maps.event.addListener(x, "position_changed", X)));
  }, [X]), y(() => {
    x && ne && (St !== null && google.maps.event.removeListener(St), bn(google.maps.event.addListener(x, "shape_changed", ne)));
  }, [ne]), y(() => {
    x && Q && (zt !== null && google.maps.event.removeListener(zt), Pn(google.maps.event.addListener(x, "title_changed", Q)));
  }, [Q]), y(() => {
    x && S && (wn !== null && google.maps.event.removeListener(wn), Sn(google.maps.event.addListener(x, "visible_changed", S)));
  }, [S]), y(() => {
    x && I && (Cn !== null && google.maps.event.removeListener(Cn), kn(google.maps.event.addListener(x, "zindex_changed", I)));
  }, [I]), y(() => {
    var tn = pi(pi(pi({}, n || Gl), r ? Gl : {
      map: Y
    }), {}, {
      position: t
    }), se = new google.maps.Marker(tn);
    return r ? r.addMarker(se, !!o) : se.setMap(Y), t && se.setPosition(t), typeof a < "u" && se.setVisible(a), typeof s < "u" && se.setDraggable(s), typeof u < "u" && se.setClickable(u), typeof c == "string" && se.setCursor(c), d && se.setIcon(d), typeof p < "u" && se.setLabel(p), typeof m < "u" && se.setOpacity(m), f && se.setShape(f), typeof g == "string" && se.setTitle(g), typeof h == "number" && se.setZIndex(h), w && B(google.maps.event.addListener(se, "dblclick", w)), E && F(google.maps.event.addListener(se, "dragend", E)), v && G(google.maps.event.addListener(se, "dragstart", v)), D && be(google.maps.event.addListener(se, "mousedown", D)), O && Ae(google.maps.event.addListener(se, "mouseout", O)), L && je(google.maps.event.addListener(se, "mouseover", L)), W && tt(google.maps.event.addListener(se, "mouseup", W)), N && ke(google.maps.event.addListener(se, "rightclick", N)), C && gt(google.maps.event.addListener(se, "click", C)), k && Te(google.maps.event.addListener(se, "drag", k)), _ && He(google.maps.event.addListener(se, "clickable_changed", _)), R && wt(google.maps.event.addListener(se, "cursor_changed", R)), U && dn(google.maps.event.addListener(se, "animation_changed", U)), z && Pt(google.maps.event.addListener(se, "draggable_changed", z)), q && vn(google.maps.event.addListener(se, "flat_changed", q)), K && yn(google.maps.event.addListener(se, "icon_changed", K)), X && en(google.maps.event.addListener(se, "position_changed", X)), ne && bn(google.maps.event.addListener(se, "shape_changed", ne)), Q && Pn(google.maps.event.addListener(se, "title_changed", Q)), S && Sn(google.maps.event.addListener(se, "visible_changed", S)), I && kn(google.maps.event.addListener(se, "zindex_changed", I)), M(se), Z && Z(se), () => {
      $ !== null && google.maps.event.removeListener($), V !== null && google.maps.event.removeListener(V), J !== null && google.maps.event.removeListener(J), fe !== null && google.maps.event.removeListener(fe), re !== null && google.maps.event.removeListener(re), Ie !== null && google.maps.event.removeListener(Ie), _e !== null && google.maps.event.removeListener(_e), Ke !== null && google.maps.event.removeListener(Ke), nt !== null && google.maps.event.removeListener(nt), Re !== null && google.maps.event.removeListener(Re), ze !== null && google.maps.event.removeListener(ze), Be !== null && google.maps.event.removeListener(Be), Ct !== null && google.maps.event.removeListener(Ct), Rt !== null && google.maps.event.removeListener(Rt), Nt !== null && google.maps.event.removeListener(Nt), mt !== null && google.maps.event.removeListener(mt), zt !== null && google.maps.event.removeListener(zt), wn !== null && google.maps.event.removeListener(wn), Cn !== null && google.maps.event.removeListener(Cn), T && T(se), r ? r.removeMarker(se, !!o) : se && se.setMap(null);
    };
  }, []);
  var Wn = Mn(() => i ? Ft.map(i, (tn) => {
    if (!Ei(tn))
      return tn;
    var se = tn;
    return Oi(se, {
      anchor: x
    });
  }) : null, [i, x]);
  return Zn.jsx(Zn.Fragment, {
    children: Wn
  }) || null;
}
Me(RR);
class NR extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return Kx(function* () {
      var n = pi(pi(pi({}, t.props.options || Gl), t.props.clusterer ? Gl : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = dt({
        updaterMap: $y,
        eventMap: zy,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: $y,
      eventMap: zy,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), ft(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? Ft.map(this.props.children, (n) => {
      if (!Ei(n))
        return n;
      var r = n;
      return Oi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ue(NR, "contextType", Ye);
var zR = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), d = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(d !== null ? "".concat(d.y, "px") : "0", "; left: ").concat(d !== null ? "".concat(d.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var p = document.createElement("img");
        p.alt = a, p.src = this.url, p.width = this.width, p.height = this.height, p.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (p.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var m = document.createElement("div");
        m.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (m.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (m.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(p), this.div.appendChild(m), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), $R = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new zR(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function UR(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var WR = 2e3, VR = 500, HR = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", qR = "png", GR = [53, 56, 66, 78, 90], ZR = "cluster", nD = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || HR, this.imageExtension = r.imageExtension || qR, this.imageSizes = r.imageSizes || GR, this.calculator = r.calculator || UR, this.batchSize = r.batchSize || WR, this.batchSizeIE = r.batchSizeIE || VR, this.clusterClass = r.clusterClass || ZR, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new $R(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var d = 0, p = this.clusters; d < p.length; d++) {
            var m = p[d];
            m.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function Uy(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function YR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Uy(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Uy(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dr = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, vt = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, XR = {};
function KR(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: d,
    imageSizes: p,
    maxZoom: m,
    minimumClusterSize: f,
    styles: g,
    title: h,
    zoomOnClick: C,
    onClick: w,
    onClusteringBegin: k,
    onClusteringEnd: E,
    onMouseOver: v,
    onMouseOut: O,
    onLoad: L,
    onUnmount: W
  } = e, [D, N] = P(null), _ = Oe(Ye), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null);
  return y(() => {
    D && O && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(D, dr.onMouseOut, O)));
  }, [O]), y(() => {
    D && v && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(D, dr.onMouseOver, v)));
  }, [v]), y(() => {
    D && w && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(D, dr.onClick, w)));
  }, [w]), y(() => {
    D && k && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(D, dr.onClusteringBegin, k)));
  }, [k]), y(() => {
    D && E && (K !== null && google.maps.event.removeListener(K), q(google.maps.event.addListener(D, dr.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && D !== null && vt.averageCenter(D, r);
  }, [D, r]), y(() => {
    typeof o < "u" && D !== null && vt.batchSizeIE(D, o);
  }, [D, o]), y(() => {
    typeof i < "u" && D !== null && vt.calculator(D, i);
  }, [D, i]), y(() => {
    typeof s < "u" && D !== null && vt.clusterClass(D, s);
  }, [D, s]), y(() => {
    typeof a < "u" && D !== null && vt.enableRetinaIcons(D, a);
  }, [D, a]), y(() => {
    typeof l < "u" && D !== null && vt.gridSize(D, l);
  }, [D, l]), y(() => {
    typeof u < "u" && D !== null && vt.ignoreHidden(D, u);
  }, [D, u]), y(() => {
    typeof c < "u" && D !== null && vt.imageExtension(D, c);
  }, [D, c]), y(() => {
    typeof d < "u" && D !== null && vt.imagePath(D, d);
  }, [D, d]), y(() => {
    typeof p < "u" && D !== null && vt.imageSizes(D, p);
  }, [D, p]), y(() => {
    typeof m < "u" && D !== null && vt.maxZoom(D, m);
  }, [D, m]), y(() => {
    typeof f < "u" && D !== null && vt.minimumClusterSize(D, f);
  }, [D, f]), y(() => {
    typeof g < "u" && D !== null && vt.styles(D, g);
  }, [D, g]), y(() => {
    typeof h < "u" && D !== null && vt.title(D, h);
  }, [D, h]), y(() => {
    typeof C < "u" && D !== null && vt.zoomOnClick(D, C);
  }, [D, C]), y(() => {
    if (_) {
      var Z = YR({}, n || XR), T = new nD(_, [], Z);
      return r && vt.averageCenter(T, r), o && vt.batchSizeIE(T, o), i && vt.calculator(T, i), s && vt.clusterClass(T, s), a && vt.enableRetinaIcons(T, a), l && vt.gridSize(T, l), u && vt.ignoreHidden(T, u), c && vt.imageExtension(T, c), d && vt.imagePath(T, d), p && vt.imageSizes(T, p), m && vt.maxZoom(T, m), f && vt.minimumClusterSize(T, f), g && vt.styles(T, g), h && vt.title(T, h), C && vt.zoomOnClick(T, C), O && Q(google.maps.event.addListener(T, dr.onMouseOut, O)), v && I(google.maps.event.addListener(T, dr.onMouseOver, v)), w && U(google.maps.event.addListener(T, dr.onClick, w)), k && q(google.maps.event.addListener(T, dr.onClusteringBegin, k)), E && X(google.maps.event.addListener(T, dr.onClusteringEnd, E)), N(T), L && L(T), () => {
        ne !== null && google.maps.event.removeListener(ne), S !== null && google.maps.event.removeListener(S), R !== null && google.maps.event.removeListener(R), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), W && W(T);
      };
    }
  }, []), D !== null && t(D) || null;
}
Me(KR);
class JR extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      markerClusterer: null
    }), ue(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new nD(this.context, [], this.props.options);
      this.registeredEvents = dt({
        updaterMap: vt,
        eventMap: dr,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: vt,
      eventMap: dr,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), ft(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ue(JR, "contextType", Ye);
function Wy(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var rD = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || Wy(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, Wy));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, d = this.div.offsetWidth, p = this.div.offsetHeight, m = this.infoBoxClearance.width, f = this.infoBoxClearance.height, g = this.getProjection(), h = g.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + m ? r = h.x + u - m : h.x + d + u + m > a && (r = h.x + d + u + m - a), this.alignBottom ? h.y < -c + f + p ? o = h.y + c - f - p : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + p + c + f > l && (o = h.y + p + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), QR = ["position"], eN = ["position"];
function Vy(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Vy(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Vy(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Hy = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, qy = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, tN = {};
function nN(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, m = Oe(Ye), [f, g] = P(null), [h, C] = P(null), [w, k] = P(null), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null), N = qe(null);
  return y(() => {
    m && f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    if (o && f !== null) {
      var _ = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(_);
    }
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), k(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    if (m) {
      var _ = r || tN, {
        position: R
      } = _, U = _h(_, QR), z;
      R && !(R instanceof google.maps.LatLng) && (z = new google.maps.LatLng(R.lat, R.lng));
      var q = new rD(Zl(Zl({}, U), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), g(q), s && C(google.maps.event.addListener(q, "closeclick", s)), a && k(google.maps.event.addListener(q, "domready", a)), l && v(google.maps.event.addListener(q, "content_changed", l)), u && L(google.maps.event.addListener(q, "position_changed", u)), c && D(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(N.current), n ? q.open(m, n) : q.getPosition() ? q.open(m) : On(!1, "You must provide either an anchor or a position prop for <InfoBox>."), d && d(q);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), p && p(f), f.close());
    };
  }, []), N.current ? vr(Ft.only(t), N.current) : null;
}
Me(nN);
class rN extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "containerElement", null), ue(this, "state", {
      infoBox: null
    }), ue(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : On(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ue(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = _h(t, eN), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new rD(Zl(Zl({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = dt({
      updaterMap: qy,
      eventMap: Hy,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: qy,
      eventMap: Hy,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), ft(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? vr(Ft.only(this.props.children), this.containerElement) : null;
  }
}
ue(rN, "contextType", Ye);
var Gy, Zy;
function oN() {
  return Zy || (Zy = 1, Gy = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), Gy;
}
var iN = oN(), Yy = /* @__PURE__ */ Xx(iN), Xy = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], hd = 1, Zi = 8;
class Ih {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== hd)
      throw new Error("Got v".concat(o, " data when expected v").concat(hd, "."));
    var i = Xy[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new Ih(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = Xy.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Zi, t), this.coords = new this.ArrayType(this.data, Zi + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Zi + s + a + l), this.ids = new this.IndexArrayType(this.data, Zi, t), this.coords = new this.ArrayType(this.data, Zi + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (hd << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return qp(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, d = l.pop() || 0, p = l.pop() || 0;
      if (d - p <= a) {
        for (var m = p; m <= d; m++) {
          var f = s[2 * m], g = s[2 * m + 1];
          f >= t && f <= r && g >= n && g <= o && u.push(i[m]);
        }
        continue;
      }
      var h = p + d >> 1, C = s[2 * h], w = s[2 * h + 1];
      C >= t && C <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= C : n <= w) && (l.push(p), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= C : o >= w) && (l.push(h + 1), l.push(d), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, d = a.pop() || 0, p = a.pop() || 0;
      if (d - p <= s) {
        for (var m = p; m <= d; m++)
          Ky(i[2 * m], i[2 * m + 1], t, n) <= u && l.push(o[m]);
        continue;
      }
      var f = p + d >> 1, g = i[2 * f], h = i[2 * f + 1];
      Ky(g, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= g : n - r <= h) && (a.push(p), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= h) && (a.push(f + 1), a.push(d), a.push(1 - c));
    }
    return l;
  }
}
function qp(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    oD(e, t, s, r, o, i), qp(e, t, n, r, s - 1, 1 - i), qp(e, t, n, s + 1, o, 1 - i);
  }
}
function oD(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), d = Math.max(r, Math.floor(n - a * u / s + c)), p = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      oD(e, t, n, d, p, i);
    }
    var m = t[2 * n + i], f = r, g = o;
    for (Yi(e, t, r, n), t[2 * o + i] > m && Yi(e, t, r, o); f < g; ) {
      for (Yi(e, t, f, g), f++, g--; t[2 * f + i] < m; ) f++;
      for (; t[2 * g + i] > m; ) g--;
    }
    t[2 * r + i] === m ? Yi(e, t, r, g) : (g++, Yi(e, t, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function Yi(e, t, n, r) {
  gd(e, n, r), gd(t, 2 * n, 2 * r), gd(t, 2 * n + 1, 2 * r + 1);
}
function gd(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function Ky(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var sN = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, Jy = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), To = 2, lo = 3, md = 4, io = 5, iD = 6;
class aN {
  constructor(t) {
    this.options = Object.assign(Object.create(sN), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, d = Jy(Na(u)), p = Jy(za(c));
        s.push(
          d,
          p,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var m = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var g = +Date.now();
      m = this.trees[f] = this._createTree(this._cluster(m, f)), n && console.log("z%d: %d clusters in %dms", f, m.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Na(r), za(s), Na(i), za(o)), d = u.data, p = [];
    for (var m of c) {
      var f = this.stride * m;
      p.push(d[f + io] > 1 ? Qy(d, f, this.clusterProps) : this.points[d[f + lo]]);
    }
    return p;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), d = [];
    for (var p of c) {
      var m = p * this.stride;
      s[m + md] === t && d.push(s[m + io] > 1 ? Qy(s, m, this.clusterProps) : this.points[s[m + lo]]);
    }
    if (d.length === 0) throw new Error(o);
    return d;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, d = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, d), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, d), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, d), d.features.length ? d : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Ih(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + io] > 1, c = void 0, d = void 0, p = void 0;
      if (u)
        c = sD(n, l, this.clusterProps), d = n[l], p = n[l + 1];
      else {
        var m = this.points[n[l + lo]];
        c = m.properties;
        var [f, g] = m.geometry.coordinates;
        d = Na(f), p = za(g);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (d * i - r)), Math.round(this.options.extent * (p * i - o))]],
        tags: c
      }, C = void 0;
      u || this.options.generateId ? C = n[l + lo] : C = this.points[n[l + lo]].id, C !== void 0 && (h.id = C), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, d = 0; d < l.length; d += c)
      if (!(l[d + To] <= n)) {
        l[d + To] = n;
        var p = l[d], m = l[d + 1], f = t.within(l[d], l[d + 1], a), g = l[d + io], h = g;
        for (var C of f) {
          var w = C * c;
          l[w + To] > n && (h += l[w + io]);
        }
        if (h > g && h >= s) {
          var k = p * g, E = m * g, v = void 0, O = -1, L = ((d / c | 0) << 5) + (n + 1) + this.points.length;
          for (var W of f) {
            var D = W * c;
            if (!(l[D + To] <= n)) {
              l[D + To] = n;
              var N = l[D + io];
              k += l[D] * N, E += l[D + 1] * N, l[D + md] = L, i && (v || (v = this._map(l, d, !0), O = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, D)));
            }
          }
          l[d + md] = L, u.push(k / h, E / h, 1 / 0, L, -1, h), i && u.push(O);
        } else {
          for (var _ = 0; _ < c; _++) u.push(l[d + _]);
          if (h > 1)
            for (var R of f) {
              var U = R * c;
              if (!(l[U + To] <= n)) {
                l[U + To] = n;
                for (var z = 0; z < c; z++) u.push(l[U + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + io] > 1) {
      var o = this.clusterProps[t[n + iD]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + lo]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function Qy(e, t, n) {
  return {
    type: "Feature",
    id: e[t + lo],
    properties: sD(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [lN(e[t]), uN(e[t + 1])]
    }
  };
}
function sD(e, t, n) {
  var r = e[t + io], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + iD], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + lo],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Na(e) {
  return e / 360 + 0.5;
}
function za(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function lN(e) {
  return (e - 0.5) * 360;
}
function uN(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function cN(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class tr {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Gp {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(tr.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => tr.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (tr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class dN {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return pN(n);
  }
}
var pN = (e) => {
  var t = e.map((n) => new Gp({
    position: tr.getPosition(n),
    markers: [n]
  }));
  return t;
};
class fN extends dN {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = cN(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new aN(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!Yy(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = tr.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !Yy(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new Gp({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Gp({
      markers: [i],
      position: tr.getPosition(i)
    });
  }
}
class hN {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class gN {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (tr.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), d = c.parseFromString(a, "image/svg+xml").documentElement;
      d.setAttribute("transform", "translate(0 25)");
      var p = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: d
      };
      return new google.maps.marker.AdvancedMarkerElement(p);
    }
    var m = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(m);
  }
}
function mN(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Fh {
  constructor() {
    mN(Fh, google.maps.OverlayView);
  }
}
var vs;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(vs || (vs = {}));
var vN = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class yN extends Fh {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new fN(o),
      renderer: s = new gN(),
      onClusterClick: a = vN
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (tr.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, vs.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || tr.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => tr.setMap(l, null)));
      }
      google.maps.event.trigger(this, vs.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => tr.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new hN(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => tr.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, vs.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), tr.setMap(r.marker, n);
    });
  }
}
function eb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eb(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function bN(e) {
  var t = vR(), [n, r] = P(null);
  return y(() => {
    if (t && n === null) {
      var o = new yN(tb(tb({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function wN(e) {
  var {
    children: t,
    options: n
  } = e, r = bN(n);
  return r !== null ? t(r) : null;
}
Me(wN);
var nb = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, rb = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function CN(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, m = Oe(Ye), [f, g] = P(null), [h, C] = P(null), [w, k] = P(null), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null), N = qe(null);
  return y(() => {
    f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), k(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    var _ = new google.maps.InfoWindow(r);
    return g(_), N.current = document.createElement("div"), s && C(google.maps.event.addListener(_, "closeclick", s)), a && k(google.maps.event.addListener(_, "domready", a)), l && v(google.maps.event.addListener(_, "content_changed", l)), u && L(google.maps.event.addListener(_, "position_changed", u)), c && D(google.maps.event.addListener(_, "zindex_changed", c)), _.setContent(N.current), o && _.setPosition(o), i && _.setZIndex(i), n ? _.open(m, n) : _.getPosition() ? _.open(m) : On(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), d && d(_), () => {
      h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), p && p(_), _.close();
    };
  }, []), N.current ? vr(Ft.only(t), N.current) : null;
}
Me(CN);
class EN extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "containerElement", null), ue(this, "state", {
      infoWindow: null
    }), ue(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : On(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ue(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = dt({
      updaterMap: rb,
      eventMap: nb,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: rb,
      eventMap: nb,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (ft(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? vr(Ft.only(this.props.children), this.containerElement) : null;
  }
}
ue(EN, "contextType", Ye);
function ob(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ob(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ob(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ib = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, sb = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, ON = {};
function xN(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onLoad: C,
    onUnmount: w
  } = e, k = Oe(Ye), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null), [N, _] = P(null), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null), [Z, T] = P(null), [Y, x] = P(null), [M, $] = P(null);
  return y(() => {
    E !== null && E.setMap(k);
  }, [k]), y(() => {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && s && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(E, "dblclick", s)));
  }, [s]), y(() => {
    E && a && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(E, "dragend", a)));
  }, [a]), y(() => {
    E && l && (N !== null && google.maps.event.removeListener(N), _(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && d && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(E, "mouseout", d)));
  }, [d]), y(() => {
    E && p && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(E, "mouseover", p)));
  }, [p]), y(() => {
    E && m && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(E, "mouseup", m)));
  }, [m]), y(() => {
    E && f && (Z !== null && google.maps.event.removeListener(Z), T(google.maps.event.addListener(E, "rightclick", f)));
  }, [f]), y(() => {
    E && g && (Y !== null && google.maps.event.removeListener(Y), x(google.maps.event.addListener(E, "click", g)));
  }, [g]), y(() => {
    E && h && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(E, "drag", h)));
  }, [h]), y(() => {
    var B = new google.maps.Polyline(Yl(Yl({}, t || ON), {}, {
      map: k
    }));
    return i && B.setPath(i), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), s && L(google.maps.event.addListener(B, "dblclick", s)), a && D(google.maps.event.addListener(B, "dragend", a)), l && _(google.maps.event.addListener(B, "dragstart", l)), u && U(google.maps.event.addListener(B, "mousedown", u)), c && q(google.maps.event.addListener(B, "mousemove", c)), d && X(google.maps.event.addListener(B, "mouseout", d)), p && Q(google.maps.event.addListener(B, "mouseover", p)), m && I(google.maps.event.addListener(B, "mouseup", m)), f && T(google.maps.event.addListener(B, "rightclick", f)), g && x(google.maps.event.addListener(B, "click", g)), h && $(google.maps.event.addListener(B, "drag", h)), v(B), C && C(B), () => {
      O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), N !== null && google.maps.event.removeListener(N), R !== null && google.maps.event.removeListener(R), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), ne !== null && google.maps.event.removeListener(ne), S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), w && w(B), B.setMap(null);
    };
  }, []), null;
}
Me(xN);
class DN extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      polyline: null
    }), ue(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Yl(Yl({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dt({
      updaterMap: sb,
      eventMap: ib,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: sb,
      eventMap: ib,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), ft(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ue(DN, "contextType", Ye);
function ab(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ab(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ab(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ub = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, cb = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function LN(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onLoad: w,
    onUnmount: k,
    onEdit: E
  } = e, v = Oe(Ye), [O, L] = P(null), [W, D] = P(null), [N, _] = P(null), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null), [Z, T] = P(null), [Y, x] = P(null), [M, $] = P(null), [B, V] = P(null);
  return y(() => {
    O !== null && O.setMap(v);
  }, [v]), y(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), y(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), y(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), y(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), y(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), y(() => {
    typeof s < "u" && O !== null && O.setPaths(s);
  }, [O, s]), y(() => {
    O && typeof a == "function" && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), y(() => {
    O && (google.maps.event.addListener(O.getPath(), "insert_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "set_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "remove_at", () => {
      E == null || E(O);
    }));
  }, [O, E]), y(() => {
    O && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), _(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), y(() => {
    O && typeof u == "function" && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), y(() => {
    O && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), y(() => {
    O && typeof d == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mousemove", d)));
  }, [d]), y(() => {
    O && typeof p == "function" && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), y(() => {
    O && typeof m == "function" && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(O, "mouseover", m)));
  }, [m]), y(() => {
    O && typeof f == "function" && (Z !== null && google.maps.event.removeListener(Z), T(google.maps.event.addListener(O, "mouseup", f)));
  }, [f]), y(() => {
    O && typeof g == "function" && (Y !== null && google.maps.event.removeListener(Y), x(google.maps.event.addListener(O, "rightclick", g)));
  }, [g]), y(() => {
    O && typeof h == "function" && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(O, "click", h)));
  }, [h]), y(() => {
    O && typeof C == "function" && (B !== null && google.maps.event.removeListener(B), V(google.maps.event.addListener(O, "drag", C)));
  }, [C]), y(() => {
    var F = new google.maps.Polygon(lb(lb({}, t), {}, {
      map: v
    }));
    return i && F.setPath(i), s && F.setPaths(s), typeof o < "u" && F.setVisible(o), typeof r < "u" && F.setEditable(r), typeof n < "u" && F.setDraggable(n), a && D(google.maps.event.addListener(F, "dblclick", a)), l && _(google.maps.event.addListener(F, "dragend", l)), u && U(google.maps.event.addListener(F, "dragstart", u)), c && q(google.maps.event.addListener(F, "mousedown", c)), d && X(google.maps.event.addListener(F, "mousemove", d)), p && Q(google.maps.event.addListener(F, "mouseout", p)), m && I(google.maps.event.addListener(F, "mouseover", m)), f && T(google.maps.event.addListener(F, "mouseup", f)), g && x(google.maps.event.addListener(F, "rightclick", g)), h && $(google.maps.event.addListener(F, "click", h)), C && V(google.maps.event.addListener(F, "drag", C)), L(F), w && w(F), () => {
      W !== null && google.maps.event.removeListener(W), N !== null && google.maps.event.removeListener(N), R !== null && google.maps.event.removeListener(R), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), ne !== null && google.maps.event.removeListener(ne), S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), k && k(F), F.setMap(null);
    };
  }, []), null;
}
Me(LN);
class PN extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = dt({
      updaterMap: cb,
      eventMap: ub,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: cb,
      eventMap: ub,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), ft(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ue(PN, "contextType", Ye);
function db(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? db(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : db(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pb = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, fb = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function SN(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onBoundsChanged: C,
    onLoad: w,
    onUnmount: k
  } = e, E = Oe(Ye), [v, O] = P(null), [L, W] = P(null), [D, N] = P(null), [_, R] = P(null), [U, z] = P(null), [q, K] = P(null), [X, ne] = P(null), [Q, S] = P(null), [I, Z] = P(null), [T, Y] = P(null), [x, M] = P(null), [$, B] = P(null), [V, F] = P(null);
  return y(() => {
    v !== null && v.setMap(E);
  }, [E]), y(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), y(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), y(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), y(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), y(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), y(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), W(google.maps.event.addListener(v, "dblclick", s)));
  }, [s]), y(() => {
    v && a && (D !== null && google.maps.event.removeListener(D), N(google.maps.event.addListener(v, "dragend", a)));
  }, [a]), y(() => {
    v && l && (_ !== null && google.maps.event.removeListener(_), R(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), y(() => {
    v && u && (U !== null && google.maps.event.removeListener(U), z(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), y(() => {
    v && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), y(() => {
    v && d && (X !== null && google.maps.event.removeListener(X), ne(google.maps.event.addListener(v, "mouseout", d)));
  }, [d]), y(() => {
    v && p && (Q !== null && google.maps.event.removeListener(Q), S(google.maps.event.addListener(v, "mouseover", p)));
  }, [p]), y(() => {
    v && m && (I !== null && google.maps.event.removeListener(I), Z(google.maps.event.addListener(v, "mouseup", m)));
  }, [m]), y(() => {
    v && f && (T !== null && google.maps.event.removeListener(T), Y(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), y(() => {
    v && g && (x !== null && google.maps.event.removeListener(x), M(google.maps.event.addListener(v, "click", g)));
  }, [g]), y(() => {
    v && h && ($ !== null && google.maps.event.removeListener($), B(google.maps.event.addListener(v, "drag", h)));
  }, [h]), y(() => {
    v && C && (V !== null && google.maps.event.removeListener(V), F(google.maps.event.addListener(v, "bounds_changed", C)));
  }, [C]), y(() => {
    var J = new google.maps.Rectangle(Xl(Xl({}, t), {}, {
      map: E
    }));
    return typeof i < "u" && J.setVisible(i), typeof o < "u" && J.setEditable(o), typeof r < "u" && J.setDraggable(r), typeof n < "u" && J.setBounds(n), s && W(google.maps.event.addListener(J, "dblclick", s)), a && N(google.maps.event.addListener(J, "dragend", a)), l && R(google.maps.event.addListener(J, "dragstart", l)), u && z(google.maps.event.addListener(J, "mousedown", u)), c && K(google.maps.event.addListener(J, "mousemove", c)), d && ne(google.maps.event.addListener(J, "mouseout", d)), p && S(google.maps.event.addListener(J, "mouseover", p)), m && Z(google.maps.event.addListener(J, "mouseup", m)), f && Y(google.maps.event.addListener(J, "rightclick", f)), g && M(google.maps.event.addListener(J, "click", g)), h && B(google.maps.event.addListener(J, "drag", h)), C && F(google.maps.event.addListener(J, "bounds_changed", C)), O(J), w && w(J), () => {
      L !== null && google.maps.event.removeListener(L), D !== null && google.maps.event.removeListener(D), _ !== null && google.maps.event.removeListener(_), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), x !== null && google.maps.event.removeListener(x), $ !== null && google.maps.event.removeListener($), V !== null && google.maps.event.removeListener(V), k && k(J), J.setMap(null);
    };
  }, []), null;
}
Me(SN);
class kN extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      rectangle: null
    }), ue(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Xl(Xl({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dt({
      updaterMap: fb,
      eventMap: pb,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: fb,
      eventMap: pb,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), ft(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ue(kN, "contextType", Ye);
function hb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hb(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gb = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, mb = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, MN = {};
function AN(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onCenterChanged: w,
    onRadiusChanged: k,
    onLoad: E,
    onUnmount: v
  } = e, O = Oe(Ye), [L, W] = P(null), [D, N] = P(null), [_, R] = P(null), [U, z] = P(null), [q, K] = P(null), [X, ne] = P(null), [Q, S] = P(null), [I, Z] = P(null), [T, Y] = P(null), [x, M] = P(null), [$, B] = P(null), [V, F] = P(null), [J, G] = P(null), [fe, be] = P(null);
  return y(() => {
    L !== null && L.setMap(O);
  }, [O]), y(() => {
    typeof t < "u" && L !== null && L.setOptions(t);
  }, [L, t]), y(() => {
    typeof o < "u" && L !== null && L.setDraggable(o);
  }, [L, o]), y(() => {
    typeof i < "u" && L !== null && L.setEditable(i);
  }, [L, i]), y(() => {
    typeof s < "u" && L !== null && L.setVisible(s);
  }, [L, s]), y(() => {
    typeof r == "number" && L !== null && L.setRadius(r);
  }, [L, r]), y(() => {
    typeof n < "u" && L !== null && L.setCenter(n);
  }, [L, n]), y(() => {
    L && a && (D !== null && google.maps.event.removeListener(D), N(google.maps.event.addListener(L, "dblclick", a)));
  }, [a]), y(() => {
    L && l && (_ !== null && google.maps.event.removeListener(_), R(google.maps.event.addListener(L, "dragend", l)));
  }, [l]), y(() => {
    L && u && (U !== null && google.maps.event.removeListener(U), z(google.maps.event.addListener(L, "dragstart", u)));
  }, [u]), y(() => {
    L && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(L, "mousedown", c)));
  }, [c]), y(() => {
    L && d && (X !== null && google.maps.event.removeListener(X), ne(google.maps.event.addListener(L, "mousemove", d)));
  }, [d]), y(() => {
    L && p && (Q !== null && google.maps.event.removeListener(Q), S(google.maps.event.addListener(L, "mouseout", p)));
  }, [p]), y(() => {
    L && m && (I !== null && google.maps.event.removeListener(I), Z(google.maps.event.addListener(L, "mouseover", m)));
  }, [m]), y(() => {
    L && f && (T !== null && google.maps.event.removeListener(T), Y(google.maps.event.addListener(L, "mouseup", f)));
  }, [f]), y(() => {
    L && g && (x !== null && google.maps.event.removeListener(x), M(google.maps.event.addListener(L, "rightclick", g)));
  }, [g]), y(() => {
    L && h && ($ !== null && google.maps.event.removeListener($), B(google.maps.event.addListener(L, "click", h)));
  }, [h]), y(() => {
    L && C && (V !== null && google.maps.event.removeListener(V), F(google.maps.event.addListener(L, "drag", C)));
  }, [C]), y(() => {
    L && w && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(L, "center_changed", w)));
  }, [h]), y(() => {
    L && k && (fe !== null && google.maps.event.removeListener(fe), be(google.maps.event.addListener(L, "radius_changed", k)));
  }, [k]), y(() => {
    var re = new google.maps.Circle(Kl(Kl({}, t || MN), {}, {
      map: O
    }));
    return typeof r == "number" && re.setRadius(r), typeof n < "u" && re.setCenter(n), typeof r == "number" && re.setRadius(r), typeof s < "u" && re.setVisible(s), typeof i < "u" && re.setEditable(i), typeof o < "u" && re.setDraggable(o), a && N(google.maps.event.addListener(re, "dblclick", a)), l && R(google.maps.event.addListener(re, "dragend", l)), u && z(google.maps.event.addListener(re, "dragstart", u)), c && K(google.maps.event.addListener(re, "mousedown", c)), d && ne(google.maps.event.addListener(re, "mousemove", d)), p && S(google.maps.event.addListener(re, "mouseout", p)), m && Z(google.maps.event.addListener(re, "mouseover", m)), f && Y(google.maps.event.addListener(re, "mouseup", f)), g && M(google.maps.event.addListener(re, "rightclick", g)), h && B(google.maps.event.addListener(re, "click", h)), C && F(google.maps.event.addListener(re, "drag", C)), w && G(google.maps.event.addListener(re, "center_changed", w)), k && be(google.maps.event.addListener(re, "radius_changed", k)), W(re), E && E(re), () => {
      D !== null && google.maps.event.removeListener(D), _ !== null && google.maps.event.removeListener(_), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), x !== null && google.maps.event.removeListener(x), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), fe !== null && google.maps.event.removeListener(fe), v && v(re), re.setMap(null);
    };
  }, []), null;
}
Me(AN);
class TN extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      circle: null
    }), ue(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Kl(Kl({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dt({
      updaterMap: mb,
      eventMap: gb,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: mb,
      eventMap: gb,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), ft(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ue(TN, "contextType", Ye);
function vb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Jl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vb(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yb = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, bb = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function BN(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: d,
    onRemoveProperty: p,
    onSetGeometry: m,
    onSetProperty: f,
    onLoad: g,
    onUnmount: h
  } = e, C = Oe(Ye), [w, k] = P(null), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null), [N, _] = P(null), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null), [Z, T] = P(null), [Y, x] = P(null), [M, $] = P(null), [B, V] = P(null);
  return y(() => {
    w !== null && w.setMap(C);
  }, [C]), y(() => {
    w && r && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), y(() => {
    w && o && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), y(() => {
    w && i && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), y(() => {
    w && s && (N !== null && google.maps.event.removeListener(N), _(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), y(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), y(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), y(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), y(() => {
    w && n && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(w, "click", n)));
  }, [n]), y(() => {
    w && c && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), y(() => {
    w && d && (Z !== null && google.maps.event.removeListener(Z), T(google.maps.event.addListener(w, "removefeature", d)));
  }, [d]), y(() => {
    w && p && (Y !== null && google.maps.event.removeListener(Y), x(google.maps.event.addListener(w, "removeproperty", p)));
  }, [p]), y(() => {
    w && m && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(w, "setgeometry", m)));
  }, [m]), y(() => {
    w && f && (B !== null && google.maps.event.removeListener(B), V(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), y(() => {
    if (C !== null) {
      var F = new google.maps.Data(Jl(Jl({}, t), {}, {
        map: C
      }));
      r && v(google.maps.event.addListener(F, "dblclick", r)), o && L(google.maps.event.addListener(F, "mousedown", o)), i && D(google.maps.event.addListener(F, "mousemove", i)), s && _(google.maps.event.addListener(F, "mouseout", s)), a && U(google.maps.event.addListener(F, "mouseover", a)), l && q(google.maps.event.addListener(F, "mouseup", l)), u && X(google.maps.event.addListener(F, "rightclick", u)), n && Q(google.maps.event.addListener(F, "click", n)), c && I(google.maps.event.addListener(F, "addfeature", c)), d && T(google.maps.event.addListener(F, "removefeature", d)), p && x(google.maps.event.addListener(F, "removeproperty", p)), m && $(google.maps.event.addListener(F, "setgeometry", m)), f && V(google.maps.event.addListener(F, "setproperty", f)), k(F), g && g(F);
    }
    return () => {
      w && (E !== null && google.maps.event.removeListener(E), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), N !== null && google.maps.event.removeListener(N), R !== null && google.maps.event.removeListener(R), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), ne !== null && google.maps.event.removeListener(ne), S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), B !== null && google.maps.event.removeListener(B), h && h(w), w.setMap(null));
    };
  }, []), null;
}
Me(BN);
class jN extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      data: null
    }), ue(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Jl(Jl({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = dt({
        updaterMap: bb,
        eventMap: yb,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: bb,
      eventMap: yb,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), ft(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ue(jN, "contextType", Ye);
function wb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wb(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Eb = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Ob = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class _N extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      kmlLayer: null
    }), ue(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(Cb(Cb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dt({
      updaterMap: Ob,
      eventMap: Eb,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: Ob,
      eventMap: Eb,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), ft(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ue(_N, "contextType", Ye);
function aD(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function IN(e, t) {
  return new t(e.lat, e.lng);
}
function FN(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function RN(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function NN(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function zN(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function $N(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function lD(e, t, n, r) {
  return n !== void 0 ? zN(e, t, NN(n, google.maps.LatLngBounds, FN)) : $N(e, t, RN(r, google.maps.LatLng, IN));
}
function UN(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function xb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function WN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xb(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function VN(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = WN({}, this.container ? aD(this.container, o) : {
        x: 0,
        y: 0
      }), u = lD(a, l, this.bounds, this.position);
      for (var [c, d] of Object.entries(u))
        this.container.style[c] = d;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function Db(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Db(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Db(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Lb(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function Pb(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function qN(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = Oe(Ye), c = Mn(() => {
    var p = document.createElement("div");
    return p.style.position = "absolute", p;
  }, []), d = Mn(() => VN(c, r, t, n, a), [c, r, t, n]);
  return y(() => (i == null || i(d), d == null || d.setMap(u), () => {
    s == null || s(d), d == null || d.setMap(null);
  }), [u, d]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), xi.createPortal(l, c);
}
Me(qN);
class ki extends Ee {
  constructor(t) {
    super(t), ue(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ue(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      On(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ue(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ue(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = HN({
        x: 0,
        y: 0
      }, this.containerRef.current ? aD(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = lD(r, o, this.props.bounds, this.props.position);
      if (!UN(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ue(this, "draw", () => {
      this.onPositionElement();
    }), ue(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = mr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = Lb(t.position), r = Lb(this.props.position), o = Pb(t.bounds), i = Pb(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? xi.createPortal(Zn.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: Ft.only(this.props.children)
    }), t) : null;
  }
}
ue(ki, "FLOAT_PANE", "floatPane");
ue(ki, "MAP_PANE", "mapPane");
ue(ki, "MARKER_LAYER", "markerLayer");
ue(ki, "OVERLAY_LAYER", "overlayLayer");
ue(ki, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ue(ki, "contextType", Ye);
function GN() {
}
function Sb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kb(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sb(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Mb = {
  onDblClick: "dblclick",
  onClick: "click"
}, Ab = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function ZN(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = Oe(Ye), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Mn(() => new google.maps.GroundOverlay(t, s, r), []);
  return y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), y(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Me(ZN);
class uD extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      groundOverlay: null
    }), ue(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    On(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, kb(kb({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dt({
      updaterMap: Ab,
      eventMap: Mb,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: Ab,
      eventMap: Mb,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ue(uD, "defaultProps", {
  onLoad: GN
});
ue(uD, "contextType", Ye);
function Tb(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ql(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Tb(Object(n), !0).forEach(function(r) {
      ue(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tb(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bb = {}, jb = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function YN(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = Oe(Ye), [s, a] = P(null);
  return y(() => {
    google.maps.visualization || On(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    On(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer(Ql(Ql({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Me(YN);
class XN extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      heatmapLayer: null
    }), ue(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    On(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), On(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Ql(Ql({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = dt({
      updaterMap: jb,
      eventMap: Bb,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: jb,
      eventMap: Bb,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), ft(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ue(XN, "contextType", Ye);
var _b = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, Ib = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class KN extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      streetViewPanorama: null
    }), ue(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = dt({
      updaterMap: Ib,
      eventMap: _b,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: Ib,
      eventMap: _b,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), ft(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ue(KN, "contextType", Ye);
class JN extends Ee {
  constructor() {
    super(...arguments), ue(this, "state", {
      streetViewService: null
    }), ue(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ue(JN, "contextType", Ye);
var Fb = {
  onDirectionsChanged: "directions_changed"
}, Rb = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class QN extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "state", {
      directionsRenderer: null
    }), ue(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = dt({
      updaterMap: Rb,
      eventMap: Fb,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: Rb,
      eventMap: Fb,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), ft(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ue(QN, "contextType", Ye);
var Nb = {
  onPlacesChanged: "places_changed"
}, zb = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class e2 extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "containerElement", mr()), ue(this, "state", {
      searchBox: null
    }), ue(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (On(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = dt({
          updaterMap: zb,
          eventMap: Nb,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: zb,
      eventMap: Nb,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), ft(this.registeredEvents));
  }
  render() {
    return Zn.jsx("div", {
      ref: this.containerElement,
      children: Ft.only(this.props.children)
    });
  }
}
ue(e2, "contextType", Ye);
var $b = {
  onPlaceChanged: "place_changed"
}, Ub = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class cD extends Ee {
  constructor() {
    super(...arguments), ue(this, "registeredEvents", []), ue(this, "containerElement", mr()), ue(this, "state", {
      autocomplete: null
    }), ue(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    On(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = dt({
        updaterMap: Ub,
        eventMap: $b,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    ft(this.registeredEvents), this.registeredEvents = dt({
      updaterMap: Ub,
      eventMap: $b,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && ft(this.registeredEvents);
  }
  render() {
    return Zn.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: Ft.only(this.props.children)
    });
  }
}
ue(cD, "defaultProps", {
  className: ""
});
ue(cD, "contextType", Ye);
let t2 = { data: "" }, n2 = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || t2, r2 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, o2 = /\/\*[^]*?\*\/|  +/g, Wb = /\n+/g, ho = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? ho(s, i) : i + "{" + ho(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += ho(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ho.p ? ho.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Fr = {}, dD = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + dD(e[n]);
    return t;
  }
  return e;
}, i2 = (e, t, n, r, o) => {
  let i = dD(e), s = Fr[i] || (Fr[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Fr[s]) {
    let l = i !== e ? e : ((u) => {
      let c, d, p = [{}];
      for (; c = r2.exec(u.replace(o2, "")); ) c[4] ? p.shift() : c[3] ? (d = c[3].replace(Wb, " ").trim(), p.unshift(p[0][d] = p[0][d] || {})) : p[0][c[1]] = c[2].replace(Wb, " ").trim();
      return p[0];
    })(e);
    Fr[s] = ho(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Fr.g ? Fr.g : null;
  return n && (Fr.g = Fr[s]), ((l, u, c, d) => {
    d ? u.data = u.data.replace(d, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Fr[s], t, r, a), s;
}, s2 = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : ho(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function mc(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return i2(n.unshift ? n.raw ? s2(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, n2(t.target), t.g, t.o, t.k);
}
let pD, Zp, Yp;
mc.bind({ g: 1 });
let Vr = mc.bind({ k: 1 });
function a2(e, t, n, r) {
  ho.p = t, pD = e, Zp = n, Yp = r;
}
function Po(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: Zp && Zp() }, a), n.o = / *go\d+/.test(l), a.className = mc.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Yp && u[0] && Yp(a), pD(u, a);
    }
    return o;
  };
}
var l2 = (e) => typeof e == "function", u2 = (e, t) => l2(e) ? e(t) : e, c2 = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), d2 = Vr`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, p2 = Vr`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, f2 = Vr`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, h2 = Po("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${d2} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${p2} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${f2} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, g2 = Vr`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, m2 = Po("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${g2} 1s linear infinite;
`, v2 = Vr`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, y2 = Vr`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, b2 = Po("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${v2} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${y2} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, w2 = Po("div")`
  position: absolute;
`, C2 = Po("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, E2 = Vr`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, O2 = Po("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${E2} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, x2 = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ve.createElement(O2, null, t) : t : n === "blank" ? null : Ve.createElement(C2, null, Ve.createElement(m2, { ...r }), n !== "loading" && Ve.createElement(w2, null, n === "error" ? Ve.createElement(h2, { ...r }) : Ve.createElement(b2, { ...r })));
}, D2 = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, L2 = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, P2 = "0%{opacity:0;} 100%{opacity:1;}", S2 = "0%{opacity:1;} 100%{opacity:0;}", k2 = Po("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, M2 = Po("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, A2 = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = c2() ? [P2, S2] : [D2(n), L2(n)];
  return { animation: t ? `${Vr(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Vr(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ve.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? A2(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ve.createElement(x2, { toast: e }), s = Ve.createElement(M2, { ...e.ariaProps }, u2(e.message, e));
  return Ve.createElement(k2, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ve.createElement(Ve.Fragment, null, i, s));
});
a2(Ve.createElement);
mc`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function fD(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    disabled: l,
    className: u = "",
    children: c,
    ...d
  } = e, p = { xs: 12, sm: 16, md: 20, lg: 24 }[i], m = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ At.jsxs("button", { className: m, disabled: l || t, ...d, children: [
    /* @__PURE__ */ At.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ At.jsx(Mr, { size: p, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ At.jsxs("div", { className: "arkynButtonContent", children: [
      Sm(p, s),
      c,
      Sm(p, a)
    ] })
  ] });
}
function T2() {
  const e = Pf(), t = RE(), n = NE(), [r, o] = P(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function s() {
    r && o(null);
  }
  y(() => {
    var u, c;
    let d = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, d) || Object.entries(d).length !== 0 && o(d);
  }, [n, e]), y(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && s();
  }, [n, t]);
  const a = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(a || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
Ze({});
function B2(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: s,
    className: a = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${a}`;
  return /* @__PURE__ */ At.jsxs(
    "button",
    {
      disabled: s || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ At.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ At.jsx(Mr, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ At.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ At.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function j2(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...s
  } = e, a = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ At.jsxs("div", { className: a.trim(), ...s, children: [
    r,
    /* @__PURE__ */ At.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function _2(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const I2 = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
_2(I2.CNPJ).length;
Hs((e, t) => /* @__PURE__ */ At.jsx("input", { ref: t, ...e }));
Ze({});
var Zr = {};
Object.defineProperty(Zr, "__esModule", {
  value: !0
});
var F2 = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), vd = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, hD = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: F2 ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, Rh = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var $a = 1; $a < 20; $a++)
  Rh["f" + $a] = 111 + $a;
function vc(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return gD(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return mD(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function R2(e, t) {
  return vc(e, t);
}
function N2(e, t) {
  return vc(e, { byKey: !0 }, t);
}
function gD(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in vd)
    r[vd[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), d; !(a = (d = c.next()).done); a = !0) {
      var p = d.value, m = p.endsWith("?") && p.length > 1;
      m && (p = p.slice(0, -1));
      var f = Nh(p), g = vd[f];
      if (p.length > 1 && !g && !hD[p] && !Rh[f])
        throw new TypeError('Unknown modifier: "' + p + '"');
      (i === 1 || !g) && (n ? r.key = f : r.which = vD(p)), g && (r[g] = m ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function mD(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function vD(e) {
  e = Nh(e);
  var t = Rh[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function Nh(e) {
  return e = e.toLowerCase(), e = hD[e] || e, e;
}
Zr.default = vc;
var yd = Zr.isHotkey = vc;
Zr.isCodeHotkey = R2;
Zr.isKeyHotkey = N2;
Zr.parseHotkey = gD;
Zr.compareHotkey = mD;
Zr.toKeyCode = vD;
Zr.toKeyName = Nh;
var z2 = typeof _t == "object" && _t && _t.Object === Object && _t, $2 = z2, U2 = $2, W2 = typeof self == "object" && self && self.Object === Object && self, V2 = U2 || W2 || Function("return this")(), H2 = V2, q2 = H2, G2 = q2.Symbol, yD = G2, Vb = yD;
Vb && Vb.toStringTag;
var Hb = yD;
Hb && Hb.toStringTag;
var qb;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(qb || (qb = {}));
var zh = function(e) {
  return Object.freeze(e);
}, Z2 = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, zh(this);
  }
  return e;
}(), Y2 = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, zh(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), Gb = typeof window < "u" ? window : {};
/msie|trident/i.test(Gb.navigator && Gb.navigator.userAgent);
var bd = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new Z2((n ? t : e) || 0, (n ? e : t) || 0);
};
zh({
  devicePixelContentBoxSize: bd(),
  borderBoxSize: bd(),
  contentBoxSize: bd(),
  contentRect: new Y2(0, 0, 0, 0)
});
function Rs(e) {
  "@babel/helpers - typeof";
  return Rs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Rs(e);
}
function X2(e, t) {
  if (Rs(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Rs(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function K2(e) {
  var t = X2(e, "string");
  return Rs(t) === "symbol" ? t : String(t);
}
function ys(e, t, n) {
  return t = K2(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var J2 = /* @__PURE__ */ Ze(null), wd, Cd;
parseInt(Ce.version.split(".")[0], 10);
var Zb = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Ed = typeof navigator < "u" && /Android/.test(navigator.userAgent), Ua = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Q2 = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (wd = navigator.userAgent.match(/Version\/(\d+)/)) !== null && wd !== void 0 && wd[1] && parseInt((Cd = navigator.userAgent.match(/Version\/(\d+)/)) === null || Cd === void 0 ? void 0 : Cd[1], 10) < 17;
var ez = /* @__PURE__ */ new WeakMap(), tz = /* @__PURE__ */ new WeakMap(), nz = /* @__PURE__ */ new WeakMap(), rz = /* @__PURE__ */ new WeakMap(), oz = /* @__PURE__ */ new WeakMap(), Yb = /* @__PURE__ */ new WeakMap(), iz = /* @__PURE__ */ new WeakMap(), Xb = /* @__PURE__ */ new WeakMap(), Wa = /* @__PURE__ */ new WeakMap(), sz = /* @__PURE__ */ new WeakMap(), az = /* @__PURE__ */ new WeakMap(), lz = /* @__PURE__ */ new WeakMap(), bD = globalThis.Node, uz = globalThis.Text, wD = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, cz = (e) => eu(e) && e.nodeType === 8, kr = (e) => eu(e) && e.nodeType === 1, eu = (e) => {
  var t = wD(e);
  return !!t && e instanceof t.Node;
}, Kb = (e) => {
  var t = e && e.anchorNode && wD(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, dz = (e) => {
  var [t, n] = e;
  if (kr(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = CD(t, o, r ? "backward" : "forward"), r = o < n; kr(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = fz(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, pz = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, CD = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (cz(o) || kr(o) && o.childNodes.length === 0 || kr(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, fz = (e, t, n) => {
  var [r] = CD(e, t, n);
  return r;
}, Jb = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), ED = (e, t, n) => {
  var {
    target: r
  } = t;
  if (kr(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = ct.getWindow(e);
  if (o.contains(r))
    return ct.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : ED(e, i, n);
}, Qb = (e, t) => !!(e.compareDocumentPosition(t) & bD.DOCUMENT_POSITION_PRECEDING), hz = (e, t) => !!(e.compareDocumentPosition(t) & bD.DOCUMENT_POSITION_FOLLOWING), gz = 0;
class mz {
  constructor() {
    ys(this, "id", void 0), this.id = "".concat(gz++);
  }
}
var ct = {
  androidPendingDiffs: (e) => lz.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = az.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = ct.toDOMNode(e, e), n = ct.findDocumentOrShadowRoot(e);
    Wa.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = ct.findDocumentOrShadowRoot(e), r = Jb(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Il.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = ct.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = ct.toSlateNode(e, t.target), s = ct.findPath(e, i);
    if (zr.isElement(i) && Tt.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = Tt.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? Tt.before(e, u) : Tt.after(e, u);
      if (c) {
        var d = Tt.range(e, c);
        return d;
      }
    }
    var p, {
      document: m
    } = ct.getWindow(e);
    if (m.caretRangeFromPoint)
      p = m.caretRangeFromPoint(n, r);
    else {
      var f = m.caretPositionFromPoint(n, r);
      f && (p = m.createRange(), p.setStart(f.offsetNode, f.offset), p.setEnd(f.offsetNode, f.offset));
    }
    if (!p)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var g = ct.toSlateRange(e, p, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (e, t) => {
    var n = Yb.get(t);
    return n || (n = new mz(), Yb.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = tz.get(r);
      if (o == null) {
        if (Tt.isEditor(r))
          return n;
        break;
      }
      var i = ez.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Qn.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Wa.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          ct.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = ct.toDOMNode(e, e), r = ct.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = Jb(r), i = ct.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Il.select(e, Tt.start(e, [])), Wa.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = nz.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = ct.toDOMNode(e, e), i;
    try {
      i = kr(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => eu(t) && ct.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Tt.hasPath(e, n.path) && Tt.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => ct.hasEditableTarget(e, t) || ct.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => eu(t) && ct.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!sz.get(e),
  isFocused: (e) => !!Wa.get(e),
  isReadOnly: (e) => !!Xb.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (Xb.get(e)) return !1;
    var n = ct.hasTarget(e, t) && ct.toSlateNode(e, t);
    return zr.isElement(n) && Tt.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = iz.get(e), r = Tt.isEditor(t) ? rz.get(e) : n == null ? void 0 : n.get(ct.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Qn.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Tt.node(e, t.path), r = ct.toDOMNode(e, n), o;
    Tt.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: d
        } = c.textContent, p = u.getAttribute("data-slate-length"), m = p == null ? d : parseInt(p, 10), f = a + m, g = s[l + 1];
        if (t.offset === f && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var h, C = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            C instanceof uz ? C : g,
            (h = g.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(d, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Qn.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Qe.isBackward(t), i = ct.toDOMPoint(e, n), s = Qe.isCollapsed(t) ? i : ct.toDOMPoint(e, r), a = ct.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [d, p] = o ? i : s, m = kr(u) ? u : u.parentElement, f = !!m.getAttribute("data-slate-zero-width"), g = kr(d) ? d : d.parentElement, h = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(d, h ? 1 : p), l;
  },
  toSlateNode: (e, t) => {
    var n = kr(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? oz.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : dz(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var d, p, m = ct.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), g = f && m.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), C = h && m.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), k = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var E = ct.getWindow(e), v = E.document.createRange();
          v.setStart(u, 0), v.setEnd(s, a);
          var O = v.cloneContents(), L = [...Array.prototype.slice.call(O.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(O.querySelectorAll("[contenteditable=false]"))];
          L.forEach((T) => {
            if (Ed && !r && T.hasAttribute("data-slate-zero-width") && T.textContent.length > 0 && T.textContext !== "\uFEFF") {
              T.textContent.startsWith("\uFEFF") && (T.textContent = T.textContent.slice(1));
              return;
            }
            T.parentNode.removeChild(T);
          }), c = O.textContent.length, k = u;
        }
      } else if (g) {
        for (var W = g.querySelectorAll("[data-slate-leaf]"), D = 0; D < W.length; D++) {
          var N = W[D];
          if (ct.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), k = w, c = k.textContent.length, k.querySelectorAll("[data-slate-zero-width]").forEach((T) => {
          c -= T.textContent.length;
        })) : c = 1;
      } else if (C) {
        var _ = (T) => T ? T.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], R = C.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var U, z = [..._(R), ..._(R == null ? void 0 : R.nextElementSibling)];
          w = (U = z.find((T) => hz(C, T))) !== null && U !== void 0 ? U : null;
        } else {
          var q, K = [..._(R == null ? void 0 : R.previousElementSibling), ..._(R)];
          w = (q = K.findLast((T) => Qb(C, T))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), k = w, i === "forward" ? c = 0 : (c = k.textContent.length, k.querySelectorAll("[data-slate-zero-width]").forEach((T) => {
          c -= T.textContent.length;
        })));
      }
      k && c === k.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Ed && k.getAttribute("data-slate-zero-width") === "z" && (d = k.textContent) !== null && d !== void 0 && d.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Ua && (p = k.textContent) !== null && p !== void 0 && p.endsWith(`

`)) && c--;
    }
    if (Ed && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && ct.hasDOMNode(e, X, {
        editable: !0
      })) {
        var ne = ct.toSlateNode(e, X), {
          path: Q,
          offset: S
        } = Tt.start(e, ct.findPath(e, ne));
        return X.querySelector("[data-slate-leaf]") || (S = a), {
          path: Q,
          offset: S
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var I = ct.toSlateNode(e, u), Z = ct.findPath(e, I);
    return {
      path: Z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = Kb(t) ? t.anchorNode : t.startContainer, a, l, u, c, d;
    if (s)
      if (Kb(t)) {
        if (Ua && t.rangeCount > 1) {
          u = t.focusNode;
          var p = t.getRangeAt(0), m = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && p.startContainer instanceof HTMLTableRowElement && m.startContainer instanceof HTMLTableRowElement) {
            let O = function(L) {
              return L.childElementCount > 0 ? O(L.children[0]) : L;
            };
            var f = p.startContainer, g = m.startContainer, h = O(f.children[p.startOffset]), C = O(g.children[m.startOffset]);
            c = 0, C.childNodes.length > 0 ? a = C.childNodes[0] : a = C, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, C instanceof HTMLElement ? l = C.innerHTML.length : l = 0;
          } else
            p.startContainer === u ? (a = m.endContainer, l = m.endOffset, c = p.startOffset) : (a = p.startContainer, l = p.endOffset, c = m.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Q2 && pz(a) || Ua ? d = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : d = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, d = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Ua && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = ct.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var k = Qb(a, u) || a === u && c < l, E = d ? w : ct.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: k ? "forward" : "backward"
    });
    if (!E)
      return null;
    var v = {
      anchor: w,
      focus: E
    };
    return Qe.isExpanded(v) && Qe.isForward(v) && kr(u) && Tt.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = Tt.unhangRange(e, v, {
      voids: !0
    })), v;
  }
}, vz = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, yz = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, bz = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Xt = (e) => {
  var t = vz[e], n = yz[e], r = bz[e], o = t && yd(t), i = n && yd(n), s = r && yd(r);
  return (a) => !!(o && o(a) || Zb && i && i(a) || !Zb && s && s(a));
};
Xt("bold"), Xt("compose"), Xt("moveBackward"), Xt("moveForward"), Xt("deleteBackward"), Xt("deleteForward"), Xt("deleteLineBackward"), Xt("deleteLineForward"), Xt("deleteWordBackward"), Xt("deleteWordForward"), Xt("extendBackward"), Xt("extendForward"), Xt("extendLineBackward"), Xt("extendLineForward"), Xt("italic"), Xt("moveLineBackward"), Xt("moveLineForward"), Xt("moveWordBackward"), Xt("moveWordForward"), Xt("redo"), Xt("insertSoftBreak"), Xt("splitBlock"), Xt("transposeCharacter"), Xt("undo");
var wz = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => ED(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, Cz = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class Ez extends xf {
  constructor() {
    super(...arguments), ys(this, "context", null), ys(this, "manager", null), ys(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, Cz);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = wz(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
ys(Ez, "contextType", J2);
Ze({});
Ze({});
Ze({});
var gn = {}, $h = {}, Qs = {}, ea = {}, OD = "Expected a function", e0 = NaN, Oz = "[object Symbol]", xz = /^\s+|\s+$/g, Dz = /^[-+]0x[0-9a-f]+$/i, Lz = /^0b[01]+$/i, Pz = /^0o[0-7]+$/i, Sz = parseInt, kz = typeof _t == "object" && _t && _t.Object === Object && _t, Mz = typeof self == "object" && self && self.Object === Object && self, Az = kz || Mz || Function("return this")(), Tz = Object.prototype, Bz = Tz.toString, jz = Math.max, _z = Math.min, Od = function() {
  return Az.Date.now();
};
function Iz(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, d = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError(OD);
  t = t0(t) || 0, tu(n) && (c = !!n.leading, d = "maxWait" in n, i = d ? jz(t0(n.maxWait) || 0, t) : i, p = "trailing" in n ? !!n.trailing : p);
  function m(O) {
    var L = r, W = o;
    return r = o = void 0, u = O, s = e.apply(W, L), s;
  }
  function f(O) {
    return u = O, a = setTimeout(C, t), c ? m(O) : s;
  }
  function g(O) {
    var L = O - l, W = O - u, D = t - L;
    return d ? _z(D, i - W) : D;
  }
  function h(O) {
    var L = O - l, W = O - u;
    return l === void 0 || L >= t || L < 0 || d && W >= i;
  }
  function C() {
    var O = Od();
    if (h(O))
      return w(O);
    a = setTimeout(C, g(O));
  }
  function w(O) {
    return a = void 0, p && r ? m(O) : (r = o = void 0, s);
  }
  function k() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(Od());
  }
  function v() {
    var O = Od(), L = h(O);
    if (r = arguments, o = this, l = O, L) {
      if (a === void 0)
        return f(l);
      if (d)
        return a = setTimeout(C, t), m(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = k, v.flush = E, v;
}
function Fz(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(OD);
  return tu(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Iz(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function tu(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function Rz(e) {
  return !!e && typeof e == "object";
}
function Nz(e) {
  return typeof e == "symbol" || Rz(e) && Bz.call(e) == Oz;
}
function t0(e) {
  if (typeof e == "number")
    return e;
  if (Nz(e))
    return e0;
  if (tu(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = tu(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(xz, "");
  var n = Lz.test(e);
  return n || Pz.test(e) ? Sz(e.slice(2), n ? 2 : 8) : Dz.test(e) ? e0 : +e;
}
var zz = Fz, ta = {};
Object.defineProperty(ta, "__esModule", {
  value: !0
});
ta.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), vl.has(t) || vl.set(t, /* @__PURE__ */ new Set());
  var o = vl.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
ta.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), vl.get(t).delete(n.name || t);
};
var vl = /* @__PURE__ */ new Map();
Object.defineProperty(ea, "__esModule", {
  value: !0
});
var $z = zz, Uz = Vz($z), Wz = ta;
function Vz(e) {
  return e && e.__esModule ? e : { default: e };
}
var Hz = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Uz.default)(e, t);
}, sn = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = Hz(function(r) {
        sn.scrollHandler(e);
      }, t);
      sn.scrollSpyContainers.push(e), (0, Wz.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return sn.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = sn.scrollSpyContainers[sn.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(sn.currentPositionX(e), sn.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    sn.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = sn.scrollSpyContainers[sn.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(sn.currentPositionX(t), sn.currentPositionY(t));
  },
  updateStates: function() {
    sn.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    sn.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), sn.spySetState && sn.spySetState.length && sn.spySetState.indexOf(e) > -1 && sn.spySetState.splice(sn.spySetState.indexOf(e), 1), document.removeEventListener("scroll", sn.scrollHandler);
  },
  update: function() {
    return sn.scrollSpyContainers.forEach(function(e) {
      return sn.scrollHandler(e);
    });
  }
};
ea.default = sn;
var Mi = {}, na = {};
Object.defineProperty(na, "__esModule", {
  value: !0
});
var qz = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, Gz = function() {
  return window.location.hash.replace(/^#/, "");
}, Zz = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Yz = function(e) {
  return getComputedStyle(e).position !== "static";
}, xd = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Xz = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Yz(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = xd(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return xd(t, a).offsetTop - xd(e, a).offsetTop;
};
na.default = {
  updateHash: qz,
  getHash: Gz,
  filterElementInContainer: Zz,
  scrollOffset: Xz
};
var yc = {}, Uh = {};
Object.defineProperty(Uh, "__esModule", {
  value: !0
});
Uh.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Wh = {};
Object.defineProperty(Wh, "__esModule", {
  value: !0
});
var Kz = ta, Jz = ["mousedown", "mousewheel", "touchmove", "keydown"];
Wh.default = {
  subscribe: function(e) {
    return typeof document < "u" && Jz.forEach(function(t) {
      return (0, Kz.addPassiveEventListener)(document, t, e);
    });
  }
};
var ra = {};
Object.defineProperty(ra, "__esModule", {
  value: !0
});
var Xp = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Xp.registered[e] = t;
    },
    remove: function(e) {
      Xp.registered[e] = null;
    }
  }
};
ra.default = Xp;
Object.defineProperty(yc, "__esModule", {
  value: !0
});
var Qz = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, e$ = na;
bc(e$);
var t$ = Uh, n0 = bc(t$), n$ = Wh, r$ = bc(n$), o$ = ra, Lr = bc(o$);
function bc(e) {
  return e && e.__esModule ? e : { default: e };
}
var xD = function(e) {
  return n0.default[e.smooth] || n0.default.defaultEasing;
}, i$ = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, s$ = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Kp = function() {
  return s$() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), DD = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, LD = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, PD = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, a$ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, l$ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, u$ = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Lr.default.registered.end && Lr.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Kp.call(window, i);
    return;
  }
  Lr.default.registered.end && Lr.default.registered.end(o.to, o.target, o.currentPosition);
}, Vh = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, oa = function(e, t, n, r) {
  t.data = t.data || DD(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (r$.default.subscribe(o), Vh(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? LD(t) : PD(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Lr.default.registered.end && Lr.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = i$(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = xD(t), s = u$.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Lr.default.registered.begin && Lr.default.registered.begin(t.data.to, t.data.target), Kp.call(window, s);
    }, t.delay);
    return;
  }
  Lr.default.registered.begin && Lr.default.registered.begin(t.data.to, t.data.target), Kp.call(window, s);
}, wc = function(e) {
  return e = Qz({}, e), e.data = e.data || DD(), e.absolute = !0, e;
}, c$ = function(e) {
  oa(0, wc(e));
}, d$ = function(e, t) {
  oa(e, wc(t));
}, p$ = function(e) {
  e = wc(e), Vh(e), oa(e.horizontal ? a$(e) : l$(e), e);
}, f$ = function(e, t) {
  t = wc(t), Vh(t);
  var n = t.horizontal ? LD(t) : PD(t);
  oa(e + n, t);
};
yc.default = {
  animateTopScroll: oa,
  getAnimationType: xD,
  scrollToTop: c$,
  scrollToBottom: p$,
  scrollTo: d$,
  scrollMore: f$
};
Object.defineProperty(Mi, "__esModule", {
  value: !0
});
var h$ = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, g$ = na, m$ = Hh(g$), v$ = yc, y$ = Hh(v$), b$ = ra, Va = Hh(b$);
function Hh(e) {
  return e && e.__esModule ? e : { default: e };
}
var Ha = {}, r0 = void 0;
Mi.default = {
  unmount: function() {
    Ha = {};
  },
  register: function(e, t) {
    Ha[e] = t;
  },
  unregister: function(e) {
    delete Ha[e];
  },
  get: function(e) {
    return Ha[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return r0 = e;
  },
  getActiveLink: function() {
    return r0;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = h$({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = m$.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      Va.default.registered.begin && Va.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, Va.default.registered.end && Va.default.registered.end(e, n);
      return;
    }
    y$.default.animateTopScroll(a, t, e, n);
  }
};
var Jp = { exports: {} }, Dd = { exports: {} }, Ot = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var o0;
function w$() {
  if (o0) return Ot;
  o0 = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function k(v) {
    if (typeof v == "object" && v !== null) {
      var O = v.$$typeof;
      switch (O) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case c:
                case f:
                case m:
                case s:
                  return v;
                default:
                  return O;
              }
          }
        case n:
          return O;
      }
    }
  }
  function E(v) {
    return k(v) === u;
  }
  return Ot.AsyncMode = l, Ot.ConcurrentMode = u, Ot.ContextConsumer = a, Ot.ContextProvider = s, Ot.Element = t, Ot.ForwardRef = c, Ot.Fragment = r, Ot.Lazy = f, Ot.Memo = m, Ot.Portal = n, Ot.Profiler = i, Ot.StrictMode = o, Ot.Suspense = d, Ot.isAsyncMode = function(v) {
    return E(v) || k(v) === l;
  }, Ot.isConcurrentMode = E, Ot.isContextConsumer = function(v) {
    return k(v) === a;
  }, Ot.isContextProvider = function(v) {
    return k(v) === s;
  }, Ot.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, Ot.isForwardRef = function(v) {
    return k(v) === c;
  }, Ot.isFragment = function(v) {
    return k(v) === r;
  }, Ot.isLazy = function(v) {
    return k(v) === f;
  }, Ot.isMemo = function(v) {
    return k(v) === m;
  }, Ot.isPortal = function(v) {
    return k(v) === n;
  }, Ot.isProfiler = function(v) {
    return k(v) === i;
  }, Ot.isStrictMode = function(v) {
    return k(v) === o;
  }, Ot.isSuspense = function(v) {
    return k(v) === d;
  }, Ot.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === d || v === p || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === m || v.$$typeof === s || v.$$typeof === a || v.$$typeof === c || v.$$typeof === h || v.$$typeof === C || v.$$typeof === w || v.$$typeof === g);
  }, Ot.typeOf = k, Ot;
}
var Mt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var i0;
function C$() {
  return i0 || (i0 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function k(G) {
      return typeof G == "string" || typeof G == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      G === r || G === u || G === i || G === o || G === d || G === p || typeof G == "object" && G !== null && (G.$$typeof === f || G.$$typeof === m || G.$$typeof === s || G.$$typeof === a || G.$$typeof === c || G.$$typeof === h || G.$$typeof === C || G.$$typeof === w || G.$$typeof === g);
    }
    function E(G) {
      if (typeof G == "object" && G !== null) {
        var fe = G.$$typeof;
        switch (fe) {
          case t:
            var be = G.type;
            switch (be) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case d:
                return be;
              default:
                var re = be && be.$$typeof;
                switch (re) {
                  case a:
                  case c:
                  case f:
                  case m:
                  case s:
                    return re;
                  default:
                    return fe;
                }
            }
          case n:
            return fe;
        }
      }
    }
    var v = l, O = u, L = a, W = s, D = t, N = c, _ = r, R = f, U = m, z = n, q = i, K = o, X = d, ne = !1;
    function Q(G) {
      return ne || (ne = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), S(G) || E(G) === l;
    }
    function S(G) {
      return E(G) === u;
    }
    function I(G) {
      return E(G) === a;
    }
    function Z(G) {
      return E(G) === s;
    }
    function T(G) {
      return typeof G == "object" && G !== null && G.$$typeof === t;
    }
    function Y(G) {
      return E(G) === c;
    }
    function x(G) {
      return E(G) === r;
    }
    function M(G) {
      return E(G) === f;
    }
    function $(G) {
      return E(G) === m;
    }
    function B(G) {
      return E(G) === n;
    }
    function V(G) {
      return E(G) === i;
    }
    function F(G) {
      return E(G) === o;
    }
    function J(G) {
      return E(G) === d;
    }
    Mt.AsyncMode = v, Mt.ConcurrentMode = O, Mt.ContextConsumer = L, Mt.ContextProvider = W, Mt.Element = D, Mt.ForwardRef = N, Mt.Fragment = _, Mt.Lazy = R, Mt.Memo = U, Mt.Portal = z, Mt.Profiler = q, Mt.StrictMode = K, Mt.Suspense = X, Mt.isAsyncMode = Q, Mt.isConcurrentMode = S, Mt.isContextConsumer = I, Mt.isContextProvider = Z, Mt.isElement = T, Mt.isForwardRef = Y, Mt.isFragment = x, Mt.isLazy = M, Mt.isMemo = $, Mt.isPortal = B, Mt.isProfiler = V, Mt.isStrictMode = F, Mt.isSuspense = J, Mt.isValidElementType = k, Mt.typeOf = E;
  }()), Mt;
}
var s0;
function SD() {
  return s0 || (s0 = 1, process.env.NODE_ENV === "production" ? Dd.exports = w$() : Dd.exports = C$()), Dd.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Ld, a0;
function E$() {
  if (a0) return Ld;
  a0 = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Ld = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var d in a)
        t.call(a, d) && (l[d] = a[d]);
      if (e) {
        u = e(a);
        for (var p = 0; p < u.length; p++)
          n.call(a, u[p]) && (l[u[p]] = a[u[p]]);
      }
    }
    return l;
  }, Ld;
}
var Pd, l0;
function qh() {
  if (l0) return Pd;
  l0 = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Pd = e, Pd;
}
var u0, c0;
function kD() {
  return c0 || (c0 = 1, u0 = Function.call.bind(Object.prototype.hasOwnProperty)), u0;
}
var Sd, d0;
function O$() {
  if (d0) return Sd;
  d0 = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = qh(), n = {}, r = kD();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var d;
          try {
            if (typeof i[c] != "function") {
              var p = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = i[c](s, c, l, a, null, t);
          } catch (f) {
            d = f;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + a + " type: " + d.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Sd = o, Sd;
}
var kd, p0;
function x$() {
  if (p0) return kd;
  p0 = 1;
  var e = SD(), t = E$(), n = qh(), r = kD(), o = O$(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return kd = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(S) {
      var I = S && (u && S[u] || S[c]);
      if (typeof I == "function")
        return I;
    }
    var p = "<<anonymous>>", m = {
      array: C("array"),
      bigint: C("bigint"),
      bool: C("boolean"),
      func: C("function"),
      number: C("number"),
      object: C("object"),
      string: C("string"),
      symbol: C("symbol"),
      any: w(),
      arrayOf: k,
      element: E(),
      elementType: v(),
      instanceOf: O,
      node: N(),
      objectOf: W,
      oneOf: L,
      oneOfType: D,
      shape: R,
      exact: U
    };
    function f(S, I) {
      return S === I ? S !== 0 || 1 / S === 1 / I : S !== S && I !== I;
    }
    function g(S, I) {
      this.message = S, this.data = I && typeof I == "object" ? I : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function h(S) {
      if (process.env.NODE_ENV !== "production")
        var I = {}, Z = 0;
      function T(x, M, $, B, V, F, J) {
        if (B = B || p, F = F || $, J !== n) {
          if (l) {
            var G = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw G.name = "Invariant Violation", G;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var fe = B + ":" + $;
            !I[fe] && // Avoid spamming the console because they are often not actionable except for lib authors
            Z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + F + "` prop on `" + B + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), I[fe] = !0, Z++);
          }
        }
        return M[$] == null ? x ? M[$] === null ? new g("The " + V + " `" + F + "` is marked as required " + ("in `" + B + "`, but its value is `null`.")) : new g("The " + V + " `" + F + "` is marked as required in " + ("`" + B + "`, but its value is `undefined`.")) : null : S(M, $, B, V, F);
      }
      var Y = T.bind(null, !1);
      return Y.isRequired = T.bind(null, !0), Y;
    }
    function C(S) {
      function I(Z, T, Y, x, M, $) {
        var B = Z[T], V = K(B);
        if (V !== S) {
          var F = X(B);
          return new g(
            "Invalid " + x + " `" + M + "` of type " + ("`" + F + "` supplied to `" + Y + "`, expected ") + ("`" + S + "`."),
            { expectedType: S }
          );
        }
        return null;
      }
      return h(I);
    }
    function w() {
      return h(s);
    }
    function k(S) {
      function I(Z, T, Y, x, M) {
        if (typeof S != "function")
          return new g("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside arrayOf.");
        var $ = Z[T];
        if (!Array.isArray($)) {
          var B = K($);
          return new g("Invalid " + x + " `" + M + "` of type " + ("`" + B + "` supplied to `" + Y + "`, expected an array."));
        }
        for (var V = 0; V < $.length; V++) {
          var F = S($, V, Y, x, M + "[" + V + "]", n);
          if (F instanceof Error)
            return F;
        }
        return null;
      }
      return h(I);
    }
    function E() {
      function S(I, Z, T, Y, x) {
        var M = I[Z];
        if (!a(M)) {
          var $ = K(M);
          return new g("Invalid " + Y + " `" + x + "` of type " + ("`" + $ + "` supplied to `" + T + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(S);
    }
    function v() {
      function S(I, Z, T, Y, x) {
        var M = I[Z];
        if (!e.isValidElementType(M)) {
          var $ = K(M);
          return new g("Invalid " + Y + " `" + x + "` of type " + ("`" + $ + "` supplied to `" + T + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(S);
    }
    function O(S) {
      function I(Z, T, Y, x, M) {
        if (!(Z[T] instanceof S)) {
          var $ = S.name || p, B = Q(Z[T]);
          return new g("Invalid " + x + " `" + M + "` of type " + ("`" + B + "` supplied to `" + Y + "`, expected ") + ("instance of `" + $ + "`."));
        }
        return null;
      }
      return h(I);
    }
    function L(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function I(Z, T, Y, x, M) {
        for (var $ = Z[T], B = 0; B < S.length; B++)
          if (f($, S[B]))
            return null;
        var V = JSON.stringify(S, function(F, J) {
          var G = X(J);
          return G === "symbol" ? String(J) : J;
        });
        return new g("Invalid " + x + " `" + M + "` of value `" + String($) + "` " + ("supplied to `" + Y + "`, expected one of " + V + "."));
      }
      return h(I);
    }
    function W(S) {
      function I(Z, T, Y, x, M) {
        if (typeof S != "function")
          return new g("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside objectOf.");
        var $ = Z[T], B = K($);
        if (B !== "object")
          return new g("Invalid " + x + " `" + M + "` of type " + ("`" + B + "` supplied to `" + Y + "`, expected an object."));
        for (var V in $)
          if (r($, V)) {
            var F = S($, V, Y, x, M + "." + V, n);
            if (F instanceof Error)
              return F;
          }
        return null;
      }
      return h(I);
    }
    function D(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var I = 0; I < S.length; I++) {
        var Z = S[I];
        if (typeof Z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ne(Z) + " at index " + I + "."
          ), s;
      }
      function T(Y, x, M, $, B) {
        for (var V = [], F = 0; F < S.length; F++) {
          var J = S[F], G = J(Y, x, M, $, B, n);
          if (G == null)
            return null;
          G.data && r(G.data, "expectedType") && V.push(G.data.expectedType);
        }
        var fe = V.length > 0 ? ", expected one of type [" + V.join(", ") + "]" : "";
        return new g("Invalid " + $ + " `" + B + "` supplied to " + ("`" + M + "`" + fe + "."));
      }
      return h(T);
    }
    function N() {
      function S(I, Z, T, Y, x) {
        return z(I[Z]) ? null : new g("Invalid " + Y + " `" + x + "` supplied to " + ("`" + T + "`, expected a ReactNode."));
      }
      return h(S);
    }
    function _(S, I, Z, T, Y) {
      return new g(
        (S || "React class") + ": " + I + " type `" + Z + "." + T + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Y + "`."
      );
    }
    function R(S) {
      function I(Z, T, Y, x, M) {
        var $ = Z[T], B = K($);
        if (B !== "object")
          return new g("Invalid " + x + " `" + M + "` of type `" + B + "` " + ("supplied to `" + Y + "`, expected `object`."));
        for (var V in S) {
          var F = S[V];
          if (typeof F != "function")
            return _(Y, x, M, V, X(F));
          var J = F($, V, Y, x, M + "." + V, n);
          if (J)
            return J;
        }
        return null;
      }
      return h(I);
    }
    function U(S) {
      function I(Z, T, Y, x, M) {
        var $ = Z[T], B = K($);
        if (B !== "object")
          return new g("Invalid " + x + " `" + M + "` of type `" + B + "` " + ("supplied to `" + Y + "`, expected `object`."));
        var V = t({}, Z[T], S);
        for (var F in V) {
          var J = S[F];
          if (r(S, F) && typeof J != "function")
            return _(Y, x, M, F, X(J));
          if (!J)
            return new g(
              "Invalid " + x + " `" + M + "` key `" + F + "` supplied to `" + Y + "`.\nBad object: " + JSON.stringify(Z[T], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(S), null, "  ")
            );
          var G = J($, F, Y, x, M + "." + F, n);
          if (G)
            return G;
        }
        return null;
      }
      return h(I);
    }
    function z(S) {
      switch (typeof S) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !S;
        case "object":
          if (Array.isArray(S))
            return S.every(z);
          if (S === null || a(S))
            return !0;
          var I = d(S);
          if (I) {
            var Z = I.call(S), T;
            if (I !== S.entries) {
              for (; !(T = Z.next()).done; )
                if (!z(T.value))
                  return !1;
            } else
              for (; !(T = Z.next()).done; ) {
                var Y = T.value;
                if (Y && !z(Y[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(S, I) {
      return S === "symbol" ? !0 : I ? I["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && I instanceof Symbol : !1;
    }
    function K(S) {
      var I = typeof S;
      return Array.isArray(S) ? "array" : S instanceof RegExp ? "object" : q(I, S) ? "symbol" : I;
    }
    function X(S) {
      if (typeof S > "u" || S === null)
        return "" + S;
      var I = K(S);
      if (I === "object") {
        if (S instanceof Date)
          return "date";
        if (S instanceof RegExp)
          return "regexp";
      }
      return I;
    }
    function ne(S) {
      var I = X(S);
      switch (I) {
        case "array":
        case "object":
          return "an " + I;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + I;
        default:
          return I;
      }
    }
    function Q(S) {
      return !S.constructor || !S.constructor.name ? p : S.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, kd;
}
var Md, f0;
function D$() {
  if (f0) return Md;
  f0 = 1;
  var e = qh();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Md = function() {
    function r(s, a, l, u, c, d) {
      if (d !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Md;
}
if (process.env.NODE_ENV !== "production") {
  var L$ = SD(), P$ = !0;
  Jp.exports = x$()(L$.isElement, P$);
} else
  Jp.exports = D$()();
var Cc = Jp.exports, Ec = {};
Object.defineProperty(Ec, "__esModule", {
  value: !0
});
var S$ = na, Ad = k$(S$);
function k$(e) {
  return e && e.__esModule ? e : { default: e };
}
var M$ = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Ad.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Ad.default.getHash() !== e && Ad.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
Ec.default = M$;
Object.defineProperty(Qs, "__esModule", {
  value: !0
});
var qa = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, A$ = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), T$ = Ce, h0 = ia(T$), B$ = ea, Ga = ia(B$), j$ = Mi, _$ = ia(j$), I$ = Cc, Kt = ia(I$), F$ = Ec, eo = ia(F$);
function ia(e) {
  return e && e.__esModule ? e : { default: e };
}
function R$(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function N$(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function z$(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var g0 = {
  to: Kt.default.string.isRequired,
  containerId: Kt.default.string,
  container: Kt.default.object,
  activeClass: Kt.default.string,
  activeStyle: Kt.default.object,
  spy: Kt.default.bool,
  horizontal: Kt.default.bool,
  smooth: Kt.default.oneOfType([Kt.default.bool, Kt.default.string]),
  offset: Kt.default.number,
  delay: Kt.default.number,
  isDynamic: Kt.default.bool,
  onClick: Kt.default.func,
  duration: Kt.default.oneOfType([Kt.default.number, Kt.default.func]),
  absolute: Kt.default.bool,
  onSetActive: Kt.default.func,
  onSetInactive: Kt.default.func,
  ignoreCancelEvents: Kt.default.bool,
  hashSpy: Kt.default.bool,
  saveHashHistory: Kt.default.bool,
  spyThrottle: Kt.default.number
};
Qs.default = function(e, t) {
  var n = t || _$.default, r = function(i) {
    z$(s, i);
    function s(a) {
      R$(this, s);
      var l = N$(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return A$(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          Ga.default.isMounted(a) || Ga.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (eo.default.isMounted() || eo.default.mount(n), eo.default.mapContainer(this.props.to, a)), Ga.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Ga.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = qa({}, this.props.style, this.props.activeStyle) : l = qa({}, this.props.style);
        var u = qa({}, this.props);
        for (var c in g0)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, h0.default.createElement(e, u);
      }
    }]), s;
  }(h0.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, qa({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(eo.default.isMounted() && !eo.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, d = null, p = void 0, m = void 0;
        if (u) {
          var f = 0, g = 0, h = 0;
          if (l.getBoundingClientRect) {
            var C = l.getBoundingClientRect();
            h = C.left;
          }
          if (!d || i.props.isDynamic) {
            if (d = n.get(c), !d)
              return;
            var w = d.getBoundingClientRect();
            f = w.left - h + s, g = f + w.width;
          }
          var k = s - i.props.offset;
          p = k >= Math.floor(f) && k < Math.floor(g), m = k < Math.floor(f) || k >= Math.floor(g);
        } else {
          var E = 0, v = 0, O = 0;
          if (l.getBoundingClientRect) {
            var L = l.getBoundingClientRect();
            O = L.top;
          }
          if (!d || i.props.isDynamic) {
            if (d = n.get(c), !d)
              return;
            var W = d.getBoundingClientRect();
            E = W.top - O + a, v = E + W.height;
          }
          var D = a - i.props.offset;
          p = D >= Math.floor(E) && D < Math.floor(v), m = D < Math.floor(E) || D >= Math.floor(v);
        }
        var N = n.getActiveLink();
        if (m) {
          if (c === N && n.setActiveLink(void 0), i.props.hashSpy && eo.default.getHash() === c) {
            var _ = i.props.saveHashHistory, R = _ === void 0 ? !1 : _;
            eo.default.changeHash("", R);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, d));
        }
        if (p && (N !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var U = i.props.saveHashHistory, z = U === void 0 ? !1 : U;
          i.props.hashSpy && eo.default.changeHash(c, z), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, d));
        }
      }
    };
  };
  return r.propTypes = g0, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty($h, "__esModule", {
  value: !0
});
var $$ = Ce, m0 = MD($$), U$ = Qs, W$ = MD(U$);
function MD(e) {
  return e && e.__esModule ? e : { default: e };
}
function V$(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function v0(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function H$(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var q$ = function(e) {
  H$(t, e);
  function t() {
    var n, r, o, i;
    V$(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = v0(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return m0.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), v0(o, i);
  }
  return t;
}(m0.default.Component);
$h.default = (0, W$.default)(q$);
var Gh = {};
Object.defineProperty(Gh, "__esModule", {
  value: !0
});
var G$ = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Z$ = Ce, y0 = AD(Z$), Y$ = Qs, X$ = AD(Y$);
function AD(e) {
  return e && e.__esModule ? e : { default: e };
}
function K$(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function J$(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Q$(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var e3 = function(e) {
  Q$(t, e);
  function t() {
    return K$(this, t), J$(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return G$(t, [{
    key: "render",
    value: function() {
      return y0.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(y0.default.Component);
Gh.default = (0, X$.default)(e3);
var Zh = {}, Oc = {};
Object.defineProperty(Oc, "__esModule", {
  value: !0
});
var t3 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, n3 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), r3 = Ce, b0 = xc(r3), o3 = xu;
xc(o3);
var i3 = Mi, w0 = xc(i3), s3 = Cc, C0 = xc(s3);
function xc(e) {
  return e && e.__esModule ? e : { default: e };
}
function a3(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function l3(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function u3(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Oc.default = function(e) {
  var t = function(n) {
    u3(r, n);
    function r(o) {
      a3(this, r);
      var i = l3(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return n3(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        w0.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        w0.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return b0.default.createElement(e, t3({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(b0.default.Component);
  return t.propTypes = {
    name: C0.default.string,
    id: C0.default.string
  }, t;
};
Object.defineProperty(Zh, "__esModule", {
  value: !0
});
var E0 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, c3 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), d3 = Ce, O0 = Yh(d3), p3 = Oc, f3 = Yh(p3), h3 = Cc, x0 = Yh(h3);
function Yh(e) {
  return e && e.__esModule ? e : { default: e };
}
function g3(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function m3(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function v3(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var TD = function(e) {
  v3(t, e);
  function t() {
    return g3(this, t), m3(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return c3(t, [{
    key: "render",
    value: function() {
      var n = this, r = E0({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, O0.default.createElement(
        "div",
        E0({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(O0.default.Component);
TD.propTypes = {
  name: x0.default.string,
  id: x0.default.string
};
Zh.default = (0, f3.default)(TD);
var Td = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, D0 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function L0(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function P0(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function S0(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Za = Ce, Bo = ea, Bd = Mi, un = Cc, to = Ec, k0 = {
  to: un.string.isRequired,
  containerId: un.string,
  container: un.object,
  activeClass: un.string,
  spy: un.bool,
  smooth: un.oneOfType([un.bool, un.string]),
  offset: un.number,
  delay: un.number,
  isDynamic: un.bool,
  onClick: un.func,
  duration: un.oneOfType([un.number, un.func]),
  absolute: un.bool,
  onSetActive: un.func,
  onSetInactive: un.func,
  ignoreCancelEvents: un.bool,
  hashSpy: un.bool,
  spyThrottle: un.number
}, y3 = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Bd, r = function(i) {
      S0(s, i);
      function s(a) {
        L0(this, s);
        var l = P0(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return D0(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Bo.isMounted(a) || Bo.mount(a, this.props.spyThrottle), this.props.hashSpy && (to.isMounted() || to.mount(n), to.mapContainer(this.props.to, a)), this.props.spy && Bo.addStateHandler(this.stateHandler), Bo.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Bo.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = Td({}, this.props);
          for (var u in k0)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Za.createElement(e, l);
        }
      }]), s;
    }(Za.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, Td({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(to.isMounted() && !to.isInitialized())) {
          var l = i.props.to, u = null, c = 0, d = 0, p = 0;
          if (a.getBoundingClientRect) {
            var m = a.getBoundingClientRect();
            p = m.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - p + s, d = c + f.height;
          }
          var g = s - i.props.offset, h = g >= Math.floor(c) && g < Math.floor(d), C = g < Math.floor(c) || g >= Math.floor(d), w = n.getActiveLink();
          if (C)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && to.getHash() === l && to.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Bo.updateStates();
          if (h && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && to.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Bo.updateStates();
        }
      };
    };
    return r.propTypes = k0, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      S0(r, n);
      function r(o) {
        L0(this, r);
        var i = P0(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return D0(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Bd.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Bd.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Za.createElement(e, Td({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Za.Component);
    return t.propTypes = {
      name: un.string,
      id: un.string
    }, t;
  }
}, b3 = y3;
Object.defineProperty(gn, "__esModule", {
  value: !0
});
gn.Helpers = gn.ScrollElement = gn.ScrollLink = gn.animateScroll = gn.scrollSpy = gn.Events = gn.scroller = gn.Element = gn.Button = gn.Link = void 0;
var w3 = $h, BD = Tr(w3), C3 = Gh, jD = Tr(C3), E3 = Zh, _D = Tr(E3), O3 = Mi, ID = Tr(O3), x3 = ra, FD = Tr(x3), D3 = ea, RD = Tr(D3), L3 = yc, ND = Tr(L3), P3 = Qs, zD = Tr(P3), S3 = Oc, $D = Tr(S3), k3 = b3, UD = Tr(k3);
function Tr(e) {
  return e && e.__esModule ? e : { default: e };
}
gn.Link = BD.default;
gn.Button = jD.default;
gn.Element = _D.default;
gn.scroller = ID.default;
gn.Events = FD.default;
gn.scrollSpy = RD.default;
gn.animateScroll = ND.default;
gn.ScrollLink = zD.default;
gn.ScrollElement = $D.default;
gn.Helpers = UD.default;
gn.default = { Link: BD.default, Button: jD.default, Element: _D.default, scroller: ID.default, Events: FD.default, scrollSpy: RD.default, animateScroll: ND.default, ScrollLink: zD.default, ScrollElement: $D.default, Helpers: UD.default };
Ze({});
Ze({});
Ze({});
function Ns(e) {
  "@babel/helpers - typeof";
  return Ns = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ns(e);
}
function M3(e, t) {
  if (Ns(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ns(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function A3(e) {
  var t = M3(e, "string");
  return Ns(t) == "symbol" ? t : t + "";
}
function ce(e, t, n) {
  return (t = A3(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function WD(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var jd, M0;
function T3() {
  if (M0) return jd;
  M0 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, s, a, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [o, i, s, a, l, u], p = 0;
        c = new Error(r.replace(/%s/g, function() {
          return d[p++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return jd = t, jd;
}
var B3 = T3(), xn = /* @__PURE__ */ WD(B3), Xe = Ze(null);
function j3() {
  xn(!!Oe, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Oe(Xe);
  return xn(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function _3(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function I3(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function F3(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return I3(e, i), o;
}
function R3(e, t, n) {
  var r = _3(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function N3(e) {
  google.maps.event.removeListener(e);
}
function ht() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(N3);
}
function pt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = R3(o, i, n);
  return F3(t, r, o, i), s;
}
function z3(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: d,
    onMouseMove: p,
    onMouseOut: m,
    onMouseOver: f,
    onMouseDown: g,
    onMouseUp: h,
    onRightClick: C,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: k,
    onUnmount: E
  } = e, [v, O] = P(null), L = qe(null), [W, D] = P(null), [N, _] = P(null), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null), [Z, T] = P(null), [Y, x] = P(null), [M, $] = P(null), [B, V] = P(null), [F, J] = P(null);
  return y(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), y(() => {
    v !== null && typeof s < "u" && v.setCenter(s);
  }, [v, s]), y(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), _(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), y(() => {
    v && c && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), y(() => {
    v && d && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(v, "dragstart", d)));
  }, [d]), y(() => {
    v && g && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", g)));
  }, [g]), y(() => {
    v && p && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(v, "mousemove", p)));
  }, [p]), y(() => {
    v && m && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(v, "mouseout", m)));
  }, [m]), y(() => {
    v && f && (Z !== null && google.maps.event.removeListener(Z), T(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), y(() => {
    v && h && (Y !== null && google.maps.event.removeListener(Y), x(google.maps.event.addListener(v, "mouseup", h)));
  }, [h]), y(() => {
    v && C && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(v, "rightclick", C)));
  }, [C]), y(() => {
    v && a && (B !== null && google.maps.event.removeListener(B), V(google.maps.event.addListener(v, "click", a)));
  }, [a]), y(() => {
    v && u && (F !== null && google.maps.event.removeListener(F), J(google.maps.event.addListener(v, "drag", u)));
  }, [u]), y(() => {
    v && w && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(v, "center_changed", w)));
  }, [a]), y(() => {
    var G = L.current === null ? null : new google.maps.Map(L.current, n);
    return O(G), G !== null && k && k(G), () => {
      G !== null && E && E(G);
    };
  }, []), At.jsx("div", {
    id: r,
    ref: L,
    style: o,
    className: i,
    children: At.jsx(Xe.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
Me(z3);
function A0(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function VD(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        A0(i, r, o, s, a, "next", l);
      }
      function a(l) {
        A0(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function HD(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return xn(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var qo = typeof document < "u";
function qD(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return qo ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(p) {
          c && c(p), i(p);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(p) {
      d.setAttribute("data-state", "error"), i(p);
    }, a.initMap = function() {
      d.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function T0(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function GD() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return T0(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return T0(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Xi = !1;
function ZD() {
  return At.jsx("div", {
    children: "Loading..."
  });
}
var Qp = {
  id: "script-loader",
  version: "weekly"
};
class $3 extends Ee {
  constructor() {
    super(...arguments), ce(this, "check", mr()), ce(this, "state", {
      loaded: !1
    }), ce(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ce(this, "isCleaningUp", /* @__PURE__ */ VD(function* () {
      function t(n) {
        if (!Xi)
          n();
        else if (qo)
          var r = window.setInterval(function() {
            Xi || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ce(this, "cleanup", () => {
      Xi = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), ce(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && GD(), xn(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: HD(this.props)
      };
      qD(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (qo) {
      if (window.google && window.google.maps && !Xi) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), qo && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (qo) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Xi = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return At.jsxs(At.Fragment, {
      children: [At.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || At.jsx(ZD, {})]
    });
  }
}
ce($3, "defaultProps", Qp);
function U3(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Xh(e, t) {
  if (e == null) return {};
  var n, r, o = U3(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var B0;
function W3(e) {
  var {
    id: t = Qp.id,
    version: n = Qp.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  } = e, m = qe(!1), [f, g] = P(!1), [h, C] = P(void 0);
  y(function() {
    return m.current = !0, () => {
      m.current = !1;
    };
  }, []), y(function() {
    qo && u && GD();
  }, [u]), y(function() {
    f && xn(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = HD({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  });
  y(function() {
    if (!qo)
      return;
    function E() {
      m.current && (g(!0), B0 = w);
    }
    if (window.google && window.google.maps && B0 === w) {
      E();
      return;
    }
    qD({
      id: t,
      url: w,
      nonce: r
    }).then(E).catch(function(v) {
      m.current && C(v), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(v);
    });
  }, [t, w, r]);
  var k = qe();
  return y(function() {
    k.current && l !== k.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), k.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var V3 = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], H3 = At.jsx(ZD, {});
function q3(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = Xh(e, V3), {
    isLoaded: a,
    loadError: l
  } = W3(s);
  return y(function() {
    a && typeof n == "function" && n();
  }, [a, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || H3;
}
Me(q3);
var j0;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(j0 || (j0 = {}));
function _0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _0(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var I0 = {}, F0 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function G3(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = Oe(Xe), [i, s] = P(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), y(() => {
    var a = new google.maps.TrafficLayer(nu(nu({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Me(G3);
class Z3 extends Ee {
  constructor() {
    super(...arguments), ce(this, "state", {
      trafficLayer: null
    }), ce(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(nu(nu({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pt({
      updaterMap: F0,
      eventMap: I0,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: F0,
      eventMap: I0,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), ht(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ce(Z3, "contextType", Xe);
function Y3(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Oe(Xe), [o, i] = P(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
Me(Y3);
class X3 extends Ee {
  constructor() {
    super(...arguments), ce(this, "state", {
      bicyclingLayer: null
    }), ce(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ce(X3, "contextType", Xe);
function K3(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Oe(Xe), [o, i] = P(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Me(K3);
class J3 extends Ee {
  constructor() {
    super(...arguments), ce(this, "state", {
      transitLayer: null
    }), ce(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ce(J3, "contextType", Xe);
function R0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ru(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R0(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var N0 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, z0 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Q3(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, d = Oe(Xe), [p, m] = P(null), [f, g] = P(null), [h, C] = P(null), [w, k] = P(null), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null);
  return y(() => {
    p !== null && p.setMap(d);
  }, [d]), y(() => {
    t && p !== null && p.setOptions(t);
  }, [p, t]), y(() => {
    p !== null && p.setDrawingMode(n ?? null);
  }, [p, n]), y(() => {
    p && r && (f !== null && google.maps.event.removeListener(f), g(google.maps.event.addListener(p, "circlecomplete", r)));
  }, [p, r]), y(() => {
    p && o && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(p, "markercomplete", o)));
  }, [p, o]), y(() => {
    p && i && (w !== null && google.maps.event.removeListener(w), k(google.maps.event.addListener(p, "overlaycomplete", i)));
  }, [p, i]), y(() => {
    p && s && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(p, "polygoncomplete", s)));
  }, [p, s]), y(() => {
    p && a && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(p, "polylinecomplete", a)));
  }, [p, a]), y(() => {
    p && l && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(p, "rectanglecomplete", l)));
  }, [p, l]), y(() => {
    xn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(ru(ru({}, t), {}, {
      map: d
    }));
    return n && N.setDrawingMode(n), r && g(google.maps.event.addListener(N, "circlecomplete", r)), o && C(google.maps.event.addListener(N, "markercomplete", o)), i && k(google.maps.event.addListener(N, "overlaycomplete", i)), s && v(google.maps.event.addListener(N, "polygoncomplete", s)), a && L(google.maps.event.addListener(N, "polylinecomplete", a)), l && D(google.maps.event.addListener(N, "rectanglecomplete", l)), m(N), u && u(N), () => {
      p !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), E && google.maps.event.removeListener(E), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), c && c(p), p.setMap(null));
    };
  }, []), null;
}
Me(Q3);
class eU extends Ee {
  constructor(t) {
    super(t), ce(this, "registeredEvents", []), ce(this, "state", {
      drawingManager: null
    }), ce(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), xn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(ru(ru({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pt({
      updaterMap: z0,
      eventMap: N0,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: z0,
      eventMap: N0,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), ht(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ce(eU, "contextType", Xe);
function $0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $0(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var U0 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, W0 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, ou = {};
function tU(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: d,
    label: p,
    opacity: m,
    shape: f,
    title: g,
    zIndex: h,
    onClick: C,
    onDblClick: w,
    onDrag: k,
    onDragEnd: E,
    onDragStart: v,
    onMouseOut: O,
    onMouseOver: L,
    onMouseUp: W,
    onMouseDown: D,
    onRightClick: N,
    onClickableChanged: _,
    onCursorChanged: R,
    onAnimationChanged: U,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: ne,
    onTitleChanged: Q,
    onVisibleChanged: S,
    onZindexChanged: I,
    onLoad: Z,
    onUnmount: T
  } = e, Y = Oe(Xe), [x, M] = P(null), [$, B] = P(null), [V, F] = P(null), [J, G] = P(null), [fe, be] = P(null), [re, Ae] = P(null), [Ie, je] = P(null), [_e, tt] = P(null), [Ke, ke] = P(null), [nt, gt] = P(null), [Pe, Te] = P(null), [Re, He] = P(null), [ze, wt] = P(null), [Be, dn] = P(null), [Ct, Pt] = P(null), [Rt, vn] = P(null), [Nt, yn] = P(null), [mt, en] = P(null), [St, bn] = P(null), [zt, Pn] = P(null), [wn, Sn] = P(null), [Cn, kn] = P(null);
  y(() => {
    x !== null && x.setMap(Y);
  }, [Y]), y(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), y(() => {
    typeof s < "u" && x !== null && x.setDraggable(s);
  }, [x, s]), y(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), y(() => {
    typeof a < "u" && x !== null && x.setVisible(a);
  }, [x, a]), y(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), y(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), y(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), y(() => {
    x && d !== void 0 && x.setIcon(d);
  }, [x, d]), y(() => {
    x && p !== void 0 && x.setLabel(p);
  }, [x, p]), y(() => {
    x && m !== void 0 && x.setOpacity(m);
  }, [x, m]), y(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), y(() => {
    x && g !== void 0 && x.setTitle(g);
  }, [x, g]), y(() => {
    x && h !== void 0 && x.setZIndex(h);
  }, [x, h]), y(() => {
    x && w && ($ !== null && google.maps.event.removeListener($), B(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), y(() => {
    x && E && (V !== null && google.maps.event.removeListener(V), F(google.maps.event.addListener(x, "dragend", E)));
  }, [E]), y(() => {
    x && v && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(x, "dragstart", v)));
  }, [v]), y(() => {
    x && D && (fe !== null && google.maps.event.removeListener(fe), be(google.maps.event.addListener(x, "mousedown", D)));
  }, [D]), y(() => {
    x && O && (re !== null && google.maps.event.removeListener(re), Ae(google.maps.event.addListener(x, "mouseout", O)));
  }, [O]), y(() => {
    x && L && (Ie !== null && google.maps.event.removeListener(Ie), je(google.maps.event.addListener(x, "mouseover", L)));
  }, [L]), y(() => {
    x && W && (_e !== null && google.maps.event.removeListener(_e), tt(google.maps.event.addListener(x, "mouseup", W)));
  }, [W]), y(() => {
    x && N && (Ke !== null && google.maps.event.removeListener(Ke), ke(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), y(() => {
    x && C && (nt !== null && google.maps.event.removeListener(nt), gt(google.maps.event.addListener(x, "click", C)));
  }, [C]), y(() => {
    x && k && (Pe !== null && google.maps.event.removeListener(Pe), Te(google.maps.event.addListener(x, "drag", k)));
  }, [k]), y(() => {
    x && _ && (Re !== null && google.maps.event.removeListener(Re), He(google.maps.event.addListener(x, "clickable_changed", _)));
  }, [_]), y(() => {
    x && R && (ze !== null && google.maps.event.removeListener(ze), wt(google.maps.event.addListener(x, "cursor_changed", R)));
  }, [R]), y(() => {
    x && U && (Be !== null && google.maps.event.removeListener(Be), dn(google.maps.event.addListener(x, "animation_changed", U)));
  }, [U]), y(() => {
    x && z && (Ct !== null && google.maps.event.removeListener(Ct), Pt(google.maps.event.addListener(x, "draggable_changed", z)));
  }, [z]), y(() => {
    x && q && (Rt !== null && google.maps.event.removeListener(Rt), vn(google.maps.event.addListener(x, "flat_changed", q)));
  }, [q]), y(() => {
    x && K && (Nt !== null && google.maps.event.removeListener(Nt), yn(google.maps.event.addListener(x, "icon_changed", K)));
  }, [K]), y(() => {
    x && X && (mt !== null && google.maps.event.removeListener(mt), en(google.maps.event.addListener(x, "position_changed", X)));
  }, [X]), y(() => {
    x && ne && (St !== null && google.maps.event.removeListener(St), bn(google.maps.event.addListener(x, "shape_changed", ne)));
  }, [ne]), y(() => {
    x && Q && (zt !== null && google.maps.event.removeListener(zt), Pn(google.maps.event.addListener(x, "title_changed", Q)));
  }, [Q]), y(() => {
    x && S && (wn !== null && google.maps.event.removeListener(wn), Sn(google.maps.event.addListener(x, "visible_changed", S)));
  }, [S]), y(() => {
    x && I && (Cn !== null && google.maps.event.removeListener(Cn), kn(google.maps.event.addListener(x, "zindex_changed", I)));
  }, [I]), y(() => {
    var tn = fi(fi(fi({}, n || ou), r ? ou : {
      map: Y
    }), {}, {
      position: t
    }), se = new google.maps.Marker(tn);
    return r ? r.addMarker(se, !!o) : se.setMap(Y), t && se.setPosition(t), typeof a < "u" && se.setVisible(a), typeof s < "u" && se.setDraggable(s), typeof u < "u" && se.setClickable(u), typeof c == "string" && se.setCursor(c), d && se.setIcon(d), typeof p < "u" && se.setLabel(p), typeof m < "u" && se.setOpacity(m), f && se.setShape(f), typeof g == "string" && se.setTitle(g), typeof h == "number" && se.setZIndex(h), w && B(google.maps.event.addListener(se, "dblclick", w)), E && F(google.maps.event.addListener(se, "dragend", E)), v && G(google.maps.event.addListener(se, "dragstart", v)), D && be(google.maps.event.addListener(se, "mousedown", D)), O && Ae(google.maps.event.addListener(se, "mouseout", O)), L && je(google.maps.event.addListener(se, "mouseover", L)), W && tt(google.maps.event.addListener(se, "mouseup", W)), N && ke(google.maps.event.addListener(se, "rightclick", N)), C && gt(google.maps.event.addListener(se, "click", C)), k && Te(google.maps.event.addListener(se, "drag", k)), _ && He(google.maps.event.addListener(se, "clickable_changed", _)), R && wt(google.maps.event.addListener(se, "cursor_changed", R)), U && dn(google.maps.event.addListener(se, "animation_changed", U)), z && Pt(google.maps.event.addListener(se, "draggable_changed", z)), q && vn(google.maps.event.addListener(se, "flat_changed", q)), K && yn(google.maps.event.addListener(se, "icon_changed", K)), X && en(google.maps.event.addListener(se, "position_changed", X)), ne && bn(google.maps.event.addListener(se, "shape_changed", ne)), Q && Pn(google.maps.event.addListener(se, "title_changed", Q)), S && Sn(google.maps.event.addListener(se, "visible_changed", S)), I && kn(google.maps.event.addListener(se, "zindex_changed", I)), M(se), Z && Z(se), () => {
      $ !== null && google.maps.event.removeListener($), V !== null && google.maps.event.removeListener(V), J !== null && google.maps.event.removeListener(J), fe !== null && google.maps.event.removeListener(fe), re !== null && google.maps.event.removeListener(re), Ie !== null && google.maps.event.removeListener(Ie), _e !== null && google.maps.event.removeListener(_e), Ke !== null && google.maps.event.removeListener(Ke), nt !== null && google.maps.event.removeListener(nt), Re !== null && google.maps.event.removeListener(Re), ze !== null && google.maps.event.removeListener(ze), Be !== null && google.maps.event.removeListener(Be), Ct !== null && google.maps.event.removeListener(Ct), Rt !== null && google.maps.event.removeListener(Rt), Nt !== null && google.maps.event.removeListener(Nt), mt !== null && google.maps.event.removeListener(mt), zt !== null && google.maps.event.removeListener(zt), wn !== null && google.maps.event.removeListener(wn), Cn !== null && google.maps.event.removeListener(Cn), T && T(se), r ? r.removeMarker(se, !!o) : se && se.setMap(null);
    };
  }, []);
  var Wn = Mn(() => i ? Ft.map(i, (tn) => {
    if (!Ei(tn))
      return tn;
    var se = tn;
    return Oi(se, {
      anchor: x
    });
  }) : null, [i, x]);
  return At.jsx(At.Fragment, {
    children: Wn
  }) || null;
}
Me(tU);
class nU extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return VD(function* () {
      var n = fi(fi(fi({}, t.props.options || ou), t.props.clusterer ? ou : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = pt({
        updaterMap: W0,
        eventMap: U0,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: W0,
      eventMap: U0,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), ht(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? Ft.map(this.props.children, (n) => {
      if (!Ei(n))
        return n;
      var r = n;
      return Oi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ce(nU, "contextType", Xe);
var rU = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), d = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(d !== null ? "".concat(d.y, "px") : "0", "; left: ").concat(d !== null ? "".concat(d.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var p = document.createElement("img");
        p.alt = a, p.src = this.url, p.width = this.width, p.height = this.height, p.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (p.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var m = document.createElement("div");
        m.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (m.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (m.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(p), this.div.appendChild(m), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), oU = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new rU(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function iU(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var sU = 2e3, aU = 500, lU = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", uU = "png", cU = [53, 56, 66, 78, 90], dU = "cluster", YD = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || lU, this.imageExtension = r.imageExtension || uU, this.imageSizes = r.imageSizes || cU, this.calculator = r.calculator || iU, this.batchSize = r.batchSize || sU, this.batchSizeIE = r.batchSizeIE || aU, this.clusterClass = r.clusterClass || dU, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new oU(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var d = 0, p = this.clusters; d < p.length; d++) {
            var m = p[d];
            m.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function V0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? V0(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : V0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pr = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, yt = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, fU = {};
function hU(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: d,
    imageSizes: p,
    maxZoom: m,
    minimumClusterSize: f,
    styles: g,
    title: h,
    zoomOnClick: C,
    onClick: w,
    onClusteringBegin: k,
    onClusteringEnd: E,
    onMouseOver: v,
    onMouseOut: O,
    onLoad: L,
    onUnmount: W
  } = e, [D, N] = P(null), _ = Oe(Xe), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null);
  return y(() => {
    D && O && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(D, pr.onMouseOut, O)));
  }, [O]), y(() => {
    D && v && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(D, pr.onMouseOver, v)));
  }, [v]), y(() => {
    D && w && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(D, pr.onClick, w)));
  }, [w]), y(() => {
    D && k && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(D, pr.onClusteringBegin, k)));
  }, [k]), y(() => {
    D && E && (K !== null && google.maps.event.removeListener(K), q(google.maps.event.addListener(D, pr.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && D !== null && yt.averageCenter(D, r);
  }, [D, r]), y(() => {
    typeof o < "u" && D !== null && yt.batchSizeIE(D, o);
  }, [D, o]), y(() => {
    typeof i < "u" && D !== null && yt.calculator(D, i);
  }, [D, i]), y(() => {
    typeof s < "u" && D !== null && yt.clusterClass(D, s);
  }, [D, s]), y(() => {
    typeof a < "u" && D !== null && yt.enableRetinaIcons(D, a);
  }, [D, a]), y(() => {
    typeof l < "u" && D !== null && yt.gridSize(D, l);
  }, [D, l]), y(() => {
    typeof u < "u" && D !== null && yt.ignoreHidden(D, u);
  }, [D, u]), y(() => {
    typeof c < "u" && D !== null && yt.imageExtension(D, c);
  }, [D, c]), y(() => {
    typeof d < "u" && D !== null && yt.imagePath(D, d);
  }, [D, d]), y(() => {
    typeof p < "u" && D !== null && yt.imageSizes(D, p);
  }, [D, p]), y(() => {
    typeof m < "u" && D !== null && yt.maxZoom(D, m);
  }, [D, m]), y(() => {
    typeof f < "u" && D !== null && yt.minimumClusterSize(D, f);
  }, [D, f]), y(() => {
    typeof g < "u" && D !== null && yt.styles(D, g);
  }, [D, g]), y(() => {
    typeof h < "u" && D !== null && yt.title(D, h);
  }, [D, h]), y(() => {
    typeof C < "u" && D !== null && yt.zoomOnClick(D, C);
  }, [D, C]), y(() => {
    if (_) {
      var Z = pU({}, n || fU), T = new YD(_, [], Z);
      return r && yt.averageCenter(T, r), o && yt.batchSizeIE(T, o), i && yt.calculator(T, i), s && yt.clusterClass(T, s), a && yt.enableRetinaIcons(T, a), l && yt.gridSize(T, l), u && yt.ignoreHidden(T, u), c && yt.imageExtension(T, c), d && yt.imagePath(T, d), p && yt.imageSizes(T, p), m && yt.maxZoom(T, m), f && yt.minimumClusterSize(T, f), g && yt.styles(T, g), h && yt.title(T, h), C && yt.zoomOnClick(T, C), O && Q(google.maps.event.addListener(T, pr.onMouseOut, O)), v && I(google.maps.event.addListener(T, pr.onMouseOver, v)), w && U(google.maps.event.addListener(T, pr.onClick, w)), k && q(google.maps.event.addListener(T, pr.onClusteringBegin, k)), E && X(google.maps.event.addListener(T, pr.onClusteringEnd, E)), N(T), L && L(T), () => {
        ne !== null && google.maps.event.removeListener(ne), S !== null && google.maps.event.removeListener(S), R !== null && google.maps.event.removeListener(R), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), W && W(T);
      };
    }
  }, []), D !== null && t(D) || null;
}
Me(hU);
class gU extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      markerClusterer: null
    }), ce(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new YD(this.context, [], this.props.options);
      this.registeredEvents = pt({
        updaterMap: yt,
        eventMap: pr,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: yt,
      eventMap: pr,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), ht(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ce(gU, "contextType", Xe);
function H0(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var XD = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || H0(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, H0));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, d = this.div.offsetWidth, p = this.div.offsetHeight, m = this.infoBoxClearance.width, f = this.infoBoxClearance.height, g = this.getProjection(), h = g.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + m ? r = h.x + u - m : h.x + d + u + m > a && (r = h.x + d + u + m - a), this.alignBottom ? h.y < -c + f + p ? o = h.y + c - f - p : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + p + c + f > l && (o = h.y + p + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), mU = ["position"], vU = ["position"];
function q0(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? q0(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : q0(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var G0 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Z0 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, yU = {};
function bU(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, m = Oe(Xe), [f, g] = P(null), [h, C] = P(null), [w, k] = P(null), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null), N = qe(null);
  return y(() => {
    m && f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    if (o && f !== null) {
      var _ = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(_);
    }
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), k(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    if (m) {
      var _ = r || yU, {
        position: R
      } = _, U = Xh(_, mU), z;
      R && !(R instanceof google.maps.LatLng) && (z = new google.maps.LatLng(R.lat, R.lng));
      var q = new XD(iu(iu({}, U), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), g(q), s && C(google.maps.event.addListener(q, "closeclick", s)), a && k(google.maps.event.addListener(q, "domready", a)), l && v(google.maps.event.addListener(q, "content_changed", l)), u && L(google.maps.event.addListener(q, "position_changed", u)), c && D(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(N.current), n ? q.open(m, n) : q.getPosition() ? q.open(m) : xn(!1, "You must provide either an anchor or a position prop for <InfoBox>."), d && d(q);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), p && p(f), f.close());
    };
  }, []), N.current ? vr(Ft.only(t), N.current) : null;
}
Me(bU);
class wU extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "containerElement", null), ce(this, "state", {
      infoBox: null
    }), ce(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : xn(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ce(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Xh(t, vU), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new XD(iu(iu({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = pt({
      updaterMap: Z0,
      eventMap: G0,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: Z0,
      eventMap: G0,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), ht(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? vr(Ft.only(this.props.children), this.containerElement) : null;
  }
}
ce(wU, "contextType", Xe);
var Y0, X0;
function CU() {
  return X0 || (X0 = 1, Y0 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), Y0;
}
var EU = CU(), K0 = /* @__PURE__ */ WD(EU), J0 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], _d = 1, Ki = 8;
class Kh {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== _d)
      throw new Error("Got v".concat(o, " data when expected v").concat(_d, "."));
    var i = J0[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new Kh(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = J0.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Ki, t), this.coords = new this.ArrayType(this.data, Ki + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Ki + s + a + l), this.ids = new this.IndexArrayType(this.data, Ki, t), this.coords = new this.ArrayType(this.data, Ki + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (_d << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return ef(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, d = l.pop() || 0, p = l.pop() || 0;
      if (d - p <= a) {
        for (var m = p; m <= d; m++) {
          var f = s[2 * m], g = s[2 * m + 1];
          f >= t && f <= r && g >= n && g <= o && u.push(i[m]);
        }
        continue;
      }
      var h = p + d >> 1, C = s[2 * h], w = s[2 * h + 1];
      C >= t && C <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= C : n <= w) && (l.push(p), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= C : o >= w) && (l.push(h + 1), l.push(d), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, d = a.pop() || 0, p = a.pop() || 0;
      if (d - p <= s) {
        for (var m = p; m <= d; m++)
          Q0(i[2 * m], i[2 * m + 1], t, n) <= u && l.push(o[m]);
        continue;
      }
      var f = p + d >> 1, g = i[2 * f], h = i[2 * f + 1];
      Q0(g, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= g : n - r <= h) && (a.push(p), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= h) && (a.push(f + 1), a.push(d), a.push(1 - c));
    }
    return l;
  }
}
function ef(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    KD(e, t, s, r, o, i), ef(e, t, n, r, s - 1, 1 - i), ef(e, t, n, s + 1, o, 1 - i);
  }
}
function KD(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), d = Math.max(r, Math.floor(n - a * u / s + c)), p = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      KD(e, t, n, d, p, i);
    }
    var m = t[2 * n + i], f = r, g = o;
    for (Ji(e, t, r, n), t[2 * o + i] > m && Ji(e, t, r, o); f < g; ) {
      for (Ji(e, t, f, g), f++, g--; t[2 * f + i] < m; ) f++;
      for (; t[2 * g + i] > m; ) g--;
    }
    t[2 * r + i] === m ? Ji(e, t, r, g) : (g++, Ji(e, t, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function Ji(e, t, n, r) {
  Id(e, n, r), Id(t, 2 * n, 2 * r), Id(t, 2 * n + 1, 2 * r + 1);
}
function Id(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function Q0(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var OU = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, ew = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), jo = 2, uo = 3, Fd = 4, so = 5, JD = 6;
class xU {
  constructor(t) {
    this.options = Object.assign(Object.create(OU), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, d = ew(Ya(u)), p = ew(Xa(c));
        s.push(
          d,
          p,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var m = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var g = +Date.now();
      m = this.trees[f] = this._createTree(this._cluster(m, f)), n && console.log("z%d: %d clusters in %dms", f, m.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Ya(r), Xa(s), Ya(i), Xa(o)), d = u.data, p = [];
    for (var m of c) {
      var f = this.stride * m;
      p.push(d[f + so] > 1 ? tw(d, f, this.clusterProps) : this.points[d[f + uo]]);
    }
    return p;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), d = [];
    for (var p of c) {
      var m = p * this.stride;
      s[m + Fd] === t && d.push(s[m + so] > 1 ? tw(s, m, this.clusterProps) : this.points[s[m + uo]]);
    }
    if (d.length === 0) throw new Error(o);
    return d;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, d = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, d), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, d), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, d), d.features.length ? d : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Kh(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + so] > 1, c = void 0, d = void 0, p = void 0;
      if (u)
        c = QD(n, l, this.clusterProps), d = n[l], p = n[l + 1];
      else {
        var m = this.points[n[l + uo]];
        c = m.properties;
        var [f, g] = m.geometry.coordinates;
        d = Ya(f), p = Xa(g);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (d * i - r)), Math.round(this.options.extent * (p * i - o))]],
        tags: c
      }, C = void 0;
      u || this.options.generateId ? C = n[l + uo] : C = this.points[n[l + uo]].id, C !== void 0 && (h.id = C), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, d = 0; d < l.length; d += c)
      if (!(l[d + jo] <= n)) {
        l[d + jo] = n;
        var p = l[d], m = l[d + 1], f = t.within(l[d], l[d + 1], a), g = l[d + so], h = g;
        for (var C of f) {
          var w = C * c;
          l[w + jo] > n && (h += l[w + so]);
        }
        if (h > g && h >= s) {
          var k = p * g, E = m * g, v = void 0, O = -1, L = ((d / c | 0) << 5) + (n + 1) + this.points.length;
          for (var W of f) {
            var D = W * c;
            if (!(l[D + jo] <= n)) {
              l[D + jo] = n;
              var N = l[D + so];
              k += l[D] * N, E += l[D + 1] * N, l[D + Fd] = L, i && (v || (v = this._map(l, d, !0), O = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, D)));
            }
          }
          l[d + Fd] = L, u.push(k / h, E / h, 1 / 0, L, -1, h), i && u.push(O);
        } else {
          for (var _ = 0; _ < c; _++) u.push(l[d + _]);
          if (h > 1)
            for (var R of f) {
              var U = R * c;
              if (!(l[U + jo] <= n)) {
                l[U + jo] = n;
                for (var z = 0; z < c; z++) u.push(l[U + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + so] > 1) {
      var o = this.clusterProps[t[n + JD]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + uo]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function tw(e, t, n) {
  return {
    type: "Feature",
    id: e[t + uo],
    properties: QD(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [DU(e[t]), LU(e[t + 1])]
    }
  };
}
function QD(e, t, n) {
  var r = e[t + so], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + JD], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + uo],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Ya(e) {
  return e / 360 + 0.5;
}
function Xa(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function DU(e) {
  return (e - 0.5) * 360;
}
function LU(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function PU(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class nr {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class tf {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(nr.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => nr.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (nr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class SU {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return kU(n);
  }
}
var kU = (e) => {
  var t = e.map((n) => new tf({
    position: nr.getPosition(n),
    markers: [n]
  }));
  return t;
};
class MU extends SU {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = PU(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new xU(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!K0(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = nr.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !K0(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new tf({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new tf({
      markers: [i],
      position: nr.getPosition(i)
    });
  }
}
class AU {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class TU {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (nr.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), d = c.parseFromString(a, "image/svg+xml").documentElement;
      d.setAttribute("transform", "translate(0 25)");
      var p = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: d
      };
      return new google.maps.marker.AdvancedMarkerElement(p);
    }
    var m = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(m);
  }
}
function BU(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Jh {
  constructor() {
    BU(Jh, google.maps.OverlayView);
  }
}
var bs;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(bs || (bs = {}));
var jU = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class _U extends Jh {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new MU(o),
      renderer: s = new TU(),
      onClusterClick: a = jU
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (nr.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, bs.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || nr.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => nr.setMap(l, null)));
      }
      google.maps.event.trigger(this, bs.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => nr.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new AU(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => nr.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, bs.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), nr.setMap(r.marker, n);
    });
  }
}
function nw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nw(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function IU(e) {
  var t = j3(), [n, r] = P(null);
  return y(() => {
    if (t && n === null) {
      var o = new _U(rw(rw({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function FU(e) {
  var {
    children: t,
    options: n
  } = e, r = IU(n);
  return r !== null ? t(r) : null;
}
Me(FU);
var ow = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, iw = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function RU(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, m = Oe(Xe), [f, g] = P(null), [h, C] = P(null), [w, k] = P(null), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null), N = qe(null);
  return y(() => {
    f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), k(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    var _ = new google.maps.InfoWindow(r);
    return g(_), N.current = document.createElement("div"), s && C(google.maps.event.addListener(_, "closeclick", s)), a && k(google.maps.event.addListener(_, "domready", a)), l && v(google.maps.event.addListener(_, "content_changed", l)), u && L(google.maps.event.addListener(_, "position_changed", u)), c && D(google.maps.event.addListener(_, "zindex_changed", c)), _.setContent(N.current), o && _.setPosition(o), i && _.setZIndex(i), n ? _.open(m, n) : _.getPosition() ? _.open(m) : xn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), d && d(_), () => {
      h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), p && p(_), _.close();
    };
  }, []), N.current ? vr(Ft.only(t), N.current) : null;
}
Me(RU);
class NU extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "containerElement", null), ce(this, "state", {
      infoWindow: null
    }), ce(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : xn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ce(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = pt({
      updaterMap: iw,
      eventMap: ow,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: iw,
      eventMap: ow,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (ht(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? vr(Ft.only(this.props.children), this.containerElement) : null;
  }
}
ce(NU, "contextType", Xe);
function sw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function su(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sw(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aw = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, lw = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, zU = {};
function $U(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onLoad: C,
    onUnmount: w
  } = e, k = Oe(Xe), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null), [N, _] = P(null), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null), [Z, T] = P(null), [Y, x] = P(null), [M, $] = P(null);
  return y(() => {
    E !== null && E.setMap(k);
  }, [k]), y(() => {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && s && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(E, "dblclick", s)));
  }, [s]), y(() => {
    E && a && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(E, "dragend", a)));
  }, [a]), y(() => {
    E && l && (N !== null && google.maps.event.removeListener(N), _(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && d && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(E, "mouseout", d)));
  }, [d]), y(() => {
    E && p && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(E, "mouseover", p)));
  }, [p]), y(() => {
    E && m && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(E, "mouseup", m)));
  }, [m]), y(() => {
    E && f && (Z !== null && google.maps.event.removeListener(Z), T(google.maps.event.addListener(E, "rightclick", f)));
  }, [f]), y(() => {
    E && g && (Y !== null && google.maps.event.removeListener(Y), x(google.maps.event.addListener(E, "click", g)));
  }, [g]), y(() => {
    E && h && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(E, "drag", h)));
  }, [h]), y(() => {
    var B = new google.maps.Polyline(su(su({}, t || zU), {}, {
      map: k
    }));
    return i && B.setPath(i), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), s && L(google.maps.event.addListener(B, "dblclick", s)), a && D(google.maps.event.addListener(B, "dragend", a)), l && _(google.maps.event.addListener(B, "dragstart", l)), u && U(google.maps.event.addListener(B, "mousedown", u)), c && q(google.maps.event.addListener(B, "mousemove", c)), d && X(google.maps.event.addListener(B, "mouseout", d)), p && Q(google.maps.event.addListener(B, "mouseover", p)), m && I(google.maps.event.addListener(B, "mouseup", m)), f && T(google.maps.event.addListener(B, "rightclick", f)), g && x(google.maps.event.addListener(B, "click", g)), h && $(google.maps.event.addListener(B, "drag", h)), v(B), C && C(B), () => {
      O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), N !== null && google.maps.event.removeListener(N), R !== null && google.maps.event.removeListener(R), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), ne !== null && google.maps.event.removeListener(ne), S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), w && w(B), B.setMap(null);
    };
  }, []), null;
}
Me($U);
class UU extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      polyline: null
    }), ce(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(su(su({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pt({
      updaterMap: lw,
      eventMap: aw,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: lw,
      eventMap: aw,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), ht(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ce(UU, "contextType", Xe);
function uw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uw(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dw = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, pw = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function WU(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onLoad: w,
    onUnmount: k,
    onEdit: E
  } = e, v = Oe(Xe), [O, L] = P(null), [W, D] = P(null), [N, _] = P(null), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null), [Z, T] = P(null), [Y, x] = P(null), [M, $] = P(null), [B, V] = P(null);
  return y(() => {
    O !== null && O.setMap(v);
  }, [v]), y(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), y(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), y(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), y(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), y(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), y(() => {
    typeof s < "u" && O !== null && O.setPaths(s);
  }, [O, s]), y(() => {
    O && typeof a == "function" && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), y(() => {
    O && (google.maps.event.addListener(O.getPath(), "insert_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "set_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "remove_at", () => {
      E == null || E(O);
    }));
  }, [O, E]), y(() => {
    O && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), _(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), y(() => {
    O && typeof u == "function" && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), y(() => {
    O && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), y(() => {
    O && typeof d == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mousemove", d)));
  }, [d]), y(() => {
    O && typeof p == "function" && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), y(() => {
    O && typeof m == "function" && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(O, "mouseover", m)));
  }, [m]), y(() => {
    O && typeof f == "function" && (Z !== null && google.maps.event.removeListener(Z), T(google.maps.event.addListener(O, "mouseup", f)));
  }, [f]), y(() => {
    O && typeof g == "function" && (Y !== null && google.maps.event.removeListener(Y), x(google.maps.event.addListener(O, "rightclick", g)));
  }, [g]), y(() => {
    O && typeof h == "function" && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(O, "click", h)));
  }, [h]), y(() => {
    O && typeof C == "function" && (B !== null && google.maps.event.removeListener(B), V(google.maps.event.addListener(O, "drag", C)));
  }, [C]), y(() => {
    var F = new google.maps.Polygon(cw(cw({}, t), {}, {
      map: v
    }));
    return i && F.setPath(i), s && F.setPaths(s), typeof o < "u" && F.setVisible(o), typeof r < "u" && F.setEditable(r), typeof n < "u" && F.setDraggable(n), a && D(google.maps.event.addListener(F, "dblclick", a)), l && _(google.maps.event.addListener(F, "dragend", l)), u && U(google.maps.event.addListener(F, "dragstart", u)), c && q(google.maps.event.addListener(F, "mousedown", c)), d && X(google.maps.event.addListener(F, "mousemove", d)), p && Q(google.maps.event.addListener(F, "mouseout", p)), m && I(google.maps.event.addListener(F, "mouseover", m)), f && T(google.maps.event.addListener(F, "mouseup", f)), g && x(google.maps.event.addListener(F, "rightclick", g)), h && $(google.maps.event.addListener(F, "click", h)), C && V(google.maps.event.addListener(F, "drag", C)), L(F), w && w(F), () => {
      W !== null && google.maps.event.removeListener(W), N !== null && google.maps.event.removeListener(N), R !== null && google.maps.event.removeListener(R), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), ne !== null && google.maps.event.removeListener(ne), S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), k && k(F), F.setMap(null);
    };
  }, []), null;
}
Me(WU);
class VU extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = pt({
      updaterMap: pw,
      eventMap: dw,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: pw,
      eventMap: dw,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), ht(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ce(VU, "contextType", Xe);
function fw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function au(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fw(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hw = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, gw = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function HU(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onBoundsChanged: C,
    onLoad: w,
    onUnmount: k
  } = e, E = Oe(Xe), [v, O] = P(null), [L, W] = P(null), [D, N] = P(null), [_, R] = P(null), [U, z] = P(null), [q, K] = P(null), [X, ne] = P(null), [Q, S] = P(null), [I, Z] = P(null), [T, Y] = P(null), [x, M] = P(null), [$, B] = P(null), [V, F] = P(null);
  return y(() => {
    v !== null && v.setMap(E);
  }, [E]), y(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), y(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), y(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), y(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), y(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), y(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), W(google.maps.event.addListener(v, "dblclick", s)));
  }, [s]), y(() => {
    v && a && (D !== null && google.maps.event.removeListener(D), N(google.maps.event.addListener(v, "dragend", a)));
  }, [a]), y(() => {
    v && l && (_ !== null && google.maps.event.removeListener(_), R(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), y(() => {
    v && u && (U !== null && google.maps.event.removeListener(U), z(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), y(() => {
    v && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), y(() => {
    v && d && (X !== null && google.maps.event.removeListener(X), ne(google.maps.event.addListener(v, "mouseout", d)));
  }, [d]), y(() => {
    v && p && (Q !== null && google.maps.event.removeListener(Q), S(google.maps.event.addListener(v, "mouseover", p)));
  }, [p]), y(() => {
    v && m && (I !== null && google.maps.event.removeListener(I), Z(google.maps.event.addListener(v, "mouseup", m)));
  }, [m]), y(() => {
    v && f && (T !== null && google.maps.event.removeListener(T), Y(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), y(() => {
    v && g && (x !== null && google.maps.event.removeListener(x), M(google.maps.event.addListener(v, "click", g)));
  }, [g]), y(() => {
    v && h && ($ !== null && google.maps.event.removeListener($), B(google.maps.event.addListener(v, "drag", h)));
  }, [h]), y(() => {
    v && C && (V !== null && google.maps.event.removeListener(V), F(google.maps.event.addListener(v, "bounds_changed", C)));
  }, [C]), y(() => {
    var J = new google.maps.Rectangle(au(au({}, t), {}, {
      map: E
    }));
    return typeof i < "u" && J.setVisible(i), typeof o < "u" && J.setEditable(o), typeof r < "u" && J.setDraggable(r), typeof n < "u" && J.setBounds(n), s && W(google.maps.event.addListener(J, "dblclick", s)), a && N(google.maps.event.addListener(J, "dragend", a)), l && R(google.maps.event.addListener(J, "dragstart", l)), u && z(google.maps.event.addListener(J, "mousedown", u)), c && K(google.maps.event.addListener(J, "mousemove", c)), d && ne(google.maps.event.addListener(J, "mouseout", d)), p && S(google.maps.event.addListener(J, "mouseover", p)), m && Z(google.maps.event.addListener(J, "mouseup", m)), f && Y(google.maps.event.addListener(J, "rightclick", f)), g && M(google.maps.event.addListener(J, "click", g)), h && B(google.maps.event.addListener(J, "drag", h)), C && F(google.maps.event.addListener(J, "bounds_changed", C)), O(J), w && w(J), () => {
      L !== null && google.maps.event.removeListener(L), D !== null && google.maps.event.removeListener(D), _ !== null && google.maps.event.removeListener(_), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), x !== null && google.maps.event.removeListener(x), $ !== null && google.maps.event.removeListener($), V !== null && google.maps.event.removeListener(V), k && k(J), J.setMap(null);
    };
  }, []), null;
}
Me(HU);
class qU extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      rectangle: null
    }), ce(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(au(au({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pt({
      updaterMap: gw,
      eventMap: hw,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: gw,
      eventMap: hw,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), ht(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ce(qU, "contextType", Xe);
function mw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mw(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vw = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, yw = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, GU = {};
function ZU(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onCenterChanged: w,
    onRadiusChanged: k,
    onLoad: E,
    onUnmount: v
  } = e, O = Oe(Xe), [L, W] = P(null), [D, N] = P(null), [_, R] = P(null), [U, z] = P(null), [q, K] = P(null), [X, ne] = P(null), [Q, S] = P(null), [I, Z] = P(null), [T, Y] = P(null), [x, M] = P(null), [$, B] = P(null), [V, F] = P(null), [J, G] = P(null), [fe, be] = P(null);
  return y(() => {
    L !== null && L.setMap(O);
  }, [O]), y(() => {
    typeof t < "u" && L !== null && L.setOptions(t);
  }, [L, t]), y(() => {
    typeof o < "u" && L !== null && L.setDraggable(o);
  }, [L, o]), y(() => {
    typeof i < "u" && L !== null && L.setEditable(i);
  }, [L, i]), y(() => {
    typeof s < "u" && L !== null && L.setVisible(s);
  }, [L, s]), y(() => {
    typeof r == "number" && L !== null && L.setRadius(r);
  }, [L, r]), y(() => {
    typeof n < "u" && L !== null && L.setCenter(n);
  }, [L, n]), y(() => {
    L && a && (D !== null && google.maps.event.removeListener(D), N(google.maps.event.addListener(L, "dblclick", a)));
  }, [a]), y(() => {
    L && l && (_ !== null && google.maps.event.removeListener(_), R(google.maps.event.addListener(L, "dragend", l)));
  }, [l]), y(() => {
    L && u && (U !== null && google.maps.event.removeListener(U), z(google.maps.event.addListener(L, "dragstart", u)));
  }, [u]), y(() => {
    L && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(L, "mousedown", c)));
  }, [c]), y(() => {
    L && d && (X !== null && google.maps.event.removeListener(X), ne(google.maps.event.addListener(L, "mousemove", d)));
  }, [d]), y(() => {
    L && p && (Q !== null && google.maps.event.removeListener(Q), S(google.maps.event.addListener(L, "mouseout", p)));
  }, [p]), y(() => {
    L && m && (I !== null && google.maps.event.removeListener(I), Z(google.maps.event.addListener(L, "mouseover", m)));
  }, [m]), y(() => {
    L && f && (T !== null && google.maps.event.removeListener(T), Y(google.maps.event.addListener(L, "mouseup", f)));
  }, [f]), y(() => {
    L && g && (x !== null && google.maps.event.removeListener(x), M(google.maps.event.addListener(L, "rightclick", g)));
  }, [g]), y(() => {
    L && h && ($ !== null && google.maps.event.removeListener($), B(google.maps.event.addListener(L, "click", h)));
  }, [h]), y(() => {
    L && C && (V !== null && google.maps.event.removeListener(V), F(google.maps.event.addListener(L, "drag", C)));
  }, [C]), y(() => {
    L && w && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(L, "center_changed", w)));
  }, [h]), y(() => {
    L && k && (fe !== null && google.maps.event.removeListener(fe), be(google.maps.event.addListener(L, "radius_changed", k)));
  }, [k]), y(() => {
    var re = new google.maps.Circle(lu(lu({}, t || GU), {}, {
      map: O
    }));
    return typeof r == "number" && re.setRadius(r), typeof n < "u" && re.setCenter(n), typeof r == "number" && re.setRadius(r), typeof s < "u" && re.setVisible(s), typeof i < "u" && re.setEditable(i), typeof o < "u" && re.setDraggable(o), a && N(google.maps.event.addListener(re, "dblclick", a)), l && R(google.maps.event.addListener(re, "dragend", l)), u && z(google.maps.event.addListener(re, "dragstart", u)), c && K(google.maps.event.addListener(re, "mousedown", c)), d && ne(google.maps.event.addListener(re, "mousemove", d)), p && S(google.maps.event.addListener(re, "mouseout", p)), m && Z(google.maps.event.addListener(re, "mouseover", m)), f && Y(google.maps.event.addListener(re, "mouseup", f)), g && M(google.maps.event.addListener(re, "rightclick", g)), h && B(google.maps.event.addListener(re, "click", h)), C && F(google.maps.event.addListener(re, "drag", C)), w && G(google.maps.event.addListener(re, "center_changed", w)), k && be(google.maps.event.addListener(re, "radius_changed", k)), W(re), E && E(re), () => {
      D !== null && google.maps.event.removeListener(D), _ !== null && google.maps.event.removeListener(_), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), x !== null && google.maps.event.removeListener(x), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), fe !== null && google.maps.event.removeListener(fe), v && v(re), re.setMap(null);
    };
  }, []), null;
}
Me(ZU);
class YU extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      circle: null
    }), ce(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(lu(lu({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pt({
      updaterMap: yw,
      eventMap: vw,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: yw,
      eventMap: vw,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), ht(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ce(YU, "contextType", Xe);
function bw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bw(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ww = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, Cw = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function XU(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: d,
    onRemoveProperty: p,
    onSetGeometry: m,
    onSetProperty: f,
    onLoad: g,
    onUnmount: h
  } = e, C = Oe(Xe), [w, k] = P(null), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null), [N, _] = P(null), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null), [Z, T] = P(null), [Y, x] = P(null), [M, $] = P(null), [B, V] = P(null);
  return y(() => {
    w !== null && w.setMap(C);
  }, [C]), y(() => {
    w && r && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), y(() => {
    w && o && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), y(() => {
    w && i && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), y(() => {
    w && s && (N !== null && google.maps.event.removeListener(N), _(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), y(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), y(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), y(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), y(() => {
    w && n && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(w, "click", n)));
  }, [n]), y(() => {
    w && c && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), y(() => {
    w && d && (Z !== null && google.maps.event.removeListener(Z), T(google.maps.event.addListener(w, "removefeature", d)));
  }, [d]), y(() => {
    w && p && (Y !== null && google.maps.event.removeListener(Y), x(google.maps.event.addListener(w, "removeproperty", p)));
  }, [p]), y(() => {
    w && m && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(w, "setgeometry", m)));
  }, [m]), y(() => {
    w && f && (B !== null && google.maps.event.removeListener(B), V(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), y(() => {
    if (C !== null) {
      var F = new google.maps.Data(uu(uu({}, t), {}, {
        map: C
      }));
      r && v(google.maps.event.addListener(F, "dblclick", r)), o && L(google.maps.event.addListener(F, "mousedown", o)), i && D(google.maps.event.addListener(F, "mousemove", i)), s && _(google.maps.event.addListener(F, "mouseout", s)), a && U(google.maps.event.addListener(F, "mouseover", a)), l && q(google.maps.event.addListener(F, "mouseup", l)), u && X(google.maps.event.addListener(F, "rightclick", u)), n && Q(google.maps.event.addListener(F, "click", n)), c && I(google.maps.event.addListener(F, "addfeature", c)), d && T(google.maps.event.addListener(F, "removefeature", d)), p && x(google.maps.event.addListener(F, "removeproperty", p)), m && $(google.maps.event.addListener(F, "setgeometry", m)), f && V(google.maps.event.addListener(F, "setproperty", f)), k(F), g && g(F);
    }
    return () => {
      w && (E !== null && google.maps.event.removeListener(E), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), N !== null && google.maps.event.removeListener(N), R !== null && google.maps.event.removeListener(R), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), ne !== null && google.maps.event.removeListener(ne), S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), B !== null && google.maps.event.removeListener(B), h && h(w), w.setMap(null));
    };
  }, []), null;
}
Me(XU);
class KU extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      data: null
    }), ce(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(uu(uu({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = pt({
        updaterMap: Cw,
        eventMap: ww,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: Cw,
      eventMap: ww,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), ht(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ce(KU, "contextType", Xe);
function Ew(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ow(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ew(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ew(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xw = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Dw = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class JU extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      kmlLayer: null
    }), ce(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(Ow(Ow({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pt({
      updaterMap: Dw,
      eventMap: xw,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: Dw,
      eventMap: xw,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), ht(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ce(JU, "contextType", Xe);
function eL(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function QU(e, t) {
  return new t(e.lat, e.lng);
}
function e9(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function t9(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function n9(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function r9(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function o9(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function tL(e, t, n, r) {
  return n !== void 0 ? r9(e, t, n9(n, google.maps.LatLngBounds, e9)) : o9(e, t, t9(r, google.maps.LatLng, QU));
}
function i9(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function Lw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function s9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Lw(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Lw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function a9(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = s9({}, this.container ? eL(this.container, o) : {
        x: 0,
        y: 0
      }), u = tL(a, l, this.bounds, this.position);
      for (var [c, d] of Object.entries(u))
        this.container.style[c] = d;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function Pw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function l9(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Pw(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Pw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Sw(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function kw(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function u9(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = Oe(Xe), c = Mn(() => {
    var p = document.createElement("div");
    return p.style.position = "absolute", p;
  }, []), d = Mn(() => a9(c, r, t, n, a), [c, r, t, n]);
  return y(() => (i == null || i(d), d == null || d.setMap(u), () => {
    s == null || s(d), d == null || d.setMap(null);
  }), [u, d]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), xi.createPortal(l, c);
}
Me(u9);
class Ai extends Ee {
  constructor(t) {
    super(t), ce(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ce(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      xn(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ce(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ce(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = l9({
        x: 0,
        y: 0
      }, this.containerRef.current ? eL(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = tL(r, o, this.props.bounds, this.props.position);
      if (!i9(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ce(this, "draw", () => {
      this.onPositionElement();
    }), ce(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = mr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = Sw(t.position), r = Sw(this.props.position), o = kw(t.bounds), i = kw(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? xi.createPortal(At.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: Ft.only(this.props.children)
    }), t) : null;
  }
}
ce(Ai, "FLOAT_PANE", "floatPane");
ce(Ai, "MAP_PANE", "mapPane");
ce(Ai, "MARKER_LAYER", "markerLayer");
ce(Ai, "OVERLAY_LAYER", "overlayLayer");
ce(Ai, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ce(Ai, "contextType", Xe);
function c9() {
}
function Mw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Aw(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Mw(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Mw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Tw = {
  onDblClick: "dblclick",
  onClick: "click"
}, Bw = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function d9(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = Oe(Xe), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Mn(() => new google.maps.GroundOverlay(t, s, r), []);
  return y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), y(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Me(d9);
class nL extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      groundOverlay: null
    }), ce(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    xn(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Aw(Aw({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pt({
      updaterMap: Bw,
      eventMap: Tw,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: Bw,
      eventMap: Tw,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ce(nL, "defaultProps", {
  onLoad: c9
});
ce(nL, "contextType", Xe);
function jw(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jw(Object(n), !0).forEach(function(r) {
      ce(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jw(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _w = {}, Iw = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function p9(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = Oe(Xe), [s, a] = P(null);
  return y(() => {
    google.maps.visualization || xn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    xn(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer(cu(cu({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Me(p9);
class f9 extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      heatmapLayer: null
    }), ce(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    xn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), xn(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(cu(cu({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = pt({
      updaterMap: Iw,
      eventMap: _w,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: Iw,
      eventMap: _w,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), ht(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ce(f9, "contextType", Xe);
var Fw = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, Rw = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class h9 extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      streetViewPanorama: null
    }), ce(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = pt({
      updaterMap: Rw,
      eventMap: Fw,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: Rw,
      eventMap: Fw,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), ht(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ce(h9, "contextType", Xe);
class g9 extends Ee {
  constructor() {
    super(...arguments), ce(this, "state", {
      streetViewService: null
    }), ce(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ce(g9, "contextType", Xe);
var Nw = {
  onDirectionsChanged: "directions_changed"
}, zw = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class m9 extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "state", {
      directionsRenderer: null
    }), ce(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = pt({
      updaterMap: zw,
      eventMap: Nw,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: zw,
      eventMap: Nw,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), ht(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ce(m9, "contextType", Xe);
var $w = {
  onPlacesChanged: "places_changed"
}, Uw = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class v9 extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "containerElement", mr()), ce(this, "state", {
      searchBox: null
    }), ce(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (xn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = pt({
          updaterMap: Uw,
          eventMap: $w,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: Uw,
      eventMap: $w,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), ht(this.registeredEvents));
  }
  render() {
    return At.jsx("div", {
      ref: this.containerElement,
      children: Ft.only(this.props.children)
    });
  }
}
ce(v9, "contextType", Xe);
var Ww = {
  onPlaceChanged: "place_changed"
}, Vw = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class rL extends Ee {
  constructor() {
    super(...arguments), ce(this, "registeredEvents", []), ce(this, "containerElement", mr()), ce(this, "state", {
      autocomplete: null
    }), ce(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    xn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = pt({
        updaterMap: Vw,
        eventMap: Ww,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    ht(this.registeredEvents), this.registeredEvents = pt({
      updaterMap: Vw,
      eventMap: Ww,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && ht(this.registeredEvents);
  }
  render() {
    return At.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: Ft.only(this.props.children)
    });
  }
}
ce(rL, "defaultProps", {
  className: ""
});
ce(rL, "contextType", Xe);
let y9 = { data: "" }, b9 = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || y9, w9 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, C9 = /\/\*[^]*?\*\/|  +/g, Hw = /\n+/g, go = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? go(s, i) : i + "{" + go(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += go(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += go.p ? go.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Rr = {}, oL = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + oL(e[n]);
    return t;
  }
  return e;
}, E9 = (e, t, n, r, o) => {
  let i = oL(e), s = Rr[i] || (Rr[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Rr[s]) {
    let l = i !== e ? e : ((u) => {
      let c, d, p = [{}];
      for (; c = w9.exec(u.replace(C9, "")); ) c[4] ? p.shift() : c[3] ? (d = c[3].replace(Hw, " ").trim(), p.unshift(p[0][d] = p[0][d] || {})) : p[0][c[1]] = c[2].replace(Hw, " ").trim();
      return p[0];
    })(e);
    Rr[s] = go(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Rr.g ? Rr.g : null;
  return n && (Rr.g = Rr[s]), ((l, u, c, d) => {
    d ? u.data = u.data.replace(d, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Rr[s], t, r, a), s;
}, O9 = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : go(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Dc(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return E9(n.unshift ? n.raw ? O9(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, b9(t.target), t.g, t.o, t.k);
}
let iL, nf, rf;
Dc.bind({ g: 1 });
let Hr = Dc.bind({ k: 1 });
function x9(e, t, n, r) {
  go.p = t, iL = e, nf = n, rf = r;
}
function So(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: nf && nf() }, a), n.o = / *go\d+/.test(l), a.className = Dc.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), rf && u[0] && rf(a), iL(u, a);
    }
    return o;
  };
}
var D9 = (e) => typeof e == "function", L9 = (e, t) => D9(e) ? e(t) : e, P9 = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), S9 = Hr`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, k9 = Hr`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, M9 = Hr`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, A9 = So("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${S9} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${k9} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${M9} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, T9 = Hr`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, B9 = So("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${T9} 1s linear infinite;
`, j9 = Hr`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, _9 = Hr`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, I9 = So("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${j9} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${_9} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, F9 = So("div")`
  position: absolute;
`, R9 = So("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, N9 = Hr`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, z9 = So("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${N9} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, $9 = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ve.createElement(z9, null, t) : t : n === "blank" ? null : Ve.createElement(R9, null, Ve.createElement(B9, { ...r }), n !== "loading" && Ve.createElement(F9, null, n === "error" ? Ve.createElement(A9, { ...r }) : Ve.createElement(I9, { ...r })));
}, U9 = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, W9 = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, V9 = "0%{opacity:0;} 100%{opacity:1;}", H9 = "0%{opacity:1;} 100%{opacity:0;}", q9 = So("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, G9 = So("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Z9 = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = P9() ? [V9, H9] : [U9(n), W9(n)];
  return { animation: t ? `${Hr(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Hr(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ve.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Z9(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ve.createElement($9, { toast: e }), s = Ve.createElement(G9, { ...e.ariaProps }, L9(e.message, e));
  return Ve.createElement(q9, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ve.createElement(Ve.Fragment, null, i, s));
});
x9(Ve.createElement);
Dc`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function Y9(e) {
  const { error: t } = e, n = "arkynAudioUploadError";
  return t ? /* @__PURE__ */ j.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ j.jsx(j.Fragment, {});
}
function X9(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ j.jsx("strong", { className: o.trim(), children: t });
}
function K9(e) {
  const { onChange: t, value: n, disableDrag: r = !1, onDragging: o } = e, [i, s] = P(!1), a = qe(null), l = () => {
    s(!0);
  }, u = () => {
    s(!1);
  }, c = (f) => {
    if (r || !i || !a.current) return;
    const g = a.current.getBoundingClientRect(), h = f.clientX - g.left, C = Math.min(Math.max(h / g.width * 100, 0), 100);
    t(C);
  }, d = (f) => {
    if (!a.current) return;
    const g = a.current.getBoundingClientRect(), h = f.clientX - g.left, C = Math.min(Math.max(h / g.width * 100, 0), 100);
    t(C);
  };
  y(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const m = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ j.jsxs(
    "div",
    {
      className: m,
      ref: a,
      onMouseDown: l,
      onClick: d,
      children: [
        /* @__PURE__ */ j.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ j.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function J9(e) {
  var L, W, D, N;
  const {
    filePath: t,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: s,
    changeAudioButtonText: a
  } = e, [l, u] = P(0), c = qe(null), [d, p] = P(!1), [m, f] = P(!1);
  y(() => {
    const _ = c.current;
    if (!_) return;
    const R = () => {
      const U = _.duration, q = _.currentTime / U * 100;
      u(q);
    };
    return _.addEventListener("timeupdate", R), () => {
      _.removeEventListener("timeupdate", R);
    };
  }, []);
  function g(_) {
    const R = c.current;
    if (!R) return;
    const U = R.duration, z = _ / 100 * U;
    R.currentTime = z;
  }
  function h() {
    var _;
    (_ = c.current) == null || _.play(), f(!0);
  }
  function C() {
    var _;
    (_ = c.current) == null || _.pause(), f(!1);
  }
  function w() {
    m ? C() : h();
  }
  const k = (L = c.current) == null ? void 0 : L.currentTime, E = (W = c.current) == null ? void 0 : W.duration;
  function v(_) {
    if (!_) return "00:00";
    const R = Math.floor(_ / 60), U = Math.floor(_ % 60), z = String(R).padStart(2, "0"), q = String(U).padStart(2, "0");
    return `${z}:${q}`;
  }
  d || !m ? (D = c.current) == null || D.pause() : m && ((N = c.current) == null || N.play());
  function O() {
    if (n) return;
    const _ = document.createElement("input");
    _.type = "file", _.accept = r, _.onchange = (R) => {
      var z;
      const U = (z = R.target.files) == null ? void 0 : z[0];
      U && o(U);
    }, _.click();
  }
  return /* @__PURE__ */ j.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ j.jsx("audio", { ref: c, src: t, onEnded: C }),
    /* @__PURE__ */ j.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ j.jsxs("button", { type: "button", onClick: w, children: [
        m && /* @__PURE__ */ j.jsx(KP, {}),
        !m && /* @__PURE__ */ j.jsx(JP, {})
      ] }),
      /* @__PURE__ */ j.jsx("p", { children: v(k) }),
      /* @__PURE__ */ j.jsx(
        K9,
        {
          value: l,
          onChange: g,
          onDragging: p
        }
      ),
      /* @__PURE__ */ j.jsx("p", { children: v(E) })
    ] }),
    /* @__PURE__ */ j.jsx(IB, {}),
    /* @__PURE__ */ j.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!s && /* @__PURE__ */ j.jsx(j2, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ j.jsx(
        B2,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: s,
          icon: _E,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ j.jsx(
        fD,
        {
          isLoading: i,
          onClick: O,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: a
        }
      )
    ] })
  ] });
}
function Q9(e) {
  const {
    dropAudioText: t,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: s
  } = e;
  function a(u) {
    if (s) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (s) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var p;
      const d = (p = c.target.files) == null ? void 0 : p[0];
      d && o(d);
    }, u.click();
  }
  return /* @__PURE__ */ j.jsxs("div", { onDrop: a, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ j.jsx(
      fD,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: s,
        children: i
      }
    ),
    /* @__PURE__ */ j.jsx("p", { children: t })
  ] });
}
function pG(e) {
  const {
    name: t,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: s = "url",
    selectAudioButtonText: a = "Selecionar arquivo de áudio",
    dropAudioText: l = "Ou arraste e solte um arquivo de áudio aqui",
    changeAudioButtonText: u = "Trocar arquivo de áudio",
    acceptAudio: c = "audio/*",
    action: d,
    defaultValue: p = "",
    showAsterisk: m = !1,
    disabled: f = !1
  } = e, h = T2()[t], [C, w] = P(p), [k, E] = P(""), [v, O] = P(null), [L, W] = P(p), [D, N] = P(!1);
  async function _(X) {
    if (f) return;
    N(!0), O(X), E("");
    const ne = new FormData();
    ne.append(r, X), await fetch(d, { method: o, body: ne }).then(async (Q) => await Q.json()).then((Q) => {
      Q != null && Q.error ? E(Q.error) : w(Q == null ? void 0 : Q[s]), i && i(Q == null ? void 0 : Q[s]);
    }).catch((Q) => {
      console.error(Q), E("Erro ao enviar audio");
    }).finally(() => N(!1));
  }
  function R(X) {
    if (!f) {
      if (console.log(X.type), X.type.indexOf("audio") === -1) {
        E("O arquivo selecionado não é um arquivo de áudio");
        return;
      }
      W(URL.createObjectURL(X)), _(X);
    }
  }
  const U = h || k, K = `arkynAudioUpload ${U ? "hasError" : "noHasError"} ${L ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ j.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ j.jsx(X9, { label: n, showAsterisk: m }),
    /* @__PURE__ */ j.jsxs("div", { className: K, children: [
      /* @__PURE__ */ j.jsx("input", { type: "hidden", name: t, value: C || "" }),
      !L && /* @__PURE__ */ j.jsx(
        Q9,
        {
          disabled: f,
          isLoading: D,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: R,
          selectAudioButtonText: a
        }
      ),
      L && /* @__PURE__ */ j.jsx(
        J9,
        {
          filePath: L,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: f,
          handleSelectFile: R,
          isLoading: D,
          reSendAudio: U && v ? () => _(v) : void 0
        }
      )
    ] }),
    U && /* @__PURE__ */ j.jsx(Y9, { error: U })
  ] });
}
function du(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    disabled: l,
    className: u = "",
    children: c,
    ...d
  } = e, m = { xs: 12, sm: 16, md: 20, lg: 24 }[i], h = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ j.jsxs("button", { className: h, disabled: l || t, ...d, children: [
    /* @__PURE__ */ j.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ j.jsx(Mr, { size: m, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ j.jsxs("div", { className: "arkynButtonContent", children: [
      Ll(m, s),
      c,
      Ll(m, a)
    ] })
  ] });
}
function sL() {
  const e = Pf(), t = RE(), n = NE(), [r, o] = P(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function s() {
    r && o(null);
  }
  y(() => {
    var c, d;
    let u = ((d = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : d.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), y(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && s();
  }, [n, t]);
  const a = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(a || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const aL = Ze({});
function qw(e) {
  var d;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = sL(), s = qe(null), a = ((d = s.current) == null ? void 0 : d.name) || "", l = (i == null ? void 0 : i[a]) || null, u = qP(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ j.jsx(aL.Provider, { value: { error: l, id: u, inputRef: s }, children: /* @__PURE__ */ j.jsx(
    "section",
    {
      id: r || a || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function Jn() {
  return Oe(aL);
}
function fG(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: s = null,
    onCheck: a,
    value: l,
    ...u
  } = e, { id: c, inputRef: d, error: p } = Jn(), m = o || !!p, [f, g] = P(i || !1), h = typeof s == "boolean" ? s : f, k = `arkynCheckbox ${r} ${m ? "errorTrue" : "errorFalse"} ${h ? "checkedTrue" : "checkedFalse"} ${n}`;
  function E() {
    const v = f;
    g(!v), a && a(v ? "" : l || "checked");
  }
  return /* @__PURE__ */ j.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: k,
      onClick: E,
      ...u,
      children: [
        /* @__PURE__ */ j.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: d,
            value: h ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ j.jsx(Df, {})
      ]
    }
  );
}
function hG(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = Jn();
  return t ? /* @__PURE__ */ j.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ j.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ j.jsx(j.Fragment, {});
}
function Gw(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = Jn(), s = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ j.jsx("label", { className: s.trim(), htmlFor: o, ...r });
}
function eW(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: s,
    className: a = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, d = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${a}`;
  return /* @__PURE__ */ j.jsxs(
    "button",
    {
      disabled: s || t,
      className: d.trim(),
      ...l,
      children: [
        /* @__PURE__ */ j.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ j.jsx(Mr, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ j.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ j.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function tW(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...s
  } = e, a = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ j.jsxs("div", { className: a.trim(), ...s, children: [
    r,
    /* @__PURE__ */ j.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function nW(e) {
  const {
    disabled: t,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: s,
    reSendImage: a
  } = e;
  function l() {
    if (t) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var p;
      const d = (p = c.target.files) == null ? void 0 : p[0];
      d && s(d);
    }, u.click();
  }
  return /* @__PURE__ */ j.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        a && /* @__PURE__ */ j.jsx(tW, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ j.jsx(
          eW,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: a,
            icon: _E,
            disabled: t
          }
        ) }),
        /* @__PURE__ */ j.jsx(
          du,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: t,
            children: i
          }
        )
      ]
    }
  );
}
function rW(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ j.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ j.jsx(j.Fragment, {});
}
function oW(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ j.jsx("strong", { className: o.trim(), children: t });
}
function iW(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: s
  } = e;
  function a(u) {
    if (s) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (s) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var p;
      const d = (p = c.target.files) == null ? void 0 : p[0];
      d && o(d);
    }, u.click();
  }
  return /* @__PURE__ */ j.jsxs("div", { onDrop: a, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ j.jsx(
      du,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: s,
        children: i
      }
    ),
    /* @__PURE__ */ j.jsx("p", { children: t })
  ] });
}
function sW(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: s = "file",
    method: a = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: d = "Selecionar imagem",
    dropImageText: p = "Ou arraste e solte a imagem aqui",
    onUpload: m,
    disabled: f = !1
  } = e, h = sL()[t], [C, w] = P(n), [k, E] = P(""), [v, O] = P(null), [L, W] = P(n), [D, N] = P(!1);
  async function _(X) {
    if (f) return;
    N(!0), O(X), E("");
    const ne = new FormData();
    ne.append(s, X), await fetch(i, { method: a, body: ne }).then(async (Q) => await Q.json()).then((Q) => {
      Q != null && Q.error ? E(Q.error) : w(Q == null ? void 0 : Q[u]), m && m(Q == null ? void 0 : Q[u]);
    }).catch((Q) => {
      console.error(Q), E("Erro ao enviar imagem");
    }).finally(() => N(!1));
  }
  function R(X) {
    f || (W(URL.createObjectURL(X)), _(X));
  }
  const U = h || k, K = `arkynImageUpload ${U ? "hasError" : "noHasError"} ${L ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ j.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ j.jsx(oW, { label: r, showAsterisk: o }),
    /* @__PURE__ */ j.jsxs("div", { className: K, children: [
      /* @__PURE__ */ j.jsx("input", { type: "hidden", name: t, value: C || "" }),
      !L && /* @__PURE__ */ j.jsx(
        iW,
        {
          disabled: f,
          isLoading: D,
          acceptImage: l,
          dropImageText: p,
          handleSelectFile: R,
          selectImageButtonText: d
        }
      ),
      L && /* @__PURE__ */ j.jsx(
        nW,
        {
          disabled: f,
          isLoading: D,
          acceptImage: l,
          filePath: L,
          handleSelectFile: R,
          changeImageButtonText: c,
          reSendImage: U && v ? () => _(v) : void 0
        }
      )
    ] }),
    U && /* @__PURE__ */ j.jsx(rW, { error: U })
  ] });
}
function bo(e, t, n) {
  if (!e) return /* @__PURE__ */ j.jsx(j.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ j.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ j.jsx("p", { className: n, children: /* @__PURE__ */ j.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function Qh(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function lL(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function uL(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const eg = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, cL = Qh(eg.CNPJ).length;
function aW(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: d,
    defaultValue: p,
    readOnly: m,
    onFocus: f,
    onBlur: g,
    title: h,
    style: C,
    onChange: w,
    ...k
  } = e;
  function E(z) {
    let q = Qh(z);
    const K = uL(q);
    if (!(q.length > cL))
      return q = lL(q, eg[K]), q;
  }
  const v = c ? "right" : "left", _ = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${d || m || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, U = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: _,
    prefix: bo(a, U, "prefix"),
    sufix: bo(l, U, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: E(p || ""),
    disabled: d,
    readOnly: m,
    onFocus: f,
    onBlur: g,
    title: h,
    style: C,
    onChange: w,
    loadingPosition: v,
    iconSize: U,
    Spinner: /* @__PURE__ */ j.jsx(Mr, { className: "spinner", size: U, strokeWidth: 2.5 }),
    ...k
  };
}
function lW(e) {
  const [t, n] = P(!1), r = qe(null), { inputRef: o, id: i, error: s } = Jn(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: d,
    className: p,
    prefix: m,
    sufix: f,
    iconSize: g,
    loadingPosition: h,
    isLoading: C,
    LeftIcon: w,
    readOnly: k,
    onFocus: E,
    onBlur: v,
    RightIcon: O,
    Spinner: L,
    onChange: W,
    value: D,
    defaultValue: N,
    ..._
  } = aW({ ...e, id: i, isError: l }, t), [R, U] = P(N), z = w && !C, q = O && !C, K = h === "left" && C, X = h === "right" && C;
  function ne() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function Q(Z) {
    let T = Qh(Z.target.value);
    const Y = uL(T);
    T.length > cL || (T = lL(T, eg[Y]), Z.target.value = T, U(T), W && W(Z));
  }
  function S(Z) {
    n(!0), E && E(Z);
  }
  function I(Z) {
    n(!1), v && v(Z);
  }
  return /* @__PURE__ */ j.jsxs(
    "section",
    {
      title: c,
      style: d,
      onClick: ne,
      className: p,
      children: [
        m,
        K && L,
        z && /* @__PURE__ */ j.jsx(w, { size: g, strokeWidth: 2.5 }),
        /* @__PURE__ */ j.jsx(
          "input",
          {
            disabled: u || C,
            readOnly: k,
            ref: a,
            value: D || R,
            onFocus: S,
            onChange: Q,
            onBlur: I,
            ..._
          }
        ),
        q && /* @__PURE__ */ j.jsx(O, { size: g, strokeWidth: 2.5 }),
        X && L,
        f
      ]
    }
  );
}
const uW = 3, cW = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? uW : 0), Ka = 2, Zw = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), of = (e) => {
  let t = e;
  return typeof e == "string" ? (t = Zw(e), t % 1 !== 0 && (t = t.toFixed(Ka))) : t = Number.isInteger(e) ? Number(e) * 10 ** Ka : e.toFixed(Ka), Zw(t) / 10 ** Ka;
}, Yw = (e, t, n) => {
  if (!t) return [0, ""];
  const r = of(t), o = cW(e, r, n);
  return [r, o];
};
function dW(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: d,
    readOnly: p,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    // showCents = false,
    max: C = 1e9,
    locale: w = "pt-BR",
    currency: k = "BRL",
    ...E
  } = e, v = c ? "right" : "left", _ = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${d || p || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, U = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: _,
    prefix: bo(a, U, "prefix"),
    sufix: bo(l, U, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: d,
    locale: w,
    currency: k,
    readOnly: p,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    max: C,
    // showCents,
    loadingPosition: v,
    iconSize: U,
    Spinner: /* @__PURE__ */ j.jsx(Mr, { className: "spinner", size: U, strokeWidth: 2.5 }),
    ...E
  };
}
function pW(e) {
  const [t, n] = P(!1), [r, o] = P("0"), i = qe(null), { inputRef: s, id: a, error: l } = Jn(), u = s || i, c = e.isError || !!l, {
    disabled: d,
    title: p,
    style: m,
    className: f,
    prefix: g,
    sufix: h,
    iconSize: C,
    loadingPosition: w,
    isLoading: k,
    LeftIcon: E,
    readOnly: v,
    onFocus: O,
    onBlur: L,
    RightIcon: W,
    Spinner: D,
    value: N,
    max: _,
    onChangeValue: R,
    onKeyPress: U,
    currency: z,
    locale: q,
    name: K,
    defaultValue: X,
    ...ne
  } = dW({ ...e, id: a, isError: c }, t), Q = E && !k, S = W && !k, I = w === "left" && k, Z = w === "right" && k;
  function T() {
    d || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function Y(V) {
    n(!0), O && O(V);
  }
  function x(V) {
    n(!1), L && L(V);
  }
  const M = (V) => {
    const [F, J] = Yw(
      q,
      V,
      z
    );
    return !_ || F <= _ ? (o(J), [F, J]) : [of(r), r];
  }, $ = (V) => {
    V.preventDefault();
    const [F, J] = M(V.target.value);
    R && R(V, String(F), String(J));
  }, B = (V) => U && U(V, V.key, V.key);
  return y(() => {
    const V = N || +X || void 0, [, F] = Yw(q, V, z);
    o(F);
  }, [z, X, N]), /* @__PURE__ */ j.jsxs(
    "section",
    {
      title: p,
      style: m,
      onClick: T,
      className: f,
      children: [
        g,
        I && D,
        Q && /* @__PURE__ */ j.jsx(E, { size: C, strokeWidth: 2.5 }),
        /* @__PURE__ */ j.jsx(
          "input",
          {
            value: r,
            onChange: $,
            onBlur: x,
            onFocus: Y,
            onKeyUp: B,
            disabled: d || k,
            readOnly: v,
            ...ne
          }
        ),
        /* @__PURE__ */ j.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: K,
            value: of(r)
          }
        ),
        Z && D,
        S && /* @__PURE__ */ j.jsx(W, { size: C, strokeWidth: 2.5 }),
        h
      ]
    }
  );
}
function fW(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: d,
    readOnly: p,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    onChange: C,
    showMask: w = !1,
    type: k,
    ...E
  } = e, v = c ? "right" : "left", _ = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${d || p || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, U = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: _,
    prefix: bo(a, U, "prefix"),
    sufix: bo(l, U, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: d,
    readOnly: p,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    onChange: C,
    loadingPosition: v,
    iconSize: U,
    showMask: w,
    Spinner: /* @__PURE__ */ j.jsx(Mr, { className: "spinner", size: U, strokeWidth: 2.5 }),
    ...E
  };
}
const hW = Hs((e, t) => /* @__PURE__ */ j.jsx("input", { ref: t, ...e }));
function gW(e) {
  const [t, n] = P(!1), r = qe(null), { inputRef: o, id: i, error: s } = Jn(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: d,
    className: p,
    prefix: m,
    sufix: f,
    iconSize: g,
    loadingPosition: h,
    isLoading: C,
    LeftIcon: w,
    readOnly: k,
    onFocus: E,
    onBlur: v,
    RightIcon: O,
    Spinner: L,
    ...W
  } = fW({ ...e, id: i, isError: l }, t), D = w && !C, N = O && !C, _ = h === "left" && C, R = h === "right" && C;
  function U() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function z(K) {
    n(!0), E && E(K);
  }
  function q(K) {
    n(!1), v && v(K);
  }
  return /* @__PURE__ */ j.jsxs(
    "section",
    {
      title: c,
      style: d,
      onClick: U,
      className: p,
      children: [
        m,
        _ && L,
        D && /* @__PURE__ */ j.jsx(w, { size: g, strokeWidth: 2.5 }),
        /* @__PURE__ */ j.jsx(
          hS,
          {
            component: hW,
            ref: a,
            onFocus: z,
            onBlur: q,
            disabled: u,
            ...W
          }
        ),
        N && /* @__PURE__ */ j.jsx(O, { size: g, strokeWidth: 2.5 }),
        R && L,
        f
      ]
    }
  );
}
function mW(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: d,
    readOnly: p,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    onChange: C,
    ...w
  } = e, k = c ? "right" : "left", D = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${d || p || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, _ = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: D,
    prefix: bo(a, _, "prefix"),
    sufix: bo(l, _, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: d,
    readOnly: p,
    onFocus: m,
    onBlur: f,
    title: g,
    style: h,
    onChange: C,
    loadingPosition: k,
    iconSize: _,
    Spinner: /* @__PURE__ */ j.jsx(Mr, { className: "spinner", size: _, strokeWidth: 2.5 }),
    ...w
  };
}
function vW(e) {
  const [t, n] = P(!1), r = qe(null), { inputRef: o, id: i, error: s } = Jn(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: d,
    className: p,
    prefix: m,
    sufix: f,
    iconSize: g,
    loadingPosition: h,
    isLoading: C,
    LeftIcon: w,
    readOnly: k,
    onFocus: E,
    onBlur: v,
    RightIcon: O,
    type: L,
    Spinner: W,
    ...D
  } = mW({ ...e, id: i, isError: l }, t), N = w && !C, _ = O && !C, R = h === "left" && C, U = h === "right" && C;
  function z() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function q(X) {
    n(!0), E && E(X);
  }
  function K(X) {
    n(!1), v && v(X);
  }
  return L === "hidden" ? /* @__PURE__ */ j.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: a,
      ...D
    }
  ) : /* @__PURE__ */ j.jsxs(
    "section",
    {
      title: c,
      style: d,
      onClick: z,
      className: p,
      children: [
        m,
        R && W,
        N && /* @__PURE__ */ j.jsx(w, { size: g, strokeWidth: 2.5 }),
        /* @__PURE__ */ j.jsx(
          "input",
          {
            disabled: u || C,
            readOnly: k,
            ref: a,
            onFocus: q,
            onBlur: K,
            type: L,
            ...D
          }
        ),
        _ && /* @__PURE__ */ j.jsx(O, { size: g, strokeWidth: 2.5 }),
        U && W,
        f
      ]
    }
  );
}
function Lc(e) {
  return e.type === "currency" ? /* @__PURE__ */ j.jsx(pW, { ...e }) : e.type === "masked" ? /* @__PURE__ */ j.jsx(gW, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ j.jsx(lW, { ...e }) : /* @__PURE__ */ j.jsx(vW, { ...e });
}
function yW(e) {
  const { iconSize: t, isLoading: n, disabled: r, readOnly: o, isFocused: i } = e, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ j.jsx(j.Fragment, {}) : /* @__PURE__ */ j.jsx(IE, { className: l, size: t, strokeWidth: 2.5 });
}
function bW(e) {
  const {
    children: t,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: s,
    className: a,
    readOnly: l,
    variant: u,
    size: c,
    id: d,
    prefixExists: p
  } = e, m = p ? "hasPrefix" : "", f = o ? "errored" : "", g = r || l || i ? "opacity" : "", h = s ? "focused" : "";
  return /* @__PURE__ */ j.jsx(
    "section",
    {
      onClick: n,
      id: d,
      className: `arkynMultiSelectContainer ${m} ${u} ${c} ${g} ${f} ${h} ${a}`,
      children: t
    }
  );
}
function wW(e) {
  const { children: t, size: n } = e, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ j.jsx("div", { className: r, children: t });
}
function CW(e) {
  const { label: t, value: n, handleChangeValue: r } = e;
  return /* @__PURE__ */ j.jsxs("div", { className: "arkynMultiSelectMark", children: [
    t,
    /* @__PURE__ */ j.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ j.jsx(Lf, {})
      }
    )
  ] });
}
function EW(e) {
  const { label: t, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = e, s = n(o) ? "active" : "", a = `arkynMultiSelectOption ${i} ${s}`;
  return /* @__PURE__ */ j.jsxs("div", { onClick: () => r(o), className: a, children: [
    t,
    " ",
    /* @__PURE__ */ j.jsx(Df, {})
  ] });
}
function OW(e) {
  const { children: t, isFocused: n, isSearchable: r, onSearch: o } = e;
  function i(s) {
    r && o(s.target.value);
  }
  return n ? /* @__PURE__ */ j.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ j.jsx(
      Lc,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: FE,
        onChange: i
      }
    ),
    t
  ] }) : /* @__PURE__ */ j.jsx(j.Fragment, {});
}
function xW(e) {
  const { isFocused: t, handleBlur: n } = e;
  return t ? /* @__PURE__ */ j.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ j.jsx(j.Fragment, {});
}
function DW(e) {
  const { iconSize: t, isLoading: n } = e;
  return n ? /* @__PURE__ */ j.jsx(
    Mr,
    {
      className: "arkynMultiSelectSpinner",
      size: t,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ j.jsx(j.Fragment, {});
}
function gG(e) {
  const {
    name: t,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: s = [],
    isError: a,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: d,
    onSearch: p,
    onSelect: m,
    onBlur: f,
    notFoundText: g = "Sem opções disponíveis",
    onFocus: h,
    disabled: C = !1,
    prefix: w,
    size: k = "md",
    value: E,
    variant: v = "solid"
  } = e, O = Jn(), L = qe(null), W = O.inputRef || L, D = O.id, N = a || !!O.error, R = { md: 20, lg: 20 }[k], U = wO(w, R, "prefix"), [z, q] = P(""), [K, X] = P(!1), [ne, Q] = P(s), S = E || ne;
  function I(B) {
    return S.includes(B);
  }
  function Z(B) {
    const V = n.find((F) => F.value === B);
    return (V == null ? void 0 : V.label) || "";
  }
  function T() {
    C || !(W != null && W.current) || K || (X(!0), W.current.focus(), h && h());
  }
  function Y() {
    X(!1), f && W.current && W.current.blur();
  }
  function x(B) {
    q(B), p && p(B);
  }
  function M(B) {
    I(B) ? Q(ne.filter((V) => V !== B)) : Q([...ne, B]), m && m(ne), i && Y();
  }
  const $ = n.filter((B) => !!(e.onSearch || !e.isSearchable || B.label.toLowerCase().includes(z.toLowerCase())));
  return /* @__PURE__ */ j.jsxs(
    bW,
    {
      handleContainerFocus: T,
      disabled: C,
      isError: N,
      isFocused: K,
      isLoading: l,
      readOnly: u,
      size: k,
      variant: v,
      className: r,
      prefixExists: !!w,
      id: D,
      children: [
        /* @__PURE__ */ j.jsx(
          "input",
          {
            ref: W,
            name: t,
            value: JSON.stringify(S),
            type: "hidden"
          }
        ),
        U,
        d && /* @__PURE__ */ j.jsx(d, { size: R, strokeWidth: 2.5 }),
        /* @__PURE__ */ j.jsxs(wW, { size: k, children: [
          S.map((B) => /* @__PURE__ */ j.jsx(
            CW,
            {
              label: Z(B),
              value: B,
              handleChangeValue: M
            },
            B
          )),
          S.length <= 0 && /* @__PURE__ */ j.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ j.jsxs(
          OW,
          {
            isFocused: K,
            isSearchable: c,
            onSearch: x,
            children: [
              $.map(({ label: B, value: V }) => /* @__PURE__ */ j.jsx(
                EW,
                {
                  label: B,
                  value: V,
                  size: k,
                  handleChangeValue: M,
                  optionHasSelected: I
                },
                V
              )),
              $.length <= 0 && /* @__PURE__ */ j.jsx("p", { children: g })
            ]
          }
        ),
        /* @__PURE__ */ j.jsx(
          yW,
          {
            disabled: C,
            isFocused: K,
            readOnly: u,
            iconSize: R,
            isLoading: l
          }
        ),
        /* @__PURE__ */ j.jsx(DW, { iconSize: R, isLoading: l }),
        /* @__PURE__ */ j.jsx(xW, { handleBlur: Y, isFocused: K })
      ]
    }
  );
}
const dL = Ze({});
function LW() {
  return Oe(dL);
}
function mG(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: s = "",
    ...a
  } = e, [l, u] = P(t || ""), { inputRef: c, id: d } = Jn();
  function p(f) {
    u(f), o && o(f);
  }
  const m = `arkynRadioGroup ${i} ${s}`;
  return /* @__PURE__ */ j.jsxs(
    dL.Provider,
    {
      value: { onChange: p, value: r || l, size: i },
      children: [
        /* @__PURE__ */ j.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: d,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ j.jsx("div", { className: m.trim(), ...a })
      ]
    }
  );
}
function vG(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...s
  } = e, { onChange: a, size: l, value: u } = LW(), { error: c } = Jn(), g = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ j.jsxs("label", { className: g.trim(), children: [
    /* @__PURE__ */ j.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => a(t),
        onFocus: () => a(t),
        ...s
      }
    ),
    o
  ] });
}
var Yr = {};
Object.defineProperty(Yr, "__esModule", {
  value: !0
});
var PW = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Rd = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, pL = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: PW ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, tg = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Ja = 1; Ja < 20; Ja++)
  tg["f" + Ja] = 111 + Ja;
function Pc(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return fL(s, t);
  }), o = function(a) {
    return r.some(function(l) {
      return hL(l, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function SW(e, t) {
  return Pc(e, t);
}
function kW(e, t) {
  return Pc(e, { byKey: !0 }, t);
}
function fL(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Rd)
    r[Rd[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), d; !(a = (d = c.next()).done); a = !0) {
      var p = d.value, m = p.endsWith("?") && p.length > 1;
      m && (p = p.slice(0, -1));
      var f = ng(p), g = Rd[f];
      if (p.length > 1 && !g && !pL[p] && !tg[f])
        throw new TypeError('Unknown modifier: "' + p + '"');
      (i === 1 || !g) && (n ? r.key = f : r.which = gL(p)), g && (r[g] = m ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function hL(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function gL(e) {
  e = ng(e);
  var t = tg[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function ng(e) {
  return e = e.toLowerCase(), e = pL[e] || e, e;
}
var MW = Yr.default = Pc, Nd = Yr.isHotkey = Pc;
Yr.isCodeHotkey = SW;
Yr.isKeyHotkey = kW;
Yr.parseHotkey = fL;
Yr.compareHotkey = hL;
Yr.toKeyCode = gL;
Yr.toKeyName = ng;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Xw(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function AW(e) {
  var t, n;
  return Xw(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(Xw(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var TW = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return AW(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || vo.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || vo.isOperationList(e.undos[0].operations));
  }
}, zd = /* @__PURE__ */ new WeakMap(), Qi = /* @__PURE__ */ new WeakMap(), Go = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return TW.isHistory(e.history) && A.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return Qi.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return zd.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = Go.isMerging(e);
    Qi.set(e, !0), t(), Qi.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = Go.isMerging(e);
    Qi.set(e, !1), t(), Qi.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = Go.isSaving(e);
    zd.set(e, !1), t(), zd.set(e, n);
  }
}, BW = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && pe.setSelection(t, i.selectionBefore), Go.withoutSaving(t, () => {
        A.withoutNormalizing(t, () => {
          for (var s of i.operations)
            t.apply(s);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      Go.withoutSaving(t, () => {
        A.withoutNormalizing(t, () => {
          var s = i.operations.map(vo.inverse).reverse();
          for (var a of s)
            t.apply(a);
          i.selectionBefore && pe.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: s
    } = i, a = s[s.length - 1], l = a && a.operations[a.operations.length - 1], u = Go.isSaving(t), c = Go.isMerging(t);
    if (u == null && (u = _W(r)), u) {
      if (c == null && (a == null ? c = !1 : o.length !== 0 ? c = !0 : c = jW(r, l)), a && c)
        a.operations.push(r);
      else {
        var d = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", d);
      }
      for (; s.length > 100; )
        s.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, jW = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && te.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && te.equals(e.path, t.path)), _W = (e, t) => e.type !== "set_selection", IW = NW, mL = "֑-߿יִ-﷽ﹰ-ﻼ", vL = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", FW = new RegExp("^[^" + vL + "]*[" + mL + "]"), RW = new RegExp("^[^" + mL + "]*[" + vL + "]");
function NW(e) {
  return e = String(e || ""), FW.test(e) ? "rtl" : RW.test(e) ? "ltr" : "neutral";
}
const yL = /* @__PURE__ */ Du(IW);
function zW(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var rg = zW, $W = typeof jt == "object" && jt && jt.Object === Object && jt, UW = $W, WW = UW, VW = typeof self == "object" && self && self.Object === Object && self, HW = WW || VW || Function("return this")(), bL = HW, qW = bL, GW = function() {
  return qW.Date.now();
}, ZW = GW, YW = /\s/;
function XW(e) {
  for (var t = e.length; t-- && YW.test(e.charAt(t)); )
    ;
  return t;
}
var KW = XW, JW = KW, QW = /^\s+/;
function e8(e) {
  return e && e.slice(0, JW(e) + 1).replace(QW, "");
}
var t8 = e8, n8 = bL, r8 = n8.Symbol, wL = r8, Kw = wL, CL = Object.prototype, o8 = CL.hasOwnProperty, i8 = CL.toString, es = Kw ? Kw.toStringTag : void 0;
function s8(e) {
  var t = o8.call(e, es), n = e[es];
  try {
    e[es] = void 0;
    var r = !0;
  } catch {
  }
  var o = i8.call(e);
  return r && (t ? e[es] = n : delete e[es]), o;
}
var a8 = s8, l8 = Object.prototype, u8 = l8.toString;
function c8(e) {
  return u8.call(e);
}
var d8 = c8, Jw = wL, p8 = a8, f8 = d8, h8 = "[object Null]", g8 = "[object Undefined]", Qw = Jw ? Jw.toStringTag : void 0;
function m8(e) {
  return e == null ? e === void 0 ? g8 : h8 : Qw && Qw in Object(e) ? p8(e) : f8(e);
}
var v8 = m8;
function y8(e) {
  return e != null && typeof e == "object";
}
var b8 = y8, w8 = v8, C8 = b8, E8 = "[object Symbol]";
function O8(e) {
  return typeof e == "symbol" || C8(e) && w8(e) == E8;
}
var x8 = O8, D8 = t8, eC = rg, L8 = x8, tC = NaN, P8 = /^[-+]0x[0-9a-f]+$/i, S8 = /^0b[01]+$/i, k8 = /^0o[0-7]+$/i, M8 = parseInt;
function A8(e) {
  if (typeof e == "number")
    return e;
  if (L8(e))
    return tC;
  if (eC(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = eC(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = D8(e);
  var n = S8.test(e);
  return n || k8.test(e) ? M8(e.slice(2), n ? 2 : 8) : P8.test(e) ? tC : +e;
}
var T8 = A8, B8 = rg, $d = ZW, nC = T8, j8 = "Expected a function", _8 = Math.max, I8 = Math.min;
function F8(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, d = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError(j8);
  t = nC(t) || 0, B8(n) && (c = !!n.leading, d = "maxWait" in n, i = d ? _8(nC(n.maxWait) || 0, t) : i, p = "trailing" in n ? !!n.trailing : p);
  function m(O) {
    var L = r, W = o;
    return r = o = void 0, u = O, s = e.apply(W, L), s;
  }
  function f(O) {
    return u = O, a = setTimeout(C, t), c ? m(O) : s;
  }
  function g(O) {
    var L = O - l, W = O - u, D = t - L;
    return d ? I8(D, i - W) : D;
  }
  function h(O) {
    var L = O - l, W = O - u;
    return l === void 0 || L >= t || L < 0 || d && W >= i;
  }
  function C() {
    var O = $d();
    if (h(O))
      return w(O);
    a = setTimeout(C, g(O));
  }
  function w(O) {
    return a = void 0, p && r ? m(O) : (r = o = void 0, s);
  }
  function k() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w($d());
  }
  function v() {
    var O = $d(), L = h(O);
    if (r = arguments, o = this, l = O, L) {
      if (a === void 0)
        return f(l);
      if (d)
        return clearTimeout(a), a = setTimeout(C, t), m(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = k, v.flush = E, v;
}
var EL = F8;
const R8 = /* @__PURE__ */ Du(EL);
var N8 = EL, z8 = rg, $8 = "Expected a function";
function U8(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError($8);
  return z8(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), N8(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var W8 = U8;
const V8 = /* @__PURE__ */ Du(W8), rC = (e) => typeof e == "object" && e != null && e.nodeType === 1, oC = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", Ud = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return oC(n.overflowY, t) || oC(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, Qa = (e, t, n, r, o, i, s, a) => i < e && s > t || i > e && s < t ? 0 : i <= e && a <= n || s >= t && a >= n ? i - e - r : s > t && a < n || i < e && a > n ? s - t + o : 0, H8 = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, iC = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: s, block: a, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, d = typeof u == "function" ? u : (K) => K !== u;
  if (!rC(e)) throw new TypeError("Invalid target");
  const p = document.scrollingElement || document.documentElement, m = [];
  let f = e;
  for (; rC(f) && d(f); ) {
    if (f = H8(f), f === p) {
      m.push(f);
      break;
    }
    f != null && f === document.body && Ud(f) && !Ud(document.documentElement) || f != null && Ud(f, c) && m.push(f);
  }
  const g = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, h = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: C, scrollY: w } = window, { height: k, width: E, top: v, right: O, bottom: L, left: W } = e.getBoundingClientRect(), { top: D, right: N, bottom: _, left: R } = ((K) => {
    const X = window.getComputedStyle(K);
    return { top: parseFloat(X.scrollMarginTop) || 0, right: parseFloat(X.scrollMarginRight) || 0, bottom: parseFloat(X.scrollMarginBottom) || 0, left: parseFloat(X.scrollMarginLeft) || 0 };
  })(e);
  let U = a === "start" || a === "nearest" ? v - D : a === "end" ? L + _ : v + k / 2 - D + _, z = l === "center" ? W + E / 2 - R + N : l === "end" ? O + N : W - R;
  const q = [];
  for (let K = 0; K < m.length; K++) {
    const X = m[K], { height: ne, width: Q, top: S, right: I, bottom: Z, left: T } = X.getBoundingClientRect();
    if (s === "if-needed" && v >= 0 && W >= 0 && L <= h && O <= g && v >= S && L <= Z && W >= T && O <= I) return q;
    const Y = getComputedStyle(X), x = parseInt(Y.borderLeftWidth, 10), M = parseInt(Y.borderTopWidth, 10), $ = parseInt(Y.borderRightWidth, 10), B = parseInt(Y.borderBottomWidth, 10);
    let V = 0, F = 0;
    const J = "offsetWidth" in X ? X.offsetWidth - X.clientWidth - x - $ : 0, G = "offsetHeight" in X ? X.offsetHeight - X.clientHeight - M - B : 0, fe = "offsetWidth" in X ? X.offsetWidth === 0 ? 0 : Q / X.offsetWidth : 0, be = "offsetHeight" in X ? X.offsetHeight === 0 ? 0 : ne / X.offsetHeight : 0;
    if (p === X) V = a === "start" ? U : a === "end" ? U - h : a === "nearest" ? Qa(w, w + h, h, M, B, w + U, w + U + k, k) : U - h / 2, F = l === "start" ? z : l === "center" ? z - g / 2 : l === "end" ? z - g : Qa(C, C + g, g, x, $, C + z, C + z + E, E), V = Math.max(0, V + w), F = Math.max(0, F + C);
    else {
      V = a === "start" ? U - S - M : a === "end" ? U - Z + B + G : a === "nearest" ? Qa(S, Z, ne, M, B + G, U, U + k, k) : U - (S + ne / 2) + G / 2, F = l === "start" ? z - T - x : l === "center" ? z - (T + Q / 2) + J / 2 : l === "end" ? z - I + $ + J : Qa(T, I, Q, x, $ + J, z, z + E, E);
      const { scrollLeft: re, scrollTop: Ae } = X;
      V = be === 0 ? 0 : Math.max(0, Math.min(Ae + V / be, X.scrollHeight - ne / be + G)), F = fe === 0 ? 0 : Math.max(0, Math.min(re + F / fe, X.scrollWidth - Q / fe + J)), U += Ae - V, z += re - F;
    }
    q.push({ el: X, top: V, left: F });
  }
  return q;
}, q8 = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function G8(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(iC(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: s } of iC(e, q8(t))) {
    const a = i - n.top + n.bottom, l = s - n.left + n.right;
    o.scroll({ top: a, left: l, behavior: r });
  }
}
var Xo = [], Z8 = function() {
  return Xo.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, Y8 = function() {
  return Xo.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, sC = "ResizeObserver loop completed with undelivered notifications.", X8 = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: sC
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = sC), window.dispatchEvent(e);
}, zs;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(zs || (zs = {}));
var Ko = function(e) {
  return Object.freeze(e);
}, K8 = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Ko(this);
  }
  return e;
}(), OL = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Ko(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), og = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, xL = function(e) {
  if (og(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, s = o.offsetHeight;
  return !(i || s || e.getClientRects().length);
}, aC = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, J8 = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, ws = typeof window < "u" ? window : {}, el = /* @__PURE__ */ new WeakMap(), lC = /auto|scroll/, Q8 = /^tb|vertical/, e5 = /msie|trident/i.test(ws.navigator && ws.navigator.userAgent), Or = function(e) {
  return parseFloat(e || "0");
}, hi = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new K8((n ? t : e) || 0, (n ? e : t) || 0);
}, uC = Ko({
  devicePixelContentBoxSize: hi(),
  borderBoxSize: hi(),
  contentBoxSize: hi(),
  contentRect: new OL(0, 0, 0, 0)
}), DL = function(e, t) {
  if (t === void 0 && (t = !1), el.has(e) && !t)
    return el.get(e);
  if (xL(e))
    return el.set(e, uC), uC;
  var n = getComputedStyle(e), r = og(e) && e.ownerSVGElement && e.getBBox(), o = !e5 && n.boxSizing === "border-box", i = Q8.test(n.writingMode || ""), s = !r && lC.test(n.overflowY || ""), a = !r && lC.test(n.overflowX || ""), l = r ? 0 : Or(n.paddingTop), u = r ? 0 : Or(n.paddingRight), c = r ? 0 : Or(n.paddingBottom), d = r ? 0 : Or(n.paddingLeft), p = r ? 0 : Or(n.borderTopWidth), m = r ? 0 : Or(n.borderRightWidth), f = r ? 0 : Or(n.borderBottomWidth), g = r ? 0 : Or(n.borderLeftWidth), h = d + u, C = l + c, w = g + m, k = p + f, E = a ? e.offsetHeight - k - e.clientHeight : 0, v = s ? e.offsetWidth - w - e.clientWidth : 0, O = o ? h + w : 0, L = o ? C + k : 0, W = r ? r.width : Or(n.width) - O - v, D = r ? r.height : Or(n.height) - L - E, N = W + h + v + w, _ = D + C + E + k, R = Ko({
    devicePixelContentBoxSize: hi(Math.round(W * devicePixelRatio), Math.round(D * devicePixelRatio), i),
    borderBoxSize: hi(N, _, i),
    contentBoxSize: hi(W, D, i),
    contentRect: new OL(d, l, W, D)
  });
  return el.set(e, R), R;
}, LL = function(e, t, n) {
  var r = DL(e, n), o = r.borderBoxSize, i = r.contentBoxSize, s = r.devicePixelContentBoxSize;
  switch (t) {
    case zs.DEVICE_PIXEL_CONTENT_BOX:
      return s;
    case zs.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, t5 = /* @__PURE__ */ function() {
  function e(t) {
    var n = DL(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = Ko([n.borderBoxSize]), this.contentBoxSize = Ko([n.contentBoxSize]), this.devicePixelContentBoxSize = Ko([n.devicePixelContentBoxSize]);
  }
  return e;
}(), PL = function(e) {
  if (xL(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, n5 = function() {
  var e = 1 / 0, t = [];
  Xo.forEach(function(s) {
    if (s.activeTargets.length !== 0) {
      var a = [];
      s.activeTargets.forEach(function(u) {
        var c = new t5(u.target), d = PL(u.target);
        a.push(c), u.lastReportedSize = LL(u.target, u.observedBox), d < e && (e = d);
      }), t.push(function() {
        s.callback.call(s.observer, a, s.observer);
      }), s.activeTargets.splice(0, s.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, cC = function(e) {
  Xo.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (PL(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, r5 = function() {
  var e = 0;
  for (cC(e); Z8(); )
    e = n5(), cC(e);
  return Y8() && X8(), e > 0;
}, Wd, SL = [], o5 = function() {
  return SL.splice(0).forEach(function(e) {
    return e();
  });
}, i5 = function(e) {
  if (!Wd) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return o5();
    }).observe(n, r), Wd = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  SL.push(e), Wd();
}, s5 = function(e) {
  i5(function() {
    requestAnimationFrame(e);
  });
}, yl = 0, a5 = function() {
  return !!yl;
}, l5 = 250, u5 = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, dC = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], pC = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, Vd = !1, c5 = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = l5), !Vd) {
      Vd = !0;
      var r = pC(t);
      s5(function() {
        var o = !1;
        try {
          o = r5();
        } finally {
          if (Vd = !1, t = r - pC(), !a5())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, u5);
    };
    document.body ? n() : ws.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), dC.forEach(function(n) {
      return ws.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), dC.forEach(function(n) {
      return ws.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), sf = new c5(), fC = function(e) {
  !yl && e > 0 && sf.start(), yl += e, !yl && sf.stop();
}, d5 = function(e) {
  return !og(e) && !J8(e) && getComputedStyle(e).display === "inline";
}, p5 = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || zs.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = LL(this.target, this.observedBox, !0);
    return d5(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), f5 = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), tl = /* @__PURE__ */ new WeakMap(), hC = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, nl = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new f5(t, n);
    tl.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = tl.get(t), i = o.observationTargets.length === 0;
    hC(o.observationTargets, n) < 0 && (i && Xo.push(o), o.observationTargets.push(new p5(n, r && r.box)), fC(1), sf.schedule());
  }, e.unobserve = function(t, n) {
    var r = tl.get(t), o = hC(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && Xo.splice(Xo.indexOf(r), 1), r.observationTargets.splice(o, 1), fC(-1));
  }, e.disconnect = function(t) {
    var n = this, r = tl.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), h5 = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    nl.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!aC(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    nl.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!aC(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    nl.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    nl.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function g5(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function wi(e, t) {
  if (e == null) return {};
  var n = g5(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function $s(e) {
  "@babel/helpers - typeof";
  return $s = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, $s(e);
}
function m5(e, t) {
  if ($s(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if ($s(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function v5(e) {
  var t = m5(e, "string");
  return $s(t) === "symbol" ? t : String(t);
}
function gr(e, t, n) {
  return t = v5(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var ig = /* @__PURE__ */ Ze(null), ko = () => {
  var e = Oe(ig);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, Hd, qd, kL = parseInt(Ce.version.split(".")[0], 10), ML = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, gC = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Rn = typeof navigator < "u" && /Android/.test(navigator.userAgent), di = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), $o = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), y5 = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), AL = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), b5 = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), w5 = Rn && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), C5 = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), E5 = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), O5 = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), bl = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((Hd = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Hd !== void 0 && Hd[1] && parseInt((qd = navigator.userAgent.match(/Version\/(\d+)/)) === null || qd === void 0 ? void 0 : qd[1], 10) < 17);
var no = (!b5 || !w5) && !y5 && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", gi = /* @__PURE__ */ new WeakMap(), sg = /* @__PURE__ */ new WeakMap(), ag = /* @__PURE__ */ new WeakMap(), TL = /* @__PURE__ */ new WeakMap(), wl = /* @__PURE__ */ new WeakMap(), af = /* @__PURE__ */ new WeakMap(), Us = /* @__PURE__ */ new WeakMap(), Jo = /* @__PURE__ */ new WeakMap(), pu = /* @__PURE__ */ new WeakMap(), Sc = /* @__PURE__ */ new WeakMap(), lf = /* @__PURE__ */ new WeakMap(), yo = /* @__PURE__ */ new WeakMap(), Zo = /* @__PURE__ */ new WeakMap(), Cs = /* @__PURE__ */ new WeakMap(), uf = /* @__PURE__ */ new WeakMap(), lg = /* @__PURE__ */ new WeakMap(), br = /* @__PURE__ */ new WeakMap(), Ur = /* @__PURE__ */ new WeakMap(), Vn = /* @__PURE__ */ new WeakMap(), co = /* @__PURE__ */ new WeakMap(), po = /* @__PURE__ */ new WeakMap(), BL = /* @__PURE__ */ new WeakMap(), Ci = Symbol("placeholder"), jL = Symbol("mark-placeholder"), _L = globalThis.Node, x5 = globalThis.Text, ug = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, D5 = (e) => wo(e) && e.nodeType === 8, hr = (e) => wo(e) && e.nodeType === 1, wo = (e) => {
  var t = ug(e);
  return !!t && e instanceof t.Node;
}, cf = (e) => {
  var t = e && e.anchorNode && ug(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, IL = (e) => wo(e) && e.nodeType === 3, L5 = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, P5 = (e) => {
  var [t, n] = e;
  if (hr(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = FL(t, o, r ? "backward" : "forward"), r = o < n; hr(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = k5(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, S5 = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, FL = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (D5(o) || hr(o) && o.childNodes.length === 0 || hr(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, k5 = (e, t, n) => {
  var [r] = FL(e, t, n);
  return r;
}, RL = (e) => {
  var t = "";
  if (IL(e) && e.nodeValue)
    return e.nodeValue;
  if (hr(e)) {
    for (var n of Array.from(e.childNodes))
      t += RL(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, M5 = /data-slate-fragment="(.+?)"/m, A5 = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(M5) || [];
  return n;
}, Es = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), cg = (e, t, n) => {
  var {
    target: r
  } = t;
  if (hr(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = le.getWindow(e);
  if (o.contains(r))
    return le.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : cg(e, i, n);
}, T5 = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, mC = (e, t) => !!(e.compareDocumentPosition(t) & _L.DOCUMENT_POSITION_PRECEDING), B5 = (e, t) => !!(e.compareDocumentPosition(t) & _L.DOCUMENT_POSITION_FOLLOWING), j5 = 0;
class _5 {
  constructor() {
    gr(this, "id", void 0), this.id = "".concat(j5++);
  }
}
var le = {
  androidPendingDiffs: (e) => Vn.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = lg.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = le.toDOMNode(e, e), n = le.findDocumentOrShadowRoot(e);
    yo.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = le.findDocumentOrShadowRoot(e), r = Es(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && pe.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = le.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = le.toSlateNode(e, t.target), s = le.findPath(e, i);
    if (xe.isElement(i) && A.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = A.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? A.before(e, u) : A.after(e, u);
      if (c) {
        var d = A.range(e, c);
        return d;
      }
    }
    var p, {
      document: m
    } = le.getWindow(e);
    if (m.caretRangeFromPoint)
      p = m.caretRangeFromPoint(n, r);
    else {
      var f = m.caretPositionFromPoint(n, r);
      f && (p = m.createRange(), p.setStart(f.offsetNode, f.offset), p.setEnd(f.offsetNode, f.offset));
    }
    if (!p)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var g = le.toSlateRange(e, p, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (e, t) => {
    var n = pu.get(t);
    return n || (n = new _5(), pu.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = ag.get(r);
      if (o == null) {
        if (A.isEditor(r))
          return n;
        break;
      }
      var i = sg.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Ln.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!yo.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          le.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = le.toDOMNode(t, t), o = le.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = Es(o), s = le.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(s);
        }
        t.selection || pe.select(t, A.start(t, [])), yo.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = TL.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = le.toDOMNode(t, t), s;
    try {
      s = hr(n) ? n : n.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return s ? s.closest("[data-slate-editor]") === i && (!o || s.isContentEditable ? !0 : typeof s.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    s.closest('[contenteditable="false"]') === i || !!s.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => wo(t) && le.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return A.hasPath(e, n.path) && A.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => le.hasEditableTarget(e, t) || le.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => wo(t) && le.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Zo.get(e),
  isFocused: (e) => !!yo.get(e),
  isReadOnly: (e) => !!lf.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (lf.get(e)) return !1;
    var n = le.hasTarget(e, t) && le.toSlateNode(e, t);
    return xe.isElement(n) && A.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Sc.get(e), r = A.isEditor(t) ? wl.get(e) : n == null ? void 0 : n.get(le.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Ln.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = A.node(e, t.path), r = le.toDOMNode(e, n), o;
    A.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: d
        } = c.textContent, p = u.getAttribute("data-slate-length"), m = p == null ? d : parseInt(p, 10), f = a + m, g = s[l + 1];
        if (t.offset === f && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var h, C = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            C instanceof x5 ? C : g,
            (h = g.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(d, Math.max(0, t.offset - a));
          o = [c, w];
          break;
        }
        a = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Ln.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = ie.isBackward(t), i = le.toDOMPoint(e, n), s = ie.isCollapsed(t) ? i : le.toDOMPoint(e, r), a = le.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [d, p] = o ? i : s, m = hr(u) ? u : u.parentElement, f = !!m.getAttribute("data-slate-zero-width"), g = hr(d) ? d : d.parentElement, h = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(d, h ? 1 : p), l;
  },
  toSlateNode: (e, t) => {
    var n = hr(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Us.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : P5(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var d, p, m = le.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), g = f && m.contains(f) ? f : null, h = l.closest('[contenteditable="false"]'), C = h && m.contains(h) ? h : null, w = l.closest("[data-slate-leaf]"), k = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var E = le.getWindow(e), v = E.document.createRange();
          v.setStart(u, 0), v.setEnd(s, a);
          var O = v.cloneContents(), L = [...Array.prototype.slice.call(O.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(O.querySelectorAll("[contenteditable=false]"))];
          L.forEach((T) => {
            if (Rn && !r && T.hasAttribute("data-slate-zero-width") && T.textContent.length > 0 && T.textContext !== "\uFEFF") {
              T.textContent.startsWith("\uFEFF") && (T.textContent = T.textContent.slice(1));
              return;
            }
            T.parentNode.removeChild(T);
          }), c = O.textContent.length, k = u;
        }
      } else if (g) {
        for (var W = g.querySelectorAll("[data-slate-leaf]"), D = 0; D < W.length; D++) {
          var N = W[D];
          if (le.hasDOMNode(e, N)) {
            w = N;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), k = w, c = k.textContent.length, k.querySelectorAll("[data-slate-zero-width]").forEach((T) => {
          c -= T.textContent.length;
        })) : c = 1;
      } else if (C) {
        var _ = (T) => T ? T.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], R = C.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var U, z = [..._(R), ..._(R == null ? void 0 : R.nextElementSibling)];
          w = (U = z.find((T) => B5(C, T))) !== null && U !== void 0 ? U : null;
        } else {
          var q, K = [..._(R == null ? void 0 : R.previousElementSibling), ..._(R)];
          w = (q = K.findLast((T) => mC(C, T))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), k = w, i === "forward" ? c = 0 : (c = k.textContent.length, k.querySelectorAll("[data-slate-zero-width]").forEach((T) => {
          c -= T.textContent.length;
        })));
      }
      k && c === k.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Rn && k.getAttribute("data-slate-zero-width") === "z" && (d = k.textContent) !== null && d !== void 0 && d.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      di && (p = k.textContent) !== null && p !== void 0 && p.endsWith(`

`)) && c--;
    }
    if (Rn && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && le.hasDOMNode(e, X, {
        editable: !0
      })) {
        var ne = le.toSlateNode(e, X), {
          path: Q,
          offset: S
        } = A.start(e, le.findPath(e, ne));
        return X.querySelector("[data-slate-leaf]") || (S = a), {
          path: Q,
          offset: S
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var I = le.toSlateNode(e, u), Z = le.findPath(e, I);
    return {
      path: Z,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = cf(t) ? t.anchorNode : t.startContainer, a, l, u, c, d;
    if (s)
      if (cf(t)) {
        if (di && t.rangeCount > 1) {
          u = t.focusNode;
          var p = t.getRangeAt(0), m = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && p.startContainer instanceof HTMLTableRowElement && m.startContainer instanceof HTMLTableRowElement) {
            let O = function(L) {
              return L.childElementCount > 0 ? O(L.children[0]) : L;
            };
            var f = p.startContainer, g = m.startContainer, h = O(f.children[p.startOffset]), C = O(g.children[m.startOffset]);
            c = 0, C.childNodes.length > 0 ? a = C.childNodes[0] : a = C, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, C instanceof HTMLElement ? l = C.innerHTML.length : l = 0;
          } else
            p.startContainer === u ? (a = m.endContainer, l = m.endOffset, c = p.startOffset) : (a = p.startContainer, l = p.endOffset, c = m.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        AL && S5(a) || di ? d = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : d = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, d = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    di && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = le.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var k = mC(a, u) || a === u && c < l, E = d ? w : le.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: k ? "forward" : "backward"
    });
    if (!E)
      return null;
    var v = {
      anchor: w,
      focus: E
    };
    return ie.isExpanded(v) && ie.isForward(v) && hr(u) && A.void(e, {
      at: v.focus,
      mode: "highest"
    }) && (v = A.unhangRange(e, v, {
      voids: !0
    })), v;
  }
};
function I5(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!A.hasPath(e, n))
    return !1;
  var o = ye.get(e, n);
  if (!De.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = te.next(n);
  if (!A.hasPath(e, i))
    return !1;
  var s = ye.get(e, i);
  return De.isText(s) && s.text.startsWith(r.text);
}
function NL(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function F5(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function R5(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function zL(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), s = F5(i, o), a = Math.min(i.length - s, o.length - s), l = R5(i, o, a), u = {
    start: n + s,
    end: r - l,
    text: o.slice(s, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function N5(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = NL(e, t, n), s = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), a = i.slice(r, s), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return zL(e, {
    start: r,
    end: l,
    text: a
  });
}
function z5(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function df(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!A.hasPath(e, n))
    return null;
  var o = ye.get(e, n);
  if (!De.isText(o))
    return null;
  var i = A.above(e, {
    match: (a) => xe.isElement(a) && A.isBlock(e, a),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var s = A.next(e, {
      at: n,
      match: De.isText
    });
    if (!s || !te.isDescendant(s[1], i[1]))
      return null;
    r -= o.text.length, o = s[0], n = s[1];
  }
  return {
    path: n,
    offset: r
  };
}
function vC(e, t) {
  var n = df(e, t.anchor);
  if (!n)
    return null;
  if (ie.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = df(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function pf(e, t, n) {
  var r = Vn.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: d
    } = c;
    return te.equals(d, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return Je.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var s = {
      path: t.path,
      offset: i.start
    }, a = Je.transform(s, n, {
      affinity: "backward"
    });
    return a ? {
      path: a.path,
      offset: a.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = Je.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && te.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function yC(e, t, n) {
  var r = pf(e, t.anchor, n);
  if (!r)
    return null;
  if (ie.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = pf(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function $5(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !te.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !te.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !te.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: te.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: te.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return te.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: te.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: te.transform(n, t)
      };
  }
  var i = te.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function bC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rl(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bC(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var U5 = 25, W5 = 200, V5 = function() {
}, H5 = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function q5(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, s = null, a = null, l = 0, u = !1, c = () => {
    var R = po.get(t);
    if (po.delete(t), R) {
      var {
        selection: U
      } = t, z = vC(t, R);
      z && (!U || !ie.equals(z, U)) && pe.select(t, z);
    }
  }, d = () => {
    var R = co.get(t);
    if (co.delete(t), !!R) {
      if (R.at) {
        var U = Je.isPoint(R.at) ? df(t, R.at) : vC(t, R.at);
        if (!U)
          return;
        var z = A.range(t, U);
        (!t.selection || !ie.equals(t.selection, z)) && pe.select(t, U);
      }
      R.run();
    }
  }, p = () => {
    if (s && (clearTimeout(s), s = null), a && (clearTimeout(a), a = null), !E() && !k()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), k() && (o = "action");
    var R = t.selection && A.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    Ur.set(t, t.marks), V5("flush", co.get(t), Vn.get(t));
    for (var U = E(), z; z = (q = Vn.get(t)) === null || q === void 0 ? void 0 : q[0]; ) {
      var q, K, X = br.get(t);
      X !== void 0 && (br.delete(t), t.marks = X), X && u === !1 && (u = null);
      var ne = z5(z);
      (!t.selection || !ie.equals(t.selection, ne)) && pe.select(t, ne), z.diff.text ? A.insertText(t, z.diff.text) : A.deleteFragment(t), Vn.set(t, (K = Vn.get(t)) === null || K === void 0 ? void 0 : K.filter((I) => {
        var {
          id: Z
        } = I;
        return Z !== z.id;
      })), I5(t, z) || (U = !1, co.delete(t), Ur.delete(t), o = "action", po.delete(t), n.cancel(), r.cancel(), R == null || R.unref());
    }
    var Q = R == null ? void 0 : R.unref();
    if (Q && !po.get(t) && (!t.selection || !ie.equals(Q, t.selection)) && pe.select(t, Q), k()) {
      d();
      return;
    }
    U && n(), n.flush(), r.flush(), c();
    var S = Ur.get(t);
    Ur.delete(t), S !== void 0 && (t.marks = S, t.onChange());
  }, m = (R) => {
    i && clearTimeout(i), i = setTimeout(() => {
      Zo.set(t, !1), p();
    }, U5);
  }, f = (R) => {
    Zo.set(t, !0), i && (clearTimeout(i), i = null);
  }, g = function() {
    var U = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, z = af.get(t);
    if (z) {
      if (E() || U) {
        z.style.display = "none";
        return;
      }
      z.style.removeProperty("display");
    }
  }, h = (R, U) => {
    var z, q = (z = Vn.get(t)) !== null && z !== void 0 ? z : [];
    Vn.set(t, q);
    var K = ye.leaf(t, R), X = q.findIndex((S) => te.equals(S.path, R));
    if (X < 0) {
      var ne = zL(K.text, U);
      ne && q.push({
        path: R,
        diff: U,
        id: l++
      }), g();
      return;
    }
    var Q = N5(K.text, q[X].diff, U);
    if (!Q) {
      q.splice(X, 1), g();
      return;
    }
    q[X] = rl(rl({}, q[X]), {}, {
      diff: Q
    });
  }, C = function(U) {
    var {
      at: z
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, po.delete(t), n.cancel(), r.cancel(), k() && p(), co.set(t, {
      at: z,
      run: U
    }), a = setTimeout(p);
  }, w = (R) => {
    var U;
    if (s && (clearTimeout(s), s = null), !gi.get(t)) {
      var {
        inputType: z
      } = R, q = null, K = R.dataTransfer || R.data || void 0;
      u !== !1 && z !== "insertText" && z !== "insertCompositionText" && (u = !1);
      var [X] = R.getTargetRanges();
      X && (q = le.toSlateRange(t, X, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var ne = le.getWindow(t), Q = ne.getSelection();
      if (!q && Q && (X = Q, q = le.toSlateRange(t, Q, {
        exactMatch: !1,
        suppressThrow: !0
      })), q = (U = q) !== null && U !== void 0 ? U : t.selection, !!q) {
        var S = !0;
        if (z.startsWith("delete")) {
          if (ie.isExpanded(q)) {
            var [I, Z] = ie.edges(q), T = ye.leaf(t, I.path);
            if (T.text.length === I.offset && Z.offset === 0) {
              var Y = A.next(t, {
                at: I.path,
                match: De.isText
              });
              Y && te.equals(Y[1], Z.path) && (q = {
                anchor: Z,
                focus: Z
              });
            }
          }
          var x = z.endsWith("Backward") ? "backward" : "forward", [M, $] = ie.edges(q), [B, V] = A.leaf(t, M.path), F = {
            text: "",
            start: M.offset,
            end: $.offset
          }, J = Vn.get(t), G = J == null ? void 0 : J.find((He) => te.equals(He.path, V)), fe = G ? [G.diff, F] : [F], be = NL(B.text, ...fe);
          if (be.length === 0 && (S = !1), ie.isExpanded(q)) {
            if (S && te.equals(q.anchor.path, q.focus.path)) {
              var re = {
                path: q.anchor.path,
                offset: M.offset
              }, Ae = A.range(t, re, re);
              return L(Ae), h(q.anchor.path, {
                text: "",
                end: $.offset,
                start: M.offset
              });
            }
            return C(() => A.deleteFragment(t, {
              direction: x
            }), {
              at: q
            });
          }
        }
        switch (z) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return C(() => A.deleteFragment(t), {
              at: q
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: Ie
            } = q;
            if (S && ie.isCollapsed(q)) {
              var je = ye.leaf(t, Ie.path);
              if (Ie.offset < je.text.length)
                return h(Ie.path, {
                  text: "",
                  start: Ie.offset,
                  end: Ie.offset + 1
                });
            }
            return C(() => A.deleteForward(t), {
              at: q
            });
          }
          case "deleteContentBackward": {
            var _e, {
              anchor: tt
            } = q, Ke = cf(X) ? X.isCollapsed : !!((_e = X) !== null && _e !== void 0 && _e.collapsed);
            return S && Ke && ie.isCollapsed(q) && tt.offset > 0 ? h(tt.path, {
              text: "",
              start: tt.offset - 1,
              end: tt.offset
            }) : C(() => A.deleteBackward(t), {
              at: q
            });
          }
          case "deleteEntireSoftLine":
            return C(() => {
              A.deleteBackward(t, {
                unit: "line"
              }), A.deleteForward(t, {
                unit: "line"
              });
            }, {
              at: q
            });
          case "deleteHardLineBackward":
            return C(() => A.deleteBackward(t, {
              unit: "block"
            }), {
              at: q
            });
          case "deleteSoftLineBackward":
            return C(() => A.deleteBackward(t, {
              unit: "line"
            }), {
              at: q
            });
          case "deleteHardLineForward":
            return C(() => A.deleteForward(t, {
              unit: "block"
            }), {
              at: q
            });
          case "deleteSoftLineForward":
            return C(() => A.deleteForward(t, {
              unit: "line"
            }), {
              at: q
            });
          case "deleteWordBackward":
            return C(() => A.deleteBackward(t, {
              unit: "word"
            }), {
              at: q
            });
          case "deleteWordForward":
            return C(() => A.deleteForward(t, {
              unit: "word"
            }), {
              at: q
            });
          case "insertLineBreak":
            return C(() => A.insertSoftBreak(t), {
              at: q
            });
          case "insertParagraph":
            return C(() => A.insertBreak(t), {
              at: q
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if (H5(K))
              return C(() => le.insertData(t, K), {
                at: q
              });
            var ke = K ?? "";
            if (br.get(t) && (ke = ke.replace("\uFEFF", "")), z === "insertText" && /.*\n.*\n$/.test(ke) && (ke = ke.slice(0, -1)), ke.includes(`
`))
              return C(() => {
                var He = ke.split(`
`);
                He.forEach((ze, wt) => {
                  ze && A.insertText(t, ze), wt !== He.length - 1 && A.insertSoftBreak(t);
                });
              }, {
                at: q
              });
            if (te.equals(q.anchor.path, q.focus.path)) {
              var [nt, gt] = ie.edges(q), Pe = {
                start: nt.offset,
                end: gt.offset,
                text: ke
              };
              if (ke && u && z === "insertCompositionText") {
                var Te = u.start + u.text.search(/\S|$/), Re = Pe.start + Pe.text.search(/\S|$/);
                Re === Te + 1 && Pe.end === u.start + u.text.length ? (Pe.start -= 1, u = null, N()) : u = !1;
              } else z === "insertText" ? u === null ? u = Pe : u && ie.isCollapsed(q) && u.end + u.text.length === nt.offset ? u = rl(rl({}, u), {}, {
                text: u.text + ke
              }) : u = !1 : u = !1;
              if (S) {
                h(nt.path, Pe);
                return;
              }
            }
            return C(() => A.insertText(t, ke), {
              at: q
            });
          }
        }
      }
    }
  }, k = () => !!co.get(t), E = () => {
    var R;
    return !!((R = Vn.get(t)) !== null && R !== void 0 && R.length);
  }, v = () => k() || E(), O = () => o, L = (R) => {
    po.set(t, R), s && (clearTimeout(s), s = null);
    var {
      selection: U
    } = t;
    if (R) {
      var z = !U || !te.equals(U.anchor.path, R.anchor.path), q = !U || !te.equals(U.anchor.path.slice(0, -1), R.anchor.path.slice(0, -1));
      (z && u || q) && (u = !1), (z || E()) && (s = setTimeout(p, W5));
    }
  }, W = () => {
    (k() || !E()) && p();
  }, D = (R) => {
    E() || (g(!0), setTimeout(g));
  }, N = () => {
    k() || (a = setTimeout(p));
  }, _ = (R) => {
    if (!(E() || k()) && R.some((z) => cg(t, z, R))) {
      var U;
      (U = BL.get(t)) === null || U === void 0 || U();
    }
  };
  return {
    flush: p,
    scheduleFlush: N,
    hasPendingDiffs: E,
    hasPendingAction: k,
    hasPendingChanges: v,
    isFlushing: O,
    handleUserSelect: L,
    handleCompositionEnd: m,
    handleCompositionStart: f,
    handleDOMBeforeInput: w,
    handleKeyDown: D,
    handleDomMutations: _,
    handleInput: W
  };
}
function G5() {
  var e = qe(!1);
  return y(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var Ws = bl ? ZP : y;
function Z5(e, t, n) {
  var [r] = P(() => new MutationObserver(t));
  Ws(() => {
    r.takeRecords();
  }), y(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var Y5 = ["node"];
function wC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function X5(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wC(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var K5 = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, J5 = Rn ? (e) => {
  var {
    node: t
  } = e, n = wi(e, Y5);
  if (!Rn)
    return null;
  var r = ko(), o = G5(), [i] = P(() => q5(X5({
    editor: r
  }, n)));
  return Z5(t, i.handleDomMutations, K5), lg.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, Q5 = ["anchor", "focus"], e6 = ["anchor", "focus"], t6 = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), $L = (e, t) => {
  var n = wi(e, Q5), r = wi(t, e6);
  return e[Ci] === t[Ci] && t6(n, r);
}, n6 = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!ie.equals(r, o) || !$L(r, o))
      return !1;
  }
  return !0;
}, r6 = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !$L(r, o))
      return !1;
  }
  return !0;
};
function CC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function o6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CC(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var i6 = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = ko(), s = le.findPath(i, o), a = te.parent(s), l = !!n[jL];
  return i.isVoid(r) ? /* @__PURE__ */ Ce.createElement(Gd, {
    length: ye.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && A.string(i, a) === "" ? /* @__PURE__ */ Ce.createElement(Gd, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ Ce.createElement(Gd, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ Ce.createElement(EC, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ Ce.createElement(EC, {
    text: n.text
  });
}, EC = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = qe(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = P(o);
  return Ws(() => {
    var s = o();
    r.current && r.current.textContent !== s && (r.current.textContent = s);
  }), /* @__PURE__ */ Ce.createElement(s6, {
    ref: r
  }, i);
}, s6 = /* @__PURE__ */ Me(/* @__PURE__ */ Hs((e, t) => /* @__PURE__ */ Ce.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), Gd = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ Ce.createElement("span", o6({}, o), !(Rn || ML) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ Ce.createElement("br", null) : null);
};
function OC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function UL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OC(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var a6 = Rn ? 300 : 0;
function l6(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function xC(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var u6 = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: s = (w) => /* @__PURE__ */ Ce.createElement(d6, UL({}, w))
  } = e, a = ko(), l = qe(null), u = qe(null), [c, d] = P(!1), p = qe(null), m = Lt((w) => {
    if (l6(l, w == null), w == null) {
      var k;
      af.delete(a), (k = t.onPlaceholderResize) === null || k === void 0 || k.call(t, null);
    } else {
      if (af.set(a, w), !l.current) {
        var E = window.ResizeObserver || h5;
        l.current = new E(() => {
          var v;
          (v = t.onPlaceholderResize) === null || v === void 0 || v.call(t, w);
        });
      }
      l.current.observe(w), u.current = w;
    }
  }, [u, t, a]), f = /* @__PURE__ */ Ce.createElement(i6, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), g = !!t[Ci];
  if (y(() => (g ? p.current || (p.current = setTimeout(() => {
    d(!0), p.current = null;
  }, a6)) : (xC(p), d(!1)), () => xC(p)), [g, d]), g && c) {
    var h = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: $o ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: m
      }
    };
    f = /* @__PURE__ */ Ce.createElement(Ce.Fragment, null, i(h), f);
  }
  var C = {
    "data-slate-leaf": !0
  };
  return s({
    attributes: C,
    children: f,
    leaf: t,
    text: r
  });
}, c6 = /* @__PURE__ */ Ce.memo(u6, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && De.equals(t.leaf, e.leaf) && t.leaf[Ci] === e.leaf[Ci]), d6 = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ Ce.createElement("span", UL({}, t), n);
}, p6 = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: s
  } = e, a = ko(), l = qe(null), u = De.decorations(s, t), c = le.findKey(a, s), d = [], p = 0; p < u.length; p++) {
    var m = u[p];
    d.push(/* @__PURE__ */ Ce.createElement(c6, {
      isLast: n && p === u.length - 1,
      key: "".concat(c.id, "-").concat(p),
      renderPlaceholder: o,
      leaf: m,
      text: s,
      parent: r,
      renderLeaf: i
    }));
  }
  var f = Lt((g) => {
    var h = Sc.get(a);
    g ? (h == null || h.set(c, g), Jo.set(s, g), Us.set(g, s)) : (h == null || h.delete(c), Jo.delete(s), l.current && Us.delete(l.current)), l.current = g;
  }, [l, a, c, s]);
  return /* @__PURE__ */ Ce.createElement("span", {
    "data-slate-node": "text",
    ref: f
  }, d);
}, WL = /* @__PURE__ */ Ce.memo(p6, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && r6(t.decorations, e.decorations));
function DC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ff(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? DC(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : DC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var f6 = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (w) => /* @__PURE__ */ Ce.createElement(g6, ff({}, w)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  } = e, a = ko(), l = y6(), u = a.isInline(n), c = le.findKey(a, n), d = Lt((w) => {
    var k = Sc.get(a);
    w ? (k == null || k.set(c, w), Jo.set(n, w), Us.set(w, n)) : (k == null || k.delete(c), Jo.delete(n));
  }, [a, c, n]), p = HL({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  }), m = {
    "data-slate-node": "element",
    ref: d
  };
  if (u && (m["data-slate-inline"] = !0), !u && A.hasInlines(a, n)) {
    var f = ye.string(n), g = yL(f);
    g === "rtl" && (m.dir = g);
  }
  if (A.isVoid(a, n)) {
    m["data-slate-void"] = !0, !l && u && (m.contentEditable = !1);
    var h = u ? "span" : "div", [[C]] = ye.texts(n);
    p = /* @__PURE__ */ Ce.createElement(h, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ Ce.createElement(WL, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: C
    })), sg.set(C, 0), ag.set(C, n);
  }
  return r({
    attributes: m,
    children: p,
    element: n
  });
}, h6 = /* @__PURE__ */ Ce.memo(f6, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && n6(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && ie.equals(e.selection, t.selection))), g6 = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = ko(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ Ce.createElement(i, ff(ff({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, VL = /* @__PURE__ */ Ze(() => []), m6 = () => Oe(VL), v6 = /* @__PURE__ */ Ze(!1), HL = (e) => {
  var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  } = e, a = m6(), l = ko();
  gi.set(l, !1);
  for (var u = le.findPath(l, n), c = [], d = xe.isElement(n) && !l.isInline(n) && A.hasInlines(l, n), p = 0; p < n.children.length; p++) {
    var m = u.concat(p), f = n.children[p], g = le.findKey(l, f), h = A.range(l, m), C = s && ie.intersection(h, s), w = a([f, m]);
    for (var k of t) {
      var E = ie.intersection(k, h);
      E && w.push(E);
    }
    xe.isElement(f) ? c.push(/* @__PURE__ */ Ce.createElement(v6.Provider, {
      key: "provider-".concat(g.id),
      value: !!C
    }, /* @__PURE__ */ Ce.createElement(h6, {
      decorations: w,
      element: f,
      key: g.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: C
    }))) : c.push(/* @__PURE__ */ Ce.createElement(WL, {
      decorations: w,
      key: g.id,
      isLast: d && p === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: f
    })), sg.set(f, p), ag.set(f, n);
  }
  return c;
}, qL = /* @__PURE__ */ Ze(!1), y6 = () => Oe(qL), GL = /* @__PURE__ */ Ze(null), kc = () => {
  var e = Oe(GL);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function b6() {
  var e = ko(), t = qe(!1), n = qe(0), r = Lt(() => {
    if (!t.current) {
      t.current = !0;
      var o = le.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return y(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var w6 = 3, C6 = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, E6 = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, O6 = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Jt = (e) => {
  var t = C6[e], n = E6[e], r = O6[e], o = t && Nd(t), i = n && Nd(n), s = r && Nd(r);
  return (a) => !!(o && o(a) || gC && i && i(a) || !gC && s && s(a));
}, rn = {
  isBold: Jt("bold"),
  isCompose: Jt("compose"),
  isMoveBackward: Jt("moveBackward"),
  isMoveForward: Jt("moveForward"),
  isDeleteBackward: Jt("deleteBackward"),
  isDeleteForward: Jt("deleteForward"),
  isDeleteLineBackward: Jt("deleteLineBackward"),
  isDeleteLineForward: Jt("deleteLineForward"),
  isDeleteWordBackward: Jt("deleteWordBackward"),
  isDeleteWordForward: Jt("deleteWordForward"),
  isExtendBackward: Jt("extendBackward"),
  isExtendForward: Jt("extendForward"),
  isExtendLineBackward: Jt("extendLineBackward"),
  isExtendLineForward: Jt("extendLineForward"),
  isItalic: Jt("italic"),
  isMoveLineBackward: Jt("moveLineBackward"),
  isMoveLineForward: Jt("moveLineForward"),
  isMoveWordBackward: Jt("moveWordBackward"),
  isMoveWordForward: Jt("moveWordForward"),
  isRedo: Jt("redo"),
  isSoftBreak: Jt("insertSoftBreak"),
  isSplitBlock: Jt("splitBlock"),
  isTransposeCharacter: Jt("transposeCharacter"),
  isUndo: Jt("undo")
}, x6 = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => cg(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, D6 = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class ZL extends xf {
  constructor() {
    super(...arguments), gr(this, "context", null), gr(this, "manager", null), gr(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, D6);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = x6(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
gr(ZL, "contextType", ig);
var L6 = Rn ? ZL : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ Ce.createElement(Ce.Fragment, null, t);
}, P6 = /* @__PURE__ */ Ze(!1), S6 = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], k6 = ["text"];
function LC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LC(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var M6 = (e) => /* @__PURE__ */ Ce.createElement(Ce.Fragment, null, HL(e)), A6 = /* @__PURE__ */ Hs((e, t) => {
  var n = Lt((M) => /* @__PURE__ */ Ce.createElement(T6, xr({}, M)), []), {
    autoFocus: r,
    decorate: o = B6,
    onDOMBeforeInput: i,
    placeholder: s,
    readOnly: a = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: d = j6,
    style: p = {},
    as: m = "div",
    disableDefaultStyles: f = !1
  } = e, g = wi(e, S6), h = kc(), [C, w] = P(!1), k = qe(null), E = qe([]), [v, O] = P(), L = qe(!1), {
    onUserInput: W,
    receivedUserInput: D
  } = b6(), [, N] = GP((M) => M + 1, 0);
  BL.set(h, N), lf.set(h, a);
  var _ = Mn(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  y(() => {
    k.current && r && k.current.focus();
  }, [r]);
  var R = qe(), U = Mn(() => V8(() => {
    if (gi.get(h)) {
      U();
      return;
    }
    var M = le.toDOMNode(h, h), $ = M.getRootNode();
    if (!L.current && $o && $ instanceof ShadowRoot) {
      L.current = !0;
      var B = T5();
      B ? document.execCommand("indent") : pe.deselect(h), L.current = !1;
      return;
    }
    var V = R.current;
    if ((Rn || !le.isComposing(h)) && (!_.isUpdatingSelection || V != null && V.isFlushing()) && !_.isDraggingInternally) {
      var F = le.findDocumentOrShadowRoot(h), {
        activeElement: J
      } = F, G = le.toDOMNode(h, h), fe = Es(F);
      if (J === G ? (_.latestElement = J, yo.set(h, !0)) : yo.delete(h), !fe)
        return pe.deselect(h);
      var {
        anchorNode: be,
        focusNode: re
      } = fe, Ae = le.hasEditableTarget(h, be) || le.isTargetInsideNonReadonlyVoid(h, be), Ie = le.hasTarget(h, re);
      if (Ae && Ie) {
        var je = le.toSlateRange(h, fe, {
          exactMatch: !1,
          suppressThrow: !0
        });
        je && (!le.isComposing(h) && !(V != null && V.hasPendingChanges()) && !(V != null && V.isFlushing()) ? pe.select(h, je) : V == null || V.handleUserSelect(je));
      }
      a && (!Ae || !Ie) && pe.deselect(h);
    }
  }, 100), [h, a, _]), z = Mn(() => R8(U, 0), [U]);
  R.current = J5({
    node: k,
    onDOMSelectionChange: U,
    scheduleOnDOMSelectionChange: z
  }), Ws(() => {
    var M, $, B;
    k.current && (B = ug(k.current)) ? (TL.set(h, B), wl.set(h, k.current), Jo.set(h, k.current), Us.set(k.current, h)) : Jo.delete(h);
    var {
      selection: V
    } = h, F = le.findDocumentOrShadowRoot(h), J = Es(F);
    if (!(!J || !le.isFocused(h) || (M = R.current) !== null && M !== void 0 && M.hasPendingAction())) {
      var G = (Ae) => {
        var Ie = J.type !== "None";
        if (!(!V && !Ie)) {
          var je = J.focusNode, _e;
          if (di && J.rangeCount > 1) {
            var tt = J.getRangeAt(0), Ke = J.getRangeAt(J.rangeCount - 1);
            tt.startContainer === je ? _e = Ke.endContainer : _e = tt.startContainer;
          } else
            _e = J.anchorNode;
          var ke = wl.get(h), nt = !1;
          if (ke.contains(_e) && ke.contains(je) && (nt = !0), Ie && nt && V && !Ae) {
            var gt = le.toSlateRange(h, J, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (gt && ie.equals(gt, V)) {
              var Pe;
              if (!_.hasMarkPlaceholder || (Pe = _e) !== null && Pe !== void 0 && (Pe = Pe.parentElement) !== null && Pe !== void 0 && Pe.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (V && !le.hasRange(h, V)) {
            h.selection = le.toSlateRange(h, J, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          _.isUpdatingSelection = !0;
          var Te = V && le.toDOMRange(h, V);
          return Te ? (le.isComposing(h) && !Rn ? J.collapseToEnd() : ie.isBackward(V) ? J.setBaseAndExtent(Te.endContainer, Te.endOffset, Te.startContainer, Te.startOffset) : J.setBaseAndExtent(Te.startContainer, Te.startOffset, Te.endContainer, Te.endOffset), d(h, Te)) : J.removeAllRanges(), Te;
        }
      };
      J.rangeCount <= 1 && G();
      var fe = (($ = R.current) === null || $ === void 0 ? void 0 : $.isFlushing()) === "action";
      if (!Rn || !fe) {
        setTimeout(() => {
          _.isUpdatingSelection = !1;
        });
        return;
      }
      var be = null, re = requestAnimationFrame(() => {
        if (fe) {
          var Ae = (Ie) => {
            try {
              var je = le.toDOMNode(h, h);
              je.focus(), G(Ie);
            } catch {
            }
          };
          Ae(), be = setTimeout(() => {
            Ae(!0), _.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(re), be && clearTimeout(be);
      };
    }
  });
  var q = Lt((M) => {
    var $ = le.toDOMNode(h, h), B = $.getRootNode();
    if (L != null && L.current && $o && B instanceof ShadowRoot) {
      var V = M.getTargetRanges(), F = V[0], J = new window.Range();
      J.setStart(F.startContainer, F.startOffset), J.setEnd(F.endContainer, F.endOffset);
      var G = le.toSlateRange(h, J, {
        exactMatch: !1,
        suppressThrow: !1
      });
      pe.select(h, G), M.preventDefault(), M.stopImmediatePropagation();
      return;
    }
    if (W(), !a && le.hasEditableTarget(h, M.target) && !_6(M, i)) {
      var fe;
      if (R.current)
        return R.current.handleDOMBeforeInput(M);
      z.flush(), U.flush();
      var {
        selection: be
      } = h, {
        inputType: re
      } = M, Ae = M.dataTransfer || M.data || void 0, Ie = re === "insertCompositionText" || re === "deleteCompositionText";
      if (Ie && le.isComposing(h))
        return;
      var je = !1;
      if (re === "insertText" && be && ie.isCollapsed(be) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      M.data && M.data.length === 1 && /[a-z ]/i.test(M.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      be.anchor.offset !== 0 && (je = !0, h.marks && (je = !1), !gi.get(h))) {
        var _e, tt, {
          anchor: Ke
        } = be, [ke, nt] = le.toDOMPoint(h, Ke), gt = (_e = ke.parentElement) === null || _e === void 0 ? void 0 : _e.closest("a"), Pe = le.getWindow(h);
        if (je && gt && le.hasDOMNode(h, gt)) {
          var Te, Re = Pe == null ? void 0 : Pe.document.createTreeWalker(gt, NodeFilter.SHOW_TEXT).lastChild();
          Re === ke && ((Te = Re.textContent) === null || Te === void 0 ? void 0 : Te.length) === nt && (je = !1);
        }
        if (je && ke.parentElement && (Pe == null || (tt = Pe.getComputedStyle(ke.parentElement)) === null || tt === void 0 ? void 0 : tt.whiteSpace) === "pre") {
          var He = A.above(h, {
            at: Ke.path,
            match: (Pt) => xe.isElement(Pt) && A.isBlock(h, Pt)
          });
          He && ye.string(He[0]).includes("	") && (je = !1);
        }
      }
      if ((!re.startsWith("delete") || re.startsWith("deleteBy")) && !gi.get(h)) {
        var [ze] = M.getTargetRanges();
        if (ze) {
          var wt = le.toSlateRange(h, ze, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!be || !ie.equals(be, wt)) {
            je = !1;
            var Be = !Ie && h.selection && A.rangeRef(h, h.selection);
            pe.select(h, wt), Be && Cs.set(h, Be);
          }
        }
      }
      if (Ie)
        return;
      if (je || M.preventDefault(), be && ie.isExpanded(be) && re.startsWith("delete")) {
        var dn = re.endsWith("Backward") ? "backward" : "forward";
        A.deleteFragment(h, {
          direction: dn
        });
        return;
      }
      switch (re) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          A.deleteFragment(h);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          A.deleteForward(h);
          break;
        }
        case "deleteContentBackward": {
          A.deleteBackward(h);
          break;
        }
        case "deleteEntireSoftLine": {
          A.deleteBackward(h, {
            unit: "line"
          }), A.deleteForward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          A.deleteBackward(h, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          A.deleteBackward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          A.deleteForward(h, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          A.deleteForward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          A.deleteBackward(h, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          A.deleteForward(h, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          A.insertSoftBreak(h);
          break;
        case "insertParagraph": {
          A.insertBreak(h);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          re === "insertFromComposition" && le.isComposing(h) && (w(!1), Zo.set(h, !1)), (Ae == null ? void 0 : Ae.constructor.name) === "DataTransfer" ? le.insertData(h, Ae) : typeof Ae == "string" && (je ? E.current.push(() => A.insertText(h, Ae)) : A.insertText(h, Ae));
          break;
        }
      }
      var Ct = (fe = Cs.get(h)) === null || fe === void 0 ? void 0 : fe.unref();
      Cs.delete(h), Ct && (!h.selection || !ie.equals(h.selection, Ct)) && pe.select(h, Ct);
    }
  }, [h, U, W, i, a, z]), K = Lt((M) => {
    M == null ? (U.cancel(), z.cancel(), wl.delete(h), Jo.delete(h), k.current && no && k.current.removeEventListener("beforeinput", q)) : no && M.addEventListener("beforeinput", q), k.current = M, typeof t == "function" ? t(M) : t && (t.current = M);
  }, [U, z, h, q, t]);
  Ws(() => {
    var M = le.getWindow(h);
    M.document.addEventListener("selectionchange", z);
    var $ = () => {
      _.isDraggingInternally = !1;
    };
    return M.document.addEventListener("dragend", $), M.document.addEventListener("drop", $), () => {
      M.document.removeEventListener("selectionchange", z), M.document.removeEventListener("dragend", $), M.document.removeEventListener("drop", $);
    };
  }, [z, _]);
  var X = o([h, []]), ne = s && h.children.length === 1 && Array.from(ye.texts(h)).length === 1 && ye.string(h) === "" && !C, Q = Lt((M) => {
    if (M && ne) {
      var $;
      O(($ = M.getBoundingClientRect()) === null || $ === void 0 ? void 0 : $.height);
    } else
      O(void 0);
  }, [ne]);
  if (ne) {
    var S = A.start(h, []);
    X.push({
      [Ci]: !0,
      placeholder: s,
      onPlaceholderResize: Q,
      anchor: S,
      focus: S
    });
  }
  var {
    marks: I
  } = h;
  if (_.hasMarkPlaceholder = !1, h.selection && ie.isCollapsed(h.selection) && I) {
    var {
      anchor: Z
    } = h.selection, T = ye.leaf(h, Z.path), Y = wi(T, k6);
    if (!De.equals(T, I, {
      loose: !0
    })) {
      _.hasMarkPlaceholder = !0;
      var x = Object.fromEntries(Object.keys(Y).map((M) => [M, null]));
      X.push(xr(xr(xr({
        [jL]: !0
      }, x), I), {}, {
        anchor: Z,
        focus: Z
      }));
    }
  }
  return y(() => {
    setTimeout(() => {
      var {
        selection: M
      } = h;
      if (M) {
        var {
          anchor: $
        } = M, B = ye.leaf(h, $.path);
        if (I && !De.equals(B, I, {
          loose: !0
        })) {
          br.set(h, I);
          return;
        }
      }
      br.delete(h);
    });
  }), /* @__PURE__ */ Ce.createElement(qL.Provider, {
    value: a
  }, /* @__PURE__ */ Ce.createElement(P6.Provider, {
    value: C
  }, /* @__PURE__ */ Ce.createElement(VL.Provider, {
    value: o
  }, /* @__PURE__ */ Ce.createElement(L6, {
    node: k,
    receivedUserInput: D
  }, /* @__PURE__ */ Ce.createElement(m, xr(xr({
    role: a ? void 0 : "textbox",
    "aria-multiline": a ? void 0 : !0
  }, g), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: no || !bl ? g.spellCheck : !1,
    autoCorrect: no || !bl ? g.autoCorrect : "false",
    autoCapitalize: no || !bl ? g.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !a,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: K,
    style: xr(xr({}, f ? {} : xr({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, v ? {
      minHeight: v
    } : {})), p),
    onBeforeInput: Lt((M) => {
      if (!no && !a && !Fn(M, g.onBeforeInput) && le.hasSelectableTarget(h, M.target) && (M.preventDefault(), !le.isComposing(h))) {
        var $ = M.data;
        A.insertText(h, $);
      }
    }, [g.onBeforeInput, h, a]),
    onInput: Lt((M) => {
      if (!Fn(M, g.onInput)) {
        if (R.current) {
          R.current.handleInput();
          return;
        }
        for (var $ of E.current)
          $();
        if (E.current = [], !le.isFocused(h)) {
          var B = M.nativeEvent, V = h;
          if (B.inputType === "historyUndo" && typeof V.undo == "function") {
            V.undo();
            return;
          }
          if (B.inputType === "historyRedo" && typeof V.redo == "function") {
            V.redo();
            return;
          }
        }
      }
    }, [g.onInput, h]),
    onBlur: Lt((M) => {
      if (!(a || _.isUpdatingSelection || !le.hasSelectableTarget(h, M.target) || Fn(M, g.onBlur))) {
        var $ = le.findDocumentOrShadowRoot(h);
        if (_.latestElement !== $.activeElement) {
          var {
            relatedTarget: B
          } = M, V = le.toDOMNode(h, h);
          if (B !== V && !(hr(B) && B.hasAttribute("data-slate-spacer"))) {
            if (B != null && wo(B) && le.hasDOMNode(h, B)) {
              var F = le.toSlateNode(h, B);
              if (xe.isElement(F) && !h.isVoid(F))
                return;
            }
            if ($o) {
              var J = Es($);
              J == null || J.removeAllRanges();
            }
            yo.delete(h);
          }
        }
      }
    }, [a, _.isUpdatingSelection, _.latestElement, h, g.onBlur]),
    onClick: Lt((M) => {
      if (le.hasTarget(h, M.target) && !Fn(M, g.onClick) && wo(M.target)) {
        var $ = le.toSlateNode(h, M.target), B = le.findPath(h, $);
        if (!A.hasPath(h, B) || ye.get(h, B) !== $)
          return;
        if (M.detail === w6 && B.length >= 1) {
          var V = B;
          if (!(xe.isElement($) && A.isBlock(h, $))) {
            var F, J = A.above(h, {
              match: (je) => xe.isElement(je) && A.isBlock(h, je),
              at: B
            });
            V = (F = J == null ? void 0 : J[1]) !== null && F !== void 0 ? F : B.slice(0, 1);
          }
          var G = A.range(h, V);
          pe.select(h, G);
          return;
        }
        if (a)
          return;
        var fe = A.start(h, B), be = A.end(h, B), re = A.void(h, {
          at: fe
        }), Ae = A.void(h, {
          at: be
        });
        if (re && Ae && te.equals(re[1], Ae[1])) {
          var Ie = A.range(h, fe);
          pe.select(h, Ie);
        }
      }
    }, [h, g.onClick, a]),
    onCompositionEnd: Lt((M) => {
      if (le.hasSelectableTarget(h, M.target)) {
        var $;
        if (le.isComposing(h) && Promise.resolve().then(() => {
          w(!1), Zo.set(h, !1);
        }), ($ = R.current) === null || $ === void 0 || $.handleCompositionEnd(M), Fn(M, g.onCompositionEnd) || Rn)
          return;
        if (!$o && !C5 && !ML && !O5 && !E5 && M.data) {
          var B = br.get(h);
          br.delete(h), B !== void 0 && (Ur.set(h, h.marks), h.marks = B), A.insertText(h, M.data);
          var V = Ur.get(h);
          Ur.delete(h), V !== void 0 && (h.marks = V);
        }
      }
    }, [g.onCompositionEnd, h]),
    onCompositionUpdate: Lt((M) => {
      le.hasSelectableTarget(h, M.target) && !Fn(M, g.onCompositionUpdate) && (le.isComposing(h) || (w(!0), Zo.set(h, !0)));
    }, [g.onCompositionUpdate, h]),
    onCompositionStart: Lt((M) => {
      if (le.hasSelectableTarget(h, M.target)) {
        var $;
        if (($ = R.current) === null || $ === void 0 || $.handleCompositionStart(M), Fn(M, g.onCompositionStart) || Rn)
          return;
        w(!0);
        var {
          selection: B
        } = h;
        if (B && ie.isExpanded(B)) {
          A.deleteFragment(h);
          return;
        }
      }
    }, [g.onCompositionStart, h]),
    onCopy: Lt((M) => {
      le.hasSelectableTarget(h, M.target) && !Fn(M, g.onCopy) && !PC(M) && (M.preventDefault(), le.setFragmentData(h, M.clipboardData, "copy"));
    }, [g.onCopy, h]),
    onCut: Lt((M) => {
      if (!a && le.hasSelectableTarget(h, M.target) && !Fn(M, g.onCut) && !PC(M)) {
        M.preventDefault(), le.setFragmentData(h, M.clipboardData, "cut");
        var {
          selection: $
        } = h;
        if ($)
          if (ie.isExpanded($))
            A.deleteFragment(h);
          else {
            var B = ye.parent(h, $.anchor.path);
            A.isVoid(h, B) && pe.delete(h);
          }
      }
    }, [a, h, g.onCut]),
    onDragOver: Lt((M) => {
      if (le.hasTarget(h, M.target) && !Fn(M, g.onDragOver)) {
        var $ = le.toSlateNode(h, M.target);
        xe.isElement($) && A.isVoid(h, $) && M.preventDefault();
      }
    }, [g.onDragOver, h]),
    onDragStart: Lt((M) => {
      if (!a && le.hasTarget(h, M.target) && !Fn(M, g.onDragStart)) {
        var $ = le.toSlateNode(h, M.target), B = le.findPath(h, $), V = xe.isElement($) && A.isVoid(h, $) || A.void(h, {
          at: B,
          voids: !0
        });
        if (V) {
          var F = A.range(h, B);
          pe.select(h, F);
        }
        _.isDraggingInternally = !0, le.setFragmentData(h, M.dataTransfer, "drag");
      }
    }, [a, h, g.onDragStart, _]),
    onDrop: Lt((M) => {
      if (!a && le.hasTarget(h, M.target) && !Fn(M, g.onDrop)) {
        M.preventDefault();
        var $ = h.selection, B = le.findEventRange(h, M), V = M.dataTransfer;
        pe.select(h, B), _.isDraggingInternally && $ && !ie.equals($, B) && !A.void(h, {
          at: B,
          voids: !0
        }) && pe.delete(h, {
          at: $
        }), le.insertData(h, V), le.isFocused(h) || le.focus(h);
      }
    }, [a, h, g.onDrop, _]),
    onDragEnd: Lt((M) => {
      !a && _.isDraggingInternally && g.onDragEnd && le.hasTarget(h, M.target) && g.onDragEnd(M);
    }, [a, _, g, h]),
    onFocus: Lt((M) => {
      if (!a && !_.isUpdatingSelection && le.hasEditableTarget(h, M.target) && !Fn(M, g.onFocus)) {
        var $ = le.toDOMNode(h, h), B = le.findDocumentOrShadowRoot(h);
        if (_.latestElement = B.activeElement, di && M.target !== $) {
          $.focus();
          return;
        }
        yo.set(h, !0);
      }
    }, [a, _, h, g.onFocus]),
    onKeyDown: Lt((M) => {
      if (!a && le.hasEditableTarget(h, M.target)) {
        var $;
        ($ = R.current) === null || $ === void 0 || $.handleKeyDown(M);
        var {
          nativeEvent: B
        } = M;
        if (le.isComposing(h) && B.isComposing === !1 && (Zo.set(h, !1), w(!1)), Fn(M, g.onKeyDown) || le.isComposing(h))
          return;
        var {
          selection: V
        } = h, F = h.children[V !== null ? V.focus.path[0] : 0], J = yL(ye.string(F)) === "rtl";
        if (rn.isRedo(B)) {
          M.preventDefault();
          var G = h;
          typeof G.redo == "function" && G.redo();
          return;
        }
        if (rn.isUndo(B)) {
          M.preventDefault();
          var fe = h;
          typeof fe.undo == "function" && fe.undo();
          return;
        }
        if (rn.isMoveLineBackward(B)) {
          M.preventDefault(), pe.move(h, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (rn.isMoveLineForward(B)) {
          M.preventDefault(), pe.move(h, {
            unit: "line"
          });
          return;
        }
        if (rn.isExtendLineBackward(B)) {
          M.preventDefault(), pe.move(h, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (rn.isExtendLineForward(B)) {
          M.preventDefault(), pe.move(h, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (rn.isMoveBackward(B)) {
          M.preventDefault(), V && ie.isCollapsed(V) ? pe.move(h, {
            reverse: !J
          }) : pe.collapse(h, {
            edge: J ? "end" : "start"
          });
          return;
        }
        if (rn.isMoveForward(B)) {
          M.preventDefault(), V && ie.isCollapsed(V) ? pe.move(h, {
            reverse: J
          }) : pe.collapse(h, {
            edge: J ? "start" : "end"
          });
          return;
        }
        if (rn.isMoveWordBackward(B)) {
          M.preventDefault(), V && ie.isExpanded(V) && pe.collapse(h, {
            edge: "focus"
          }), pe.move(h, {
            unit: "word",
            reverse: !J
          });
          return;
        }
        if (rn.isMoveWordForward(B)) {
          M.preventDefault(), V && ie.isExpanded(V) && pe.collapse(h, {
            edge: "focus"
          }), pe.move(h, {
            unit: "word",
            reverse: J
          });
          return;
        }
        if (no) {
          if ((AL || $o) && V && (rn.isDeleteBackward(B) || rn.isDeleteForward(B)) && ie.isCollapsed(V)) {
            var be = ye.parent(h, V.anchor.path);
            if (xe.isElement(be) && A.isVoid(h, be) && (A.isInline(h, be) || A.isBlock(h, be))) {
              M.preventDefault(), A.deleteBackward(h, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (rn.isBold(B) || rn.isItalic(B) || rn.isTransposeCharacter(B)) {
            M.preventDefault();
            return;
          }
          if (rn.isSoftBreak(B)) {
            M.preventDefault(), A.insertSoftBreak(h);
            return;
          }
          if (rn.isSplitBlock(B)) {
            M.preventDefault(), A.insertBreak(h);
            return;
          }
          if (rn.isDeleteBackward(B)) {
            M.preventDefault(), V && ie.isExpanded(V) ? A.deleteFragment(h, {
              direction: "backward"
            }) : A.deleteBackward(h);
            return;
          }
          if (rn.isDeleteForward(B)) {
            M.preventDefault(), V && ie.isExpanded(V) ? A.deleteFragment(h, {
              direction: "forward"
            }) : A.deleteForward(h);
            return;
          }
          if (rn.isDeleteLineBackward(B)) {
            M.preventDefault(), V && ie.isExpanded(V) ? A.deleteFragment(h, {
              direction: "backward"
            }) : A.deleteBackward(h, {
              unit: "line"
            });
            return;
          }
          if (rn.isDeleteLineForward(B)) {
            M.preventDefault(), V && ie.isExpanded(V) ? A.deleteFragment(h, {
              direction: "forward"
            }) : A.deleteForward(h, {
              unit: "line"
            });
            return;
          }
          if (rn.isDeleteWordBackward(B)) {
            M.preventDefault(), V && ie.isExpanded(V) ? A.deleteFragment(h, {
              direction: "backward"
            }) : A.deleteBackward(h, {
              unit: "word"
            });
            return;
          }
          if (rn.isDeleteWordForward(B)) {
            M.preventDefault(), V && ie.isExpanded(V) ? A.deleteFragment(h, {
              direction: "forward"
            }) : A.deleteForward(h, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [a, h, g.onKeyDown]),
    onPaste: Lt((M) => {
      !a && le.hasEditableTarget(h, M.target) && !Fn(M, g.onPaste) && (!no || L5(M.nativeEvent) || $o) && (M.preventDefault(), le.insertData(h, M.clipboardData));
    }, [a, h, g.onPaste])
  }), /* @__PURE__ */ Ce.createElement(M6, {
    decorations: X,
    node: h,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: h.selection
  }))))));
}), T6 = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ Ce.createElement("span", xr({}, t), n, Rn && /* @__PURE__ */ Ce.createElement("br", null))
  );
}, B6 = () => [], j6 = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && ie.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), G8(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, Fn = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, PC = (e) => wo(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), _6 = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, I6 = /* @__PURE__ */ Ze(!1), F6 = /* @__PURE__ */ Ze({});
function R6(e) {
  var t = qe([]).current, n = qe({
    editor: e
  }).current, r = Lt((i) => {
    n.editor = i, t.forEach((s) => s(i));
  }, [t, n]), o = Mn(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var N6 = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], z6 = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: s
  } = e, a = wi(e, N6), [l, u] = Ce.useState(() => {
    if (!ye.isNodeList(s))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(Ln.stringify(s)));
    if (!A.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Ln.stringify(t)));
    return t.children = s, Object.assign(t, a), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: d
  } = R6(t), p = Lt((g) => {
    var h;
    switch (r && r(t.children), g == null || (h = g.operation) === null || h === void 0 ? void 0 : h.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((C) => ({
      v: C.v + 1,
      editor: t
    })), d(t);
  }, [t, d, r, o, i]);
  y(() => (uf.set(t, p), () => {
    uf.set(t, () => {
    });
  }), [t, p]);
  var [m, f] = P(le.isFocused(t));
  return y(() => {
    f(le.isFocused(t));
  }, [t]), Ws(() => {
    var g = () => f(le.isFocused(t));
    return kL >= 17 ? (document.addEventListener("focusin", g), document.addEventListener("focusout", g), () => {
      document.removeEventListener("focusin", g), document.removeEventListener("focusout", g);
    }) : (document.addEventListener("focus", g, !0), document.addEventListener("blur", g, !0), () => {
      document.removeEventListener("focus", g, !0), document.removeEventListener("blur", g, !0);
    });
  }, []), /* @__PURE__ */ Ce.createElement(F6.Provider, {
    value: c
  }, /* @__PURE__ */ Ce.createElement(GL.Provider, {
    value: l
  }, /* @__PURE__ */ Ce.createElement(ig.Provider, {
    value: l.editor
  }, /* @__PURE__ */ Ce.createElement(I6.Provider, {
    value: m
  }, n))));
}, SC = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, kC = (e, t, n) => {
  var r = le.toDOMRange(e, t).getBoundingClientRect(), o = le.toDOMRange(e, n).getBoundingClientRect();
  return SC(r, o) && SC(o, r);
}, $6 = (e, t) => {
  var n = A.range(e, ie.end(t)), r = Array.from(A.positions(e, {
    at: t
  })), o = 0, i = r.length, s = Math.floor(i / 2);
  if (kC(e, A.range(e, r[o]), n))
    return A.range(e, r[o], n);
  if (r.length < 2)
    return A.range(e, r[r.length - 1], n);
  for (; s !== r.length && s !== o; )
    kC(e, A.range(e, r[s]), n) ? i = s : o = s, s = Math.floor((o + i) / 2);
  return A.range(e, r[i], n);
};
function MC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function AC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MC(Object(n), !0).forEach(function(r) {
      gr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var U6 = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: s,
    addMark: a,
    removeMark: l
  } = r;
  return Sc.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var d, p;
    (d = lg.get(r)) === null || d === void 0 || d(), !br.get(r) && (p = Vn.get(r)) !== null && p !== void 0 && p.length && br.set(r, null), Ur.delete(r), a(u, c);
  }, r.removeMark = (u) => {
    var c;
    !br.get(r) && (c = Vn.get(r)) !== null && c !== void 0 && c.length && br.set(r, null), Ur.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return s(u);
    if (r.selection && ie.isCollapsed(r.selection)) {
      var c = A.above(r, {
        match: (f) => xe.isElement(f) && A.isBlock(r, f),
        at: r.selection
      });
      if (c) {
        var [, d] = c, p = A.range(r, d, r.selection.anchor), m = $6(r, p);
        ie.isCollapsed(m) || pe.delete(r, {
          at: m
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], d = [], p = Vn.get(r);
    if (p != null && p.length) {
      var m = p.map((z) => $5(z, u)).filter(Boolean);
      Vn.set(r, m);
    }
    var f = po.get(r);
    f && po.set(r, yC(r, f, u));
    var g = co.get(r);
    if (g != null && g.at) {
      var h = Je.isPoint(g == null ? void 0 : g.at) ? pf(r, g.at, u) : yC(r, g.at, u);
      co.set(r, h ? AC(AC({}, g), {}, {
        at: h
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...ui(r, u.path));
        break;
      }
      case "set_selection": {
        var C;
        (C = Cs.get(r)) === null || C === void 0 || C.unref(), Cs.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...ui(r, te.parent(u.path)));
        break;
      }
      case "merge_node": {
        var w = te.previous(u.path);
        c.push(...ui(r, w));
        break;
      }
      case "move_node": {
        var k = te.common(te.parent(u.path), te.parent(u.newPath));
        c.push(...ui(r, k));
        var E;
        te.isBefore(u.path, u.newPath) ? (c.push(...ui(r, te.parent(u.path))), E = u.newPath) : (c.push(...ui(r, te.parent(u.newPath))), E = u.path);
        var v = ye.get(t, te.parent(E)), O = le.findKey(r, v), L = A.pathRef(r, te.parent(E));
        d.push([L, O]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        gi.set(r, !0);
    }
    for (var [W, D] of c) {
      var [N] = A.node(r, W);
      pu.set(N, D);
    }
    for (var [_, R] of d) {
      if (_.current) {
        var [U] = A.node(r, _.current);
        pu.set(U, R);
      }
      _.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [d, p] = ie.edges(c), m = A.void(r, {
        at: d.path
      }), f = A.void(r, {
        at: p.path
      });
      if (!(ie.isCollapsed(c) && !m)) {
        var g = le.toDOMRange(r, c), h = g.cloneContents(), C = h.childNodes[0];
        if (h.childNodes.forEach((N) => {
          N.textContent && N.textContent.trim() !== "" && (C = N);
        }), f) {
          var [w] = f, k = g.cloneRange(), E = le.toDOMNode(r, w);
          k.setEndAfter(E), h = k.cloneContents();
        }
        if (m && (C = h.querySelector("[data-slate-spacer]")), Array.from(h.querySelectorAll("[data-slate-zero-width]")).forEach((N) => {
          var _ = N.getAttribute("data-slate-zero-width") === "n";
          N.textContent = _ ? `
` : "";
        }), IL(C)) {
          var v = C.ownerDocument.createElement("span");
          v.style.whiteSpace = "pre", v.appendChild(C), h.appendChild(v), C = v;
        }
        var O = r.getFragment(), L = JSON.stringify(O), W = window.btoa(encodeURIComponent(L));
        C.setAttribute("data-slate-fragment", W), u.setData("application/".concat(n), W);
        var D = h.ownerDocument.createElement("div");
        return D.appendChild(h), D.setAttribute("hidden", "true"), h.ownerDocument.body.appendChild(D), u.setData("text/html", D.innerHTML), u.setData("text/plain", RL(D)), h.ownerDocument.body.removeChild(D), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || A5(u);
    if (c) {
      var d = decodeURIComponent(window.atob(c)), p = JSON.parse(d);
      return r.insertFragment(p), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var d = c.split(/\r\n|\r|\n/), p = !1;
      for (var m of d)
        p && pe.splitNodes(r, {
          always: !0
        }), r.insertText(m), p = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = kL < 18 ? xu.unstable_batchedUpdates : (d) => d();
    c(() => {
      var d = uf.get(r);
      d && d(u), i(u);
    });
  }, r;
}, ui = (e, t) => {
  var n = [];
  for (var [r, o] of A.levels(e, {
    at: t
  })) {
    var i = le.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function YL(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    A.nodes(e, {
      at: A.unhangRange(e, r),
      match: (i) => !A.isEditor(i) && xe.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const TC = ["listItem", "numberedList"], Cl = ["left", "center", "right", "justify"];
function W6(e, t) {
  const n = Cl.includes(t) ? "align" : "type", r = YL(e, t, n), o = TC.includes(t);
  pe.unwrapNodes(e, {
    match: (s) => !A.isEditor(s) && xe.isElement(s) && TC.includes(s.type) && !Cl.includes(t),
    split: !0
  });
  let i;
  if (Cl.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, pe.setNodes(e, i), !r && o) {
    const s = { type: t, children: [] };
    pe.wrapNodes(e, s);
  }
}
function _o({ format: e, icon: t }) {
  const n = kc(), r = Cl.includes(e) ? "align" : "type", i = YL(n, e, r) ? "activeTrue" : "activeFalse";
  function s(a) {
    a.preventDefault(), W6(n, e);
  }
  return /* @__PURE__ */ j.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: s,
      children: /* @__PURE__ */ j.jsx(t, {})
    }
  );
}
function V6({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ j.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ j.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ j.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ j.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ j.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ j.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    case "image":
      return /* @__PURE__ */ j.jsxs("div", { style: r, ...e, children: [
        /* @__PURE__ */ j.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        t
      ] });
    default:
      return /* @__PURE__ */ j.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
const XL = Ze({});
function H6(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, a = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ j.jsx(XL.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ j.jsx($E, { children: t && /* @__PURE__ */ j.jsxs("aside", { className: a.trim(), ...i, children: [
    /* @__PURE__ */ j.jsx(
      xs.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ j.jsx(
      xs.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function q6(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ j.jsx("footer", { className: o.trim(), ...r });
}
function G6(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = Oe(XL), s = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ j.jsxs("header", { className: s.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ j.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ j.jsx(Lf, { size: 24 })
      }
    )
  ] });
}
const hf = Ze({});
function Z6() {
  if (!hf)
    throw new Error("useTabContext must be used within a TabProvider");
  return Oe(hf);
}
function Y6(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [s, a] = P(r || ""), [l, u] = P(!0), c = qe(null), d = `arkynTabContainer ${o || ""}`, [p, m] = P({
    width: "0px",
    left: "0px",
    transition: "none"
  }), f = (h, C) => {
    const w = h.getBoundingClientRect(), k = c.current.getBoundingClientRect(), E = C ? void 0 : "none";
    u(!1), m({
      transition: E,
      width: `${w.width}px`,
      left: `${w.left - k.left}px`
    });
  };
  y(() => {
    const h = c.current;
    if (!h) return;
    let C = null;
    C = h.querySelector("button.activeTrue"), C && f(C);
  }, []);
  const g = (h) => {
    const C = h.target;
    C && (a(C.value), C.classList.add("activeTrue"), f(C, !0), n && n(C.value));
  };
  return /* @__PURE__ */ j.jsxs("nav", { ref: c, className: d.trim(), ...i, children: [
    /* @__PURE__ */ j.jsx(hf.Provider, { value: { handleTabClick: g, showInitialTab: l, value: s }, children: t }),
    /* @__PURE__ */ j.jsx("div", { className: "activeLine", style: p })
  ] });
}
function BC(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: s, handleTabClick: a } = Z6(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && s ? "showBorderBottom" : ""} ${l} ${n}`;
  function d(p) {
    a(p), r && r(p);
  }
  return /* @__PURE__ */ j.jsx(
    "button",
    {
      onClick: d,
      className: c.trim(),
      ...o,
      type: "button",
      children: t
    }
  );
}
function X6(e) {
  const {
    action: t,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: s = "URL da imagem:",
    modalTitle: a = "Inserir imagem"
  } = e, l = kc(), [u, c] = P(!1), [d, p] = P(""), [m, f] = P("url");
  function g(h) {
    h.preventDefault(), !(!d || d === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: d, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ j.jsxs(j.Fragment, { children: [
    /* @__PURE__ */ j.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ j.jsx(QP, {})
      }
    ),
    /* @__PURE__ */ j.jsxs(
      H6,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ j.jsx(G6, { children: a }),
          /* @__PURE__ */ j.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ j.jsxs(Y6, { defaultActive: m, onClick: f, children: [
              /* @__PURE__ */ j.jsx(BC, { value: "url", children: n[0] }),
              /* @__PURE__ */ j.jsx(BC, { value: "file", children: n[1] })
            ] }),
            m === "url" && /* @__PURE__ */ j.jsxs(j.Fragment, { children: [
              /* @__PURE__ */ j.jsxs(qw, { children: [
                /* @__PURE__ */ j.jsx(Gw, { children: s }),
                /* @__PURE__ */ j.jsx(
                  Lc,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: d,
                    onChange: (h) => p(h.target.value)
                  }
                )
              ] }),
              d && /* @__PURE__ */ j.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: d,
                  alt: "preview"
                }
              )
            ] }),
            m === "file" && /* @__PURE__ */ j.jsxs(qw, { children: [
              /* @__PURE__ */ j.jsx(Gw, { children: i }),
              /* @__PURE__ */ j.jsx(
                sW,
                {
                  name: "richTextimageURL",
                  action: t,
                  defaultValue: d,
                  onUpload: (h) => p(h || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ j.jsxs(q6, { children: [
            /* @__PURE__ */ j.jsx(
              du,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ j.jsx(du, { type: "button", onClick: g, children: o })
          ] })
        ]
      }
    )
  ] });
}
function K6({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ j.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ j.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ j.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ j.jsx("u", { children: t })), /* @__PURE__ */ j.jsx("span", { ...e, children: t });
}
function KL(e, t) {
  const n = A.marks(e);
  return n ? n[t] === !0 : !1;
}
function JL(e, t) {
  KL(e, t) ? A.removeMark(e, t) : A.addMark(e, t, !0);
}
function ol({ format: e, icon: t }) {
  const n = kc(), o = KL(n, e) ? "activeTrue" : "activeFalse";
  function i(s) {
    s.preventDefault(), JL(n, e);
  }
  return /* @__PURE__ */ j.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ j.jsx(t, {})
    }
  );
}
function J6({ children: e }) {
  return /* @__PURE__ */ j.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
function jC(e) {
  return e.map((t) => ye.string(t)).join("");
}
const _C = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, il = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function yG(e) {
  const {
    name: t,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: s,
    maxLimit: a = 2e3,
    onChange: l,
    isError: u
  } = e, c = Mn(() => BW(U6(XM())), []), { id: d, inputRef: p, error: m } = Jn(), f = qe(null);
  function g() {
    try {
      const X = JSON.parse(o);
      return !Array.isArray(X) || X.length <= 0 ? il : X.every(
        (Q) => typeof Q == "object" && Q !== null && "type" in Q && "children" in Q
      ) ? X : il;
    } catch {
      return il;
    }
  }
  const h = jC(g()), [C, w] = P(h.length), [k, E] = P(
    JSON.stringify(g()) || "[]"
  ), [v, O] = P(!1), L = p || f, W = u || !!m, D = Lt(K6, []), N = Lt(V6, []);
  function _(X) {
    const ne = jC(X);
    w(ne.length), s && s(ne.length), !(i && ne.length >= a) && (E(JSON.stringify(X)), l && l(X), c.children = X, pe.setNodes(c, { children: X }));
  }
  const R = v ? "focusTrue" : "focusFalse", z = `arkynRichText ${W || a < C ? "errorTrue" : "errorFalse"} ${R}`, q = a - C;
  function K(X) {
    return !(n != null && n.includes(X));
  }
  return /* @__PURE__ */ j.jsxs(
    z6,
    {
      editor: c,
      initialValue: g(),
      onChange: _,
      onValueChange: _,
      children: [
        /* @__PURE__ */ j.jsxs("div", { className: z, children: [
          /* @__PURE__ */ j.jsxs(J6, { children: [
            K("headingOne") && /* @__PURE__ */ j.jsx(_o, { format: "headingOne", icon: eS }),
            K("headingTwo") && /* @__PURE__ */ j.jsx(_o, { format: "headingTwo", icon: tS }),
            K("blockQuote") && /* @__PURE__ */ j.jsx(_o, { format: "blockQuote", icon: nS }),
            K("bold") && /* @__PURE__ */ j.jsx(ol, { format: "bold", icon: rS }),
            K("italic") && /* @__PURE__ */ j.jsx(ol, { format: "italic", icon: oS }),
            K("underline") && /* @__PURE__ */ j.jsx(ol, { format: "underline", icon: iS }),
            K("code") && /* @__PURE__ */ j.jsx(ol, { format: "code", icon: sS }),
            K("left") && /* @__PURE__ */ j.jsx(_o, { format: "left", icon: aS }),
            K("right") && /* @__PURE__ */ j.jsx(_o, { format: "right", icon: lS }),
            K("center") && /* @__PURE__ */ j.jsx(_o, { format: "center", icon: uS }),
            K("justify") && /* @__PURE__ */ j.jsx(_o, { format: "justify", icon: cS }),
            r && K("image") && /* @__PURE__ */ j.jsx(X6, { ...r })
          ] }),
          /* @__PURE__ */ j.jsx(
            A6,
            {
              className: "editorContainer",
              renderElement: N,
              renderLeaf: D,
              spellCheck: !0,
              id: d,
              onFocus: () => O(!0),
              onBlur: () => O(!1),
              onKeyDown: (X) => {
                for (const ne in _C)
                  if (MW(ne, X)) {
                    X.preventDefault();
                    const Q = _C[ne];
                    JL(c, Q);
                  }
              }
            }
          ),
          q < 0 && /* @__PURE__ */ j.jsx("div", { className: "restatesCharacters", children: q })
        ] }),
        /* @__PURE__ */ j.jsx("input", { type: "hidden", ref: L, name: t, value: k }),
        /* @__PURE__ */ j.jsx("input", { type: "hidden", name: `${t}Count`, value: C })
      ]
    }
  );
}
function Q6(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: d,
    onBlur: p,
    title: m,
    style: f,
    closeOnSelect: g = !0,
    ...h
  } = e, v = `arkyn_select ${a ? "hasPrefix" : ""} ${s} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, L = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: v,
    prefix: wO(a, L, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: d,
    onBlur: p,
    title: m,
    closeOnSelect: g,
    style: f,
    iconSize: L,
    Spinner: /* @__PURE__ */ j.jsx(Mr, { className: "spinner", size: L, strokeWidth: 2.5 }),
    ...h
  };
}
function bG(e) {
  var M;
  const [t, n] = P(""), [r, o] = P(!1), { inputRef: i, id: s, error: a } = Jn(), l = qe(null), u = i || l, c = e.isError || !!a, {
    disabled: d,
    title: p,
    style: m,
    className: f,
    prefix: g,
    iconSize: h,
    isLoading: C,
    LeftIcon: w,
    value: k = null,
    defaultValue: E = "",
    onFocus: v,
    onBlur: O,
    Spinner: L,
    name: W,
    placeholder: D,
    onSelect: N,
    options: _,
    optionMaxHeight: R,
    closeOnSelect: U,
    isSearchable: z,
    onSearch: q,
    ...K
  } = Q6({ ...e, id: s, isError: c }, r), [X, ne] = P(E);
  function Q() {
    d || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function S($) {
    r || (o(!0), v && v($));
  }
  function I() {
    o(!1), O && u.current && u.current.blur();
  }
  function Z($) {
    const { label: B, value: V } = $;
    ne(X !== V ? V : ""), N && N({ label: B, value: V }), U && I();
  }
  const T = typeof k == "string" ? k : X, Y = ((M = _.find(($) => $.value === T)) == null ? void 0 : M.label) || "", x = () => {
    if (!r && Y) return !0;
    if (!r && !Y) return !1;
    if (r && Y) return !0;
    if (r && !Y) return !1;
  };
  return /* @__PURE__ */ j.jsxs(j.Fragment, { children: [
    /* @__PURE__ */ j.jsxs(
      "section",
      {
        title: p,
        style: m,
        onClick: Q,
        className: `${f} placeholder_dark_${x()}`,
        children: [
          g,
          w && /* @__PURE__ */ j.jsx(w, { size: h, strokeWidth: 2.5 }),
          /* @__PURE__ */ j.jsx(
            "input",
            {
              disabled: d,
              readOnly: !0,
              placeholder: Y || D,
              onFocus: S,
              ...K
            }
          ),
          /* @__PURE__ */ j.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: W,
              value: T || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ j.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: R },
              children: [
                z && /* @__PURE__ */ j.jsx(
                  Lc,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: FE,
                    onChange: ($) => n($.target.value)
                  }
                ),
                _.filter(($) => !!(e.onSearch || !e.isSearchable || $.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: $, value: B }) => /* @__PURE__ */ j.jsxs(
                  "div",
                  {
                    onClick: () => Z({ label: $, value: B }),
                    className: T === B ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      $,
                      " ",
                      /* @__PURE__ */ j.jsx(Df, {})
                    ]
                  },
                  B
                )),
                _.length <= 0 && /* @__PURE__ */ j.jsx("p", { children: "Sem opções disponíveis" })
              ]
            }
          ),
          !C && /* @__PURE__ */ j.jsx(
            IE,
            {
              className: "arkyn_select_arrow",
              size: h,
              strokeWidth: 2.5
            }
          ),
          C && L
        ]
      }
    ),
    r && /* @__PURE__ */ j.jsx("aside", { className: "arkyn_select_overlay", onClick: I })
  ] });
}
function wG(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: s,
    className: a = "",
    onCheck: l,
    ...u
  } = e, [c, d] = P(n), { id: p, inputRef: m } = Jn(), f = typeof r == "boolean" ? r : c;
  function g() {
    d(!c), l && l(f ? i : o || "checked");
  }
  const C = `arkynSwitch ${f ? "checkedTrue" : "checkedFalse"} ${t} ${a}`;
  return /* @__PURE__ */ j.jsx("button", { type: "button", onClick: g, className: C, ...u, children: /* @__PURE__ */ j.jsx(
    "input",
    {
      id: p,
      type: "hidden",
      name: s,
      ref: m,
      onClick: g,
      value: f ? o || "checked" : i
    }
  ) });
}
function CG(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: s,
    onBlur: a,
    title: l,
    style: u,
    ...c
  } = e, [d, p] = P(!1), { inputRef: m, id: f, error: g } = Jn(), h = qe(null), C = m || h, k = e.isError || !!g ? "errorTrue" : "errorFalse", O = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${k} ${d ? "focusedTrue" : "focusedFalse"} ${r}`;
  function L() {
    o || !(C != null && C.current) || (p(!0), C.current.focus());
  }
  function W(N) {
    p(!0), s && s(N);
  }
  function D(N) {
    p(!1), a && a(N);
  }
  return /* @__PURE__ */ j.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: L,
      className: O,
      children: /* @__PURE__ */ j.jsx(
        "textarea",
        {
          id: f,
          disabled: o,
          readOnly: i,
          ref: C,
          onFocus: W,
          onBlur: D,
          ...c
        }
      )
    }
  );
}
function EG(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ j.jsx("nav", { className: r, ...n });
}
function OG(e) {
  const { pathname: t } = Sf(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...s
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ j.jsxs("p", { className: l, children: [
    /* @__PURE__ */ j.jsx(cp, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ j.jsxs(fS, { to: i, className: l, ...s, children: [
    /* @__PURE__ */ j.jsx(cp, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function QL(e = "") {
  const t = Sf(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([s, a]) => {
      a === void 0 ? n.delete(`${r}${s}`) : n.set(`${r}${s}`, String(a));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let s = n.toString();
      return s && (s = "?" + s), s;
    }
  };
}
function IC(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function xG(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: s = 1,
    registerPerPage: a = 20,
    ...l
  } = e, u = zE(), { getParam: c, getScopedSearch: d } = QL(t), p = Number(c("page")) || s, m = Number(c("per_page")) || a, f = Math.ceil(n / m), g = p > 1 ? IC(p - 1 - i, p - 1) : [], h = p < f ? IC(
    p,
    Math.min(p + i, f)
  ) : [];
  function C(w) {
    u(d({ page: w }));
  }
  return /* @__PURE__ */ j.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ j.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: p <= 1,
        onClick: () => C(p - 1),
        children: /* @__PURE__ */ j.jsx(dS, {})
      }
    ),
    p > 1 + i && /* @__PURE__ */ j.jsxs(j.Fragment, { children: [
      /* @__PURE__ */ j.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => C(1),
          children: "1"
        }
      ),
      p > 2 + i && /* @__PURE__ */ j.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ j.jsx(xg, {}) })
    ] }),
    g.length > 0 && g.map((w, k) => /* @__PURE__ */ j.jsx(
      "button",
      {
        onClick: () => C(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      k
    )),
    /* @__PURE__ */ j.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: p }),
    h.length > 0 && h.map((w, k) => /* @__PURE__ */ j.jsx(
      "button",
      {
        onClick: () => C(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      k
    )),
    p + i < f && /* @__PURE__ */ j.jsxs(j.Fragment, { children: [
      p + 1 + i < f && /* @__PURE__ */ j.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ j.jsx(xg, {}) }),
      /* @__PURE__ */ j.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => C(f),
          children: f
        }
      )
    ] }),
    /* @__PURE__ */ j.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: p >= f,
        onClick: () => C(p + 1),
        children: /* @__PURE__ */ j.jsx(cp, {})
      }
    )
  ] });
}
const eP = Ze({});
function DG(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...s
  } = e, a = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ j.jsx(eP.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ j.jsx($E, { children: t && /* @__PURE__ */ j.jsxs("aside", { className: u.trim(), ...s, children: [
    /* @__PURE__ */ j.jsx(
      xs.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ j.jsx(
      xs.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${a})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${a})` },
        children: o
      }
    )
  ] }) }) });
}
function LG(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = Oe(eP), s = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ j.jsxs("header", { className: s.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ j.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ j.jsx(Lf, { size: 24 })
      }
    )
  ] });
}
function PG(e) {
  const { children: t, button: n, closeOnClick: r, orientation: o = "bottomLeft" } = e, [i, s] = P(!1), l = `arkynPopover ${o} ${i ? "visibleTrue" : "visibleFalse"}`;
  function u() {
    i || s(!0);
  }
  return /* @__PURE__ */ j.jsxs("div", { className: l, onClick: u, children: [
    n,
    /* @__PURE__ */ j.jsx(
      xs.div,
      {
        style: { visibility: i ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: i ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && s(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    i && /* @__PURE__ */ j.jsx("div", { onClick: () => s(!1), className: "arkynPopoverOverlay" })
  ] });
}
function SG(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ j.jsx(jE, {});
      case "danger":
        return /* @__PURE__ */ j.jsx(BE, {});
      default:
        return /* @__PURE__ */ j.jsx(TE, {});
    }
  }
  return /* @__PURE__ */ j.jsxs("div", { className: r, children: [
    /* @__PURE__ */ j.jsxs("div", { children: [
      /* @__PURE__ */ j.jsx("div", { className: "bg" }),
      /* @__PURE__ */ j.jsx(o, {})
    ] }),
    /* @__PURE__ */ j.jsx("p", { children: /* @__PURE__ */ j.jsx("span", { children: t }) })
  ] });
}
var mn = {}, dg = {}, sa = {}, aa = {}, tP = "Expected a function", FC = NaN, e4 = "[object Symbol]", t4 = /^\s+|\s+$/g, n4 = /^[-+]0x[0-9a-f]+$/i, r4 = /^0b[01]+$/i, o4 = /^0o[0-7]+$/i, i4 = parseInt, s4 = typeof jt == "object" && jt && jt.Object === Object && jt, a4 = typeof self == "object" && self && self.Object === Object && self, l4 = s4 || a4 || Function("return this")(), u4 = Object.prototype, c4 = u4.toString, d4 = Math.max, p4 = Math.min, Zd = function() {
  return l4.Date.now();
};
function f4(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, d = !1, p = !0;
  if (typeof e != "function")
    throw new TypeError(tP);
  t = RC(t) || 0, fu(n) && (c = !!n.leading, d = "maxWait" in n, i = d ? d4(RC(n.maxWait) || 0, t) : i, p = "trailing" in n ? !!n.trailing : p);
  function m(O) {
    var L = r, W = o;
    return r = o = void 0, u = O, s = e.apply(W, L), s;
  }
  function f(O) {
    return u = O, a = setTimeout(C, t), c ? m(O) : s;
  }
  function g(O) {
    var L = O - l, W = O - u, D = t - L;
    return d ? p4(D, i - W) : D;
  }
  function h(O) {
    var L = O - l, W = O - u;
    return l === void 0 || L >= t || L < 0 || d && W >= i;
  }
  function C() {
    var O = Zd();
    if (h(O))
      return w(O);
    a = setTimeout(C, g(O));
  }
  function w(O) {
    return a = void 0, p && r ? m(O) : (r = o = void 0, s);
  }
  function k() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function E() {
    return a === void 0 ? s : w(Zd());
  }
  function v() {
    var O = Zd(), L = h(O);
    if (r = arguments, o = this, l = O, L) {
      if (a === void 0)
        return f(l);
      if (d)
        return a = setTimeout(C, t), m(l);
    }
    return a === void 0 && (a = setTimeout(C, t)), s;
  }
  return v.cancel = k, v.flush = E, v;
}
function h4(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(tP);
  return fu(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), f4(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function fu(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function g4(e) {
  return !!e && typeof e == "object";
}
function m4(e) {
  return typeof e == "symbol" || g4(e) && c4.call(e) == e4;
}
function RC(e) {
  if (typeof e == "number")
    return e;
  if (m4(e))
    return FC;
  if (fu(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = fu(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(t4, "");
  var n = r4.test(e);
  return n || o4.test(e) ? i4(e.slice(2), n ? 2 : 8) : n4.test(e) ? FC : +e;
}
var v4 = h4, la = {};
Object.defineProperty(la, "__esModule", {
  value: !0
});
la.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), El.has(n) || El.set(n, /* @__PURE__ */ new Set());
  var i = El.get(n);
  if (!i.has(o)) {
    var s = function() {
      var a = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return a;
    }();
    t.addEventListener(n, r, s ? { passive: !0 } : !1), i.add(o);
  }
};
la.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), El.get(n).delete(r.name || n);
};
var El = /* @__PURE__ */ new Map();
Object.defineProperty(aa, "__esModule", {
  value: !0
});
var y4 = v4, b4 = C4(y4), w4 = la;
function C4(e) {
  return e && e.__esModule ? e : { default: e };
}
var E4 = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, b4.default)(t, n);
}, an = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = E4(function(o) {
        an.scrollHandler(t);
      }, n);
      an.scrollSpyContainers.push(t), (0, w4.addPassiveEventListener)(t, "scroll", r);
    }
  },
  isMounted: function(t) {
    return an.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.pageYOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = an.scrollSpyContainers[an.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(an.currentPositionX(t), an.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    an.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = an.scrollSpyContainers[an.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t), t(an.currentPositionX(n), an.currentPositionY(n));
  },
  updateStates: function() {
    an.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    an.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), an.spySetState && an.spySetState.length && an.spySetState.indexOf(t) > -1 && an.spySetState.splice(an.spySetState.indexOf(t), 1), document.removeEventListener("scroll", an.scrollHandler);
  },
  update: function() {
    return an.scrollSpyContainers.forEach(function(t) {
      return an.scrollHandler(t);
    });
  }
};
aa.default = an;
var Ti = {}, ua = {};
Object.defineProperty(ua, "__esModule", {
  value: !0
});
var O4 = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, s = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", s) : history.replaceState(history.state, "", s);
}, x4 = function() {
  return window.location.hash.replace(/^#/, "");
}, D4 = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, L4 = function(t) {
  return getComputedStyle(t).position !== "static";
}, Yd = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, P4 = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (L4(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = Yd(n, o), s = i.offsetTop, a = i.offsetParent;
      if (a !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return s;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return Yd(n, l).offsetTop - Yd(t, l).offsetTop;
};
ua.default = {
  updateHash: O4,
  getHash: x4,
  filterElementInContainer: D4,
  scrollOffset: P4
};
var Mc = {}, pg = {};
Object.defineProperty(pg, "__esModule", {
  value: !0
});
pg.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var fg = {};
Object.defineProperty(fg, "__esModule", {
  value: !0
});
var S4 = la, k4 = ["mousedown", "mousewheel", "touchmove", "keydown"];
fg.default = {
  subscribe: function(t) {
    return typeof document < "u" && k4.forEach(function(n) {
      return (0, S4.addPassiveEventListener)(document, n, t);
    });
  }
};
var ca = {};
Object.defineProperty(ca, "__esModule", {
  value: !0
});
var gf = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      gf.registered[t] = n;
    },
    remove: function(t) {
      gf.registered[t] = null;
    }
  }
};
ca.default = gf;
Object.defineProperty(Mc, "__esModule", {
  value: !0
});
var M4 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, A4 = ua;
Ac(A4);
var T4 = pg, NC = Ac(T4), B4 = fg, j4 = Ac(B4), _4 = ca, Pr = Ac(_4);
function Ac(e) {
  return e && e.__esModule ? e : { default: e };
}
var nP = function(t) {
  return NC.default[t.smooth] || NC.default.defaultEasing;
}, I4 = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, F4 = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, mf = function() {
  return F4() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), rP = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, oP = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, iP = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, R4 = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, N4 = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, z4 = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Pr.default.registered.end && Pr.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    mf.call(window, i);
    return;
  }
  Pr.default.registered.end && Pr.default.registered.end(o.to, o.target, o.currentPosition);
}, hg = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, da = function(t, n, r, o) {
  n.data = n.data || rP(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (j4.default.subscribe(i), hg(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? oP(n) : iP(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    Pr.default.registered.end && Pr.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = I4(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var s = nP(n), a = z4.bind(null, s, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      Pr.default.registered.begin && Pr.default.registered.begin(n.data.to, n.data.target), mf.call(window, a);
    }, n.delay);
    return;
  }
  Pr.default.registered.begin && Pr.default.registered.begin(n.data.to, n.data.target), mf.call(window, a);
}, Tc = function(t) {
  return t = M4({}, t), t.data = t.data || rP(), t.absolute = !0, t;
}, $4 = function(t) {
  da(0, Tc(t));
}, U4 = function(t, n) {
  da(t, Tc(n));
}, W4 = function(t) {
  t = Tc(t), hg(t), da(t.horizontal ? R4(t) : N4(t), t);
}, V4 = function(t, n) {
  n = Tc(n), hg(n);
  var r = n.horizontal ? oP(n) : iP(n);
  da(t + r, n);
};
Mc.default = {
  animateTopScroll: da,
  getAnimationType: nP,
  scrollToTop: $4,
  scrollToBottom: W4,
  scrollTo: U4,
  scrollMore: V4
};
Object.defineProperty(Ti, "__esModule", {
  value: !0
});
var H4 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, q4 = ua, G4 = gg(q4), Z4 = Mc, Y4 = gg(Z4), X4 = ca, sl = gg(X4);
function gg(e) {
  return e && e.__esModule ? e : { default: e };
}
var al = {}, zC = void 0;
Ti.default = {
  unmount: function() {
    al = {};
  },
  register: function(t, n) {
    al[t] = n;
  },
  unregister: function(t) {
    delete al[t];
  },
  get: function(t) {
    return al[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return zC = t;
  },
  getActiveLink: function() {
    return zC;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = H4({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, s = void 0;
    o ? s = document.getElementById(o) : i && i.nodeType ? s = i : s = document, n.absolute = !0;
    var a = n.horizontal, l = G4.default.scrollOffset(s, r, a) + (n.offset || 0);
    if (!n.smooth) {
      sl.default.registered.begin && sl.default.registered.begin(t, r), s === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : s.scrollTop = l, sl.default.registered.end && sl.default.registered.end(t, r);
      return;
    }
    Y4.default.animateTopScroll(l, n, t, r);
  }
};
var vf = { exports: {} }, ll = { exports: {} }, xt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var $C;
function K4() {
  if ($C) return xt;
  $C = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function k(v) {
    if (typeof v == "object" && v !== null) {
      var O = v.$$typeof;
      switch (O) {
        case t:
          switch (v = v.type, v) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case d:
              return v;
            default:
              switch (v = v && v.$$typeof, v) {
                case a:
                case c:
                case f:
                case m:
                case s:
                  return v;
                default:
                  return O;
              }
          }
        case n:
          return O;
      }
    }
  }
  function E(v) {
    return k(v) === u;
  }
  return xt.AsyncMode = l, xt.ConcurrentMode = u, xt.ContextConsumer = a, xt.ContextProvider = s, xt.Element = t, xt.ForwardRef = c, xt.Fragment = r, xt.Lazy = f, xt.Memo = m, xt.Portal = n, xt.Profiler = i, xt.StrictMode = o, xt.Suspense = d, xt.isAsyncMode = function(v) {
    return E(v) || k(v) === l;
  }, xt.isConcurrentMode = E, xt.isContextConsumer = function(v) {
    return k(v) === a;
  }, xt.isContextProvider = function(v) {
    return k(v) === s;
  }, xt.isElement = function(v) {
    return typeof v == "object" && v !== null && v.$$typeof === t;
  }, xt.isForwardRef = function(v) {
    return k(v) === c;
  }, xt.isFragment = function(v) {
    return k(v) === r;
  }, xt.isLazy = function(v) {
    return k(v) === f;
  }, xt.isMemo = function(v) {
    return k(v) === m;
  }, xt.isPortal = function(v) {
    return k(v) === n;
  }, xt.isProfiler = function(v) {
    return k(v) === i;
  }, xt.isStrictMode = function(v) {
    return k(v) === o;
  }, xt.isSuspense = function(v) {
    return k(v) === d;
  }, xt.isValidElementType = function(v) {
    return typeof v == "string" || typeof v == "function" || v === r || v === u || v === i || v === o || v === d || v === p || typeof v == "object" && v !== null && (v.$$typeof === f || v.$$typeof === m || v.$$typeof === s || v.$$typeof === a || v.$$typeof === c || v.$$typeof === h || v.$$typeof === C || v.$$typeof === w || v.$$typeof === g);
  }, xt.typeOf = k, xt;
}
var Dt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var UC;
function J4() {
  return UC || (UC = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, d = e ? Symbol.for("react.suspense") : 60113, p = e ? Symbol.for("react.suspense_list") : 60120, m = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, g = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, C = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function k(G) {
      return typeof G == "string" || typeof G == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      G === r || G === u || G === i || G === o || G === d || G === p || typeof G == "object" && G !== null && (G.$$typeof === f || G.$$typeof === m || G.$$typeof === s || G.$$typeof === a || G.$$typeof === c || G.$$typeof === h || G.$$typeof === C || G.$$typeof === w || G.$$typeof === g);
    }
    function E(G) {
      if (typeof G == "object" && G !== null) {
        var fe = G.$$typeof;
        switch (fe) {
          case t:
            var be = G.type;
            switch (be) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case d:
                return be;
              default:
                var re = be && be.$$typeof;
                switch (re) {
                  case a:
                  case c:
                  case f:
                  case m:
                  case s:
                    return re;
                  default:
                    return fe;
                }
            }
          case n:
            return fe;
        }
      }
    }
    var v = l, O = u, L = a, W = s, D = t, N = c, _ = r, R = f, U = m, z = n, q = i, K = o, X = d, ne = !1;
    function Q(G) {
      return ne || (ne = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), S(G) || E(G) === l;
    }
    function S(G) {
      return E(G) === u;
    }
    function I(G) {
      return E(G) === a;
    }
    function Z(G) {
      return E(G) === s;
    }
    function T(G) {
      return typeof G == "object" && G !== null && G.$$typeof === t;
    }
    function Y(G) {
      return E(G) === c;
    }
    function x(G) {
      return E(G) === r;
    }
    function M(G) {
      return E(G) === f;
    }
    function $(G) {
      return E(G) === m;
    }
    function B(G) {
      return E(G) === n;
    }
    function V(G) {
      return E(G) === i;
    }
    function F(G) {
      return E(G) === o;
    }
    function J(G) {
      return E(G) === d;
    }
    Dt.AsyncMode = v, Dt.ConcurrentMode = O, Dt.ContextConsumer = L, Dt.ContextProvider = W, Dt.Element = D, Dt.ForwardRef = N, Dt.Fragment = _, Dt.Lazy = R, Dt.Memo = U, Dt.Portal = z, Dt.Profiler = q, Dt.StrictMode = K, Dt.Suspense = X, Dt.isAsyncMode = Q, Dt.isConcurrentMode = S, Dt.isContextConsumer = I, Dt.isContextProvider = Z, Dt.isElement = T, Dt.isForwardRef = Y, Dt.isFragment = x, Dt.isLazy = M, Dt.isMemo = $, Dt.isPortal = B, Dt.isProfiler = V, Dt.isStrictMode = F, Dt.isSuspense = J, Dt.isValidElementType = k, Dt.typeOf = E;
  }()), Dt;
}
var WC;
function sP() {
  return WC || (WC = 1, process.env.NODE_ENV === "production" ? ll.exports = K4() : ll.exports = J4()), ll.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Xd, VC;
function Q4() {
  if (VC) return Xd;
  VC = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Xd = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var d in a)
        t.call(a, d) && (l[d] = a[d]);
      if (e) {
        u = e(a);
        for (var p = 0; p < u.length; p++)
          n.call(a, u[p]) && (l[u[p]] = a[u[p]]);
      }
    }
    return l;
  }, Xd;
}
var Kd, HC;
function mg() {
  if (HC) return Kd;
  HC = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Kd = e, Kd;
}
var Jd, qC;
function aP() {
  return qC || (qC = 1, Jd = Function.call.bind(Object.prototype.hasOwnProperty)), Jd;
}
var Qd, GC;
function eV() {
  if (GC) return Qd;
  GC = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = mg(), n = {}, r = aP();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var d;
          try {
            if (typeof i[c] != "function") {
              var p = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw p.name = "Invariant Violation", p;
            }
            d = i[c](s, c, l, a, null, t);
          } catch (f) {
            d = f;
          }
          if (d && !(d instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var m = u ? u() : "";
            e(
              "Failed " + a + " type: " + d.message + (m ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Qd = o, Qd;
}
var ep, ZC;
function tV() {
  if (ZC) return ep;
  ZC = 1;
  var e = sP(), t = Q4(), n = mg(), r = aP(), o = eV(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return ep = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(S) {
      var I = S && (u && S[u] || S[c]);
      if (typeof I == "function")
        return I;
    }
    var p = "<<anonymous>>", m = {
      array: C("array"),
      bigint: C("bigint"),
      bool: C("boolean"),
      func: C("function"),
      number: C("number"),
      object: C("object"),
      string: C("string"),
      symbol: C("symbol"),
      any: w(),
      arrayOf: k,
      element: E(),
      elementType: v(),
      instanceOf: O,
      node: N(),
      objectOf: W,
      oneOf: L,
      oneOfType: D,
      shape: R,
      exact: U
    };
    function f(S, I) {
      return S === I ? S !== 0 || 1 / S === 1 / I : S !== S && I !== I;
    }
    function g(S, I) {
      this.message = S, this.data = I && typeof I == "object" ? I : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function h(S) {
      if (process.env.NODE_ENV !== "production")
        var I = {}, Z = 0;
      function T(x, M, $, B, V, F, J) {
        if (B = B || p, F = F || $, J !== n) {
          if (l) {
            var G = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw G.name = "Invariant Violation", G;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var fe = B + ":" + $;
            !I[fe] && // Avoid spamming the console because they are often not actionable except for lib authors
            Z < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + F + "` prop on `" + B + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), I[fe] = !0, Z++);
          }
        }
        return M[$] == null ? x ? M[$] === null ? new g("The " + V + " `" + F + "` is marked as required " + ("in `" + B + "`, but its value is `null`.")) : new g("The " + V + " `" + F + "` is marked as required in " + ("`" + B + "`, but its value is `undefined`.")) : null : S(M, $, B, V, F);
      }
      var Y = T.bind(null, !1);
      return Y.isRequired = T.bind(null, !0), Y;
    }
    function C(S) {
      function I(Z, T, Y, x, M, $) {
        var B = Z[T], V = K(B);
        if (V !== S) {
          var F = X(B);
          return new g(
            "Invalid " + x + " `" + M + "` of type " + ("`" + F + "` supplied to `" + Y + "`, expected ") + ("`" + S + "`."),
            { expectedType: S }
          );
        }
        return null;
      }
      return h(I);
    }
    function w() {
      return h(s);
    }
    function k(S) {
      function I(Z, T, Y, x, M) {
        if (typeof S != "function")
          return new g("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside arrayOf.");
        var $ = Z[T];
        if (!Array.isArray($)) {
          var B = K($);
          return new g("Invalid " + x + " `" + M + "` of type " + ("`" + B + "` supplied to `" + Y + "`, expected an array."));
        }
        for (var V = 0; V < $.length; V++) {
          var F = S($, V, Y, x, M + "[" + V + "]", n);
          if (F instanceof Error)
            return F;
        }
        return null;
      }
      return h(I);
    }
    function E() {
      function S(I, Z, T, Y, x) {
        var M = I[Z];
        if (!a(M)) {
          var $ = K(M);
          return new g("Invalid " + Y + " `" + x + "` of type " + ("`" + $ + "` supplied to `" + T + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(S);
    }
    function v() {
      function S(I, Z, T, Y, x) {
        var M = I[Z];
        if (!e.isValidElementType(M)) {
          var $ = K(M);
          return new g("Invalid " + Y + " `" + x + "` of type " + ("`" + $ + "` supplied to `" + T + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(S);
    }
    function O(S) {
      function I(Z, T, Y, x, M) {
        if (!(Z[T] instanceof S)) {
          var $ = S.name || p, B = Q(Z[T]);
          return new g("Invalid " + x + " `" + M + "` of type " + ("`" + B + "` supplied to `" + Y + "`, expected ") + ("instance of `" + $ + "`."));
        }
        return null;
      }
      return h(I);
    }
    function L(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function I(Z, T, Y, x, M) {
        for (var $ = Z[T], B = 0; B < S.length; B++)
          if (f($, S[B]))
            return null;
        var V = JSON.stringify(S, function(J, G) {
          var fe = X(G);
          return fe === "symbol" ? String(G) : G;
        });
        return new g("Invalid " + x + " `" + M + "` of value `" + String($) + "` " + ("supplied to `" + Y + "`, expected one of " + V + "."));
      }
      return h(I);
    }
    function W(S) {
      function I(Z, T, Y, x, M) {
        if (typeof S != "function")
          return new g("Property `" + M + "` of component `" + Y + "` has invalid PropType notation inside objectOf.");
        var $ = Z[T], B = K($);
        if (B !== "object")
          return new g("Invalid " + x + " `" + M + "` of type " + ("`" + B + "` supplied to `" + Y + "`, expected an object."));
        for (var V in $)
          if (r($, V)) {
            var F = S($, V, Y, x, M + "." + V, n);
            if (F instanceof Error)
              return F;
          }
        return null;
      }
      return h(I);
    }
    function D(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var I = 0; I < S.length; I++) {
        var Z = S[I];
        if (typeof Z != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ne(Z) + " at index " + I + "."
          ), s;
      }
      function T(Y, x, M, $, B) {
        for (var V = [], F = 0; F < S.length; F++) {
          var J = S[F], G = J(Y, x, M, $, B, n);
          if (G == null)
            return null;
          G.data && r(G.data, "expectedType") && V.push(G.data.expectedType);
        }
        var fe = V.length > 0 ? ", expected one of type [" + V.join(", ") + "]" : "";
        return new g("Invalid " + $ + " `" + B + "` supplied to " + ("`" + M + "`" + fe + "."));
      }
      return h(T);
    }
    function N() {
      function S(I, Z, T, Y, x) {
        return z(I[Z]) ? null : new g("Invalid " + Y + " `" + x + "` supplied to " + ("`" + T + "`, expected a ReactNode."));
      }
      return h(S);
    }
    function _(S, I, Z, T, Y) {
      return new g(
        (S || "React class") + ": " + I + " type `" + Z + "." + T + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Y + "`."
      );
    }
    function R(S) {
      function I(Z, T, Y, x, M) {
        var $ = Z[T], B = K($);
        if (B !== "object")
          return new g("Invalid " + x + " `" + M + "` of type `" + B + "` " + ("supplied to `" + Y + "`, expected `object`."));
        for (var V in S) {
          var F = S[V];
          if (typeof F != "function")
            return _(Y, x, M, V, X(F));
          var J = F($, V, Y, x, M + "." + V, n);
          if (J)
            return J;
        }
        return null;
      }
      return h(I);
    }
    function U(S) {
      function I(Z, T, Y, x, M) {
        var $ = Z[T], B = K($);
        if (B !== "object")
          return new g("Invalid " + x + " `" + M + "` of type `" + B + "` " + ("supplied to `" + Y + "`, expected `object`."));
        var V = t({}, Z[T], S);
        for (var F in V) {
          var J = S[F];
          if (r(S, F) && typeof J != "function")
            return _(Y, x, M, F, X(J));
          if (!J)
            return new g(
              "Invalid " + x + " `" + M + "` key `" + F + "` supplied to `" + Y + "`.\nBad object: " + JSON.stringify(Z[T], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(S), null, "  ")
            );
          var G = J($, F, Y, x, M + "." + F, n);
          if (G)
            return G;
        }
        return null;
      }
      return h(I);
    }
    function z(S) {
      switch (typeof S) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !S;
        case "object":
          if (Array.isArray(S))
            return S.every(z);
          if (S === null || a(S))
            return !0;
          var I = d(S);
          if (I) {
            var Z = I.call(S), T;
            if (I !== S.entries) {
              for (; !(T = Z.next()).done; )
                if (!z(T.value))
                  return !1;
            } else
              for (; !(T = Z.next()).done; ) {
                var Y = T.value;
                if (Y && !z(Y[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(S, I) {
      return S === "symbol" ? !0 : I ? I["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && I instanceof Symbol : !1;
    }
    function K(S) {
      var I = typeof S;
      return Array.isArray(S) ? "array" : S instanceof RegExp ? "object" : q(I, S) ? "symbol" : I;
    }
    function X(S) {
      if (typeof S > "u" || S === null)
        return "" + S;
      var I = K(S);
      if (I === "object") {
        if (S instanceof Date)
          return "date";
        if (S instanceof RegExp)
          return "regexp";
      }
      return I;
    }
    function ne(S) {
      var I = X(S);
      switch (I) {
        case "array":
        case "object":
          return "an " + I;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + I;
        default:
          return I;
      }
    }
    function Q(S) {
      return !S.constructor || !S.constructor.name ? p : S.constructor.name;
    }
    return m.checkPropTypes = o, m.resetWarningCache = o.resetWarningCache, m.PropTypes = m, m;
  }, ep;
}
var tp, YC;
function nV() {
  if (YC) return tp;
  YC = 1;
  var e = mg();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, tp = function() {
    function r(s, a, l, u, c, d) {
      if (d !== e) {
        var p = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw p.name = "Invariant Violation", p;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, tp;
}
if (process.env.NODE_ENV !== "production") {
  var rV = sP(), oV = !0;
  vf.exports = tV()(rV.isElement, oV);
} else
  vf.exports = nV()();
var Bc = vf.exports, jc = {};
Object.defineProperty(jc, "__esModule", {
  value: !0
});
var iV = ua, np = sV(iV);
function sV(e) {
  return e && e.__esModule ? e : { default: e };
}
var aV = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return np.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && np.default.getHash() !== t && np.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
jc.default = aV;
Object.defineProperty(sa, "__esModule", {
  value: !0
});
var ul = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, lV = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), uV = Ce, XC = pa(uV), cV = aa, cl = pa(cV), dV = Ti, pV = pa(dV), fV = Bc, Qt = pa(fV), hV = jc, ro = pa(hV);
function pa(e) {
  return e && e.__esModule ? e : { default: e };
}
function gV(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function mV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function vV(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var KC = {
  to: Qt.default.string.isRequired,
  containerId: Qt.default.string,
  container: Qt.default.object,
  activeClass: Qt.default.string,
  activeStyle: Qt.default.object,
  spy: Qt.default.bool,
  horizontal: Qt.default.bool,
  smooth: Qt.default.oneOfType([Qt.default.bool, Qt.default.string]),
  offset: Qt.default.number,
  delay: Qt.default.number,
  isDynamic: Qt.default.bool,
  onClick: Qt.default.func,
  duration: Qt.default.oneOfType([Qt.default.number, Qt.default.func]),
  absolute: Qt.default.bool,
  onSetActive: Qt.default.func,
  onSetInactive: Qt.default.func,
  ignoreCancelEvents: Qt.default.bool,
  hashSpy: Qt.default.bool,
  saveHashHistory: Qt.default.bool,
  spyThrottle: Qt.default.number
};
sa.default = function(e, t) {
  var n = t || pV.default, r = function(i) {
    vV(s, i);
    function s(a) {
      gV(this, s);
      var l = mV(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return lV(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          cl.default.isMounted(l) || cl.default.mount(l, this.props.spyThrottle), this.props.hashSpy && (ro.default.isMounted() || ro.default.mount(n), ro.default.mapContainer(this.props.to, l)), cl.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        cl.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = ul({}, this.props.style, this.props.activeStyle) : u = ul({}, this.props.style);
        var c = ul({}, this.props);
        for (var d in KC)
          c.hasOwnProperty(d) && delete c[d];
        return c.className = l, c.style = u, c.onClick = this.handleClick, XC.default.createElement(e, c);
      }
    }]), s;
  }(XC.default.PureComponent), o = function() {
    var s = this;
    this.scrollTo = function(a, l) {
      n.scrollTo(a, ul({}, s.state, l));
    }, this.handleClick = function(a) {
      s.props.onClick && s.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), s.scrollTo(s.props.to, s.props);
    }, this.spyHandler = function(a, l) {
      var u = s.getScrollSpyContainer();
      if (!(ro.default.isMounted() && !ro.default.isInitialized())) {
        var c = s.props.horizontal, d = s.props.to, p = null, m = void 0, f = void 0;
        if (c) {
          var g = 0, h = 0, C = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            C = w.left;
          }
          if (!p || s.props.isDynamic) {
            if (p = n.get(d), !p)
              return;
            var k = p.getBoundingClientRect();
            g = k.left - C + a, h = g + k.width;
          }
          var E = a - s.props.offset;
          m = E >= Math.floor(g) && E < Math.floor(h), f = E < Math.floor(g) || E >= Math.floor(h);
        } else {
          var v = 0, O = 0, L = 0;
          if (u.getBoundingClientRect) {
            var W = u.getBoundingClientRect();
            L = W.top;
          }
          if (!p || s.props.isDynamic) {
            if (p = n.get(d), !p)
              return;
            var D = p.getBoundingClientRect();
            v = D.top - L + l, O = v + D.height;
          }
          var N = l - s.props.offset;
          m = N >= Math.floor(v) && N < Math.floor(O), f = N < Math.floor(v) || N >= Math.floor(O);
        }
        var _ = n.getActiveLink();
        if (f) {
          if (d === _ && n.setActiveLink(void 0), s.props.hashSpy && ro.default.getHash() === d) {
            var R = s.props.saveHashHistory, U = R === void 0 ? !1 : R;
            ro.default.changeHash("", U);
          }
          s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive(d, p));
        }
        if (m && (_ !== d || s.state.active === !1)) {
          n.setActiveLink(d);
          var z = s.props.saveHashHistory, q = z === void 0 ? !1 : z;
          s.props.hashSpy && ro.default.changeHash(d, q), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(d, p));
        }
      }
    };
  };
  return r.propTypes = KC, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(dg, "__esModule", {
  value: !0
});
var yV = Ce, JC = lP(yV), bV = sa, wV = lP(bV);
function lP(e) {
  return e && e.__esModule ? e : { default: e };
}
function CV(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function QC(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function EV(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var OV = function(e) {
  EV(t, e);
  function t() {
    var n, r, o, i;
    CV(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = QC(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return JC.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), QC(o, i);
  }
  return t;
}(JC.default.Component);
dg.default = (0, wV.default)(OV);
var vg = {};
Object.defineProperty(vg, "__esModule", {
  value: !0
});
var xV = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), DV = Ce, e1 = uP(DV), LV = sa, PV = uP(LV);
function uP(e) {
  return e && e.__esModule ? e : { default: e };
}
function SV(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function MV(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var AV = function(e) {
  MV(t, e);
  function t() {
    return SV(this, t), kV(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return xV(t, [{
    key: "render",
    value: function() {
      return e1.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(e1.default.Component);
vg.default = (0, PV.default)(AV);
var yg = {}, _c = {};
Object.defineProperty(_c, "__esModule", {
  value: !0
});
var TV = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, BV = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), jV = Ce, t1 = Ic(jV), _V = xu;
Ic(_V);
var IV = Ti, n1 = Ic(IV), FV = Bc, r1 = Ic(FV);
function Ic(e) {
  return e && e.__esModule ? e : { default: e };
}
function RV(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function NV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function zV(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
_c.default = function(e) {
  var t = function(n) {
    zV(r, n);
    function r(o) {
      RV(this, r);
      var i = NV(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return BV(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        n1.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        n1.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return t1.default.createElement(e, TV({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(t1.default.Component);
  return t.propTypes = {
    name: r1.default.string,
    id: r1.default.string
  }, t;
};
Object.defineProperty(yg, "__esModule", {
  value: !0
});
var o1 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, $V = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), UV = Ce, i1 = bg(UV), WV = _c, VV = bg(WV), HV = Bc, s1 = bg(HV);
function bg(e) {
  return e && e.__esModule ? e : { default: e };
}
function qV(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function GV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ZV(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var cP = function(e) {
  ZV(t, e);
  function t() {
    return qV(this, t), GV(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return $V(t, [{
    key: "render",
    value: function() {
      var r = this, o = o1({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, i1.default.createElement(
        "div",
        o1({}, o, { ref: function(s) {
          r.props.parentBindings.domNode = s;
        } }),
        this.props.children
      );
    }
  }]), t;
}(i1.default.Component);
cP.propTypes = {
  name: s1.default.string,
  id: s1.default.string
};
yg.default = (0, VV.default)(cP);
var rp = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, a1 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function l1(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function u1(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function c1(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var dl = Ce, Io = aa, op = Ti, cn = Bc, oo = jc, d1 = {
  to: cn.string.isRequired,
  containerId: cn.string,
  container: cn.object,
  activeClass: cn.string,
  spy: cn.bool,
  smooth: cn.oneOfType([cn.bool, cn.string]),
  offset: cn.number,
  delay: cn.number,
  isDynamic: cn.bool,
  onClick: cn.func,
  duration: cn.oneOfType([cn.number, cn.func]),
  absolute: cn.bool,
  onSetActive: cn.func,
  onSetInactive: cn.func,
  ignoreCancelEvents: cn.bool,
  hashSpy: cn.bool,
  spyThrottle: cn.number
}, YV = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || op, o = function(s) {
      c1(a, s);
      function a(l) {
        l1(this, a);
        var u = u1(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return a1(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Io.isMounted(u) || Io.mount(u, this.props.spyThrottle), this.props.hashSpy && (oo.isMounted() || oo.mount(r), oo.mapContainer(this.props.to, u)), this.props.spy && Io.addStateHandler(this.stateHandler), Io.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Io.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = rp({}, this.props);
          for (var d in d1)
            c.hasOwnProperty(d) && delete c[d];
          return c.className = u, c.onClick = this.handleClick, dl.createElement(t, c);
        }
      }]), a;
    }(dl.Component), i = function() {
      var a = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, rp({}, a.state, u));
      }, this.handleClick = function(l) {
        a.props.onClick && a.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), a.scrollTo(a.props.to, a.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== a.props.to && (a.state !== null && a.state.active && a.props.onSetInactive && a.props.onSetInactive(), a.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = a.getScrollSpyContainer();
        if (!(oo.isMounted() && !oo.isInitialized())) {
          var c = a.props.to, d = null, p = 0, m = 0, f = 0;
          if (u.getBoundingClientRect) {
            var g = u.getBoundingClientRect();
            f = g.top;
          }
          if (!d || a.props.isDynamic) {
            if (d = r.get(c), !d)
              return;
            var h = d.getBoundingClientRect();
            p = h.top - f + l, m = p + h.height;
          }
          var C = l - a.props.offset, w = C >= Math.floor(p) && C < Math.floor(m), k = C < Math.floor(p) || C >= Math.floor(m), E = r.getActiveLink();
          if (k)
            return c === E && r.setActiveLink(void 0), a.props.hashSpy && oo.getHash() === c && oo.changeHash(), a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive()), Io.updateStates();
          if (w && E !== c)
            return r.setActiveLink(c), a.props.hashSpy && oo.changeHash(c), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(c)), Io.updateStates();
        }
      };
    };
    return o.propTypes = d1, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      c1(o, r);
      function o(i) {
        l1(this, o);
        var s = u1(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return s.childBindings = {
          domNode: null
        }, s;
      }
      return a1(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(s) {
          this.props.name !== s.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          op.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(s) {
          op.register(s, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return dl.createElement(t, rp({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(dl.Component);
    return n.propTypes = {
      name: cn.string,
      id: cn.string
    }, n;
  }
}, XV = YV;
Object.defineProperty(mn, "__esModule", {
  value: !0
});
mn.Helpers = mn.ScrollElement = mn.ScrollLink = CP = mn.animateScroll = mn.scrollSpy = mn.Events = mn.scroller = mn.Element = mn.Button = mn.Link = void 0;
var KV = dg, dP = Br(KV), JV = vg, pP = Br(JV), QV = yg, fP = Br(QV), eH = Ti, hP = Br(eH), tH = ca, gP = Br(tH), nH = aa, mP = Br(nH), rH = Mc, vP = Br(rH), oH = sa, yP = Br(oH), iH = _c, bP = Br(iH), sH = XV, wP = Br(sH);
function Br(e) {
  return e && e.__esModule ? e : { default: e };
}
mn.Link = dP.default;
mn.Button = pP.default;
mn.Element = fP.default;
mn.scroller = hP.default;
mn.Events = gP.default;
mn.scrollSpy = mP.default;
var CP = mn.animateScroll = vP.default;
mn.ScrollLink = yP.default;
mn.ScrollElement = bP.default;
mn.Helpers = wP.default;
mn.default = { Link: dP.default, Button: pP.default, Element: fP.default, scroller: hP.default, Events: gP.default, scrollSpy: mP.default, animateScroll: vP.default, ScrollLink: yP.default, ScrollElement: bP.default, Helpers: wP.default };
const wg = Ze({}), EP = Ze({});
function aH() {
  const e = Oe(EP);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function p1(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function kG() {
  const e = Pf(), { closeModal: t, closeAll: n } = Oe(wg), { showToast: r } = aH(), { getParam: o } = QL(), { pathname: i } = Sf(), s = zE(), a = o("closeAllModals");
  y(() => {
    a === "true" && (n(), s(i));
  }, [a]), y(() => {
    const l = e == null ? void 0 : e.closeModalKey;
    l && t(l);
  }, [e]), y(() => {
    const l = e == null ? void 0 : e.closeAllModals;
    typeof l == "boolean" && l && n();
  }, [e]), y(() => {
    const l = e == null ? void 0 : e.toast, u = e == null ? void 0 : e.message;
    p1(l) && r(l), !p1(l) && u && r({ message: u, type: "danger" });
  }, [e]), y(() => {
    var l, u;
    if (typeof ((l = e == null ? void 0 : e.data) == null ? void 0 : l.scrollTo) == "string") {
      const c = document.getElementById((u = e == null ? void 0 : e.data) == null ? void 0 : u.scrollTo);
      c && CP.scrollTo(c.offsetTop - 200);
    }
  }, [e]);
}
const OP = Ze({});
function MG(e) {
  const t = Oe(OP);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, s = r(e), a = n(e);
    return { drawerIsOpen: s, drawerData: a, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function lH() {
  return () => {
  };
}
function uH() {
  return YP(
    lH,
    () => !0,
    () => !1
  );
}
function AG(e) {
  const t = Oe(wg);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, s = r(e), a = n(e);
    return { modalIsOpen: s, modalData: a, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function TG(e) {
  const { children: t = !1 } = e, [n, r] = P([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function s(l, u) {
    const c = o(l);
    r(c ? (d) => [...d.filter((m) => m.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function a(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ j.jsx(
    OP.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: s, closeDrawer: a },
      children: t
    }
  );
}
function Vs(e) {
  "@babel/helpers - typeof";
  return Vs = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Vs(e);
}
function cH(e, t) {
  if (Vs(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Vs(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function dH(e) {
  var t = cH(e, "string");
  return Vs(t) == "symbol" ? t : t + "";
}
function ae(e, t, n) {
  return (t = dH(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function xP(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ip, f1;
function pH() {
  if (f1) return ip;
  f1 = 1;
  var e = process.env.NODE_ENV, t = function(r, o, i, s, a, l, u, c) {
    if (e !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var d;
      if (o === void 0)
        d = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [i, s, a, l, u, c], m = 0;
        d = new Error(o.replace(/%s/g, function() {
          return p[m++];
        })), d.name = "Invariant Violation";
      }
      throw d.framesToPop = 1, d;
    }
  };
  return ip = t, ip;
}
var fH = pH(), Dn = /* @__PURE__ */ xP(fH), Ge = Ze(null);
function hH() {
  Dn(!!Oe, "useGoogleMap is React hook and requires React version 16.8+");
  var e = Oe(Ge);
  return Dn(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function gH(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function mH(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function vH(e, t, n, r) {
  var o = {}, i = (s, a) => {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return mH(e, i), o;
}
function yH(e, t, n) {
  var r = gH(n, function(i, s, a) {
    return typeof e[a] == "function" && i.push(google.maps.event.addListener(t, s, e[a])), i;
  }, []);
  return r;
}
function bH(e) {
  google.maps.event.removeListener(e);
}
function lt() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(bH);
}
function ot(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, s = yH(o, i, n);
  return vH(t, r, o, i), s;
}
var h1 = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, g1 = {
  extraMapTypes(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center(e, t) {
    e.setCenter(t);
  },
  clickableIcons(e, t) {
    e.setClickableIcons(t);
  },
  heading(e, t) {
    e.setHeading(t);
  },
  mapTypeId(e, t) {
    e.setMapTypeId(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  streetView(e, t) {
    e.setStreetView(t);
  },
  tilt(e, t) {
    e.setTilt(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
function wH(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: s,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: a,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: d,
    onMouseMove: p,
    onMouseOut: m,
    onMouseOver: f,
    onMouseDown: g,
    onMouseUp: h,
    onRightClick: C,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: k,
    onUnmount: E
  } = e, [v, O] = P(null), L = qe(null), [W, D] = P(null), [N, _] = P(null), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null), [Z, T] = P(null), [Y, x] = P(null), [M, $] = P(null), [B, V] = P(null), [F, J] = P(null);
  return y(() => {
    n && v !== null && v.setOptions(n);
  }, [v, n]), y(() => {
    v !== null && typeof s < "u" && v.setCenter(s);
  }, [v, s]), y(() => {
    v && l && (N !== null && google.maps.event.removeListener(N), _(google.maps.event.addListener(v, "dblclick", l)));
  }, [l]), y(() => {
    v && c && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(v, "dragend", c)));
  }, [c]), y(() => {
    v && d && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(v, "dragstart", d)));
  }, [d]), y(() => {
    v && g && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(v, "mousedown", g)));
  }, [g]), y(() => {
    v && p && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(v, "mousemove", p)));
  }, [p]), y(() => {
    v && m && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(v, "mouseout", m)));
  }, [m]), y(() => {
    v && f && (Z !== null && google.maps.event.removeListener(Z), T(google.maps.event.addListener(v, "mouseover", f)));
  }, [f]), y(() => {
    v && h && (Y !== null && google.maps.event.removeListener(Y), x(google.maps.event.addListener(v, "mouseup", h)));
  }, [h]), y(() => {
    v && C && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(v, "rightclick", C)));
  }, [C]), y(() => {
    v && a && (B !== null && google.maps.event.removeListener(B), V(google.maps.event.addListener(v, "click", a)));
  }, [a]), y(() => {
    v && u && (F !== null && google.maps.event.removeListener(F), J(google.maps.event.addListener(v, "drag", u)));
  }, [u]), y(() => {
    v && w && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(v, "center_changed", w)));
  }, [a]), y(() => {
    var G = L.current === null ? null : new google.maps.Map(L.current, n);
    return O(G), G !== null && k && k(G), () => {
      G !== null && E && E(G);
    };
  }, []), j.jsx("div", {
    id: r,
    ref: L,
    style: o,
    className: i,
    children: j.jsx(Ge.Provider, {
      value: v,
      children: v !== null ? t : null
    })
  });
}
Me(wH);
let CH = class extends Ee {
  constructor() {
    super(...arguments), ae(this, "state", {
      map: null
    }), ae(this, "registeredEvents", []), ae(this, "mapRef", null), ae(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), ae(this, "panTo", (t) => {
      var n = this.getInstance();
      n && n.panTo(t);
    }), ae(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), ae(this, "getRef", (t) => {
      this.mapRef = t;
    });
  }
  componentDidMount() {
    var t = this.getInstance();
    this.registeredEvents = ot({
      updaterMap: g1,
      eventMap: h1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        map: t
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(t) {
    this.state.map !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: g1,
      eventMap: h1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), lt(this.registeredEvents));
  }
  render() {
    return j.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: j.jsx(Ge.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function m1(e, t, n, r, o, i, s) {
  try {
    var a = e[i](s), l = a.value;
  } catch (u) {
    return void n(u);
  }
  a.done ? t(l) : Promise.resolve(l).then(r, o);
}
function DP(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function s(l) {
        m1(i, r, o, s, a, "next", l);
      }
      function a(l) {
        m1(i, r, o, s, a, "throw", l);
      }
      s(void 0);
    });
  };
}
function LP(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: s,
    channel: a,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Dn(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), s && s.length && c.push("libraries=".concat(s.sort().join(","))), a && c.push("channel=".concat(a)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var Yo = typeof document < "u";
function PP(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return Yo ? new Promise(function(i, s) {
    var a = document.getElementById(n), l = window;
    if (a) {
      var u = a.getAttribute("data-state");
      if (a.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, d = a.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, a.onerror = function(m) {
          d && d(m), s(m);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(f) {
      p.setAttribute("data-state", "error"), s(f);
    }, l.initMap = function() {
      p.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function v1(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function SP() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return v1(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return v1(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
var ts = !1;
function kP() {
  return j.jsx("div", {
    children: "Loading..."
  });
}
var yf = {
  id: "script-loader",
  version: "weekly"
};
class MP extends Ee {
  constructor() {
    super(...arguments), ae(this, "check", mr()), ae(this, "state", {
      loaded: !1
    }), ae(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ae(this, "isCleaningUp", /* @__PURE__ */ DP(function* () {
      function t(n) {
        if (!ts)
          n();
        else if (Yo)
          var r = window.setInterval(function() {
            ts || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ae(this, "cleanup", () => {
      ts = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), ae(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && SP(), Dn(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: LP(this.props)
      };
      PP(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (Yo) {
      if (window.google && window.google.maps && !ts) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), Yo && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (Yo) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, ts = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return j.jsxs(j.Fragment, {
      children: [j.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || j.jsx(kP, {})]
    });
  }
}
ae(MP, "defaultProps", yf);
function EH(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Cg(e, t) {
  if (e == null) return {};
  var n, r, o = EH(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var y1;
function OH(e) {
  var {
    id: t = yf.id,
    version: n = yf.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  } = e, m = qe(!1), [f, g] = P(!1), [h, C] = P(void 0);
  y(function() {
    return m.current = !0, () => {
      m.current = !1;
    };
  }, []), y(function() {
    Yo && u && SP();
  }, [u]), y(function() {
    f && Dn(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = LP({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: s,
    region: a,
    libraries: l,
    channel: c,
    mapIds: d,
    authReferrerPolicy: p
  });
  y(function() {
    if (!Yo)
      return;
    function v() {
      m.current && (g(!0), y1 = w);
    }
    if (window.google && window.google.maps && y1 === w) {
      v();
      return;
    }
    PP({
      id: t,
      url: w,
      nonce: r
    }).then(v).catch(function(L) {
      m.current && C(L), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(L);
    });
  }, [t, w, r]);
  var k = qe();
  return y(function() {
    k.current && l !== k.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), k.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: h,
    url: w
  };
}
var xH = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], DH = j.jsx(kP, {});
function LH(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, s = Cg(e, xH), {
    isLoaded: a,
    loadError: l
  } = OH(s);
  return y(function() {
    a && typeof n == "function" && n();
  }, [a, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), a ? i : t || DH;
}
Me(LH);
var b1;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(b1 || (b1 = {}));
function w1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? w1(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : w1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var C1 = {}, E1 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function PH(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = Oe(Ge), [i, s] = P(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), y(() => {
    var a = new google.maps.TrafficLayer(hu(hu({}, t), {}, {
      map: o
    }));
    return s(a), n && n(a), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Me(PH);
class SH extends Ee {
  constructor() {
    super(...arguments), ae(this, "state", {
      trafficLayer: null
    }), ae(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ae(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(hu(hu({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ot({
      updaterMap: E1,
      eventMap: C1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: E1,
      eventMap: C1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), lt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ae(SH, "contextType", Ge);
function kH(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Oe(Ge), [o, i] = P(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.BicyclingLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      s !== null && (n && n(s), s.setMap(null));
    };
  }, []), null;
}
Me(kH);
class MH extends Ee {
  constructor() {
    super(...arguments), ae(this, "state", {
      bicyclingLayer: null
    }), ae(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ae(MH, "contextType", Ge);
function AH(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = Oe(Ge), [o, i] = P(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var s = new google.maps.TransitLayer();
    return i(s), s.setMap(r), t && t(s), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Me(AH);
class TH extends Ee {
  constructor() {
    super(...arguments), ae(this, "state", {
      transitLayer: null
    }), ae(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ae(TH, "contextType", Ge);
function O1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? O1(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : O1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var x1 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, D1 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function BH(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: s,
    onPolylineComplete: a,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, d = Oe(Ge), [p, m] = P(null), [f, g] = P(null), [h, C] = P(null), [w, k] = P(null), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null);
  return y(() => {
    p !== null && p.setMap(d);
  }, [d]), y(() => {
    t && p !== null && p.setOptions(t);
  }, [p, t]), y(() => {
    p !== null && p.setDrawingMode(n ?? null);
  }, [p, n]), y(() => {
    p && r && (f !== null && google.maps.event.removeListener(f), g(google.maps.event.addListener(p, "circlecomplete", r)));
  }, [p, r]), y(() => {
    p && o && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(p, "markercomplete", o)));
  }, [p, o]), y(() => {
    p && i && (w !== null && google.maps.event.removeListener(w), k(google.maps.event.addListener(p, "overlaycomplete", i)));
  }, [p, i]), y(() => {
    p && s && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(p, "polygoncomplete", s)));
  }, [p, s]), y(() => {
    p && a && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(p, "polylinecomplete", a)));
  }, [p, a]), y(() => {
    p && l && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(p, "rectanglecomplete", l)));
  }, [p, l]), y(() => {
    Dn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var N = new google.maps.drawing.DrawingManager(gu(gu({}, t), {}, {
      map: d
    }));
    return n && N.setDrawingMode(n), r && g(google.maps.event.addListener(N, "circlecomplete", r)), o && C(google.maps.event.addListener(N, "markercomplete", o)), i && k(google.maps.event.addListener(N, "overlaycomplete", i)), s && v(google.maps.event.addListener(N, "polygoncomplete", s)), a && L(google.maps.event.addListener(N, "polylinecomplete", a)), l && D(google.maps.event.addListener(N, "rectanglecomplete", l)), m(N), u && u(N), () => {
      p !== null && (f && google.maps.event.removeListener(f), h && google.maps.event.removeListener(h), w && google.maps.event.removeListener(w), E && google.maps.event.removeListener(E), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), c && c(p), p.setMap(null));
    };
  }, []), null;
}
Me(BH);
class jH extends Ee {
  constructor(t) {
    super(t), ae(this, "registeredEvents", []), ae(this, "state", {
      drawingManager: null
    }), ae(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Dn(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(gu(gu({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ot({
      updaterMap: D1,
      eventMap: x1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: D1,
      eventMap: x1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), lt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ae(jH, "contextType", Ge);
function L1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mi(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? L1(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : L1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var P1 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, S1 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, mu = {};
function _H(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: s,
    visible: a,
    animation: l,
    clickable: u,
    cursor: c,
    icon: d,
    label: p,
    opacity: m,
    shape: f,
    title: g,
    zIndex: h,
    onClick: C,
    onDblClick: w,
    onDrag: k,
    onDragEnd: E,
    onDragStart: v,
    onMouseOut: O,
    onMouseOver: L,
    onMouseUp: W,
    onMouseDown: D,
    onRightClick: N,
    onClickableChanged: _,
    onCursorChanged: R,
    onAnimationChanged: U,
    onDraggableChanged: z,
    onFlatChanged: q,
    onIconChanged: K,
    onPositionChanged: X,
    onShapeChanged: ne,
    onTitleChanged: Q,
    onVisibleChanged: S,
    onZindexChanged: I,
    onLoad: Z,
    onUnmount: T
  } = e, Y = Oe(Ge), [x, M] = P(null), [$, B] = P(null), [V, F] = P(null), [J, G] = P(null), [fe, be] = P(null), [re, Ae] = P(null), [Ie, je] = P(null), [_e, tt] = P(null), [Ke, ke] = P(null), [nt, gt] = P(null), [Pe, Te] = P(null), [Re, He] = P(null), [ze, wt] = P(null), [Be, dn] = P(null), [Ct, Pt] = P(null), [Rt, vn] = P(null), [Nt, yn] = P(null), [mt, en] = P(null), [St, bn] = P(null), [zt, Pn] = P(null), [wn, Sn] = P(null), [Cn, kn] = P(null);
  y(() => {
    x !== null && x.setMap(Y);
  }, [Y]), y(() => {
    typeof n < "u" && x !== null && x.setOptions(n);
  }, [x, n]), y(() => {
    typeof s < "u" && x !== null && x.setDraggable(s);
  }, [x, s]), y(() => {
    t && x !== null && x.setPosition(t);
  }, [x, t]), y(() => {
    typeof a < "u" && x !== null && x.setVisible(a);
  }, [x, a]), y(() => {
    x == null || x.setAnimation(l);
  }, [x, l]), y(() => {
    x && u !== void 0 && x.setClickable(u);
  }, [x, u]), y(() => {
    x && c !== void 0 && x.setCursor(c);
  }, [x, c]), y(() => {
    x && d !== void 0 && x.setIcon(d);
  }, [x, d]), y(() => {
    x && p !== void 0 && x.setLabel(p);
  }, [x, p]), y(() => {
    x && m !== void 0 && x.setOpacity(m);
  }, [x, m]), y(() => {
    x && f !== void 0 && x.setShape(f);
  }, [x, f]), y(() => {
    x && g !== void 0 && x.setTitle(g);
  }, [x, g]), y(() => {
    x && h !== void 0 && x.setZIndex(h);
  }, [x, h]), y(() => {
    x && w && ($ !== null && google.maps.event.removeListener($), B(google.maps.event.addListener(x, "dblclick", w)));
  }, [w]), y(() => {
    x && E && (V !== null && google.maps.event.removeListener(V), F(google.maps.event.addListener(x, "dragend", E)));
  }, [E]), y(() => {
    x && v && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(x, "dragstart", v)));
  }, [v]), y(() => {
    x && D && (fe !== null && google.maps.event.removeListener(fe), be(google.maps.event.addListener(x, "mousedown", D)));
  }, [D]), y(() => {
    x && O && (re !== null && google.maps.event.removeListener(re), Ae(google.maps.event.addListener(x, "mouseout", O)));
  }, [O]), y(() => {
    x && L && (Ie !== null && google.maps.event.removeListener(Ie), je(google.maps.event.addListener(x, "mouseover", L)));
  }, [L]), y(() => {
    x && W && (_e !== null && google.maps.event.removeListener(_e), tt(google.maps.event.addListener(x, "mouseup", W)));
  }, [W]), y(() => {
    x && N && (Ke !== null && google.maps.event.removeListener(Ke), ke(google.maps.event.addListener(x, "rightclick", N)));
  }, [N]), y(() => {
    x && C && (nt !== null && google.maps.event.removeListener(nt), gt(google.maps.event.addListener(x, "click", C)));
  }, [C]), y(() => {
    x && k && (Pe !== null && google.maps.event.removeListener(Pe), Te(google.maps.event.addListener(x, "drag", k)));
  }, [k]), y(() => {
    x && _ && (Re !== null && google.maps.event.removeListener(Re), He(google.maps.event.addListener(x, "clickable_changed", _)));
  }, [_]), y(() => {
    x && R && (ze !== null && google.maps.event.removeListener(ze), wt(google.maps.event.addListener(x, "cursor_changed", R)));
  }, [R]), y(() => {
    x && U && (Be !== null && google.maps.event.removeListener(Be), dn(google.maps.event.addListener(x, "animation_changed", U)));
  }, [U]), y(() => {
    x && z && (Ct !== null && google.maps.event.removeListener(Ct), Pt(google.maps.event.addListener(x, "draggable_changed", z)));
  }, [z]), y(() => {
    x && q && (Rt !== null && google.maps.event.removeListener(Rt), vn(google.maps.event.addListener(x, "flat_changed", q)));
  }, [q]), y(() => {
    x && K && (Nt !== null && google.maps.event.removeListener(Nt), yn(google.maps.event.addListener(x, "icon_changed", K)));
  }, [K]), y(() => {
    x && X && (mt !== null && google.maps.event.removeListener(mt), en(google.maps.event.addListener(x, "position_changed", X)));
  }, [X]), y(() => {
    x && ne && (St !== null && google.maps.event.removeListener(St), bn(google.maps.event.addListener(x, "shape_changed", ne)));
  }, [ne]), y(() => {
    x && Q && (zt !== null && google.maps.event.removeListener(zt), Pn(google.maps.event.addListener(x, "title_changed", Q)));
  }, [Q]), y(() => {
    x && S && (wn !== null && google.maps.event.removeListener(wn), Sn(google.maps.event.addListener(x, "visible_changed", S)));
  }, [S]), y(() => {
    x && I && (Cn !== null && google.maps.event.removeListener(Cn), kn(google.maps.event.addListener(x, "zindex_changed", I)));
  }, [I]), y(() => {
    var tn = mi(mi(mi({}, n || mu), r ? mu : {
      map: Y
    }), {}, {
      position: t
    }), se = new google.maps.Marker(tn);
    return r ? r.addMarker(se, !!o) : se.setMap(Y), t && se.setPosition(t), typeof a < "u" && se.setVisible(a), typeof s < "u" && se.setDraggable(s), typeof u < "u" && se.setClickable(u), typeof c == "string" && se.setCursor(c), d && se.setIcon(d), typeof p < "u" && se.setLabel(p), typeof m < "u" && se.setOpacity(m), f && se.setShape(f), typeof g == "string" && se.setTitle(g), typeof h == "number" && se.setZIndex(h), w && B(google.maps.event.addListener(se, "dblclick", w)), E && F(google.maps.event.addListener(se, "dragend", E)), v && G(google.maps.event.addListener(se, "dragstart", v)), D && be(google.maps.event.addListener(se, "mousedown", D)), O && Ae(google.maps.event.addListener(se, "mouseout", O)), L && je(google.maps.event.addListener(se, "mouseover", L)), W && tt(google.maps.event.addListener(se, "mouseup", W)), N && ke(google.maps.event.addListener(se, "rightclick", N)), C && gt(google.maps.event.addListener(se, "click", C)), k && Te(google.maps.event.addListener(se, "drag", k)), _ && He(google.maps.event.addListener(se, "clickable_changed", _)), R && wt(google.maps.event.addListener(se, "cursor_changed", R)), U && dn(google.maps.event.addListener(se, "animation_changed", U)), z && Pt(google.maps.event.addListener(se, "draggable_changed", z)), q && vn(google.maps.event.addListener(se, "flat_changed", q)), K && yn(google.maps.event.addListener(se, "icon_changed", K)), X && en(google.maps.event.addListener(se, "position_changed", X)), ne && bn(google.maps.event.addListener(se, "shape_changed", ne)), Q && Pn(google.maps.event.addListener(se, "title_changed", Q)), S && Sn(google.maps.event.addListener(se, "visible_changed", S)), I && kn(google.maps.event.addListener(se, "zindex_changed", I)), M(se), Z && Z(se), () => {
      $ !== null && google.maps.event.removeListener($), V !== null && google.maps.event.removeListener(V), J !== null && google.maps.event.removeListener(J), fe !== null && google.maps.event.removeListener(fe), re !== null && google.maps.event.removeListener(re), Ie !== null && google.maps.event.removeListener(Ie), _e !== null && google.maps.event.removeListener(_e), Ke !== null && google.maps.event.removeListener(Ke), nt !== null && google.maps.event.removeListener(nt), Re !== null && google.maps.event.removeListener(Re), ze !== null && google.maps.event.removeListener(ze), Be !== null && google.maps.event.removeListener(Be), Ct !== null && google.maps.event.removeListener(Ct), Rt !== null && google.maps.event.removeListener(Rt), Nt !== null && google.maps.event.removeListener(Nt), mt !== null && google.maps.event.removeListener(mt), zt !== null && google.maps.event.removeListener(zt), wn !== null && google.maps.event.removeListener(wn), Cn !== null && google.maps.event.removeListener(Cn), T && T(se), r ? r.removeMarker(se, !!o) : se && se.setMap(null);
    };
  }, []);
  var Wn = Mn(() => i ? Ft.map(i, (tn) => {
    if (!Ei(tn))
      return tn;
    var se = tn;
    return Oi(se, {
      anchor: x
    });
  }) : null, [i, x]);
  return j.jsx(j.Fragment, {
    children: Wn
  }) || null;
}
Me(_H);
class AP extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return DP(function* () {
      var n = mi(mi(mi({}, t.props.options || mu), t.props.clusterer ? mu : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = ot({
        updaterMap: S1,
        eventMap: P1,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: S1,
      eventMap: P1,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), lt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? Ft.map(this.props.children, (n) => {
      if (!Ei(n))
        return n;
      var r = n;
      return Oi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ae(AP, "contextType", Ge);
var IH = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), d = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(d !== null ? "".concat(d.y, "px") : "0", "; left: ").concat(d !== null ? "".concat(d.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var p = document.createElement("img");
        p.alt = a, p.src = this.url, p.width = this.width, p.height = this.height, p.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (p.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var m = document.createElement("div");
        m.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (m.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (m.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(p), this.div.appendChild(m), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), FH = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new IH(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function RH(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var NH = 2e3, zH = 500, $H = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", UH = "png", WH = [53, 56, 66, 78, 90], VH = "cluster", TP = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || $H, this.imageExtension = r.imageExtension || UH, this.imageSizes = r.imageSizes || WH, this.calculator = r.calculator || RH, this.batchSize = r.batchSize || NH, this.batchSizeIE = r.batchSizeIE || zH, this.clusterClass = r.clusterClass || VH, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new FH(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var d = 0, p = this.clusters; d < p.length; d++) {
            var m = p[d];
            m.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var s = i;
          this.prototype[s] = o.prototype[s];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function k1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? k1(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : k1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fr = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, bt = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, qH = {};
function GH(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: s,
    enableRetinaIcons: a,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: d,
    imageSizes: p,
    maxZoom: m,
    minimumClusterSize: f,
    styles: g,
    title: h,
    zoomOnClick: C,
    onClick: w,
    onClusteringBegin: k,
    onClusteringEnd: E,
    onMouseOver: v,
    onMouseOut: O,
    onLoad: L,
    onUnmount: W
  } = e, [D, N] = P(null), _ = Oe(Ge), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null);
  return y(() => {
    D && O && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(D, fr.onMouseOut, O)));
  }, [O]), y(() => {
    D && v && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(D, fr.onMouseOver, v)));
  }, [v]), y(() => {
    D && w && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(D, fr.onClick, w)));
  }, [w]), y(() => {
    D && k && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(D, fr.onClusteringBegin, k)));
  }, [k]), y(() => {
    D && E && (K !== null && google.maps.event.removeListener(K), q(google.maps.event.addListener(D, fr.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && D !== null && bt.averageCenter(D, r);
  }, [D, r]), y(() => {
    typeof o < "u" && D !== null && bt.batchSizeIE(D, o);
  }, [D, o]), y(() => {
    typeof i < "u" && D !== null && bt.calculator(D, i);
  }, [D, i]), y(() => {
    typeof s < "u" && D !== null && bt.clusterClass(D, s);
  }, [D, s]), y(() => {
    typeof a < "u" && D !== null && bt.enableRetinaIcons(D, a);
  }, [D, a]), y(() => {
    typeof l < "u" && D !== null && bt.gridSize(D, l);
  }, [D, l]), y(() => {
    typeof u < "u" && D !== null && bt.ignoreHidden(D, u);
  }, [D, u]), y(() => {
    typeof c < "u" && D !== null && bt.imageExtension(D, c);
  }, [D, c]), y(() => {
    typeof d < "u" && D !== null && bt.imagePath(D, d);
  }, [D, d]), y(() => {
    typeof p < "u" && D !== null && bt.imageSizes(D, p);
  }, [D, p]), y(() => {
    typeof m < "u" && D !== null && bt.maxZoom(D, m);
  }, [D, m]), y(() => {
    typeof f < "u" && D !== null && bt.minimumClusterSize(D, f);
  }, [D, f]), y(() => {
    typeof g < "u" && D !== null && bt.styles(D, g);
  }, [D, g]), y(() => {
    typeof h < "u" && D !== null && bt.title(D, h);
  }, [D, h]), y(() => {
    typeof C < "u" && D !== null && bt.zoomOnClick(D, C);
  }, [D, C]), y(() => {
    if (_) {
      var Z = HH({}, n || qH), T = new TP(_, [], Z);
      return r && bt.averageCenter(T, r), o && bt.batchSizeIE(T, o), i && bt.calculator(T, i), s && bt.clusterClass(T, s), a && bt.enableRetinaIcons(T, a), l && bt.gridSize(T, l), u && bt.ignoreHidden(T, u), c && bt.imageExtension(T, c), d && bt.imagePath(T, d), p && bt.imageSizes(T, p), m && bt.maxZoom(T, m), f && bt.minimumClusterSize(T, f), g && bt.styles(T, g), h && bt.title(T, h), C && bt.zoomOnClick(T, C), O && Q(google.maps.event.addListener(T, fr.onMouseOut, O)), v && I(google.maps.event.addListener(T, fr.onMouseOver, v)), w && U(google.maps.event.addListener(T, fr.onClick, w)), k && q(google.maps.event.addListener(T, fr.onClusteringBegin, k)), E && X(google.maps.event.addListener(T, fr.onClusteringEnd, E)), N(T), L && L(T), () => {
        ne !== null && google.maps.event.removeListener(ne), S !== null && google.maps.event.removeListener(S), R !== null && google.maps.event.removeListener(R), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), W && W(T);
      };
    }
  }, []), D !== null && t(D) || null;
}
Me(GH);
class ZH extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      markerClusterer: null
    }), ae(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new TP(this.context, [], this.props.options);
      this.registeredEvents = ot({
        updaterMap: bt,
        eventMap: fr,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: bt,
      eventMap: fr,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), lt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ae(ZH, "contextType", Ge);
function M1(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var BP = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), t.enableEventPropagation || M1(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, M1));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, d = this.div.offsetWidth, p = this.div.offsetHeight, m = this.infoBoxClearance.width, f = this.infoBoxClearance.height, g = this.getProjection(), h = g.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + m ? r = h.x + u - m : h.x + d + u + m > a && (r = h.x + d + u + m - a), this.alignBottom ? h.y < -c + f + p ? o = h.y + c - f - p : h.y + c + f > l && (o = h.y + c + f - l) : h.y < -c + f ? o = h.y + c - f : h.y + p + c + f > l && (o = h.y + p + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), YH = ["position"], XH = ["position"];
function A1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? A1(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : A1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var T1 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, B1 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, KH = {};
function JH(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, m = Oe(Ge), [f, g] = P(null), [h, C] = P(null), [w, k] = P(null), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null), N = qe(null);
  return y(() => {
    m && f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    if (o && f !== null) {
      var _ = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(_);
    }
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), k(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    if (m) {
      var _ = r || KH, {
        position: R
      } = _, U = Cg(_, YH), z;
      R && !(R instanceof google.maps.LatLng) && (z = new google.maps.LatLng(R.lat, R.lng));
      var q = new BP(vu(vu({}, U), z ? {
        position: z
      } : {}));
      N.current = document.createElement("div"), g(q), s && C(google.maps.event.addListener(q, "closeclick", s)), a && k(google.maps.event.addListener(q, "domready", a)), l && v(google.maps.event.addListener(q, "content_changed", l)), u && L(google.maps.event.addListener(q, "position_changed", u)), c && D(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(N.current), n ? q.open(m, n) : q.getPosition() ? q.open(m) : Dn(!1, "You must provide either an anchor or a position prop for <InfoBox>."), d && d(q);
    }
    return () => {
      f !== null && (h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), p && p(f), f.close());
    };
  }, []), N.current ? vr(Ft.only(t), N.current) : null;
}
Me(JH);
class QH extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "containerElement", null), ae(this, "state", {
      infoBox: null
    }), ae(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Dn(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ae(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Cg(t, XH), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new BP(vu(vu({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = ot({
      updaterMap: B1,
      eventMap: T1,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: B1,
      eventMap: T1,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), lt(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? vr(Ft.only(this.props.children), this.containerElement) : null;
  }
}
ae(QH, "contextType", Ge);
var sp, j1;
function e7() {
  return j1 || (j1 = 1, sp = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var s = i[o];
        if (!e(t[s], n[s])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), sp;
}
var t7 = e7(), _1 = /* @__PURE__ */ xP(t7), I1 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], ap = 1, ns = 8;
class Eg {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== ap)
      throw new Error("Got v".concat(o, " data when expected v").concat(ap, "."));
    var i = I1[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new Eg(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = I1.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, ns, t), this.coords = new this.ArrayType(this.data, ns + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(ns + s + a + l), this.ids = new this.IndexArrayType(this.data, ns, t), this.coords = new this.ArrayType(this.data, ns + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (ap << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return bf(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: s,
      nodeSize: a
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, d = l.pop() || 0, p = l.pop() || 0;
      if (d - p <= a) {
        for (var m = p; m <= d; m++) {
          var f = s[2 * m], g = s[2 * m + 1];
          f >= t && f <= r && g >= n && g <= o && u.push(i[m]);
        }
        continue;
      }
      var h = p + d >> 1, C = s[2 * h], w = s[2 * h + 1];
      C >= t && C <= r && w >= n && w <= o && u.push(i[h]), (c === 0 ? t <= C : n <= w) && (l.push(p), l.push(h - 1), l.push(1 - c)), (c === 0 ? r >= C : o >= w) && (l.push(h + 1), l.push(d), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: s
    } = this, a = [0, o.length - 1, 0], l = [], u = r * r; a.length; ) {
      var c = a.pop() || 0, d = a.pop() || 0, p = a.pop() || 0;
      if (d - p <= s) {
        for (var m = p; m <= d; m++)
          F1(i[2 * m], i[2 * m + 1], t, n) <= u && l.push(o[m]);
        continue;
      }
      var f = p + d >> 1, g = i[2 * f], h = i[2 * f + 1];
      F1(g, h, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= g : n - r <= h) && (a.push(p), a.push(f - 1), a.push(1 - c)), (c === 0 ? t + r >= g : n + r >= h) && (a.push(f + 1), a.push(d), a.push(1 - c));
    }
    return l;
  }
}
function bf(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var s = r + o >> 1;
    jP(e, t, s, r, o, i), bf(e, t, n, r, s - 1, 1 - i), bf(e, t, n, s + 1, o, 1 - i);
  }
}
function jP(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var s = o - r + 1, a = n - r + 1, l = Math.log(s), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (s - u) / s) * (a - s / 2 < 0 ? -1 : 1), d = Math.max(r, Math.floor(n - a * u / s + c)), p = Math.min(o, Math.floor(n + (s - a) * u / s + c));
      jP(e, t, n, d, p, i);
    }
    var m = t[2 * n + i], f = r, g = o;
    for (rs(e, t, r, n), t[2 * o + i] > m && rs(e, t, r, o); f < g; ) {
      for (rs(e, t, f, g), f++, g--; t[2 * f + i] < m; ) f++;
      for (; t[2 * g + i] > m; ) g--;
    }
    t[2 * r + i] === m ? rs(e, t, r, g) : (g++, rs(e, t, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function rs(e, t, n, r) {
  lp(e, n, r), lp(t, 2 * n, 2 * r), lp(t, 2 * n + 1, 2 * r + 1);
}
function lp(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function F1(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var n7 = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, R1 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Fo = 2, fo = 3, up = 4, ao = 5, _P = 6;
class r7 {
  constructor(t) {
    this.options = Object.assign(Object.create(n7), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var s = [], a = 0; a < t.length; a++) {
      var l = t[a];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, d = R1(pl(u)), p = R1(fl(c));
        s.push(
          d,
          p,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          a,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && s.push(0);
      }
    }
    var m = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var g = +Date.now();
      m = this.trees[f] = this._createTree(this._cluster(m, f)), n && console.log("z%d: %d clusters in %dms", f, m.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var a = this.getClusters([r, o, 180, s], n), l = this.getClusters([-180, o, i, s], n);
      return a.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(pl(r), fl(s), pl(i), fl(o)), d = u.data, p = [];
    for (var m of c) {
      var f = this.stride * m;
      p.push(d[f + ao] > 1 ? N1(d, f, this.clusterProps) : this.points[d[f + fo]]);
    }
    return p;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    var a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), d = [];
    for (var p of c) {
      var m = p * this.stride;
      s[m + up] === t && d.push(s[m + ao] > 1 ? N1(s, m, this.clusterProps) : this.points[s[m + fo]]);
    }
    if (d.length === 0) throw new Error(o);
    return d;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: s,
      radius: a
    } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, d = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, d), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, d), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, d), d.features.length ? d : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var s = this.getChildren(n);
    for (var a of s) {
      var l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Eg(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (var a of t) {
      var l = a * this.stride, u = n[l + ao] > 1, c = void 0, d = void 0, p = void 0;
      if (u)
        c = IP(n, l, this.clusterProps), d = n[l], p = n[l + 1];
      else {
        var m = this.points[n[l + fo]];
        c = m.properties;
        var [f, g] = m.geometry.coordinates;
        d = pl(f), p = fl(g);
      }
      var h = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (d * i - r)), Math.round(this.options.extent * (p * i - o))]],
        tags: c
      }, C = void 0;
      u || this.options.generateId ? C = n[l + fo] : C = this.points[n[l + fo]].id, C !== void 0 && (h.id = C), s.features.push(h);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: s
    } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, d = 0; d < l.length; d += c)
      if (!(l[d + Fo] <= n)) {
        l[d + Fo] = n;
        var p = l[d], m = l[d + 1], f = t.within(l[d], l[d + 1], a), g = l[d + ao], h = g;
        for (var C of f) {
          var w = C * c;
          l[w + Fo] > n && (h += l[w + ao]);
        }
        if (h > g && h >= s) {
          var k = p * g, E = m * g, v = void 0, O = -1, L = ((d / c | 0) << 5) + (n + 1) + this.points.length;
          for (var W of f) {
            var D = W * c;
            if (!(l[D + Fo] <= n)) {
              l[D + Fo] = n;
              var N = l[D + ao];
              k += l[D] * N, E += l[D + 1] * N, l[D + up] = L, i && (v || (v = this._map(l, d, !0), O = this.clusterProps.length, this.clusterProps.push(v)), i(v, this._map(l, D)));
            }
          }
          l[d + up] = L, u.push(k / h, E / h, 1 / 0, L, -1, h), i && u.push(O);
        } else {
          for (var _ = 0; _ < c; _++) u.push(l[d + _]);
          if (h > 1)
            for (var R of f) {
              var U = R * c;
              if (!(l[U + Fo] <= n)) {
                l[U + Fo] = n;
                for (var z = 0; z < c; z++) u.push(l[U + z]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ao] > 1) {
      var o = this.clusterProps[t[n + _P]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + fo]].properties, s = this.options.map(i);
    return r && s === i ? Object.assign({}, s) : s;
  }
}
function N1(e, t, n) {
  return {
    type: "Feature",
    id: e[t + fo],
    properties: IP(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [o7(e[t]), i7(e[t + 1])]
    }
  };
}
function IP(e, t, n) {
  var r = e[t + ao], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + _P], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + fo],
    point_count: r,
    point_count_abbreviated: o
  });
}
function pl(e) {
  return e / 360 + 0.5;
}
function fl(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function o7(e) {
  return (e - 0.5) * 360;
}
function i7(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function s7(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class rr {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class wf {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(rr.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => rr.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (rr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class a7 {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return l7(n);
  }
}
var l7 = (e) => {
  var t = e.map((n) => new wf({
    position: rr.getPosition(n),
    markers: [n]
  }));
  return t;
};
class u7 extends a7 {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = s7(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new r7(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!_1(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var s = rr.getPosition(i), a = [s.lng(), s.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: a
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !_1(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new wf({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((s) => s.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new wf({
      markers: [i],
      position: rr.getPosition(i)
    });
  }
}
class c7 {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class d7 {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, s = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", a = '<svg fill="'.concat(s, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (rr.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), d = c.parseFromString(a, "image/svg+xml").documentElement;
      d.setAttribute("transform", "translate(0 25)");
      var p = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: d
      };
      return new google.maps.marker.AdvancedMarkerElement(p);
    }
    var m = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(a)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(m);
  }
}
function p7(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Og {
  constructor() {
    p7(Og, google.maps.OverlayView);
  }
}
var Os;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Os || (Os = {}));
var f7 = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class h7 extends Og {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new u7(o),
      renderer: s = new d7(),
      onClusterClick: a = f7
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = s, this.onClusterClick = a, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (rr.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Os.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var s = [];
        for (var a of this.clusters)
          a.marker != null && (a.markers.length == 1 ? o.has(a.marker) || rr.setMap(a.marker, null) : s.push(a.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => s.forEach((l) => rr.setMap(l, null)));
      }
      google.maps.event.trigger(this, Os.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => rr.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new c7(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => rr.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Os.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), rr.setMap(r.marker, n);
    });
  }
}
function z1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? z1(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function g7(e) {
  var t = hH(), [n, r] = P(null);
  return y(() => {
    if (t && n === null) {
      var o = new h7($1($1({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function m7(e) {
  var {
    children: t,
    options: n
  } = e, r = g7(n);
  return r !== null ? t(r) : null;
}
Me(m7);
var U1 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, W1 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function v7(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: s,
    onDomReady: a,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: p
  } = e, m = Oe(Ge), [f, g] = P(null), [h, C] = P(null), [w, k] = P(null), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null), N = qe(null);
  return y(() => {
    f !== null && (f.close(), n ? f.open(m, n) : f.getPosition() && f.open(m));
  }, [m, f, n]), y(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), y(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), y(() => {
    f && s && (h !== null && google.maps.event.removeListener(h), C(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), y(() => {
    f && a && (w !== null && google.maps.event.removeListener(w), k(google.maps.event.addListener(f, "domready", a)));
  }, [a]), y(() => {
    f && l && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), y(() => {
    f && u && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), y(() => {
    f && c && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), y(() => {
    var _ = new google.maps.InfoWindow(r);
    return g(_), N.current = document.createElement("div"), s && C(google.maps.event.addListener(_, "closeclick", s)), a && k(google.maps.event.addListener(_, "domready", a)), l && v(google.maps.event.addListener(_, "content_changed", l)), u && L(google.maps.event.addListener(_, "position_changed", u)), c && D(google.maps.event.addListener(_, "zindex_changed", c)), _.setContent(N.current), o && _.setPosition(o), i && _.setZIndex(i), n ? _.open(m, n) : _.getPosition() ? _.open(m) : Dn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), d && d(_), () => {
      h && google.maps.event.removeListener(h), E && google.maps.event.removeListener(E), w && google.maps.event.removeListener(w), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), p && p(_), _.close();
    };
  }, []), N.current ? vr(Ft.only(t), N.current) : null;
}
Me(v7);
class y7 extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "containerElement", null), ae(this, "state", {
      infoWindow: null
    }), ae(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Dn(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ae(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = ot({
      updaterMap: W1,
      eventMap: U1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: W1,
      eventMap: U1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (lt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? vr(Ft.only(this.props.children), this.containerElement) : null;
  }
}
ae(y7, "contextType", Ge);
function V1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? V1(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : V1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var H1 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, q1 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, b7 = {};
function w7(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onLoad: C,
    onUnmount: w
  } = e, k = Oe(Ge), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null), [N, _] = P(null), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null), [Z, T] = P(null), [Y, x] = P(null), [M, $] = P(null);
  return y(() => {
    E !== null && E.setMap(k);
  }, [k]), y(() => {
    typeof t < "u" && E !== null && E.setOptions(t);
  }, [E, t]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && s && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(E, "dblclick", s)));
  }, [s]), y(() => {
    E && a && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(E, "dragend", a)));
  }, [a]), y(() => {
    E && l && (N !== null && google.maps.event.removeListener(N), _(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && d && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(E, "mouseout", d)));
  }, [d]), y(() => {
    E && p && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(E, "mouseover", p)));
  }, [p]), y(() => {
    E && m && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(E, "mouseup", m)));
  }, [m]), y(() => {
    E && f && (Z !== null && google.maps.event.removeListener(Z), T(google.maps.event.addListener(E, "rightclick", f)));
  }, [f]), y(() => {
    E && g && (Y !== null && google.maps.event.removeListener(Y), x(google.maps.event.addListener(E, "click", g)));
  }, [g]), y(() => {
    E && h && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(E, "drag", h)));
  }, [h]), y(() => {
    var B = new google.maps.Polyline(yu(yu({}, t || b7), {}, {
      map: k
    }));
    return i && B.setPath(i), typeof o < "u" && B.setVisible(o), typeof r < "u" && B.setEditable(r), typeof n < "u" && B.setDraggable(n), s && L(google.maps.event.addListener(B, "dblclick", s)), a && D(google.maps.event.addListener(B, "dragend", a)), l && _(google.maps.event.addListener(B, "dragstart", l)), u && U(google.maps.event.addListener(B, "mousedown", u)), c && q(google.maps.event.addListener(B, "mousemove", c)), d && X(google.maps.event.addListener(B, "mouseout", d)), p && Q(google.maps.event.addListener(B, "mouseover", p)), m && I(google.maps.event.addListener(B, "mouseup", m)), f && T(google.maps.event.addListener(B, "rightclick", f)), g && x(google.maps.event.addListener(B, "click", g)), h && $(google.maps.event.addListener(B, "drag", h)), v(B), C && C(B), () => {
      O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), N !== null && google.maps.event.removeListener(N), R !== null && google.maps.event.removeListener(R), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), ne !== null && google.maps.event.removeListener(ne), S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), w && w(B), B.setMap(null);
    };
  }, []), null;
}
Me(w7);
class C7 extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      polyline: null
    }), ae(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(yu(yu({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ot({
      updaterMap: q1,
      eventMap: H1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: q1,
      eventMap: H1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), lt(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ae(C7, "contextType", Ge);
function G1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Z1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G1(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Y1 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, X1 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function E7(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onLoad: w,
    onUnmount: k,
    onEdit: E
  } = e, v = Oe(Ge), [O, L] = P(null), [W, D] = P(null), [N, _] = P(null), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null), [Z, T] = P(null), [Y, x] = P(null), [M, $] = P(null), [B, V] = P(null);
  return y(() => {
    O !== null && O.setMap(v);
  }, [v]), y(() => {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), y(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), y(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), y(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), y(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), y(() => {
    typeof s < "u" && O !== null && O.setPaths(s);
  }, [O, s]), y(() => {
    O && typeof a == "function" && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), y(() => {
    O && (google.maps.event.addListener(O.getPath(), "insert_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "set_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "remove_at", () => {
      E == null || E(O);
    }));
  }, [O, E]), y(() => {
    O && typeof l == "function" && (N !== null && google.maps.event.removeListener(N), _(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), y(() => {
    O && typeof u == "function" && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), y(() => {
    O && typeof c == "function" && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), y(() => {
    O && typeof d == "function" && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(O, "mousemove", d)));
  }, [d]), y(() => {
    O && typeof p == "function" && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(O, "mouseout", p)));
  }, [p]), y(() => {
    O && typeof m == "function" && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(O, "mouseover", m)));
  }, [m]), y(() => {
    O && typeof f == "function" && (Z !== null && google.maps.event.removeListener(Z), T(google.maps.event.addListener(O, "mouseup", f)));
  }, [f]), y(() => {
    O && typeof g == "function" && (Y !== null && google.maps.event.removeListener(Y), x(google.maps.event.addListener(O, "rightclick", g)));
  }, [g]), y(() => {
    O && typeof h == "function" && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(O, "click", h)));
  }, [h]), y(() => {
    O && typeof C == "function" && (B !== null && google.maps.event.removeListener(B), V(google.maps.event.addListener(O, "drag", C)));
  }, [C]), y(() => {
    var F = new google.maps.Polygon(Z1(Z1({}, t), {}, {
      map: v
    }));
    return i && F.setPath(i), s && F.setPaths(s), typeof o < "u" && F.setVisible(o), typeof r < "u" && F.setEditable(r), typeof n < "u" && F.setDraggable(n), a && D(google.maps.event.addListener(F, "dblclick", a)), l && _(google.maps.event.addListener(F, "dragend", l)), u && U(google.maps.event.addListener(F, "dragstart", u)), c && q(google.maps.event.addListener(F, "mousedown", c)), d && X(google.maps.event.addListener(F, "mousemove", d)), p && Q(google.maps.event.addListener(F, "mouseout", p)), m && I(google.maps.event.addListener(F, "mouseover", m)), f && T(google.maps.event.addListener(F, "mouseup", f)), g && x(google.maps.event.addListener(F, "rightclick", g)), h && $(google.maps.event.addListener(F, "click", h)), C && V(google.maps.event.addListener(F, "drag", C)), L(F), w && w(F), () => {
      W !== null && google.maps.event.removeListener(W), N !== null && google.maps.event.removeListener(N), R !== null && google.maps.event.removeListener(R), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), ne !== null && google.maps.event.removeListener(ne), S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), k && k(F), F.setMap(null);
    };
  }, []), null;
}
Me(E7);
class O7 extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = ot({
      updaterMap: X1,
      eventMap: Y1,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: X1,
      eventMap: Y1,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), lt(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ae(O7, "contextType", Ge);
function K1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? K1(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : K1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J1 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Q1 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function x7(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: s,
    onDragEnd: a,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: p,
    onMouseUp: m,
    onRightClick: f,
    onClick: g,
    onDrag: h,
    onBoundsChanged: C,
    onLoad: w,
    onUnmount: k
  } = e, E = Oe(Ge), [v, O] = P(null), [L, W] = P(null), [D, N] = P(null), [_, R] = P(null), [U, z] = P(null), [q, K] = P(null), [X, ne] = P(null), [Q, S] = P(null), [I, Z] = P(null), [T, Y] = P(null), [x, M] = P(null), [$, B] = P(null), [V, F] = P(null);
  return y(() => {
    v !== null && v.setMap(E);
  }, [E]), y(() => {
    typeof t < "u" && v !== null && v.setOptions(t);
  }, [v, t]), y(() => {
    typeof r < "u" && v !== null && v.setDraggable(r);
  }, [v, r]), y(() => {
    typeof o < "u" && v !== null && v.setEditable(o);
  }, [v, o]), y(() => {
    typeof i < "u" && v !== null && v.setVisible(i);
  }, [v, i]), y(() => {
    typeof n < "u" && v !== null && v.setBounds(n);
  }, [v, n]), y(() => {
    v && s && (L !== null && google.maps.event.removeListener(L), W(google.maps.event.addListener(v, "dblclick", s)));
  }, [s]), y(() => {
    v && a && (D !== null && google.maps.event.removeListener(D), N(google.maps.event.addListener(v, "dragend", a)));
  }, [a]), y(() => {
    v && l && (_ !== null && google.maps.event.removeListener(_), R(google.maps.event.addListener(v, "dragstart", l)));
  }, [l]), y(() => {
    v && u && (U !== null && google.maps.event.removeListener(U), z(google.maps.event.addListener(v, "mousedown", u)));
  }, [u]), y(() => {
    v && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(v, "mousemove", c)));
  }, [c]), y(() => {
    v && d && (X !== null && google.maps.event.removeListener(X), ne(google.maps.event.addListener(v, "mouseout", d)));
  }, [d]), y(() => {
    v && p && (Q !== null && google.maps.event.removeListener(Q), S(google.maps.event.addListener(v, "mouseover", p)));
  }, [p]), y(() => {
    v && m && (I !== null && google.maps.event.removeListener(I), Z(google.maps.event.addListener(v, "mouseup", m)));
  }, [m]), y(() => {
    v && f && (T !== null && google.maps.event.removeListener(T), Y(google.maps.event.addListener(v, "rightclick", f)));
  }, [f]), y(() => {
    v && g && (x !== null && google.maps.event.removeListener(x), M(google.maps.event.addListener(v, "click", g)));
  }, [g]), y(() => {
    v && h && ($ !== null && google.maps.event.removeListener($), B(google.maps.event.addListener(v, "drag", h)));
  }, [h]), y(() => {
    v && C && (V !== null && google.maps.event.removeListener(V), F(google.maps.event.addListener(v, "bounds_changed", C)));
  }, [C]), y(() => {
    var J = new google.maps.Rectangle(bu(bu({}, t), {}, {
      map: E
    }));
    return typeof i < "u" && J.setVisible(i), typeof o < "u" && J.setEditable(o), typeof r < "u" && J.setDraggable(r), typeof n < "u" && J.setBounds(n), s && W(google.maps.event.addListener(J, "dblclick", s)), a && N(google.maps.event.addListener(J, "dragend", a)), l && R(google.maps.event.addListener(J, "dragstart", l)), u && z(google.maps.event.addListener(J, "mousedown", u)), c && K(google.maps.event.addListener(J, "mousemove", c)), d && ne(google.maps.event.addListener(J, "mouseout", d)), p && S(google.maps.event.addListener(J, "mouseover", p)), m && Z(google.maps.event.addListener(J, "mouseup", m)), f && Y(google.maps.event.addListener(J, "rightclick", f)), g && M(google.maps.event.addListener(J, "click", g)), h && B(google.maps.event.addListener(J, "drag", h)), C && F(google.maps.event.addListener(J, "bounds_changed", C)), O(J), w && w(J), () => {
      L !== null && google.maps.event.removeListener(L), D !== null && google.maps.event.removeListener(D), _ !== null && google.maps.event.removeListener(_), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), x !== null && google.maps.event.removeListener(x), $ !== null && google.maps.event.removeListener($), V !== null && google.maps.event.removeListener(V), k && k(J), J.setMap(null);
    };
  }, []), null;
}
Me(x7);
class D7 extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      rectangle: null
    }), ae(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(bu(bu({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ot({
      updaterMap: Q1,
      eventMap: J1,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: Q1,
      eventMap: J1,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), lt(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ae(D7, "contextType", Ge);
function eE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eE(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tE = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, nE = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, L7 = {};
function P7(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: s,
    onDblClick: a,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: p,
    onMouseOver: m,
    onMouseUp: f,
    onRightClick: g,
    onClick: h,
    onDrag: C,
    onCenterChanged: w,
    onRadiusChanged: k,
    onLoad: E,
    onUnmount: v
  } = e, O = Oe(Ge), [L, W] = P(null), [D, N] = P(null), [_, R] = P(null), [U, z] = P(null), [q, K] = P(null), [X, ne] = P(null), [Q, S] = P(null), [I, Z] = P(null), [T, Y] = P(null), [x, M] = P(null), [$, B] = P(null), [V, F] = P(null), [J, G] = P(null), [fe, be] = P(null);
  return y(() => {
    L !== null && L.setMap(O);
  }, [O]), y(() => {
    typeof t < "u" && L !== null && L.setOptions(t);
  }, [L, t]), y(() => {
    typeof o < "u" && L !== null && L.setDraggable(o);
  }, [L, o]), y(() => {
    typeof i < "u" && L !== null && L.setEditable(i);
  }, [L, i]), y(() => {
    typeof s < "u" && L !== null && L.setVisible(s);
  }, [L, s]), y(() => {
    typeof r == "number" && L !== null && L.setRadius(r);
  }, [L, r]), y(() => {
    typeof n < "u" && L !== null && L.setCenter(n);
  }, [L, n]), y(() => {
    L && a && (D !== null && google.maps.event.removeListener(D), N(google.maps.event.addListener(L, "dblclick", a)));
  }, [a]), y(() => {
    L && l && (_ !== null && google.maps.event.removeListener(_), R(google.maps.event.addListener(L, "dragend", l)));
  }, [l]), y(() => {
    L && u && (U !== null && google.maps.event.removeListener(U), z(google.maps.event.addListener(L, "dragstart", u)));
  }, [u]), y(() => {
    L && c && (q !== null && google.maps.event.removeListener(q), K(google.maps.event.addListener(L, "mousedown", c)));
  }, [c]), y(() => {
    L && d && (X !== null && google.maps.event.removeListener(X), ne(google.maps.event.addListener(L, "mousemove", d)));
  }, [d]), y(() => {
    L && p && (Q !== null && google.maps.event.removeListener(Q), S(google.maps.event.addListener(L, "mouseout", p)));
  }, [p]), y(() => {
    L && m && (I !== null && google.maps.event.removeListener(I), Z(google.maps.event.addListener(L, "mouseover", m)));
  }, [m]), y(() => {
    L && f && (T !== null && google.maps.event.removeListener(T), Y(google.maps.event.addListener(L, "mouseup", f)));
  }, [f]), y(() => {
    L && g && (x !== null && google.maps.event.removeListener(x), M(google.maps.event.addListener(L, "rightclick", g)));
  }, [g]), y(() => {
    L && h && ($ !== null && google.maps.event.removeListener($), B(google.maps.event.addListener(L, "click", h)));
  }, [h]), y(() => {
    L && C && (V !== null && google.maps.event.removeListener(V), F(google.maps.event.addListener(L, "drag", C)));
  }, [C]), y(() => {
    L && w && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(L, "center_changed", w)));
  }, [h]), y(() => {
    L && k && (fe !== null && google.maps.event.removeListener(fe), be(google.maps.event.addListener(L, "radius_changed", k)));
  }, [k]), y(() => {
    var re = new google.maps.Circle(wu(wu({}, t || L7), {}, {
      map: O
    }));
    return typeof r == "number" && re.setRadius(r), typeof n < "u" && re.setCenter(n), typeof r == "number" && re.setRadius(r), typeof s < "u" && re.setVisible(s), typeof i < "u" && re.setEditable(i), typeof o < "u" && re.setDraggable(o), a && N(google.maps.event.addListener(re, "dblclick", a)), l && R(google.maps.event.addListener(re, "dragend", l)), u && z(google.maps.event.addListener(re, "dragstart", u)), c && K(google.maps.event.addListener(re, "mousedown", c)), d && ne(google.maps.event.addListener(re, "mousemove", d)), p && S(google.maps.event.addListener(re, "mouseout", p)), m && Z(google.maps.event.addListener(re, "mouseover", m)), f && Y(google.maps.event.addListener(re, "mouseup", f)), g && M(google.maps.event.addListener(re, "rightclick", g)), h && B(google.maps.event.addListener(re, "click", h)), C && F(google.maps.event.addListener(re, "drag", C)), w && G(google.maps.event.addListener(re, "center_changed", w)), k && be(google.maps.event.addListener(re, "radius_changed", k)), W(re), E && E(re), () => {
      D !== null && google.maps.event.removeListener(D), _ !== null && google.maps.event.removeListener(_), U !== null && google.maps.event.removeListener(U), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), Q !== null && google.maps.event.removeListener(Q), I !== null && google.maps.event.removeListener(I), T !== null && google.maps.event.removeListener(T), x !== null && google.maps.event.removeListener(x), $ !== null && google.maps.event.removeListener($), J !== null && google.maps.event.removeListener(J), fe !== null && google.maps.event.removeListener(fe), v && v(re), re.setMap(null);
    };
  }, []), null;
}
Me(P7);
class S7 extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      circle: null
    }), ae(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(wu(wu({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ot({
      updaterMap: nE,
      eventMap: tE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: nE,
      eventMap: tE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), lt(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ae(S7, "contextType", Ge);
function rE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rE(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oE = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, iE = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function k7(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: s,
    onMouseOver: a,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: d,
    onRemoveProperty: p,
    onSetGeometry: m,
    onSetProperty: f,
    onLoad: g,
    onUnmount: h
  } = e, C = Oe(Ge), [w, k] = P(null), [E, v] = P(null), [O, L] = P(null), [W, D] = P(null), [N, _] = P(null), [R, U] = P(null), [z, q] = P(null), [K, X] = P(null), [ne, Q] = P(null), [S, I] = P(null), [Z, T] = P(null), [Y, x] = P(null), [M, $] = P(null), [B, V] = P(null);
  return y(() => {
    w !== null && w.setMap(C);
  }, [C]), y(() => {
    w && r && (E !== null && google.maps.event.removeListener(E), v(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), y(() => {
    w && o && (O !== null && google.maps.event.removeListener(O), L(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), y(() => {
    w && i && (W !== null && google.maps.event.removeListener(W), D(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), y(() => {
    w && s && (N !== null && google.maps.event.removeListener(N), _(google.maps.event.addListener(w, "mouseout", s)));
  }, [s]), y(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), U(google.maps.event.addListener(w, "mouseover", a)));
  }, [a]), y(() => {
    w && l && (z !== null && google.maps.event.removeListener(z), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), y(() => {
    w && u && (K !== null && google.maps.event.removeListener(K), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), y(() => {
    w && n && (ne !== null && google.maps.event.removeListener(ne), Q(google.maps.event.addListener(w, "click", n)));
  }, [n]), y(() => {
    w && c && (S !== null && google.maps.event.removeListener(S), I(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), y(() => {
    w && d && (Z !== null && google.maps.event.removeListener(Z), T(google.maps.event.addListener(w, "removefeature", d)));
  }, [d]), y(() => {
    w && p && (Y !== null && google.maps.event.removeListener(Y), x(google.maps.event.addListener(w, "removeproperty", p)));
  }, [p]), y(() => {
    w && m && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(w, "setgeometry", m)));
  }, [m]), y(() => {
    w && f && (B !== null && google.maps.event.removeListener(B), V(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), y(() => {
    if (C !== null) {
      var F = new google.maps.Data(Cu(Cu({}, t), {}, {
        map: C
      }));
      r && v(google.maps.event.addListener(F, "dblclick", r)), o && L(google.maps.event.addListener(F, "mousedown", o)), i && D(google.maps.event.addListener(F, "mousemove", i)), s && _(google.maps.event.addListener(F, "mouseout", s)), a && U(google.maps.event.addListener(F, "mouseover", a)), l && q(google.maps.event.addListener(F, "mouseup", l)), u && X(google.maps.event.addListener(F, "rightclick", u)), n && Q(google.maps.event.addListener(F, "click", n)), c && I(google.maps.event.addListener(F, "addfeature", c)), d && T(google.maps.event.addListener(F, "removefeature", d)), p && x(google.maps.event.addListener(F, "removeproperty", p)), m && $(google.maps.event.addListener(F, "setgeometry", m)), f && V(google.maps.event.addListener(F, "setproperty", f)), k(F), g && g(F);
    }
    return () => {
      w && (E !== null && google.maps.event.removeListener(E), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), N !== null && google.maps.event.removeListener(N), R !== null && google.maps.event.removeListener(R), z !== null && google.maps.event.removeListener(z), K !== null && google.maps.event.removeListener(K), ne !== null && google.maps.event.removeListener(ne), S !== null && google.maps.event.removeListener(S), Z !== null && google.maps.event.removeListener(Z), Y !== null && google.maps.event.removeListener(Y), M !== null && google.maps.event.removeListener(M), B !== null && google.maps.event.removeListener(B), h && h(w), w.setMap(null));
    };
  }, []), null;
}
Me(k7);
class M7 extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      data: null
    }), ae(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Cu(Cu({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = ot({
        updaterMap: iE,
        eventMap: oE,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: iE,
      eventMap: oE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), lt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ae(M7, "contextType", Ge);
function sE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function aE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sE(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lE = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, uE = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class A7 extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      kmlLayer: null
    }), ae(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(aE(aE({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ot({
      updaterMap: uE,
      eventMap: lE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: uE,
      eventMap: lE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), lt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ae(A7, "contextType", Ge);
function FP(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function T7(e, t) {
  return new t(e.lat, e.lng);
}
function B7(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function j7(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function _7(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function I7(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function F7(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function RP(e, t, n, r) {
  return n !== void 0 ? I7(e, t, _7(n, google.maps.LatLngBounds, B7)) : F7(e, t, j7(r, google.maps.LatLng, T7));
}
function R7(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function cE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function N7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cE(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function z7(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(a, l, u, c) {
      super(), this.container = a, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var a, l = (a = this.getPanes()) === null || a === void 0 ? void 0 : a[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var a = this.getProjection(), l = N7({}, this.container ? FP(this.container, o) : {
        x: 0,
        y: 0
      }), u = RP(a, l, this.bounds, this.position);
      for (var [c, d] of Object.entries(u))
        this.container.style[c] = d;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function dE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $7(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dE(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function pE(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function fE(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function U7(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: s,
    getPixelPositionOffset: a,
    children: l
  } = e, u = Oe(Ge), c = Mn(() => {
    var p = document.createElement("div");
    return p.style.position = "absolute", p;
  }, []), d = Mn(() => z7(c, r, t, n, a), [c, r, t, n]);
  return y(() => (i == null || i(d), d == null || d.setMap(u), () => {
    s == null || s(d), d == null || d.setMap(null);
  }), [u, d]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), xi.createPortal(l, c);
}
Me(U7);
class Bi extends Ee {
  constructor(t) {
    super(t), ae(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ae(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Dn(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ae(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ae(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = $7({
        x: 0,
        y: 0
      }, this.containerRef.current ? FP(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = RP(r, o, this.props.bounds, this.props.position);
      if (!R7(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var s, a, l, u;
        this.setState({
          containerStyle: {
            top: (s = i.top) !== null && s !== void 0 ? s : 0,
            left: (a = i.left) !== null && a !== void 0 ? a : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ae(this, "draw", () => {
      this.onPositionElement();
    }), ae(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = mr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = pE(t.position), r = pE(this.props.position), o = fE(t.bounds), i = fE(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? xi.createPortal(j.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: Ft.only(this.props.children)
    }), t) : null;
  }
}
ae(Bi, "FLOAT_PANE", "floatPane");
ae(Bi, "MAP_PANE", "mapPane");
ae(Bi, "MARKER_LAYER", "markerLayer");
ae(Bi, "OVERLAY_LAYER", "overlayLayer");
ae(Bi, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ae(Bi, "contextType", Ge);
function W7() {
}
function hE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gE(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hE(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mE = {
  onDblClick: "dblclick",
  onClick: "click"
}, vE = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function V7(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = Oe(Ge), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = Mn(() => new google.maps.GroundOverlay(t, s, r), []);
  return y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), y(() => {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Me(V7);
class NP extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      groundOverlay: null
    }), ae(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Dn(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, gE(gE({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = ot({
      updaterMap: vE,
      eventMap: mE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: vE,
      eventMap: mE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ae(NP, "defaultProps", {
  onLoad: W7
});
ae(NP, "contextType", Ge);
function yE(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Eu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? yE(Object(n), !0).forEach(function(r) {
      ae(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : yE(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bE = {}, wE = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function H7(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = Oe(Ge), [s, a] = P(null);
  return y(() => {
    google.maps.visualization || Dn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    Dn(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    o && s !== null && s.setOptions(o);
  }, [s, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer(Eu(Eu({}, o), {}, {
      data: t,
      map: i
    }));
    return a(l), n && n(l), () => {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Me(H7);
class q7 extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      heatmapLayer: null
    }), ae(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Dn(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Dn(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Eu(Eu({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = ot({
      updaterMap: wE,
      eventMap: bE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: wE,
      eventMap: bE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), lt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ae(q7, "contextType", Ge);
var CE = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, EE = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class G7 extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      streetViewPanorama: null
    }), ae(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = ot({
      updaterMap: EE,
      eventMap: CE,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: EE,
      eventMap: CE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), lt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ae(G7, "contextType", Ge);
class Z7 extends Ee {
  constructor() {
    super(...arguments), ae(this, "state", {
      streetViewService: null
    }), ae(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ae(Z7, "contextType", Ge);
var OE = {
  onDirectionsChanged: "directions_changed"
}, xE = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Y7 extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      directionsRenderer: null
    }), ae(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = ot({
      updaterMap: xE,
      eventMap: OE,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: xE,
      eventMap: OE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), lt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ae(Y7, "contextType", Ge);
var DE = {
  onPlacesChanged: "places_changed"
}, LE = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class zP extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "containerElement", mr()), ae(this, "state", {
      searchBox: null
    }), ae(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Dn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = ot({
          updaterMap: LE,
          eventMap: DE,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: LE,
      eventMap: DE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), lt(this.registeredEvents));
  }
  render() {
    return j.jsx("div", {
      ref: this.containerElement,
      children: Ft.only(this.props.children)
    });
  }
}
ae(zP, "contextType", Ge);
var PE = {
  onPlaceChanged: "place_changed"
}, SE = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class $P extends Ee {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "containerElement", mr()), ae(this, "state", {
      autocomplete: null
    }), ae(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Dn(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = ot({
        updaterMap: SE,
        eventMap: PE,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    lt(this.registeredEvents), this.registeredEvents = ot({
      updaterMap: SE,
      eventMap: PE,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && lt(this.registeredEvents);
  }
  render() {
    return j.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: Ft.only(this.props.children)
    });
  }
}
ae($P, "defaultProps", {
  className: ""
});
ae($P, "contextType", Ge);
function jG({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ j.jsx(
    MP,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function _G(e) {
  const { children: t = !1 } = e, [n, r] = P([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((d) => d.key === u)) == null ? void 0 : c.data;
  }
  function s(u, c) {
    const d = o(u);
    r(d ? (p) => [...p.filter((f) => f.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function a(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ j.jsx(
    wg.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: s, closeModal: a, closeAll: l },
      children: t
    }
  );
}
let X7 = { data: "" }, K7 = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || X7, J7 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Q7 = /\/\*[^]*?\*\/|  +/g, kE = /\n+/g, mo = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? mo(s, i) : i + "{" + mo(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += mo(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += mo.p ? mo.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Nr = {}, UP = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + UP(e[n]);
    return t;
  }
  return e;
}, eq = (e, t, n, r, o) => {
  let i = UP(e), s = Nr[i] || (Nr[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Nr[s]) {
    let l = i !== e ? e : ((u) => {
      let c, d, p = [{}];
      for (; c = J7.exec(u.replace(Q7, "")); ) c[4] ? p.shift() : c[3] ? (d = c[3].replace(kE, " ").trim(), p.unshift(p[0][d] = p[0][d] || {})) : p[0][c[1]] = c[2].replace(kE, " ").trim();
      return p[0];
    })(e);
    Nr[s] = mo(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Nr.g ? Nr.g : null;
  return n && (Nr.g = Nr[s]), ((l, u, c, d) => {
    d ? u.data = u.data.replace(d, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Nr[s], t, r, a), s;
}, tq = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : mo(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Fc(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return eq(n.unshift ? n.raw ? tq(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, K7(t.target), t.g, t.o, t.k);
}
let WP, Cf, Ef;
Fc.bind({ g: 1 });
let qr = Fc.bind({ k: 1 });
function nq(e, t, n, r) {
  mo.p = t, WP = e, Cf = n, Ef = r;
}
function Mo(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: Cf && Cf() }, a), n.o = / *go\d+/.test(l), a.className = Fc.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Ef && u[0] && Ef(a), WP(u, a);
    }
    return o;
  };
}
var rq = (e) => typeof e == "function", Ou = (e, t) => rq(e) ? e(t) : e, oq = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), VP = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), iq = 20, Ol = /* @__PURE__ */ new Map(), sq = 1e3, ME = (e) => {
  if (Ol.has(e)) return;
  let t = setTimeout(() => {
    Ol.delete(e), li({ type: 4, toastId: e });
  }, sq);
  Ol.set(e, t);
}, aq = (e) => {
  let t = Ol.get(e);
  t && clearTimeout(t);
}, Of = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, iq) };
    case 1:
      return t.toast.id && aq(t.toast.id), { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return e.toasts.find((i) => i.id === n.id) ? Of(e, { type: 1, toast: n }) : Of(e, { type: 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return r ? ME(r) : e.toasts.forEach((i) => {
        ME(i.id);
      }), { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, xl = [], Dl = { toasts: [], pausedAt: void 0 }, li = (e) => {
  Dl = Of(Dl, e), xl.forEach((t) => {
    t(Dl);
  });
}, lq = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, uq = (e = {}) => {
  let [t, n] = P(Dl);
  y(() => (xl.push(n), () => {
    let o = xl.indexOf(n);
    o > -1 && xl.splice(o, 1);
  }), [t]);
  let r = t.toasts.map((o) => {
    var i, s;
    return { ...e, ...e[o.type], ...o, duration: o.duration || ((i = e[o.type]) == null ? void 0 : i.duration) || (e == null ? void 0 : e.duration) || lq[o.type], style: { ...e.style, ...(s = e[o.type]) == null ? void 0 : s.style, ...o.style } };
  });
  return { ...t, toasts: r };
}, cq = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || oq() }), fa = (e) => (t, n) => {
  let r = cq(t, e, n);
  return li({ type: 2, toast: r }), r.id;
}, or = (e, t) => fa("blank")(e, t);
or.error = fa("error");
or.success = fa("success");
or.loading = fa("loading");
or.custom = fa("custom");
or.dismiss = (e) => {
  li({ type: 3, toastId: e });
};
or.remove = (e) => li({ type: 4, toastId: e });
or.promise = (e, t, n) => {
  let r = or.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return e.then((o) => (or.success(Ou(t.success, o), { id: r, ...n, ...n == null ? void 0 : n.success }), o)).catch((o) => {
    or.error(Ou(t.error, o), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), e;
};
var dq = (e, t) => {
  li({ type: 1, toast: { id: e, height: t } });
}, pq = () => {
  li({ type: 5, time: Date.now() });
}, fq = (e) => {
  let { toasts: t, pausedAt: n } = uq(e);
  y(() => {
    if (n) return;
    let i = Date.now(), s = t.map((a) => {
      if (a.duration === 1 / 0) return;
      let l = (a.duration || 0) + a.pauseDuration - (i - a.createdAt);
      if (l < 0) {
        a.visible && or.dismiss(a.id);
        return;
      }
      return setTimeout(() => or.dismiss(a.id), l);
    });
    return () => {
      s.forEach((a) => a && clearTimeout(a));
    };
  }, [t, n]);
  let r = Lt(() => {
    n && li({ type: 6, time: Date.now() });
  }, [n]), o = Lt((i, s) => {
    let { reverseOrder: a = !1, gutter: l = 8, defaultPosition: u } = s || {}, c = t.filter((m) => (m.position || u) === (i.position || u) && m.height), d = c.findIndex((m) => m.id === i.id), p = c.filter((m, f) => f < d && m.visible).length;
    return c.filter((m) => m.visible).slice(...a ? [p + 1] : [0, p]).reduce((m, f) => m + (f.height || 0) + l, 0);
  }, [t]);
  return { toasts: t, handlers: { updateHeight: dq, startPause: pq, endPause: r, calculateOffset: o } };
}, hq = qr`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, gq = qr`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, mq = qr`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, vq = Mo("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${hq} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${gq} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${mq} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, yq = qr`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, bq = Mo("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${yq} 1s linear infinite;
`, wq = qr`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, Cq = qr`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, Eq = Mo("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${wq} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${Cq} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, Oq = Mo("div")`
  position: absolute;
`, xq = Mo("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, Dq = qr`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Lq = Mo("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${Dq} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, Pq = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ve.createElement(Lq, null, t) : t : n === "blank" ? null : Ve.createElement(xq, null, Ve.createElement(bq, { ...r }), n !== "loading" && Ve.createElement(Oq, null, n === "error" ? Ve.createElement(vq, { ...r }) : Ve.createElement(Eq, { ...r })));
}, Sq = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, kq = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, Mq = "0%{opacity:0;} 100%{opacity:1;}", Aq = "0%{opacity:1;} 100%{opacity:0;}", Tq = Mo("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, Bq = Mo("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, jq = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = VP() ? [Mq, Aq] : [Sq(n), kq(n)];
  return { animation: t ? `${qr(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${qr(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, _q = Ve.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? jq(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ve.createElement(Pq, { toast: e }), s = Ve.createElement(Bq, { ...e.ariaProps }, Ou(e.message, e));
  return Ve.createElement(Tq, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ve.createElement(Ve.Fragment, null, i, s));
});
nq(Ve.createElement);
var Iq = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = Ve.useCallback((s) => {
    if (s) {
      let a = () => {
        let l = s.getBoundingClientRect().height;
        r(e, l);
      };
      a(), new MutationObserver(a).observe(s, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return Ve.createElement("div", { ref: i, className: t, style: n }, o);
}, Fq = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: VP() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, Rq = Fc`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, hl = 16, Nq = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: s }) => {
  let { toasts: a, handlers: l } = fq(n);
  return Ve.createElement("div", { style: { position: "fixed", zIndex: 9999, top: hl, left: hl, right: hl, bottom: hl, pointerEvents: "none", ...i }, className: s, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, a.map((u) => {
    let c = u.position || t, d = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), p = Fq(c, d);
    return Ve.createElement(Iq, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? Rq : "", style: p }, u.type === "custom" ? Ou(u.message, u) : o ? o(u) : Ve.createElement(_q, { toast: u, position: c }));
  }));
}, AE = or;
function IG({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return AE.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return AE.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ j.jsxs(EP.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ j.jsx(
      Nq,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
function zq({ children: e, fallback: t = null }) {
  return uH() ? /* @__PURE__ */ j.jsx(j.Fragment, { children: e() }) : /* @__PURE__ */ j.jsx(j.Fragment, { children: t });
}
function FG({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ j.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ j.jsx(
    CH,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ j.jsx(AP, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ j.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ j.jsx(pS, {}) });
}
function RG({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = P(null), s = (l) => i(l), a = () => {
    var m, f, g, h;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function d(C) {
      const w = c.find((k) => k.types[0] === C);
      return w ? w.long_name : "";
    }
    function p(C) {
      const w = c.find((k) => k.types[0] === C);
      return w ? w.short_name : "";
    }
    if (u) {
      const C = d("route"), w = d("street_number"), k = d("sublocality_level_1"), E = d("administrative_area_level_2"), v = d("administrative_area_level_1"), O = p("administrative_area_level_1"), L = d("postal_code"), W = (f = (m = u.geometry) == null ? void 0 : m.location) == null ? void 0 : f.lat(), D = (h = (g = u.geometry) == null ? void 0 : g.location) == null ? void 0 : h.lng();
      t && t({
        street: C,
        city: E,
        state: v,
        district: k,
        cep: L,
        streetNumber: w,
        stateShortName: O,
        coordinates: { lat: W, lng: D }
      });
    }
  };
  return /* @__PURE__ */ j.jsx(
    zP,
    {
      onLoad: s,
      onPlacesChanged: a,
      options: n,
      children: /* @__PURE__ */ j.jsx(Lc, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function HP(e) {
  const { dataLayer: t, dataLayerName: n } = e;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(t)})`;
}
function $q(e) {
  const { id: t, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: s } = e, a = `&gtm_auth=${s}`, l = `&gtm_preview=${i}`;
  t || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${t}${a}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${a}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${t}');`, d = HP({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: d
  };
}
let Uq = class {
  initializeDataScript(t) {
    const n = document.createElement("script");
    return n.innerHTML = t, n;
  }
  initializeGTMElements(t) {
    const n = $q(t), r = () => {
      const s = document.createElement("noscript");
      return s.innerHTML = n.iframe, s;
    }, o = () => {
      const s = document.createElement("script");
      return s.innerHTML = n.script, s;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(t) {
    const { dataLayer: n, dataLayerName: r } = t;
    if (window[r]) return window[r].push(n);
    const o = HP({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(t) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: s = "",
      dataLayerName: a = "dataLayer"
    } = t, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: a,
      auth: i,
      preview: s
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function Wq(e) {
  return new Uq().initialize(e), /* @__PURE__ */ j.jsx(j.Fragment, {});
}
function zG(e) {
  const {
    gtmId: t,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: s = {}
  } = e;
  return /* @__PURE__ */ j.jsx(zq, { children: () => /* @__PURE__ */ j.jsx(
    Wq,
    {
      auth: n,
      dataLayer: s,
      dataLayerName: o,
      events: i,
      gtmId: t,
      preview: r
    }
  ) });
}
export {
  Xq as AlertContainer,
  Kq as AlertContent,
  Jq as AlertDescription,
  Qq as AlertIcon,
  vS as AlertTitle,
  pG as AudioUpload,
  rG as Badge,
  EG as BreadcrumbContainer,
  OG as BreadcrumbLink,
  du as Button,
  oG as Card,
  fG as Checkbox,
  zq as ClientOnly,
  iG as Divider,
  DG as DrawerContainer,
  LG as DrawerHeader,
  TG as DrawerProvider,
  qw as FormController,
  hG as FormError,
  Gw as FormLabel,
  FG as GoogleMap,
  jG as GoogleProvider,
  RG as GoogleSearchPlaces,
  zG as GoogleTagManager,
  eW as IconButton,
  sW as ImageUpload,
  Lc as Input,
  H6 as ModalContainer,
  q6 as ModalFooter,
  G6 as ModalHeader,
  _G as ModalProvider,
  gG as MultiSelect,
  xG as Pagination,
  PG as Popover,
  vG as RadioBox,
  mG as RadioGroup,
  yG as RichText,
  bG as Select,
  sG as Skeleton,
  K9 as Slider,
  wG as Switch,
  BC as TabButton,
  Y6 as TabContainer,
  aG as TableBody,
  lG as TableCaption,
  uG as TableContainer,
  cG as TableFooter,
  dG as TableHeader,
  CG as Textarea,
  SG as Toast,
  IG as ToastProvider,
  tW as Tooltip,
  eG as getHtmlFromRichTextValue,
  tG as getRichTextValueFromHtml,
  nG as isHtml,
  wO as morpheme,
  kG as useAutomation,
  MG as useDrawer,
  sL as useFieldErrors,
  Jn as useFormController,
  uH as useHydrated,
  AG as useModal,
  QL as useScopedParams,
  aH as useToast
};
