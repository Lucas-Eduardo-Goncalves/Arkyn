import * as Re from "react";
import Ce, { createContext as Ye, useContext as ge, Children as lt, forwardRef as ga, memo as ve, useState as P, useRef as dt, useEffect as h, useMemo as On, isValidElement as mi, cloneElement as vi, Component as $u, PureComponent as pe, createRef as ir, useId as YX, useCallback as Rn, useReducer as XX, useLayoutEffect as JX, useSyncExternalStore as QX } from "react";
import { Info as f9, AlertTriangle as eJ, XCircle as h9, CheckCircle2 as g9, Loader2 as js, Pause as tJ, Play as nJ, RefreshCw as m9, Check as fL, ChevronDown as v9, X as hL, Search as y9, Image as rJ, Heading1 as oJ, Heading2 as iJ, Quote as sJ, Bold as aJ, Italic as lJ, Underline as uJ, Code as cJ, AlignLeft as pJ, AlignRight as dJ, AlignCenter as fJ, AlignJustify as hJ, ChevronRight as BO, ChevronLeft as gJ, Ellipsis as xM, MapPinned as mJ } from "lucide-react";
import { useActionData as gL, useNavigation as b9, useFetchers as w9, useLocation as mL, Link as vJ, useNavigate as C9 } from "@remix-run/react";
import { InputMask as yJ } from "@react-input/mask";
import * as yi from "react-dom";
import pl, { createPortal as sr } from "react-dom";
import { AnimatePresence as O9, motion as ad } from "framer-motion";
var Jn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function My(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var NO = { exports: {} }, Tc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var EM;
function bJ() {
  if (EM) return Tc;
  EM = 1;
  var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return Tc.Fragment = n, Tc.jsx = a, Tc.jsxs = a, Tc;
}
var Ac = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var LM;
function wJ() {
  return LM || (LM = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[v];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, K = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          K[ne - 1] = arguments[ne];
        D("error", b, K);
      }
    }
    function D(b, I, K) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (I += "%s", K = K.concat([ae]));
        var ce = K.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function R(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || z || b === o || b === u || b === c || S || b === y || x || m || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function B(b, I, K) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var ae = I.displayName || I.name || "";
      return ae !== "" ? K + "(" + ae + ")" : K;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return H(I) + ".Consumer";
          case a:
            var K = b;
            return H(K._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var ae = b, ce = ae._payload, se = ae._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, q = 0, Y, X, ee, J, k, _, U;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function $() {
      {
        if (q === 0) {
          Y = console.log, X = console.info, ee = console.warn, J = console.error, k = console.group, _ = console.groupCollapsed, U = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, b, {
              value: Y
            }),
            info: W({}, b, {
              value: X
            }),
            warn: W({}, b, {
              value: ee
            }),
            error: W({}, b, {
              value: J
            }),
            group: W({}, b, {
              value: k
            }),
            groupCollapsed: W({}, b, {
              value: _
            }),
            groupEnd: W({}, b, {
              value: U
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, F;
    function T(b, I, K) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            F = ne && ne[1] || "";
          }
        return `
` + F + b;
      }
    }
    var Z = !1, A;
    {
      var G = typeof WeakMap == "function" ? WeakMap : Map;
      A = new G();
    }
    function N(b, I) {
      if (!b || Z)
        return "";
      {
        var K = A.get(b);
        if (K !== void 0)
          return K;
      }
      var ne;
      Z = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Te) {
              ne = Te;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (Te) {
              ne = Te;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Te) {
            ne = Te;
          }
          b();
        }
      } catch (Te) {
        if (Te && ne && typeof Te.stack == "string") {
          for (var ie = Te.stack.split(`
`), De = ne.stack.split(`
`), de = ie.length - 1, he = De.length - 1; de >= 1 && he >= 0 && ie[de] !== De[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== De[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== De[he]) {
                    var Ze = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ze.includes("<anonymous>") && (Ze = Ze.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ze), Ze;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        Z = !1, j.current = ce, O(), Error.prepareStackTrace = ae;
      }
      var Ot = b ? b.displayName || b.name : "", gt = Ot ? T(Ot) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, I, K) {
      return N(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, K) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, K);
          case d: {
            var ne = b, ae = ne._payload, ce = ne._init;
            try {
              return oe(ce(ae), I, K);
            } catch {
            }
          }
        }
      return "";
    }
    var Ie = Object.prototype.hasOwnProperty, qe = {}, Ge = E.ReactDebugCurrentFrame;
    function Be(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(K);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, K, ne, ae) {
      {
        var ce = Function.call.bind(Ie);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var De = Error((ne || "React class") + ": " + K + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              ie = b[se](I, se, ne, K, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Be(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", K, se, typeof ie), Be(null)), ie instanceof Error && !(ie.message in qe) && (qe[ie.message] = !0, Be(ae), w("Failed %s type: %s", K, ie.message), Be(null));
          }
      }
    }
    var Xe = Array.isArray;
    function Me(b) {
      return Xe(b);
    }
    function Je(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, K = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return K;
      }
    }
    function at(b) {
      try {
        return Se(b), !1;
      } catch {
        return !0;
      }
    }
    function Se(b) {
      return "" + b;
    }
    function _e(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Je(b)), Se(b);
    }
    var Ae = E.ReactCurrentOwner, Ve = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ne, nt, we;
    we = {};
    function mt(b) {
      if (Ie.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function ot(b) {
      if (Ie.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function st(b, I) {
      if (typeof b.ref == "string" && Ae.current && I && Ae.current.stateNode !== I) {
        var K = V(Ae.current.type);
        we[K] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Ae.current.type), b.ref), we[K] = !0);
      }
    }
    function ut(b, I) {
      {
        var K = function() {
          Ne || (Ne = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: K,
          configurable: !0
        });
      }
    }
    function vt(b, I) {
      {
        var K = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: K,
          configurable: !0
        });
      }
    }
    var ct = function(b, I, K, ne, ae, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: K,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function yt(b, I, K, ne, ae) {
      {
        var ce, se = {}, ie = null, De = null;
        K !== void 0 && (_e(K), ie = "" + K), ot(I) && (_e(I.key), ie = "" + I.key), mt(I) && (De = I.ref, st(I, ae));
        for (ce in I)
          Ie.call(I, ce) && !Ve.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || De) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && ut(se, he), De && vt(se, he);
        }
        return ct(b, ie, De, ae, ne, Ae.current, se);
      }
    }
    var Qe = E.ReactCurrentOwner, ft = E.ReactDebugCurrentFrame;
    function tt(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        ft.setExtraStackFrame(K);
      } else
        ft.setExtraStackFrame(null);
    }
    var bt;
    bt = !1;
    function pt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Dt() {
      {
        if (Qe.current) {
          var b = V(Qe.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function wt(b) {
      return "";
    }
    var _t = {};
    function Ct(b) {
      {
        var I = Dt();
        if (!I) {
          var K = typeof b == "string" ? b : b.displayName || b.name;
          K && (I = `

Check the top-level render call using <` + K + ">.");
        }
        return I;
      }
    }
    function jt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var K = Ct(I);
        if (_t[K])
          return;
        _t[K] = !0;
        var ne = "";
        b && b._owner && b._owner !== Qe.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), tt(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', K, ne), tt(null);
      }
    }
    function Cn(b, I) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var K = 0; K < b.length; K++) {
            var ne = b[K];
            pt(ne) && jt(ne, I);
          }
        else if (pt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ae = g(b);
          if (typeof ae == "function" && ae !== b.entries)
            for (var ce = ae.call(b), se; !(se = ce.next()).done; )
              pt(se.value) && jt(se.value, I);
        }
      }
    }
    function ht(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var K;
        if (typeof I == "function")
          K = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          K = I.propTypes;
        else
          return;
        if (K) {
          var ne = V(I);
          et(K, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !bt) {
          bt = !0;
          var ae = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function re(b) {
      {
        for (var I = Object.keys(b.props), K = 0; K < I.length; K++) {
          var ne = I[K];
          if (ne !== "children" && ne !== "key") {
            tt(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), tt(null);
            break;
          }
        }
        b.ref !== null && (tt(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var mo = {};
    function vo(b, I, K, ne, ae, ce) {
      {
        var se = R(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = wt();
          De ? ie += De : ie += Dt();
          var de;
          b === null ? de = "null" : Me(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = yt(b, I, K, ae, ce);
        if (he == null)
          return he;
        if (se) {
          var Ze = I.children;
          if (Ze !== void 0)
            if (ne)
              if (Me(Ze)) {
                for (var Ot = 0; Ot < Ze.length; Ot++)
                  Cn(Ze[Ot], b);
                Object.freeze && Object.freeze(Ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Cn(Ze, b);
        }
        if (Ie.call(I, "key")) {
          var gt = V(b), Te = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), ar = Te.length > 0 ? "{key: someKey, " + Te.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!mo[gt + ar]) {
            var Ei = Te.length > 0 ? "{" + Te.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ar, gt, Ei, gt), mo[gt + ar] = !0;
          }
        }
        return b === r ? re(he) : ht(he), he;
      }
    }
    function wi(b, I, K) {
      return vo(b, I, K, !0);
    }
    function Ci(b, I, K) {
      return vo(b, I, K, !1);
    }
    var Oi = Ci, xi = wi;
    Ac.Fragment = r, Ac.jsx = Oi, Ac.jsxs = xi;
  }()), Ac;
}
process.env.NODE_ENV === "production" ? NO.exports = bJ() : NO.exports = wJ();
var te = NO.exports;
function CJ(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ te.jsx("div", { className: r.trim(), ...n });
}
const x9 = Ye({});
function OJ() {
  return ge(x9);
}
function I8e(e) {
  const { schema: t, children: n, className: r, ...o } = e, s = !((u) => {
    let c = !1;
    const p = (d) => {
      Array.isArray(d) ? d.forEach(p) : d && typeof d == "object" && "type" in d && (d.type === CJ ? c = !0 : d.props && d.props.children && p(d.props.children));
    };
    return p(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${s} ${r}`;
  return /* @__PURE__ */ te.jsx(x9.Provider, { value: e, children: /* @__PURE__ */ te.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function B8e(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ te.jsx("div", { className: r.trim(), ...n });
}
function N8e(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ te.jsx("div", { className: r.trim(), ...n });
}
function R8e(e) {
  const { className: t, ...n } = e, { schema: r } = OJ(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ te.jsx(g9, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ te.jsx(h9, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ te.jsx(eJ, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ te.jsx(f9, { className: o, ...n });
  }
}
function Cm(e, t) {
  return t ? /* @__PURE__ */ te.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ te.jsx(te.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function PM(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function To(e) {
  var t, n;
  return PM(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(PM(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var E9 = Symbol.for("immer-nothing"), kM = Symbol.for("immer-draftable"), zi = Symbol.for("immer-state"), xJ = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Xo(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = xJ[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var rc = Object.getPrototypeOf;
function Ou(e) {
  return !!e && !!e[zi];
}
function xu(e) {
  var t;
  return e ? L9(e) || Array.isArray(e) || !!e[kM] || !!((t = e.constructor) != null && t[kM]) || _y(e) || jy(e) : !1;
}
var EJ = Object.prototype.constructor.toString();
function L9(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = rc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === EJ;
}
function Om(e, t) {
  Dy(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Dy(e) {
  const t = e[zi];
  return t ? t.type_ : Array.isArray(e) ? 1 : _y(e) ? 2 : jy(e) ? 3 : 0;
}
function RO(e, t) {
  return Dy(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function P9(e, t, n) {
  const r = Dy(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function LJ(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function _y(e) {
  return e instanceof Map;
}
function jy(e) {
  return e instanceof Set;
}
function Gl(e) {
  return e.copy_ || e.base_;
}
function FO(e, t) {
  if (_y(e))
    return new Map(e);
  if (jy(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = L9(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[zi];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(rc(e), r);
  } else {
    const r = rc(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function vL(e, t = !1) {
  return Ty(e) || Ou(e) || !xu(e) || (Dy(e) > 1 && (e.set = e.add = e.clear = e.delete = PJ), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => vL(r, !0))), e;
}
function PJ() {
  Xo(2);
}
function Ty(e) {
  return Object.isFrozen(e);
}
var kJ = {};
function Eu(e) {
  const t = kJ[e];
  return t || Xo(0, e), t;
}
var ld;
function k9() {
  return ld;
}
function SJ(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function SM(e, t) {
  t && (Eu("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function zO(e) {
  UO(e), e.drafts_.forEach(MJ), e.drafts_ = null;
}
function UO(e) {
  e === ld && (ld = e.parent_);
}
function MM(e) {
  return ld = SJ(ld, e);
}
function MJ(e) {
  const t = e[zi];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function DM(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[zi].modified_ && (zO(t), Xo(4)), xu(e) && (e = xm(t, e), t.parent_ || Em(t, e)), t.patches_ && Eu("Patches").generateReplacementPatches_(
    n[zi].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = xm(t, n, []), zO(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== E9 ? e : void 0;
}
function xm(e, t, n) {
  if (Ty(t))
    return t;
  const r = t[zi];
  if (!r)
    return Om(
      t,
      (o, i) => _M(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Em(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Om(
      i,
      (s, l) => _M(e, r, o, s, l, n, a)
    ), Em(e, o, !1), n && e.patches_ && Eu("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function _M(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Xo(5), Ou(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !RO(t.assigned_, r) ? i.concat(r) : void 0, l = xm(e, o, s);
    if (P9(n, r, l), Ou(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (xu(o) && !Ty(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    xm(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Em(e, o);
  }
}
function Em(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && vL(t, n);
}
function DJ(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : k9(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = yL;
  n && (o = [r], i = ud);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var yL = {
  get(e, t) {
    if (t === zi)
      return e;
    const n = Gl(e);
    if (!RO(n, t))
      return _J(e, n, t);
    const r = n[t];
    return e.finalized_ || !xu(r) ? r : r === yw(e.base_, t) ? (bw(e), e.copy_[t] = $O(r, e)) : r;
  },
  has(e, t) {
    return t in Gl(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Gl(e));
  },
  set(e, t, n) {
    const r = S9(Gl(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = yw(Gl(e), t), i = o == null ? void 0 : o[zi];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (LJ(n, o) && (n !== void 0 || RO(e.base_, t)))
        return !0;
      bw(e), WO(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return yw(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, bw(e), WO(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Gl(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Xo(11);
  },
  getPrototypeOf(e) {
    return rc(e.base_);
  },
  setPrototypeOf() {
    Xo(12);
  }
}, ud = {};
Om(yL, (e, t) => {
  ud[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
ud.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Xo(13), ud.set.call(this, e, t, void 0);
};
ud.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Xo(14), yL.set.call(this, e[0], t, n, e[0]);
};
function yw(e, t) {
  const n = e[zi];
  return (n ? Gl(n) : e)[t];
}
function _J(e, t, n) {
  var o;
  const r = S9(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function S9(e, t) {
  if (!(t in e))
    return;
  let n = rc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = rc(n);
  }
}
function WO(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && WO(e.parent_));
}
function bw(e) {
  e.copy_ || (e.copy_ = FO(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var jJ = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(l = i, ...u) {
          return a.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && Xo(6), r !== void 0 && typeof r != "function" && Xo(7);
      let o;
      if (xu(t)) {
        const i = MM(this), a = $O(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? zO(i) : UO(i);
        }
        return SM(i, r), DM(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === E9 && (o = void 0), this.autoFreeze_ && vL(o, !0), r) {
          const i = [], a = [];
          Eu("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Xo(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (a, ...s) => this.produceWithPatches(a, (l) => t(l, ...s));
      let r, o;
      return [this.produce(t, n, (a, s) => {
        r = a, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    xu(e) || Xo(8), Ou(e) && (e = TJ(e));
    const t = MM(this), n = $O(e, void 0);
    return n[zi].isManual_ = !0, UO(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[zi];
    (!n || !n.isManual_) && Xo(9);
    const { scope_: r } = n;
    return SM(r, t), DM(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Eu("Patches").applyPatches_;
    return Ou(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function $O(e, t) {
  const n = _y(e) ? Eu("MapSet").proxyMap_(e, t) : jy(e) ? Eu("MapSet").proxySet_(e, t) : DJ(e, t);
  return (t ? t.scope_ : k9()).drafts_.push(n), n;
}
function TJ(e) {
  return Ou(e) || Xo(10, e), M9(e);
}
function M9(e) {
  if (!xu(e) || Ty(e))
    return e;
  const t = e[zi];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = FO(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = FO(e, !0);
  return Om(n, (r, o) => {
    P9(n, r, M9(o));
  }), t && (t.finalized_ = !1), n;
}
var Ui = new jJ(), bL = Ui.produce;
Ui.produceWithPatches.bind(
  Ui
);
Ui.setAutoFreeze.bind(Ui);
Ui.setUseStrictShallowCopy.bind(Ui);
Ui.applyPatches.bind(Ui);
var jM = Ui.createDraft.bind(Ui), TM = Ui.finishDraft.bind(Ui), AJ = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = le.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, IJ = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = zt.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, BJ = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = me.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Lm = /* @__PURE__ */ new WeakMap(), Pm = /* @__PURE__ */ new WeakMap(), Dp = /* @__PURE__ */ new WeakMap(), D9 = /* @__PURE__ */ new WeakMap(), AM = /* @__PURE__ */ new WeakMap(), IM = /* @__PURE__ */ new WeakMap(), BM = /* @__PURE__ */ new WeakMap(), le = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = le.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return le.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return le.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return le.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return le.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && le.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return le.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && le.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && le.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && le.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && le.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && le.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!le.isAncestor(t, e) && !le.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (le.equals(i, r) || le.endsBefore(i, r) || le.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (le.equals(a, r) || le.isAncestor(a, r))
          return null;
        le.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        le.equals(s, r) || le.endsBefore(s, r) ? r[s.length - 1] -= 1 : le.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (le.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else le.endsBefore(u, r) ? r[u.length - 1] += 1 : le.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (le.equals(p, d))
          return r;
        if (le.isAncestor(p, r) || le.equals(p, r)) {
          var y = d.slice();
          return le.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else le.isSibling(p, d) && (le.isAncestor(d, r) || le.equals(d, r)) ? le.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : le.endsBefore(d, r) || le.equals(d, r) || le.isAncestor(d, r) ? (le.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : le.endsBefore(p, r) && (le.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function cd(e) {
  "@babel/helpers - typeof";
  return cd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, cd(e);
}
function NJ(e, t) {
  if (cd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (cd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function RJ(e) {
  var t = NJ(e, "string");
  return cd(t) === "symbol" ? t : String(t);
}
function Wo(e, t, n) {
  return t = RJ(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function NM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ic(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NM(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FJ = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Ke.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of me.points(t))
          t[l] = zt.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Ke.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, g] of me.points(t))
          t[g] = zt.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Ke.get(e, E), D = le.previous(E), x = Ke.get(e, D), m = Ke.parent(e, E), C = E[E.length - 1];
      if (it.isText(w) && it.isText(x))
        x.text += w.text;
      else if (!it.isText(w) && !it.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Lo.stringify(w), " ").concat(Lo.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, z] of me.points(t))
          t[z] = zt.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: R
      } = n;
      if (le.isAncestor(L, R))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(R, "] because the destination is inside itself."));
      var B = Ke.get(e, L), H = Ke.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var W = le.transform(L, n), q = Ke.get(e, le.parent(W)), Y = W[W.length - 1];
      if (q.children.splice(Y, 0, B), t)
        for (var [X, ee] of me.points(t))
          t[ee] = zt.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, k = J[J.length - 1], _ = Ke.parent(e, J);
      if (_.children.splice(k, 1), t)
        for (var [U, M] of me.points(t)) {
          var $ = zt.transform(U, n);
          if (t != null && $ != null)
            t[M] = $;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of Ke.texts(e))
              if (le.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var Z = !1;
            O && j && (le.equals(j[1], J) ? Z = !le.hasPrevious(j[1]) : Z = le.common(O[1], J).length < le.common(j[1], J).length), O && !Z ? (U.path = O[1], U.offset = O[0].text.length) : j ? (U.path = j[1], U.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: G,
        text: N
      } = n;
      if (N.length === 0) break;
      var ue = Ke.leaf(e, A), fe = ue.text.slice(0, G), oe = ue.text.slice(G + N.length);
      if (ue.text = fe + oe, t)
        for (var [Ie, qe] of me.points(t))
          t[qe] = zt.transform(Ie, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Be,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Xe = Ke.get(e, Ge);
      for (var Me in et) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Je = et[Me];
        Je == null ? delete Xe[Me] : Xe[Me] = Je;
      }
      for (var at in Be)
        et.hasOwnProperty(at) || delete Xe[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Se
      } = n;
      if (Se == null)
        t = Se;
      else {
        if (t == null) {
          if (!me.isRange(Se))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Lo.stringify(Se), " when there is no current selection."));
          t = Ic({}, Se);
        }
        for (var _e in Se) {
          var Ae = Se[_e];
          if (Ae == null) {
            if (_e === "anchor" || _e === "focus")
              throw new Error('Cannot remove the "'.concat(_e, '" selection property'));
            delete t[_e];
          } else
            t[_e] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ve,
        position: Ne,
        properties: nt
      } = n;
      if (Ve.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ve, "] because the root node cannot be split."));
      var we = Ke.get(e, Ve), mt = Ke.parent(e, Ve), ot = Ve[Ve.length - 1], st;
      if (it.isText(we)) {
        var ut = we.text.slice(0, Ne), vt = we.text.slice(Ne);
        we.text = ut, st = Ic(Ic({}, nt), {}, {
          text: vt
        });
      } else {
        var ct = we.children.slice(0, Ne), yt = we.children.slice(Ne);
        we.children = ct, st = Ic(Ic({}, nt), {}, {
          children: yt
        });
      }
      if (mt.children.splice(ot + 1, 0, st), t)
        for (var [Qe, ft] of me.points(t))
          t[ft] = zt.transform(Qe, n);
      break;
    }
  }
  return t;
}, zJ = {
  transform(e, t) {
    e.children = jM(e.children);
    var n = e.selection && jM(e.selection);
    try {
      n = FJ(e, n, t);
    } finally {
      e.children = TM(e.children), n ? e.selection = Ou(n) ? TM(n) : n : e.selection = null;
    }
  }
}, UJ = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, WJ = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, _9 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (To(r) && To(o)) {
      if (!_9(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function $J(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function aa(e, t) {
  if (e == null) return {};
  var n = $J(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var HJ = ["anchor", "focus"];
function RM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function VJ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RM(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var me = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return me.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = me.edges(e);
    return t;
  },
  equals(e, t) {
    return zt.equals(e.anchor, t.anchor) && zt.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (me.isRange(t)) {
      if (me.includes(e, t.anchor) || me.includes(e, t.focus))
        return !0;
      var [n, r] = me.edges(e), [o, i] = me.edges(t);
      return zt.isBefore(n, o) && zt.isAfter(r, i);
    }
    var [a, s] = me.edges(e), l = !1, u = !1;
    return zt.isPoint(t) ? (l = zt.compare(t, a) >= 0, u = zt.compare(t, s) <= 0) : (l = le.compare(t, a.path) >= 0, u = le.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = aa(e, HJ), [r, o] = me.edges(e), [i, a] = me.edges(t), s = zt.isBefore(r, i) ? i : r, l = zt.isBefore(o, a) ? o : a;
    return zt.isBefore(l, s) ? null : VJ({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return zt.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return zt.equals(t, n);
  },
  isExpanded(e) {
    return !me.isCollapsed(e);
  },
  isForward(e) {
    return !me.isBackward(e);
  },
  isRange(e) {
    return To(e) && zt.isPoint(e.anchor) && zt.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = me.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return bL(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = me.isCollapsed(r);
        me.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? me.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = zt.transform(r.anchor, t, {
        affinity: i
      }), u = zt.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, FM = (e) => To(e) && Ke.isNodeList(e.children) && !Q.isEditor(e), rt = {
  isAncestor(e) {
    return To(e) && Ke.isNodeList(e.children);
  },
  isElement: FM,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => rt.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return FM(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, ZJ = ["children"], qJ = ["text"], zM = /* @__PURE__ */ new WeakMap(), Ke = {
  ancestor(e, t) {
    var n = Ke.get(e, t);
    if (it.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Lo.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of le.ancestors(t, n)) {
        var o = Ke.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (it.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Lo.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Lo.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Ke.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Ke.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = le.common(t, n), o = Ke.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Ke.get(e, t);
    if (Q.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Lo.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ke.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ke.nodes(e, t))
        rt.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (rt.isAncestor(e)) {
      var t = aa(e, ZJ);
      return t;
    } else {
      var t = aa(e, qJ);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Ke.get(e, n); r && !(it.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (it.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Lo.stringify(e)));
    var n = bL({
      children: e.children
    }, (r) => {
      var [o, i] = me.edges(t), a = Ke.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !me.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!me.includes(t, s)) {
          var l = Ke.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (le.equals(s, i.path)) {
          var c = Ke.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (le.equals(s, o.path)) {
          var p = Ke.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Q.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (it.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Lo.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (it.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return it.isText(e) || rt.isElement(e) || Q.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = zM.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Ke.isNode(r));
    return zM.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Ke.get(e, n); r && !(it.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Ke.get(e, t);
    if (!it.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Lo.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of le.levels(t, n)) {
        var o = Ke.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return rt.isElement(e) && rt.isElementProps(t) && rt.matches(e, t) || it.isText(e) && it.isTextProps(t) && it.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? le.isBefore(s, i) : le.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !it.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          le.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Ke.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = le.next(s);
          if (Ke.has(e, c)) {
            s = c, l = Ke.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = le.previous(s);
          s = p, l = Ke.get(e, s);
          continue;
        }
        s = le.parent(s), l = Ke.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = le.parent(t), r = Ke.get(e, n);
    if (it.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return it.isText(e) ? e.text : e.children.map(Ke.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ke.nodes(e, t))
        it.isText(n) && (yield [n, r]);
    }();
  }
};
function UM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UM(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var al = {
  isNodeOperation(e) {
    return al.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!To(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return le.isPath(e.path) && Ke.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && le.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && le.isPath(e.path) && To(e.properties);
      case "move_node":
        return le.isPath(e.path) && le.isPath(e.newPath);
      case "remove_node":
        return le.isPath(e.path) && Ke.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && le.isPath(e.path);
      case "set_node":
        return le.isPath(e.path) && To(e.properties) && To(e.newProperties);
      case "set_selection":
        return e.properties === null && me.isRange(e.newProperties) || e.newProperties === null && me.isRange(e.properties) || To(e.properties) && To(e.newProperties);
      case "split_node":
        return le.isPath(e.path) && typeof e.position == "number" && To(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => al.isOperation(t));
  },
  isSelectionOperation(e) {
    return al.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return al.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return wr(wr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return wr(wr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return wr(wr({}, e), {}, {
          type: "split_node",
          path: le.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (le.equals(t, n))
          return e;
        if (le.isSibling(n, t))
          return wr(wr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = le.transform(n, e), o = le.transform(le.next(n), e);
        return wr(wr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return wr(wr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return wr(wr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return wr(wr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? wr(wr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? wr(wr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : wr(wr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return wr(wr({}, e), {}, {
          type: "merge_node",
          path: le.next(e.path)
        });
    }
  }
}, WM = /* @__PURE__ */ new WeakMap(), KJ = (e) => {
  var t = WM.get(e);
  if (t !== void 0)
    return t;
  if (!To(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || To(e.marks)) && (e.selection === null || me.isRange(e.selection)) && Ke.isNodeList(e.children) && al.isOperationList(e.operations);
  return WM.set(e, n), n;
}, Q = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return KJ(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, GJ = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(le.isPath);
  }
};
function $M(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $M(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $M(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zt = {
  compare(e, t) {
    var n = le.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return zt.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return zt.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && le.equals(e.path, t.path);
  },
  isPoint(e) {
    return To(e) && typeof e.offset == "number" && le.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return bL(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = le.transform(i, t, n);
          break;
        }
        case "insert_text": {
          le.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          le.equals(t.path, i) && (r.offset += t.position), r.path = le.transform(i, t, n);
          break;
        }
        case "remove_text": {
          le.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (le.equals(t.path, i) || le.isAncestor(t.path, i))
            return null;
          r.path = le.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (le.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = le.transform(i, t, HM(HM({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = le.transform(i, t, n);
          break;
        }
      }
    });
  }
}, VM = void 0, Lo = {
  setScrubber(e) {
    VM = e;
  },
  stringify(e) {
    return JSON.stringify(e, VM);
  }
}, YJ = ["text"], XJ = ["anchor", "focus"];
function ZM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZM(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var it = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = aa(i, YJ);
      return a;
    }
    return _9(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return To(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => it.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [zs({}, e)];
    for (var r of t) {
      var o = aa(r, XJ), [i, a] = me.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, g = void 0;
        if (c < l) {
          var E = c - y;
          g = zs(zs({}, f), {}, {
            text: f.text.slice(E)
          }), f = zs(zs({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > y) {
          var w = u - y;
          v = zs(zs({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = zs(zs({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, wL = (e) => e.selection ? e.selection : e.children.length > 0 ? Q.end(e, []) : [0], dc = (e, t) => {
  var [n] = Q.node(e, t);
  return (r) => r === n;
}, CL = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? rQ(t) : t, i = xt.None, a = xt.None, s = 0, l = null, u = null;
  for (var c of o) {
    var p = c.codePointAt(0);
    if (!p) break;
    var d = gQ(c, p);
    if ([i, a] = r ? [a, d] : [d, i], Zu(i, xt.ZWJ) && Zu(a, xt.ExtPict) && (r ? l = qM(t.substring(0, s)) : l = qM(t.substring(0, t.length - s)), !l) || Zu(i, xt.RI) && Zu(a, xt.RI) && (u !== null ? u = !u : r ? u = !0 : u = wQ(t.substring(0, t.length - s)), !u) || i !== xt.None && a !== xt.None && vQ(i, a))
      break;
    s += c.length;
  }
  return s || 1;
}, JJ = /\s/, QJ = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, eQ = /['\u2018\u2019]/, tQ = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = CL(t, n), [a, s] = OL(t, i, n);
    if (nQ(a, s, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = s;
  }
  return r;
}, OL = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, nQ = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (JJ.test(t))
    return !1;
  if (eQ.test(t)) {
    var o = CL(n, r), [i, a] = OL(n, o, r);
    if (e(i, a, r))
      return !0;
  }
  return !QJ.test(t);
}, rQ = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (iQ(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (oQ(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, oQ = (e) => e >= 55296 && e <= 56319, iQ = (e) => e >= 56320 && e <= 57343, xt;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(xt || (xt = {}));
var sQ = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, aQ = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, lQ = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, uQ = /^[\u1100-\u115F\uA960-\uA97C]$/, cQ = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, pQ = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, dQ = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, fQ = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, hQ = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, gQ = (e, t) => {
  var n = xt.Any;
  return e.search(sQ) !== -1 && (n |= xt.Extend), t === 8205 && (n |= xt.ZWJ), t >= 127462 && t <= 127487 && (n |= xt.RI), e.search(aQ) !== -1 && (n |= xt.Prepend), e.search(lQ) !== -1 && (n |= xt.SpacingMark), e.search(uQ) !== -1 && (n |= xt.L), e.search(cQ) !== -1 && (n |= xt.V), e.search(pQ) !== -1 && (n |= xt.T), e.search(dQ) !== -1 && (n |= xt.LV), e.search(fQ) !== -1 && (n |= xt.LVT), e.search(hQ) !== -1 && (n |= xt.ExtPict), n;
};
function Zu(e, t) {
  return (e & t) !== 0;
}
var mQ = [
  // GB6
  [xt.L, xt.L | xt.V | xt.LV | xt.LVT],
  // GB7
  [xt.LV | xt.V, xt.V | xt.T],
  // GB8
  [xt.LVT | xt.T, xt.T],
  // GB9
  [xt.Any, xt.Extend | xt.ZWJ],
  // GB9a
  [xt.Any, xt.SpacingMark],
  // GB9b
  [xt.Prepend, xt.Any],
  // GB11
  [xt.ZWJ, xt.ExtPict],
  // GB12 and GB13
  [xt.RI, xt.RI]
];
function vQ(e, t) {
  return mQ.findIndex((n) => Zu(e, n[0]) && Zu(t, n[1])) === -1;
}
var yQ = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, qM = (e) => e.search(yQ) !== -1, bQ = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, wQ = (e) => {
  var t = e.match(bQ);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, CQ = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Q.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = wL(e)
      } = n;
      if (le.isPath(o) && (o = Q.range(e, o)), me.isRange(o))
        if (me.isCollapsed(o))
          o = o.anchor;
        else {
          var i = me.end(o);
          if (!r && Q.void(e, {
            at: i
          }))
            return;
          var a = me.start(o), s = Q.pointRef(e, a), l = Q.pointRef(e, i);
          je.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, je.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Q.void(e, {
        at: o
      }) || Q.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function KM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gf(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KM(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var je = Gf(Gf(Gf(Gf({}, zJ), UJ), WJ), CQ), sm = /* @__PURE__ */ new WeakMap(), OQ = (e) => sm.get(e) || !1, xQ = (e, t, n) => {
  var r = sm.get(e) || !1;
  sm.set(e, !0);
  try {
    t(), n();
  } finally {
    sm.set(e, r);
  }
};
function j9(e, t, n) {
  var r = Lm.get(e) || [], o = Pm.get(e) || /* @__PURE__ */ new Set(), i, a, s = (p) => {
    if (p) {
      var d = p.join(",");
      a.has(d) || (a.add(d), i.push(p));
    }
  };
  if (n) {
    i = [], a = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      s(u);
    }
  } else
    i = r, a = o;
  for (var c of t)
    s(c);
  Lm.set(e, i), Pm.set(e, a);
}
var EQ = (e, t) => {
  for (var n of Q.pathRefs(e))
    AJ.transform(n, t);
  for (var r of Q.pointRefs(e))
    IJ.transform(r, t);
  for (var o of Q.rangeRefs(e))
    BJ.transform(o, t);
  if (!OQ(e)) {
    var i = le.operationCanTransformPath(t) ? (a) => le.transform(a, t) : void 0;
    j9(e, e.getDirtyPaths(t), i);
  }
  je.transform(e, t), e.operations.push(t), Q.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), Dp.get(e) || (Dp.set(e, !0), Promise.resolve().then(() => {
    Dp.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, LQ = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return le.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = le.levels(o), a = it.isText(r) ? [] : Array.from(Ke.nodes(r), (R) => {
        var [, B] = R;
        return o.concat(B);
      });
      return [...i, ...a];
    }
    case "merge_node": {
      var {
        path: s
      } = t, l = le.ancestors(s), u = le.previous(s);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: p
      } = t;
      if (le.equals(c, p))
        return [];
      var d = [], y = [];
      for (var f of le.ancestors(c)) {
        var v = le.transform(f, t);
        d.push(v);
      }
      for (var g of le.ancestors(p)) {
        var E = le.transform(g, t);
        y.push(E);
      }
      var w = y[y.length - 1], D = p[p.length - 1], x = w.concat(D);
      return [...d, ...y, x];
    }
    case "remove_node": {
      var {
        path: m
      } = t, C = le.ancestors(m);
      return [...C];
    }
    case "split_node": {
      var {
        path: S
      } = t, z = le.levels(S), L = le.next(S);
      return [...z, L];
    }
    default:
      return [];
  }
}, PQ = (e) => {
  var {
    selection: t
  } = e;
  return t ? Ke.fragment(e, t) : [];
}, kQ = (e, t) => {
  var [n, r] = t;
  if (!it.isText(n)) {
    if (rt.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      je.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = Q.isEditor(n) ? !1 : rt.isElement(n) && (e.isInline(n) || n.children.length === 0 || it.isText(n.children[0]) || e.isInline(n.children[0])), a = 0, s = 0; s < n.children.length; s++, a++) {
      var l = Ke.get(e, r);
      if (!it.isText(l)) {
        var u = l.children[a], c = l.children[a - 1], p = s === n.children.length - 1, d = it.isText(u) || rt.isElement(u) && e.isInline(u);
        if (d !== i)
          je.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--;
        else if (rt.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !it.isText(c)) {
              var y = {
                text: ""
              };
              je.insertNodes(e, y, {
                at: r.concat(a),
                voids: !0
              }), a++;
            } else if (p) {
              var f = {
                text: ""
              };
              je.insertNodes(e, f, {
                at: r.concat(a + 1),
                voids: !0
              }), a++;
            }
          }
        } else {
          if (!it.isText(u) && !("children" in u)) {
            var v = u;
            v.children = [];
          }
          c != null && it.isText(c) && (it.equals(u, c, {
            loose: !0
          }) ? (je.mergeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--) : c.text === "" ? (je.removeNodes(e, {
            at: r.concat(a - 1),
            voids: !0
          }), a--) : u.text === "" && (je.removeNodes(e, {
            at: r.concat(a),
            voids: !0
          }), a--));
        }
      }
    }
  }
}, SQ = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, MQ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: a
  } = n;
  if (i) {
    var s = Q.path(t, i), l = o === "lowest";
    for (var [u, c] of Q.levels(t, {
      at: s,
      voids: r,
      match: a,
      reverse: l
    }))
      if (!it.isText(u)) {
        if (me.isRange(i)) {
          if (le.isAncestor(c, i.anchor.path) && le.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!le.equals(s, c))
          return [u, c];
      }
  }
};
function GM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function YM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GM(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var DQ = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (p, d) => {
      if (!it.isText(p))
        return !1;
      var [y, f] = Q.parent(e, d);
      return !e.isVoid(y) || e.markableVoid(y);
    }, i = me.isExpanded(r), a = !1;
    if (!i) {
      var [s, l] = Q.node(e, r);
      if (s && o(s, l)) {
        var [u] = Q.parent(e, l);
        a = u && e.markableVoid(u);
      }
    }
    if (i || a)
      je.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = YM(YM({}, Q.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, Dp.get(e) || e.onChange();
    }
  }
};
function XM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function JM(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XM(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _Q = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = Q.point(t, n, {
    edge: "end"
  }), i = Q.end(t, []), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of Q.positions(t, JM(JM({}, r), {}, {
    at: a
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function QM(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QM(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QM(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jQ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = Q.start(t, []), i = Q.point(t, n, {
    edge: "start"
  }), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of Q.positions(t, eD(eD({}, r), {}, {
    at: a,
    reverse: !0
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, TQ = (e, t) => {
  var {
    selection: n
  } = e;
  n && me.isCollapsed(n) && je.delete(e, {
    unit: t,
    reverse: !0
  });
}, AQ = (e, t) => {
  var {
    selection: n
  } = e;
  n && me.isCollapsed(n) && je.delete(e, {
    unit: t
  });
}, IQ = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && me.isExpanded(r) && je.delete(t, {
    reverse: n === "backward"
  });
}, BQ = (e, t) => [Q.start(e, t), Q.end(e, t)];
function tD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tD(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var NQ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Q.above(t, nD(nD({}, n), {}, {
    match: (r) => rt.isElement(r) && Q.isElementReadOnly(t, r)
  }));
}, RQ = (e, t) => Q.point(e, t, {
  edge: "end"
}), FQ = (e, t) => {
  var n = Q.path(e, t, {
    edge: "start"
  });
  return Q.node(e, n);
}, zQ = (e, t) => {
  var n = Q.range(e, t);
  return Ke.fragment(e, n);
};
function rD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rD(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var UQ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return Q.above(t, oD(oD({}, n), {}, {
    match: (r) => rt.isElement(r) && Q.isVoid(t, r)
  }));
}, WQ = (e, t) => t.children.some((n) => rt.isElement(n) && Q.isBlock(e, n)), $Q = (e, t) => t.children.some((n) => it.isText(n) || Q.isInline(e, n)), HQ = (e, t) => Ke.has(e, t), VQ = (e, t) => t.children.every((n) => it.isText(n)), ZQ = (e) => {
  je.splitNodes(e, {
    always: !0
  });
}, qQ = (e, t, n) => {
  je.insertNodes(e, t, n);
}, KQ = (e) => {
  je.splitNodes(e, {
    always: !0
  });
};
function iD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function GQ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iD(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YQ = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var a = GQ({
        text: n
      }, i);
      je.insertNodes(t, a, {
        at: r.at,
        voids: r.voids
      });
    } else
      je.insertText(t, n, r);
    t.marks = null;
  }
}, XQ = (e, t) => !e.isInline(t), JQ = (e, t, n) => Q.isStart(e, t, n) || Q.isEnd(e, t, n), QQ = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && it.isText(r) && r.text === "" && !e.isVoid(t);
}, eee = (e, t, n) => {
  var r = Q.end(e, n);
  return zt.equals(t, r);
}, tee = (e) => {
  var t = D9.get(e);
  return t === void 0 ? !0 : t;
}, nee = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = Q.start(e, n);
  return zt.equals(t, r);
}, ree = (e, t) => {
  var n = Q.path(e, t, {
    edge: "end"
  });
  return Q.node(e, n);
}, oee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = Q.path(t, n, r), i = Ke.leaf(t, o);
  return [i, o];
};
function iee(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var a = [], s = Q.path(e, n);
      for (var [l, u] of Ke.levels(e, s))
        if (i(l, u) && (a.push([l, u]), !o && rt.isElement(l) && Q.isVoid(e, l)))
          break;
      r && a.reverse(), yield* a;
    }
  }();
}
var see = ["text"], aee = ["text"], lee = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (me.isExpanded(r)) {
    var a = Q.isEnd(t, o, o.path);
    if (a) {
      var s = Q.after(t, o);
      s && (o = s);
    }
    var [l] = Q.nodes(t, {
      match: it.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = aa(u, see);
      return c;
    } else
      return {};
  }
  var {
    path: p
  } = o, [d] = Q.leaf(t, p);
  if (o.offset === 0) {
    var y = Q.previous(t, {
      at: p,
      match: it.isText
    }), f = Q.above(t, {
      match: (x) => rt.isElement(x) && Q.isVoid(t, x) && t.markableVoid(x)
    });
    if (!f) {
      var v = Q.above(t, {
        match: (x) => rt.isElement(x) && Q.isBlock(t, x)
      });
      if (y && v) {
        var [g, E] = y, [, w] = v;
        le.isAncestor(w, E) && (d = g);
      }
    }
  }
  var D = aa(d, aee);
  return D;
}, uee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = Q.after(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = Q.last(t, []), u = [s.path, l];
      if (le.isPath(a) && a.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (le.isPath(a)) {
          var [c] = Q.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = Q.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, cee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = Q.path(t, n, r), i = Ke.get(t, o);
  return [i, o];
};
function pee(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: a = !1,
      ignoreNonSelectable: s = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (GJ.isSpan(n))
        u = n[0], c = n[1];
      else {
        var p = Q.path(e, n, {
          edge: "start"
        }), d = Q.path(e, n, {
          edge: "end"
        });
        u = i ? d : p, c = i ? p : d;
      }
      var y = Ke.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (x) => {
          var [m] = x;
          return rt.isElement(m) ? !!(!a && (Q.isVoid(e, m) || Q.isElementReadOnly(e, m)) || s && !Q.isSelectable(e, m)) : !1;
        }
      }), f = [], v;
      for (var [g, E] of y)
        if (!(s && rt.isElement(g) && !Q.isSelectable(e, g))) {
          var w = v && le.compare(E, v[1]) === 0;
          if (!(r === "highest" && w)) {
            if (!l(g, E)) {
              if (o && !w && it.isText(g))
                return;
              continue;
            }
            if (r === "lowest" && w) {
              v = [g, E];
              continue;
            }
            var D = r === "lowest" ? v : [g, E];
            D && (o ? f.push(D) : yield D), v = [g, E];
          }
        }
      r === "lowest" && v && (o ? f.push(v) : yield v), o && (yield* f);
    }
  }();
}
var dee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => Lm.get(c) || [], a = (c) => Pm.get(c) || /* @__PURE__ */ new Set(), s = (c) => {
    var p = i(c).pop(), d = p.join(",");
    return a(c).delete(d), p;
  };
  if (Q.isNormalizing(t)) {
    if (r) {
      var l = Array.from(Ke.nodes(t), (c) => {
        var [, p] = c;
        return p;
      }), u = new Set(l.map((c) => c.join(",")));
      Lm.set(t, l), Pm.set(t, u);
    }
    i(t).length !== 0 && Q.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (Ke.has(t, c)) {
          var p = Q.node(t, c), [d, y] = p;
          rt.isElement(d) && d.children.length === 0 && t.normalizeNode(p, {
            operation: o
          });
        }
      for (var f = i(t), v = f.length, g = 0; f.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: f,
          iteration: g,
          initialDirtyPathsLength: v,
          operation: o
        }))
          return;
        var E = s(t);
        if (Ke.has(t, E)) {
          var w = Q.node(t, E);
          t.normalizeNode(w, {
            operation: o
          });
        }
        g++, f = i(t);
      }
    });
  }
}, fee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = Q.path(t, n, r), i = le.parent(o), a = Q.node(t, i);
  return a;
}, hee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = Q.pathRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = Q.pathRefs(t);
  return a.add(i), i;
}, gee = (e) => {
  var t = AM.get(e);
  return t || (t = /* @__PURE__ */ new Set(), AM.set(e, t)), t;
}, mee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (le.isPath(n)) {
    if (i === "start") {
      var [, a] = Ke.first(t, n);
      n = a;
    } else if (i === "end") {
      var [, s] = Ke.last(t, n);
      n = s;
    }
  }
  return me.isRange(n) && (i === "start" ? n = me.start(n) : i === "end" ? n = me.end(n) : n = le.common(n.anchor.path, n.focus.path)), zt.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, vee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = Q.pointRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = Q.pointRefs(t);
  return a.add(i), i;
}, yee = (e) => {
  var t = IM.get(e);
  return t || (t = /* @__PURE__ */ new Set(), IM.set(e, t)), t;
}, bee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (le.isPath(n)) {
    var i;
    if (o === "end") {
      var [, a] = Ke.last(t, n);
      i = a;
    } else {
      var [, s] = Ke.first(t, n);
      i = s;
    }
    var l = Ke.get(t, i);
    if (!it.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (me.isRange(n)) {
    var [u, c] = me.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function wee(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: a = !1
    } = t;
    if (!n)
      return;
    var s = Q.range(e, n), [l, u] = me.edges(s), c = o ? u : l, p = !1, d = "", y = 0, f = 0, v = 0;
    for (var [g, E] of Q.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: a
    })) {
      if (rt.isElement(g)) {
        if (!i && (e.isVoid(g) || e.isElementReadOnly(g))) {
          yield Q.start(e, E);
          continue;
        }
        if (e.isInline(g)) continue;
        if (Q.hasInlines(e, g)) {
          var w = le.isAncestor(E, u.path) ? u : Q.end(e, E), D = le.isAncestor(E, l.path) ? l : Q.start(e, E);
          d = Q.string(e, {
            anchor: D,
            focus: w
          }, {
            voids: i
          }), p = !0;
        }
      }
      if (it.isText(g)) {
        var x = le.equals(E, c.path);
        for (x ? (f = o ? c.offset : g.text.length - c.offset, v = c.offset) : (f = g.text.length, v = o ? f : 0), (x || p || r === "offset") && (yield {
          path: E,
          offset: v
        }, p = !1); ; ) {
          if (y === 0) {
            if (d === "") break;
            y = m(d, r, o), d = OL(d, y, o)[1];
          }
          if (v = o ? v - y : v + y, f = f - y, f < 0) {
            y = -f;
            break;
          }
          y = 0, yield {
            path: E,
            offset: v
          };
        }
      }
    }
    function m(C, S, z) {
      return S === "character" ? CL(C, z) : S === "word" ? tQ(C, z) : S === "line" || S === "block" ? C.length : 1;
    }
  }();
}
var Cee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = t.selection
  } = n;
  if (a) {
    var s = Q.before(t, a, {
      voids: o
    });
    if (s) {
      var [, l] = Q.first(t, []), u = [s.path, l];
      if (le.isPath(a) && a.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (le.isPath(a)) {
          var [c] = Q.parent(t, a);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = Q.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, Oee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = Q.rangeRefs(t);
      return l.delete(i), i.current = null, s;
    }
  }, a = Q.rangeRefs(t);
  return a.add(i), i;
}, xee = (e) => {
  var t = BM.get(e);
  return t || (t = /* @__PURE__ */ new Set(), BM.set(e, t)), t;
}, Eee = (e, t, n) => {
  if (me.isRange(t) && !n)
    return t;
  var r = Q.start(e, t), o = Q.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function sD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lee(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sD(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Pee = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, p) => {
      if (!it.isText(c))
        return !1;
      var [d, y] = Q.parent(e, p);
      return !e.isVoid(d) || e.markableVoid(d);
    }, o = me.isExpanded(n), i = !1;
    if (!o) {
      var [a, s] = Q.node(e, n);
      if (a && r(a, s)) {
        var [l] = Q.parent(e, s);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      je.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = Lee({}, Q.marks(e) || {});
      delete u[t], e.marks = u, Dp.get(e) || e.onChange();
    }
  }
}, kee = (e, t) => {
  D9.set(e, t);
}, See = (e, t) => Q.point(e, t, {
  edge: "start"
}), Mee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = Q.range(t, n), [a, s] = me.edges(i), l = "";
  for (var [u, c] of Q.nodes(t, {
    at: i,
    match: it.isText,
    voids: o
  })) {
    var p = u.text;
    le.equals(c, s.path) && (p = p.slice(0, s.offset)), le.equals(c, a.path) && (p = p.slice(a.offset)), l += p;
  }
  return l;
}, Dee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, a] = me.edges(n);
  if (i.offset !== 0 || a.offset !== 0 || me.isCollapsed(n) || le.hasPrevious(a.path))
    return n;
  var s = Q.above(t, {
    at: a,
    match: (f) => rt.isElement(f) && Q.isBlock(t, f),
    voids: o
  }), l = s ? s[1] : [], u = Q.start(t, i), c = {
    anchor: u,
    focus: a
  }, p = !0;
  for (var [d, y] of Q.nodes(t, {
    at: c,
    match: it.isText,
    reverse: !0,
    voids: o
  })) {
    if (p) {
      p = !1;
      continue;
    }
    if (d.text !== "" || le.isBefore(y, l)) {
      a = {
        path: y,
        offset: d.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: a
  };
}, _ee = (e, t) => {
  var n = Q.isNormalizing(e);
  Q.setNormalizing(e, !1);
  try {
    t();
  } finally {
    Q.setNormalizing(e, n);
  }
  Q.normalize(e);
}, jee = (e, t, n) => {
  var [r, o] = t;
  return rt.isElement(r) && Q.isEmpty(e, r) || it.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, Tee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Q.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: a = "character",
      distance: s = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var p = !1;
      if (me.isRange(u) && me.isCollapsed(u) && (p = !0, u = u.anchor), zt.isPoint(u)) {
        var d = Q.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && d) {
          var [, y] = d;
          u = y;
        } else {
          var f = {
            unit: a,
            distance: s
          }, v = i ? Q.before(t, u, f) || Q.start(t, []) : Q.after(t, u, f) || Q.end(t, []);
          u = {
            anchor: u,
            focus: v
          }, c = !0;
        }
      }
      if (le.isPath(u)) {
        je.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!me.isCollapsed(u)) {
        if (!c) {
          var [, g] = me.edges(u), E = Q.end(t, []);
          zt.equals(g, E) || (u = Q.unhangRange(t, u, {
            voids: l
          }));
        }
        var [w, D] = me.edges(u), x = Q.above(t, {
          match: (fe) => rt.isElement(fe) && Q.isBlock(t, fe),
          at: w,
          voids: l
        }), m = Q.above(t, {
          match: (fe) => rt.isElement(fe) && Q.isBlock(t, fe),
          at: D,
          voids: l
        }), C = x && m && !le.equals(x[1], m[1]), S = le.equals(w.path, D.path), z = l ? null : (r = Q.void(t, {
          at: w,
          mode: "highest"
        })) !== null && r !== void 0 ? r : Q.elementReadOnly(t, {
          at: w,
          mode: "highest"
        }), L = l ? null : (o = Q.void(t, {
          at: D,
          mode: "highest"
        })) !== null && o !== void 0 ? o : Q.elementReadOnly(t, {
          at: D,
          mode: "highest"
        });
        if (z) {
          var R = Q.before(t, w);
          R && x && le.isAncestor(x[1], R.path) && (w = R);
        }
        if (L) {
          var B = Q.after(t, D);
          B && m && le.isAncestor(m[1], B.path) && (D = B);
        }
        var H = [], V;
        for (var W of Q.nodes(t, {
          at: u,
          voids: l
        })) {
          var [q, Y] = W;
          V && le.compare(Y, V) === 0 || (!l && rt.isElement(q) && (Q.isVoid(t, q) || Q.isElementReadOnly(t, q)) || !le.isCommon(Y, w.path) && !le.isCommon(Y, D.path)) && (H.push(W), V = Y);
        }
        var X = Array.from(H, (fe) => {
          var [, oe] = fe;
          return Q.pathRef(t, oe);
        }), ee = Q.pointRef(t, w), J = Q.pointRef(t, D), k = "";
        if (!S && !z) {
          var _ = ee.current, [U] = Q.leaf(t, _), {
            path: M
          } = _, {
            offset: $
          } = w, O = U.text.slice($);
          O.length > 0 && (t.apply({
            type: "remove_text",
            path: M,
            offset: $,
            text: O
          }), k = O);
        }
        if (X.reverse().map((fe) => fe.unref()).filter((fe) => fe !== null).forEach((fe) => je.removeNodes(t, {
          at: fe,
          voids: l
        })), !L) {
          var j = J.current, [F] = Q.leaf(t, j), {
            path: T
          } = j, Z = S ? w.offset : 0, A = F.text.slice(Z, D.offset);
          A.length > 0 && (t.apply({
            type: "remove_text",
            path: T,
            offset: Z,
            text: A
          }), k = A);
        }
        !S && C && J.current && ee.current && je.mergeNodes(t, {
          at: J.current,
          hanging: !0,
          voids: l
        }), p && i && a === "character" && k.length > 1 && k.match(/[\u0E00-\u0E7F]+/) && je.insertText(t, k.slice(0, k.length - s));
        var G = ee.unref(), N = J.unref(), ue = i ? G || N : N || G;
        n.at == null && ue && je.select(t, ue);
      }
    }
  });
}, Aee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Q.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: a = wL(t),
      batchDirty: s = !0
    } = r;
    if (n.length) {
      if (me.isRange(a))
        if (o || (a = Q.unhangRange(t, a, {
          voids: i
        })), me.isCollapsed(a))
          a = a.anchor;
        else {
          var [, l] = me.edges(a);
          if (!i && Q.void(t, {
            at: l
          }))
            return;
          var u = Q.pointRef(t, l);
          je.delete(t, {
            at: a
          }), a = u.unref();
        }
      else le.isPath(a) && (a = Q.start(t, a));
      if (!(!i && Q.void(t, {
        at: a
      }))) {
        var c = Q.above(t, {
          at: a,
          match: (O) => rt.isElement(O) && Q.isInline(t, O),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, p] = c;
          if (Q.isEnd(t, a, p)) {
            var d = Q.after(t, p);
            a = d;
          } else if (Q.isStart(t, a, p)) {
            var y = Q.before(t, p);
            a = y;
          }
        }
        var f = Q.above(t, {
          match: (O) => rt.isElement(O) && Q.isBlock(t, O),
          at: a,
          voids: i
        }), [, v] = f, g = Q.isStart(t, a, v), E = Q.isEnd(t, a, v), w = g && E, D = !g || g && E, x = !E, [, m] = Ke.first({
          children: n
        }, []), [, C] = Ke.last({
          children: n
        }, []), S = [], z = (O) => {
          var [j, F] = O, T = F.length === 0;
          return T ? !1 : w ? !0 : !(D && le.isAncestor(F, m) && rt.isElement(j) && !t.isVoid(j) && !t.isInline(j) || x && le.isAncestor(F, C) && rt.isElement(j) && !t.isVoid(j) && !t.isInline(j));
        };
        for (var L of Ke.nodes({
          children: n
        }, {
          pass: z
        }))
          z(L) && S.push(L);
        var R = [], B = [], H = [], V = !0, W = !1;
        for (var [q] of S)
          rt.isElement(q) && !t.isInline(q) ? (V = !1, W = !0, B.push(q)) : V ? R.push(q) : H.push(q);
        var [Y] = Q.nodes(t, {
          at: a,
          match: (O) => it.isText(O) || Q.isInline(t, O),
          mode: "highest",
          voids: i
        }), [, X] = Y, ee = Q.isStart(t, a, X), J = Q.isEnd(t, a, X), k = Q.pathRef(t, E && !H.length ? le.next(v) : v), _ = Q.pathRef(t, J ? le.next(X) : X);
        je.splitNodes(t, {
          at: a,
          match: (O) => W ? rt.isElement(O) && Q.isBlock(t, O) : it.isText(O) || Q.isInline(t, O),
          mode: W ? "lowest" : "highest",
          always: W && (!g || R.length > 0) && (!E || H.length > 0),
          voids: i
        });
        var U = Q.pathRef(t, !ee || ee && J ? le.next(X) : X);
        if (je.insertNodes(t, R, {
          at: U.current,
          match: (O) => it.isText(O) || Q.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), w && !R.length && B.length && !H.length && je.delete(t, {
          at: v,
          voids: i
        }), je.insertNodes(t, B, {
          at: k.current,
          match: (O) => rt.isElement(O) && Q.isBlock(t, O),
          mode: "lowest",
          voids: i,
          batchDirty: s
        }), je.insertNodes(t, H, {
          at: _.current,
          match: (O) => it.isText(O) || Q.isInline(t, O),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), !r.at) {
          var M;
          if (H.length > 0 && _.current ? M = le.previous(_.current) : B.length > 0 && k.current ? M = le.previous(k.current) : U.current && (M = le.previous(U.current)), M) {
            var $ = Q.end(t, M);
            je.select(t, $);
          }
        }
        U.unref(), k.unref(), _.unref();
      }
    }
  });
}, Iee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      je.select(t, o.anchor);
    else if (r === "focus")
      je.select(t, o.focus);
    else if (r === "start") {
      var [i] = me.edges(o);
      je.select(t, i);
    } else if (r === "end") {
      var [, a] = me.edges(o);
      je.select(t, a);
    }
  } else return;
}, Bee = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, Nee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: a = !1
  } = n, {
    edge: s = null
  } = n;
  if (r) {
    s === "start" && (s = me.isBackward(r) ? "focus" : "anchor"), s === "end" && (s = me.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, p = {};
    if (s == null || s === "anchor") {
      var d = a ? Q.before(t, l, c) : Q.after(t, l, c);
      d && (p.anchor = d);
    }
    if (s == null || s === "focus") {
      var y = a ? Q.before(t, u, c) : Q.after(t, u, c);
      y && (p.focus = y);
    }
    je.setSelection(t, p);
  }
}, Ree = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = Q.range(e, t), n) {
    je.setSelection(e, t);
    return;
  }
  if (!me.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Lo.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function aD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aD(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = me.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = me.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: a,
      focus: s
    } = o, l = i === "anchor" ? a : s;
    je.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: lD(lD({}, l), n)
    });
  }
}, zee = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !zt.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !zt.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, Uee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Q.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: a = "lowest",
      batchDirty: s = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (Ke.isNode(n) && (n = [n]), n.length !== 0) {
      var [p] = n;
      if (l || (l = wL(t), c !== !1 && (c = !0)), c == null && (c = !1), me.isRange(l))
        if (o || (l = Q.unhangRange(t, l, {
          voids: i
        })), me.isCollapsed(l))
          l = l.anchor;
        else {
          var [, d] = me.edges(l), y = Q.pointRef(t, d);
          je.delete(t, {
            at: l
          }), l = y.unref();
        }
      if (zt.isPoint(l)) {
        u == null && (it.isText(p) ? u = (R) => it.isText(R) : t.isInline(p) ? u = (R) => it.isText(R) || Q.isInline(t, R) : u = (R) => rt.isElement(R) && Q.isBlock(t, R));
        var [f] = Q.nodes(t, {
          at: l.path,
          match: u,
          mode: a,
          voids: i
        });
        if (f) {
          var [, v] = f, g = Q.pathRef(t, v), E = Q.isEnd(t, l, v);
          je.splitNodes(t, {
            at: l,
            match: u,
            mode: a,
            voids: i
          });
          var w = g.unref();
          l = E ? le.next(w) : w;
        } else
          return;
      }
      var D = le.parent(l), x = l[l.length - 1];
      if (!(!i && Q.void(t, {
        at: D
      }))) {
        if (s) {
          var m = [], C = le.levels(D);
          xQ(t, () => {
            var R = function() {
              var V = D.concat(x);
              x++;
              var W = {
                type: "insert_node",
                path: V,
                node: B
              };
              t.apply(W), l = le.next(l), m.push(W), it.isText ? C.push(...Array.from(Ke.nodes(B), (q) => {
                var [, Y] = q;
                return V.concat(Y);
              })) : C.push(V);
            };
            for (var B of n)
              R();
          }, () => {
            j9(t, C, (R) => {
              var B = R;
              for (var H of m)
                if (le.operationCanTransformPath(H) && (B = le.transform(B, H), !B))
                  return null;
              return B;
            });
          });
        } else
          for (var S of n) {
            var z = D.concat(x);
            x++, t.apply({
              type: "insert_node",
              path: z,
              node: S
            }), l = le.next(l);
          }
        if (l = le.previous(l), c) {
          var L = Q.end(t, l);
          L && je.select(t, L);
        }
      }
    }
  });
}, Wee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Q.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: a
    } = n;
    if (a == null && (a = le.isPath(r) ? dc(t, r) : (x) => rt.isElement(x) && Q.isBlock(t, x)), !!r) {
      var s = Q.nodes(t, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), l = Array.from(s, (x) => {
        var [, m] = x;
        return Q.pathRef(t, m);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var p = Q.node(t, le.parent(c)), [d, y] = p, f = c[c.length - 1], {
          length: v
        } = d.children;
        if (v === 1) {
          var g = le.next(y);
          je.moveNodes(t, {
            at: c,
            to: g,
            voids: i
          }), je.removeNodes(t, {
            at: y,
            voids: i
          });
        } else if (f === 0)
          je.moveNodes(t, {
            at: c,
            to: y,
            voids: i
          });
        else if (f === v - 1) {
          var E = le.next(y);
          je.moveNodes(t, {
            at: c,
            to: E,
            voids: i
          });
        } else {
          var w = le.next(c), D = le.next(y);
          je.splitNodes(t, {
            at: w,
            voids: i
          }), je.moveNodes(t, {
            at: c,
            to: D,
            voids: i
          });
        }
      }
    }
  });
}, $ee = ["text"], Hee = ["children"], T9 = (e, t) => {
  if (rt.isElement(t)) {
    var n = t;
    return Q.isVoid(e, t) ? !0 : n.children.length === 1 ? T9(e, n.children[0]) : !1;
  } else return !Q.isEditor(t);
}, Vee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Q.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: a = !1,
      mode: s = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (le.isPath(o)) {
          var [l] = Q.parent(t, o);
          r = (R) => l.children.includes(R);
        } else
          r = (R) => rt.isElement(R) && Q.isBlock(t, R);
      if (!i && me.isRange(o) && (o = Q.unhangRange(t, o, {
        voids: a
      })), me.isRange(o))
        if (me.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = me.edges(o), c = Q.pointRef(t, u);
          je.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && je.select(t, o);
        }
      var [p] = Q.nodes(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      }), d = Q.previous(t, {
        at: o,
        match: r,
        voids: a,
        mode: s
      });
      if (!(!p || !d)) {
        var [y, f] = p, [v, g] = d;
        if (!(f.length === 0 || g.length === 0)) {
          var E = le.next(g), w = le.common(f, g), D = le.isSibling(f, g), x = Array.from(Q.levels(t, {
            at: f
          }), (R) => {
            var [B] = R;
            return B;
          }).slice(w.length).slice(0, -1), m = Q.above(t, {
            at: f,
            mode: "highest",
            match: (R) => x.includes(R) && T9(t, R)
          }), C = m && Q.pathRef(t, m[1]), S, z;
          if (it.isText(y) && it.isText(v)) {
            var L = aa(y, $ee);
            z = v.text.length, S = L;
          } else if (rt.isElement(y) && rt.isElement(v)) {
            var L = aa(y, Hee);
            z = v.children.length, S = L;
          } else
            throw new Error("Cannot merge the node at path [".concat(f, "] with the previous sibling because it is not the same kind: ").concat(Lo.stringify(y), " ").concat(Lo.stringify(v)));
          D || je.moveNodes(t, {
            at: f,
            to: E,
            voids: a
          }), C && je.removeNodes(t, {
            at: C.current,
            voids: a
          }), Q.shouldMergeNodesRemovePrevNode(t, d, p) ? je.removeNodes(t, {
            at: g,
            voids: a
          }) : t.apply({
            type: "merge_node",
            path: E,
            position: z,
            properties: S
          }), C && C.unref();
        }
      }
    }
  });
}, Zee = (e, t) => {
  Q.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: a
    } = t;
    if (r) {
      a == null && (a = le.isPath(r) ? dc(e, r) : (y) => rt.isElement(y) && Q.isBlock(e, y));
      var s = Q.pathRef(e, n), l = Q.nodes(e, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), u = Array.from(l, (y) => {
        var [, f] = y;
        return Q.pathRef(e, f);
      });
      for (var c of u) {
        var p = c.unref(), d = s.current;
        p.length !== 0 && e.apply({
          type: "move_node",
          path: p,
          newPath: d
        }), s.current && le.isSibling(d, p) && le.isAfter(d, p) && (s.current = le.next(s.current));
      }
      s.unref();
    }
  });
}, qee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Q.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = le.isPath(a) ? dc(t, a) : (y) => rt.isElement(y) && Q.isBlock(t, y)), !r && me.isRange(a) && (a = Q.unhangRange(t, a, {
        voids: o
      }));
      var l = Q.nodes(t, {
        at: a,
        match: s,
        mode: i,
        voids: o
      }), u = Array.from(l, (y) => {
        var [, f] = y;
        return Q.pathRef(t, f);
      });
      for (var c of u) {
        var p = c.unref();
        if (p) {
          var [d] = Q.node(t, p);
          t.apply({
            type: "remove_node",
            path: p,
            node: d
          });
        }
      }
    }
  });
}, Kee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Q.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: a,
      merge: s
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: p = !1
    } = r;
    if (i) {
      if (o == null && (o = le.isPath(i) ? dc(t, i) : (z) => rt.isElement(z) && Q.isBlock(t, z)), !l && me.isRange(i) && (i = Q.unhangRange(t, i, {
        voids: p
      })), c && me.isRange(i)) {
        if (me.isCollapsed(i) && Q.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var d = Q.rangeRef(t, i, {
          affinity: "inward"
        }), [y, f] = me.edges(i), v = u === "lowest" ? "lowest" : "highest", g = Q.isEnd(t, f, f.path);
        je.splitNodes(t, {
          at: f,
          match: o,
          mode: v,
          voids: p,
          always: !g
        });
        var E = Q.isStart(t, y, y.path);
        je.splitNodes(t, {
          at: y,
          match: o,
          mode: v,
          voids: p,
          always: !E
        }), i = d.unref(), r.at == null && je.select(t, i);
      }
      a || (a = (z, L) => z !== L);
      for (var [w, D] of Q.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: p
      })) {
        var x = {}, m = {};
        if (D.length !== 0) {
          var C = !1;
          for (var S in n)
            S === "children" || S === "text" || a(n[S], w[S]) && (C = !0, w.hasOwnProperty(S) && (x[S] = w[S]), s ? n[S] != null && (m[S] = s(w[S], n[S])) : n[S] != null && (m[S] = n[S]));
          C && t.apply({
            type: "set_node",
            path: D,
            properties: x,
            newProperties: m
          });
        }
      }
    }
  });
}, Gee = (e, t) => {
  if (me.isCollapsed(t))
    return t.anchor;
  var [, n] = me.edges(t), r = Q.pointRef(e, n);
  return je.delete(e, {
    at: t
  }), r.unref();
}, Yee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Q.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: a = t.selection,
      height: s = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (J) => rt.isElement(J) && Q.isBlock(t, J)), me.isRange(a) && (a = Gee(t, a)), le.isPath(a)) {
      var u = a, c = Q.point(t, u), [p] = Q.parent(t, u);
      i = (J) => J === p, s = c.path.length - u.length + 1, a = c, l = !0;
    }
    if (a) {
      var d = Q.pointRef(t, a, {
        affinity: "backward"
      }), y;
      try {
        var [f] = Q.nodes(t, {
          at: a,
          match: i,
          mode: r,
          voids: o
        });
        if (!f)
          return;
        var v = Q.void(t, {
          at: a,
          mode: "highest"
        }), g = 0;
        if (!o && v) {
          var [E, w] = v;
          if (rt.isElement(E) && t.isInline(E)) {
            var D = Q.after(t, w);
            if (!D) {
              var x = {
                text: ""
              }, m = le.next(w);
              je.insertNodes(t, x, {
                at: m,
                voids: o
              }), D = Q.point(t, m);
            }
            a = D, l = !0;
          }
          var C = a.path.length - w.length;
          s = C + 1, l = !0;
        }
        y = Q.pointRef(t, a);
        var S = a.path.length - s, [, z] = f, L = a.path.slice(0, S), R = s === 0 ? a.offset : a.path[S] + g;
        for (var [B, H] of Q.levels(t, {
          at: L,
          reverse: !0,
          voids: o
        })) {
          var V = !1;
          if (H.length < z.length || H.length === 0 || !o && rt.isElement(B) && Q.isVoid(t, B))
            break;
          var W = d.current, q = Q.isEnd(t, W, H);
          if (l || !d || !Q.isEdge(t, W, H)) {
            V = !0;
            var Y = Ke.extractProps(B);
            t.apply({
              type: "split_node",
              path: H,
              position: R,
              properties: Y
            });
          }
          R = H[H.length - 1] + (V || q ? 1 : 0);
        }
        if (n.at == null) {
          var X = y.current || Q.end(t, []);
          je.select(t, X);
        }
      } finally {
        var ee;
        d.unref(), (ee = y) === null || ee === void 0 || ee.unref();
      }
    }
  });
}, Xee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  je.setNodes(t, o, r);
}, Jee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  Q.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: a = t.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = le.isPath(a) ? dc(t, a) : (y) => rt.isElement(y) && Q.isBlock(t, y)), le.isPath(a) && (a = Q.range(t, a));
      var l = me.isRange(a) ? Q.rangeRef(t, a) : null, u = Q.nodes(t, {
        at: a,
        match: s,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (y) => {
          var [, f] = y;
          return Q.pathRef(t, f);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), p = function() {
        var f = d.unref(), [v] = Q.node(t, f), g = Q.range(t, f);
        o && l && (g = me.intersection(l.current, g)), je.liftNodes(t, {
          at: g,
          match: (E) => rt.isAncestor(v) && v.children.includes(E),
          voids: i
        });
      };
      for (var d of c)
        p();
      l && l.unref();
    }
  });
};
function uD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cD(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uD(Object(n), !0).forEach(function(r) {
      Wo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qee = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Q.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: a = !1
    } = r, {
      match: s,
      at: l = t.selection
    } = r;
    if (l) {
      if (s == null && (le.isPath(l) ? s = dc(t, l) : t.isInline(n) ? s = (g) => rt.isElement(g) && Q.isInline(t, g) || it.isText(g) : s = (g) => rt.isElement(g) && Q.isBlock(t, g)), i && me.isRange(l)) {
        var [u, c] = me.edges(l), p = Q.rangeRef(t, l, {
          affinity: "inward"
        });
        je.splitNodes(t, {
          at: c,
          match: s,
          voids: a
        }), je.splitNodes(t, {
          at: u,
          match: s,
          voids: a
        }), l = p.unref(), r.at == null && je.select(t, l);
      }
      var d = Array.from(Q.nodes(t, {
        at: l,
        match: t.isInline(n) ? (g) => rt.isElement(g) && Q.isBlock(t, g) : (g) => Q.isEditor(g),
        mode: "lowest",
        voids: a
      })), y = function() {
        var E = me.isRange(l) ? me.intersection(l, Q.range(t, v)) : l;
        if (!E)
          return 0;
        var w = Array.from(Q.nodes(t, {
          at: E,
          match: s,
          mode: o,
          voids: a
        }));
        if (w.length > 0) {
          var [D] = w, x = w[w.length - 1], [, m] = D, [, C] = x;
          if (m.length === 0 && C.length === 0)
            return 0;
          var S = le.equals(m, C) ? le.parent(m) : le.common(m, C), z = Q.range(t, m, C), L = Q.node(t, S), [R] = L, B = S.length + 1, H = le.next(C.slice(0, B)), V = cD(cD({}, n), {}, {
            children: []
          });
          je.insertNodes(t, V, {
            at: H,
            voids: a
          }), je.moveNodes(t, {
            at: z,
            match: (W) => rt.isAncestor(R) && R.children.includes(W),
            to: H.concat(0),
            voids: a
          });
        }
      }, f;
      for (var [, v] of d)
        f = y();
    }
  });
}, ete = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return EQ(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DQ(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return TQ(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return AQ(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return IQ(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PQ(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ZQ(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return KQ(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Aee(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qQ(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return YQ(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kQ(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Pee(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LQ(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SQ(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return MQ(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _Q(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jQ(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Iee(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tee(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bee(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return BQ(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return NQ(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return RQ(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return FQ(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zQ(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lee(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return WQ(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $Q(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return HQ(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return VQ(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Uee(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return XQ(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return JQ(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return QQ(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eee(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return tee(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nee(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ree(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return oee(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iee(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wee(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vee(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nee(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zee(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uee(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cee(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pee(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dee(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fee(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mee(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hee(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gee(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bee(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vee(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yee(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wee(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Cee(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Eee(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Oee(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xee(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qee(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Ree(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Kee(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kee(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fee(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zee(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Yee(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return See(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Mee(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Dee(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Xee(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jee(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return UQ(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _ee(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qee(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jee(e, ...r);
    }
  };
  return e;
};
const A9 = (e) => {
  if (it.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if (rt.isElement(e)) {
    const t = e.children.map((r) => A9(r)).join(""), n = e.align || "left";
    switch (e.type) {
      case "image":
        return `<img src="${e.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${t}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${t}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${t}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${t}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${t}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${t}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, F8e = (e) => e.map((t) => A9(t)).join("");
var I9 = {}, xL = {}, EL = {};
Object.defineProperty(EL, "__esModule", { value: !0 });
EL.default = ote;
var pD = "html", dD = "head", Yf = "body", tte = /<([a-zA-Z]+[0-9]?)/, fD = /<head[^]*>/i, hD = /<body[^]*>/i, km = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, HO = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, gD = typeof window == "object" && window.DOMParser;
if (typeof gD == "function") {
  var nte = new gD(), rte = "text/html";
  HO = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), nte.parseFromString(e, rte);
  }, km = HO;
}
if (typeof document == "object" && document.implementation) {
  var Xf = document.implementation.createHTMLDocument();
  km = function(e, t) {
    if (t) {
      var n = Xf.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Xf;
    }
    return Xf.documentElement.innerHTML = e, Xf;
  };
}
var Jf = typeof document == "object" && document.createElement("template"), VO;
Jf && Jf.content && (VO = function(e) {
  return Jf.innerHTML = e, Jf.content.childNodes;
});
function ote(e) {
  var t, n, r = e.match(tte), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case pD: {
      var i = HO(e);
      if (!fD.test(e)) {
        var a = i.querySelector(dD);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!hD.test(e)) {
        var a = i.querySelector(Yf);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(pD);
    }
    case dD:
    case Yf: {
      var s = km(e).querySelectorAll(o);
      return hD.test(e) && fD.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (VO)
        return VO(e);
      var a = km(e, Yf).querySelector(Yf);
      return a.childNodes;
    }
  }
}
var Ay = {}, LL = {}, PL = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(PL);
var Kt = {}, dl = Jn && Jn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), _p = Jn && Jn.__assign || function() {
  return _p = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, _p.apply(this, arguments);
};
Object.defineProperty(Kt, "__esModule", { value: !0 });
Kt.cloneNode = Kt.hasChildren = Kt.isDocument = Kt.isDirective = Kt.isComment = Kt.isText = Kt.isCDATA = Kt.isTag = Kt.Element = Kt.Document = Kt.CDATA = Kt.NodeWithChildren = Kt.ProcessingInstruction = Kt.Comment = Kt.Text = Kt.DataNode = Kt.Node = void 0;
var ui = PL, kL = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), SL(this, t);
    }, e;
  }()
);
Kt.Node = kL;
var Iy = (
  /** @class */
  function(e) {
    dl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kL)
);
Kt.DataNode = Iy;
var B9 = (
  /** @class */
  function(e) {
    dl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ui.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Iy)
);
Kt.Text = B9;
var N9 = (
  /** @class */
  function(e) {
    dl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ui.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Iy)
);
Kt.Comment = N9;
var R9 = (
  /** @class */
  function(e) {
    dl(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = ui.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Iy)
);
Kt.ProcessingInstruction = R9;
var By = (
  /** @class */
  function(e) {
    dl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kL)
);
Kt.NodeWithChildren = By;
var F9 = (
  /** @class */
  function(e) {
    dl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ui.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(By)
);
Kt.CDATA = F9;
var z9 = (
  /** @class */
  function(e) {
    dl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ui.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(By)
);
Kt.Document = z9;
var U9 = (
  /** @class */
  function(e) {
    dl(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? ui.ElementType.Script : n === "style" ? ui.ElementType.Style : ui.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(By)
);
Kt.Element = U9;
function W9(e) {
  return (0, ui.isTag)(e);
}
Kt.isTag = W9;
function $9(e) {
  return e.type === ui.ElementType.CDATA;
}
Kt.isCDATA = $9;
function H9(e) {
  return e.type === ui.ElementType.Text;
}
Kt.isText = H9;
function V9(e) {
  return e.type === ui.ElementType.Comment;
}
Kt.isComment = V9;
function Z9(e) {
  return e.type === ui.ElementType.Directive;
}
Kt.isDirective = Z9;
function q9(e) {
  return e.type === ui.ElementType.Root;
}
Kt.isDocument = q9;
function ite(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Kt.hasChildren = ite;
function SL(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (H9(e))
    n = new B9(e.data);
  else if (V9(e))
    n = new N9(e.data);
  else if (W9(e)) {
    var r = t ? ww(e.children) : [], o = new U9(e.name, _p({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = _p({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = _p({}, e["x-attribsPrefix"])), n = o;
  } else if ($9(e)) {
    var r = t ? ww(e.children) : [], i = new F9(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (q9(e)) {
    var r = t ? ww(e.children) : [], a = new z9(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (Z9(e)) {
    var s = new R9(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Kt.cloneNode = SL;
function ww(e) {
  for (var t = e.map(function(r) {
    return SL(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Jn && Jn.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Jn && Jn.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = PL, o = Kt;
  n(Kt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(LL);
var K9 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(K9);
Object.defineProperty(Ay, "__esModule", { value: !0 });
Ay.formatAttributes = G9;
Ay.formatDOM = Y9;
var Qf = LL, ste = K9;
function ate(e) {
  return ste.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function G9(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function lte(e) {
  e = e.toLowerCase();
  var t = ate(e);
  return t || e;
}
function Y9(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = lte(s.nodeName);
        o = new Qf.Element(l, G9(s.attributes)), o.children = Y9(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Qf.Text(s.nodeValue);
        break;
      case 8:
        o = new Qf.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Qf.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var ute = Jn && Jn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(xL, "__esModule", { value: !0 });
xL.default = fte;
var cte = ute(EL), pte = Ay, dte = /<(![a-zA-Z\s]+)>/;
function fte(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(dte), n = t ? t[1] : void 0;
  return (0, pte.formatDOM)((0, cte.default)(e), null, n);
}
var Ny = {}, cs = {}, Ry = {}, hte = 0;
Ry.SAME = hte;
var gte = 1;
Ry.CAMELCASE = gte;
Ry.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const X9 = 0, fl = 1, Fy = 2, zy = 3, ML = 4, J9 = 5, Q9 = 6;
function mte(e) {
  return Po.hasOwnProperty(e) ? Po[e] : null;
}
function $o(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Fy || t === zy || t === ML, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Po = {}, vte = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
vte.forEach((e) => {
  Po[e] = new $o(
    e,
    X9,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Po[e] = new $o(
    e,
    fl,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Po[e] = new $o(
    e,
    Fy,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Po[e] = new $o(
    e,
    Fy,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Po[e] = new $o(
    e,
    zy,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Po[e] = new $o(
    e,
    zy,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Po[e] = new $o(
    e,
    ML,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Po[e] = new $o(
    e,
    Q9,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Po[e] = new $o(
    e,
    J9,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const DL = /[\-\:]([a-z])/g, _L = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(DL, _L);
  Po[t] = new $o(
    t,
    fl,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(DL, _L);
  Po[t] = new $o(
    t,
    fl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(DL, _L);
  Po[t] = new $o(
    t,
    fl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Po[e] = new $o(
    e,
    fl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const yte = "xlinkHref";
Po[yte] = new $o(
  "xlinkHref",
  fl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Po[e] = new $o(
    e,
    fl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: bte,
  SAME: wte,
  possibleStandardNames: mD
} = Ry, Cte = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Ote = Cte + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", xte = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Ote + "]*$")
), Ete = Object.keys(
  mD
).reduce((e, t) => {
  const n = mD[t];
  return n === wte ? e[t] = t : n === bte ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
cs.BOOLEAN = zy;
cs.BOOLEANISH_STRING = Fy;
cs.NUMERIC = J9;
cs.OVERLOADED_BOOLEAN = ML;
cs.POSITIVE_NUMERIC = Q9;
cs.RESERVED = X9;
cs.STRING = fl;
cs.getPropertyInfo = mte;
cs.isCustomAttribute = xte;
cs.possibleStandardNames = Ete;
var jL = {}, TL = {}, vD = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Lte = /\n/g, Pte = /^\s*/, kte = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Ste = /^:\s*/, Mte = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Dte = /^[;\s]*/, _te = /^\s+|\s+$/g, jte = `
`, yD = "/", bD = "*", ru = "", Tte = "comment", Ate = "declaration", Ite = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(Lte);
    v && (n += v.length);
    var g = f.lastIndexOf(jte);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var g = v[0];
      return o(g), e = e.slice(g.length), v;
    }
  }
  function u() {
    l(Pte);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(yD != e.charAt(0) || bD != e.charAt(1))) {
      for (var v = 2; ru != e.charAt(v) && (bD != e.charAt(v) || yD != e.charAt(v + 1)); )
        ++v;
      if (v += 2, ru === e.charAt(v - 1))
        return s("End of comment missing");
      var g = e.slice(2, v - 2);
      return r += 2, o(g), e = e.slice(v), r += 2, f({
        type: Tte,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), v = l(kte);
    if (v) {
      if (p(), !l(Ste)) return s("property missing ':'");
      var g = l(Mte), E = f({
        type: Ate,
        property: wD(v[0].replace(vD, ru)),
        value: g ? wD(g[0].replace(vD, ru)) : ru
      });
      return l(Dte), E;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function wD(e) {
  return e ? e.replace(_te, ru) : ru;
}
var Bte = Jn && Jn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(TL, "__esModule", { value: !0 });
TL.default = Rte;
var Nte = Bte(Ite);
function Rte(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Nte.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Uy = {};
Object.defineProperty(Uy, "__esModule", { value: !0 });
Uy.camelCase = void 0;
var Fte = /^--[a-zA-Z0-9_-]+$/, zte = /-([a-z])/g, Ute = /^[^-]+$/, Wte = /^-(webkit|moz|ms|o|khtml)-/, $te = /^-(ms)-/, Hte = function(e) {
  return !e || Ute.test(e) || Fte.test(e);
}, Vte = function(e, t) {
  return t.toUpperCase();
}, CD = function(e, t) {
  return "".concat(t, "-");
}, Zte = function(e, t) {
  return t === void 0 && (t = {}), Hte(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace($te, CD) : e = e.replace(Wte, CD), e.replace(zte, Vte));
};
Uy.camelCase = Zte;
var qte = Jn && Jn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Kte = qte(TL), Gte = Uy;
function ZO(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Kte.default)(e, function(r, o) {
    r && o && (n[(0, Gte.camelCase)(r, t)] = o);
  }), n;
}
ZO.default = ZO;
var Yte = ZO;
(function(e) {
  var t = Jn && Jn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Ce, r = t(Yte), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(jL);
Object.defineProperty(Ny, "__esModule", { value: !0 });
Ny.default = ene;
var vp = cs, OD = jL, Xte = ["checked", "value"], Jte = ["input", "select", "textarea"], Qte = {
  reset: !0,
  submit: !0
};
function ene(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Qte[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, vp.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = xD(a);
    if (s) {
      var l = (0, vp.getPropertyInfo)(s);
      switch (Xte.includes(s) && Jte.includes(t) && !r && (s = xD("default" + a)), n[s] = i, l && l.type) {
        case vp.BOOLEAN:
          n[s] = !0;
          break;
        case vp.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    OD.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, OD.setStyleProp)(e.style, n), n;
}
function xD(e) {
  return vp.possibleStandardNames[e];
}
var AL = {}, tne = Jn && Jn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(AL, "__esModule", { value: !0 });
AL.default = e8;
var Cw = Ce, nne = tne(Ny), jp = jL, rne = {
  cloneElement: Cw.cloneElement,
  createElement: Cw.createElement,
  isValidElement: Cw.isValidElement
};
function e8(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || jp.returnFirstArg, i = t.library || rne, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, jp.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    one(f) ? ((0, jp.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, nne.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (g = e8(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function one(e) {
  return jp.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, jp.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Jn && Jn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(xL);
  e.htmlToDOM = n.default;
  var r = t(Ny);
  e.attributesToProps = r.default;
  var o = t(AL);
  e.domToReact = o.default;
  var i = LL;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(I9);
const ED = /* @__PURE__ */ My(I9), ine = ED.default || ED, qO = (e) => {
  var r;
  if (typeof e == "string")
    return { text: e };
  const t = Array.isArray(e.props.children) ? e.props.children.map((o) => qO(o)) : [{ text: e.props.children || "" }], n = (r = e.props.className) == null ? void 0 : r.replace("align_", "");
  switch (e.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: e.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: t };
    case "blockquote":
      return { type: "blockQuote", align: n, children: t };
    case "ul":
      return { type: "bulletedList", align: n, children: t };
    case "ol":
      return { type: "numberedList", align: n, children: t };
    case "li":
      return { type: "listItem", align: n, children: t };
    case "h1":
      return { type: "headingOne", align: n, children: t };
    case "h2":
      return { type: "headingTwo", align: n, children: t };
    case "strong":
      return { text: e.props.children, bold: !0 };
    case "code":
      return { text: e.props.children, code: !0 };
    case "em":
      return { text: e.props.children, italic: !0 };
    case "u":
      return { text: e.props.children, underline: !0 };
    default:
      return { text: e.props.children || "" };
  }
}, z8e = (e) => {
  const t = ine(e);
  return Array.isArray(t) ? t.map((n) => typeof n == "string" ? { text: n } : qO(n)) : typeof t == "string" ? [{ text: t }] : [qO(t)];
}, U8e = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function t8(e, t, n) {
  if (!e) return /* @__PURE__ */ te.jsx(te.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ te.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ te.jsx("p", { className: n, children: /* @__PURE__ */ te.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function W8e(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: a = "",
    children: s,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], p = `arkynBadge ${t} ${n} ${r} ${a}`;
  return /* @__PURE__ */ te.jsxs("div", { className: p.trim(), ...l, children: [
    Cm(c, o),
    s,
    Cm(c, o)
  ] });
}
function $8e(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ te.jsx("div", { className: r.trim(), ...n });
}
function H8e(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ te.jsx("div", { className: o.trim(), ...r });
}
function V8e(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ te.jsx("aside", { className: r.trim(), ...n });
}
function Z8e(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, a = lt.count(r) === 0;
  return /* @__PURE__ */ te.jsx("tbody", { className: i.trim(), ...o, children: a ? /* @__PURE__ */ te.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ te.jsx("td", { colSpan: 100, children: /* @__PURE__ */ te.jsx("div", { children: t }) }) }) : r });
}
function q8e(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ te.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ te.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function K8e(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ te.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ te.jsx("table", { children: t }) });
}
function G8e(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ te.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ te.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ te.jsx("tr", { children: /* @__PURE__ */ te.jsx("th", { colSpan: 100, children: /* @__PURE__ */ te.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function Y8e(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ te.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ te.jsx("tr", { children: n }),
    /* @__PURE__ */ te.jsx("tr", { className: "spacingRow" })
  ] });
}
var Qn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function sne(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var KO = { exports: {} }, Bc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var LD;
function ane() {
  if (LD) return Bc;
  LD = 1;
  var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return Bc.Fragment = n, Bc.jsx = a, Bc.jsxs = a, Bc;
}
var eh = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var PD;
function lne() {
  return PD || (PD = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[v];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, K = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          K[ne - 1] = arguments[ne];
        D("error", b, K);
      }
    }
    function D(b, I, K) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (I += "%s", K = K.concat([ae]));
        var ce = K.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function R(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || z || b === o || b === u || b === c || S || b === y || x || m || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function B(b, I, K) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var ae = I.displayName || I.name || "";
      return ae !== "" ? K + "(" + ae + ")" : K;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return H(I) + ".Consumer";
          case a:
            var K = b;
            return H(K._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var ae = b, ce = ae._payload, se = ae._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, q = 0, Y, X, ee, J, k, _, U;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function $() {
      {
        if (q === 0) {
          Y = console.log, X = console.info, ee = console.warn, J = console.error, k = console.group, _ = console.groupCollapsed, U = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, b, {
              value: Y
            }),
            info: W({}, b, {
              value: X
            }),
            warn: W({}, b, {
              value: ee
            }),
            error: W({}, b, {
              value: J
            }),
            group: W({}, b, {
              value: k
            }),
            groupCollapsed: W({}, b, {
              value: _
            }),
            groupEnd: W({}, b, {
              value: U
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, F;
    function T(b, I, K) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            F = ne && ne[1] || "";
          }
        return `
` + F + b;
      }
    }
    var Z = !1, A;
    {
      var G = typeof WeakMap == "function" ? WeakMap : Map;
      A = new G();
    }
    function N(b, I) {
      if (!b || Z)
        return "";
      {
        var K = A.get(b);
        if (K !== void 0)
          return K;
      }
      var ne;
      Z = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Te) {
              ne = Te;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (Te) {
              ne = Te;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Te) {
            ne = Te;
          }
          b();
        }
      } catch (Te) {
        if (Te && ne && typeof Te.stack == "string") {
          for (var ie = Te.stack.split(`
`), De = ne.stack.split(`
`), de = ie.length - 1, he = De.length - 1; de >= 1 && he >= 0 && ie[de] !== De[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== De[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== De[he]) {
                    var Ze = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ze.includes("<anonymous>") && (Ze = Ze.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ze), Ze;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        Z = !1, j.current = ce, O(), Error.prepareStackTrace = ae;
      }
      var Ot = b ? b.displayName || b.name : "", gt = Ot ? T(Ot) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, I, K) {
      return N(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, K) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, K);
          case d: {
            var ne = b, ae = ne._payload, ce = ne._init;
            try {
              return oe(ce(ae), I, K);
            } catch {
            }
          }
        }
      return "";
    }
    var Ie = Object.prototype.hasOwnProperty, qe = {}, Ge = E.ReactDebugCurrentFrame;
    function Be(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(K);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, K, ne, ae) {
      {
        var ce = Function.call.bind(Ie);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var De = Error((ne || "React class") + ": " + K + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              ie = b[se](I, se, ne, K, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Be(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", K, se, typeof ie), Be(null)), ie instanceof Error && !(ie.message in qe) && (qe[ie.message] = !0, Be(ae), w("Failed %s type: %s", K, ie.message), Be(null));
          }
      }
    }
    var Xe = Array.isArray;
    function Me(b) {
      return Xe(b);
    }
    function Je(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, K = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return K;
      }
    }
    function at(b) {
      try {
        return Se(b), !1;
      } catch {
        return !0;
      }
    }
    function Se(b) {
      return "" + b;
    }
    function _e(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Je(b)), Se(b);
    }
    var Ae = E.ReactCurrentOwner, Ve = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ne, nt, we;
    we = {};
    function mt(b) {
      if (Ie.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function ot(b) {
      if (Ie.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function st(b, I) {
      if (typeof b.ref == "string" && Ae.current && I && Ae.current.stateNode !== I) {
        var K = V(Ae.current.type);
        we[K] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Ae.current.type), b.ref), we[K] = !0);
      }
    }
    function ut(b, I) {
      {
        var K = function() {
          Ne || (Ne = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: K,
          configurable: !0
        });
      }
    }
    function vt(b, I) {
      {
        var K = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: K,
          configurable: !0
        });
      }
    }
    var ct = function(b, I, K, ne, ae, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: K,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function yt(b, I, K, ne, ae) {
      {
        var ce, se = {}, ie = null, De = null;
        K !== void 0 && (_e(K), ie = "" + K), ot(I) && (_e(I.key), ie = "" + I.key), mt(I) && (De = I.ref, st(I, ae));
        for (ce in I)
          Ie.call(I, ce) && !Ve.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || De) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && ut(se, he), De && vt(se, he);
        }
        return ct(b, ie, De, ae, ne, Ae.current, se);
      }
    }
    var Qe = E.ReactCurrentOwner, ft = E.ReactDebugCurrentFrame;
    function tt(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        ft.setExtraStackFrame(K);
      } else
        ft.setExtraStackFrame(null);
    }
    var bt;
    bt = !1;
    function pt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Dt() {
      {
        if (Qe.current) {
          var b = V(Qe.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function wt(b) {
      return "";
    }
    var _t = {};
    function Ct(b) {
      {
        var I = Dt();
        if (!I) {
          var K = typeof b == "string" ? b : b.displayName || b.name;
          K && (I = `

Check the top-level render call using <` + K + ">.");
        }
        return I;
      }
    }
    function jt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var K = Ct(I);
        if (_t[K])
          return;
        _t[K] = !0;
        var ne = "";
        b && b._owner && b._owner !== Qe.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), tt(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', K, ne), tt(null);
      }
    }
    function Cn(b, I) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var K = 0; K < b.length; K++) {
            var ne = b[K];
            pt(ne) && jt(ne, I);
          }
        else if (pt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ae = g(b);
          if (typeof ae == "function" && ae !== b.entries)
            for (var ce = ae.call(b), se; !(se = ce.next()).done; )
              pt(se.value) && jt(se.value, I);
        }
      }
    }
    function ht(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var K;
        if (typeof I == "function")
          K = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          K = I.propTypes;
        else
          return;
        if (K) {
          var ne = V(I);
          et(K, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !bt) {
          bt = !0;
          var ae = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function re(b) {
      {
        for (var I = Object.keys(b.props), K = 0; K < I.length; K++) {
          var ne = I[K];
          if (ne !== "children" && ne !== "key") {
            tt(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), tt(null);
            break;
          }
        }
        b.ref !== null && (tt(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var mo = {};
    function vo(b, I, K, ne, ae, ce) {
      {
        var se = R(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = wt();
          De ? ie += De : ie += Dt();
          var de;
          b === null ? de = "null" : Me(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = yt(b, I, K, ae, ce);
        if (he == null)
          return he;
        if (se) {
          var Ze = I.children;
          if (Ze !== void 0)
            if (ne)
              if (Me(Ze)) {
                for (var Ot = 0; Ot < Ze.length; Ot++)
                  Cn(Ze[Ot], b);
                Object.freeze && Object.freeze(Ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Cn(Ze, b);
        }
        if (Ie.call(I, "key")) {
          var gt = V(b), Te = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), ar = Te.length > 0 ? "{key: someKey, " + Te.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!mo[gt + ar]) {
            var Ei = Te.length > 0 ? "{" + Te.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ar, gt, Ei, gt), mo[gt + ar] = !0;
          }
        }
        return b === r ? re(he) : ht(he), he;
      }
    }
    function wi(b, I, K) {
      return vo(b, I, K, !0);
    }
    function Ci(b, I, K) {
      return vo(b, I, K, !1);
    }
    var Oi = Ci, xi = wi;
    eh.Fragment = r, eh.jsx = Oi, eh.jsxs = xi;
  }()), eh;
}
process.env.NODE_ENV === "production" ? KO.exports = ane() : KO.exports = lne();
var Vn = KO.exports;
Ye({});
function kD(e, t) {
  return t ? /* @__PURE__ */ Vn.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ Vn.jsx(Vn.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function SD(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ao(e) {
  var t, n;
  return SD(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(SD(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var n8 = Symbol.for("immer-nothing"), MD = Symbol.for("immer-draftable"), Wi = Symbol.for("immer-state"), une = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Jo(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = une[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var oc = Object.getPrototypeOf;
function Lu(e) {
  return !!e && !!e[Wi];
}
function Pu(e) {
  var t;
  return e ? r8(e) || Array.isArray(e) || !!e[MD] || !!((t = e.constructor) != null && t[MD]) || $y(e) || Hy(e) : !1;
}
var cne = Object.prototype.constructor.toString();
function r8(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = oc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === cne;
}
function Sm(e, t) {
  Wy(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Wy(e) {
  const t = e[Wi];
  return t ? t.type_ : Array.isArray(e) ? 1 : $y(e) ? 2 : Hy(e) ? 3 : 0;
}
function GO(e, t) {
  return Wy(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function o8(e, t, n) {
  const r = Wy(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function pne(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function $y(e) {
  return e instanceof Map;
}
function Hy(e) {
  return e instanceof Set;
}
function Yl(e) {
  return e.copy_ || e.base_;
}
function YO(e, t) {
  if ($y(e))
    return new Map(e);
  if (Hy(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = r8(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Wi];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(oc(e), r);
  } else {
    const r = oc(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function IL(e, t = !1) {
  return Vy(e) || Lu(e) || !Pu(e) || (Wy(e) > 1 && (e.set = e.add = e.clear = e.delete = dne), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => IL(r, !0))), e;
}
function dne() {
  Jo(2);
}
function Vy(e) {
  return Object.isFrozen(e);
}
var fne = {};
function ku(e) {
  const t = fne[e];
  return t || Jo(0, e), t;
}
var pd;
function i8() {
  return pd;
}
function hne(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function DD(e, t) {
  t && (ku("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function XO(e) {
  JO(e), e.drafts_.forEach(gne), e.drafts_ = null;
}
function JO(e) {
  e === pd && (pd = e.parent_);
}
function _D(e) {
  return pd = hne(pd, e);
}
function gne(e) {
  const t = e[Wi];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function jD(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Wi].modified_ && (XO(t), Jo(4)), Pu(e) && (e = Mm(t, e), t.parent_ || Dm(t, e)), t.patches_ && ku("Patches").generateReplacementPatches_(
    n[Wi].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Mm(t, n, []), XO(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== n8 ? e : void 0;
}
function Mm(e, t, n) {
  if (Vy(t))
    return t;
  const r = t[Wi];
  if (!r)
    return Sm(
      t,
      (o, i) => TD(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Dm(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Sm(
      i,
      (s, l) => TD(e, r, o, s, l, n, a)
    ), Dm(e, o, !1), n && e.patches_ && ku("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function TD(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Jo(5), Lu(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !GO(t.assigned_, r) ? i.concat(r) : void 0, l = Mm(e, o, s);
    if (o8(n, r, l), Lu(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Pu(o) && !Vy(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Mm(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Dm(e, o);
  }
}
function Dm(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && IL(t, n);
}
function mne(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : i8(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = BL;
  n && (o = [r], i = dd);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var BL = {
  get(e, t) {
    if (t === Wi)
      return e;
    const n = Yl(e);
    if (!GO(n, t))
      return vne(e, n, t);
    const r = n[t];
    return e.finalized_ || !Pu(r) ? r : r === Ow(e.base_, t) ? (xw(e), e.copy_[t] = ex(r, e)) : r;
  },
  has(e, t) {
    return t in Yl(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Yl(e));
  },
  set(e, t, n) {
    const r = s8(Yl(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Ow(Yl(e), t), i = o == null ? void 0 : o[Wi];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (pne(n, o) && (n !== void 0 || GO(e.base_, t)))
        return !0;
      xw(e), QO(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Ow(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, xw(e), QO(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Yl(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Jo(11);
  },
  getPrototypeOf(e) {
    return oc(e.base_);
  },
  setPrototypeOf() {
    Jo(12);
  }
}, dd = {};
Sm(BL, (e, t) => {
  dd[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
dd.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Jo(13), dd.set.call(this, e, t, void 0);
};
dd.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Jo(14), BL.set.call(this, e[0], t, n, e[0]);
};
function Ow(e, t) {
  const n = e[Wi];
  return (n ? Yl(n) : e)[t];
}
function vne(e, t, n) {
  var r;
  const o = s8(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function s8(e, t) {
  if (!(t in e))
    return;
  let n = oc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = oc(n);
  }
}
function QO(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && QO(e.parent_));
}
function xw(e) {
  e.copy_ || (e.copy_ = YO(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var yne = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Jo(6), r !== void 0 && typeof r != "function" && Jo(7);
      let o;
      if (Pu(t)) {
        const i = _D(this), a = ex(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? XO(i) : JO(i);
        }
        return DD(i, r), jD(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === n8 && (o = void 0), this.autoFreeze_ && IL(o, !0), r) {
          const i = [], a = [];
          ku("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Jo(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Pu(e) || Jo(8), Lu(e) && (e = bne(e));
    const t = _D(this), n = ex(e, void 0);
    return n[Wi].isManual_ = !0, JO(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Wi];
    (!n || !n.isManual_) && Jo(9);
    const { scope_: r } = n;
    return DD(r, t), jD(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = ku("Patches").applyPatches_;
    return Lu(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function ex(e, t) {
  const n = $y(e) ? ku("MapSet").proxyMap_(e, t) : Hy(e) ? ku("MapSet").proxySet_(e, t) : mne(e, t);
  return (t ? t.scope_ : i8()).drafts_.push(n), n;
}
function bne(e) {
  return Lu(e) || Jo(10, e), a8(e);
}
function a8(e) {
  if (!Pu(e) || Vy(e))
    return e;
  const t = e[Wi];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = YO(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = YO(e, !0);
  return Sm(n, (r, o) => {
    o8(n, r, a8(o));
  }), t && (t.finalized_ = !1), n;
}
var $i = new yne(), NL = $i.produce;
$i.produceWithPatches.bind(
  $i
);
$i.setAutoFreeze.bind($i);
$i.setUseStrictShallowCopy.bind($i);
$i.applyPatches.bind($i);
var AD = $i.createDraft.bind($i), ID = $i.finishDraft.bind($i), Fe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Fe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Fe.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Fe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Fe.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Fe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Fe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Fe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Fe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Fe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Fe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Fe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Fe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Fe.isAncestor(t, e) && !Fe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Fe.equals(i, r) || Fe.endsBefore(i, r) || Fe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Fe.equals(a, r) || Fe.isAncestor(a, r))
          return null;
        Fe.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Fe.equals(s, r) || Fe.endsBefore(s, r) ? r[s.length - 1] -= 1 : Fe.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Fe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Fe.endsBefore(u, r) ? r[u.length - 1] += 1 : Fe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Fe.equals(p, d))
          return r;
        if (Fe.isAncestor(p, r) || Fe.equals(p, r)) {
          var y = d.slice();
          return Fe.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Fe.isSibling(p, d) && (Fe.isAncestor(d, r) || Fe.equals(d, r)) ? Fe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Fe.endsBefore(d, r) || Fe.equals(d, r) || Fe.isAncestor(d, r) ? (Fe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Fe.endsBefore(p, r) && (Fe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function fd(e) {
  "@babel/helpers - typeof";
  return fd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, fd(e);
}
function wne(e, t) {
  if (fd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (fd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Cne(e) {
  var t = wne(e, "string");
  return fd(t) === "symbol" ? t : String(t);
}
function fc(e, t, n) {
  return t = Cne(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function BD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Nc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BD(Object(n), !0).forEach(function(r) {
      fc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var One = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Et.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Ut.points(t))
          t[l] = hr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Et.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, g] of Ut.points(t))
          t[g] = hr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Et.get(e, E), D = Fe.previous(E), x = Et.get(e, D), m = Et.parent(e, E), C = E[E.length - 1];
      if (no.isText(w) && no.isText(x))
        x.text += w.text;
      else if (!no.isText(w) && !no.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Pi.stringify(w), " ").concat(Pi.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, z] of Ut.points(t))
          t[z] = hr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: R
      } = n;
      if (Fe.isAncestor(L, R))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(R, "] because the destination is inside itself."));
      var B = Et.get(e, L), H = Et.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var W = Fe.transform(L, n), q = Et.get(e, Fe.parent(W)), Y = W[W.length - 1];
      if (q.children.splice(Y, 0, B), t)
        for (var [X, ee] of Ut.points(t))
          t[ee] = hr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, k = J[J.length - 1], _ = Et.parent(e, J);
      if (_.children.splice(k, 1), t)
        for (var [U, M] of Ut.points(t)) {
          var $ = hr.transform(U, n);
          if (t != null && $ != null)
            t[M] = $;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of Et.texts(e))
              if (Fe.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var Z = !1;
            O && j && (Fe.equals(j[1], J) ? Z = !Fe.hasPrevious(j[1]) : Z = Fe.common(O[1], J).length < Fe.common(j[1], J).length), O && !Z ? (U.path = O[1], U.offset = O[0].text.length) : j ? (U.path = j[1], U.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: G,
        text: N
      } = n;
      if (N.length === 0) break;
      var ue = Et.leaf(e, A), fe = ue.text.slice(0, G), oe = ue.text.slice(G + N.length);
      if (ue.text = fe + oe, t)
        for (var [Ie, qe] of Ut.points(t))
          t[qe] = hr.transform(Ie, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Be,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Xe = Et.get(e, Ge);
      for (var Me in et) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Je = et[Me];
        Je == null ? delete Xe[Me] : Xe[Me] = Je;
      }
      for (var at in Be)
        et.hasOwnProperty(at) || delete Xe[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Se
      } = n;
      if (Se == null)
        t = Se;
      else {
        if (t == null) {
          if (!Ut.isRange(Se))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Pi.stringify(Se), " when there is no current selection."));
          t = Nc({}, Se);
        }
        for (var _e in Se) {
          var Ae = Se[_e];
          if (Ae == null) {
            if (_e === "anchor" || _e === "focus")
              throw new Error('Cannot remove the "'.concat(_e, '" selection property'));
            delete t[_e];
          } else
            t[_e] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ve,
        position: Ne,
        properties: nt
      } = n;
      if (Ve.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ve, "] because the root node cannot be split."));
      var we = Et.get(e, Ve), mt = Et.parent(e, Ve), ot = Ve[Ve.length - 1], st;
      if (no.isText(we)) {
        var ut = we.text.slice(0, Ne), vt = we.text.slice(Ne);
        we.text = ut, st = Nc(Nc({}, nt), {}, {
          text: vt
        });
      } else {
        var ct = we.children.slice(0, Ne), yt = we.children.slice(Ne);
        we.children = ct, st = Nc(Nc({}, nt), {}, {
          children: yt
        });
      }
      if (mt.children.splice(ot + 1, 0, st), t)
        for (var [Qe, ft] of Ut.points(t))
          t[ft] = hr.transform(Qe, n);
      break;
    }
  }
  return t;
}, xne = {
  transform(e, t) {
    e.children = AD(e.children);
    var n = e.selection && AD(e.selection);
    try {
      n = One(e, n, t);
    } finally {
      e.children = ID(e.children), n ? e.selection = Lu(n) ? ID(n) : n : e.selection = null;
    }
  }
}, Ene = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Lne = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, l8 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Ao(r) && Ao(o)) {
      if (!l8(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Pne(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function hd(e, t) {
  if (e == null) return {};
  var n = Pne(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var kne = ["anchor", "focus"];
function ND(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sne(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ND(Object(n), !0).forEach(function(r) {
      fc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ND(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ut = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Ut.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Ut.edges(e);
    return t;
  },
  equals(e, t) {
    return hr.equals(e.anchor, t.anchor) && hr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Ut.isRange(t)) {
      if (Ut.includes(e, t.anchor) || Ut.includes(e, t.focus))
        return !0;
      var [n, r] = Ut.edges(e), [o, i] = Ut.edges(t);
      return hr.isBefore(n, o) && hr.isAfter(r, i);
    }
    var [a, s] = Ut.edges(e), l = !1, u = !1;
    return hr.isPoint(t) ? (l = hr.compare(t, a) >= 0, u = hr.compare(t, s) <= 0) : (l = Fe.compare(t, a.path) >= 0, u = Fe.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = hd(e, kne), [r, o] = Ut.edges(e), [i, a] = Ut.edges(t), s = hr.isBefore(r, i) ? i : r, l = hr.isBefore(o, a) ? o : a;
    return hr.isBefore(l, s) ? null : Sne({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return hr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return hr.equals(t, n);
  },
  isExpanded(e) {
    return !Ut.isCollapsed(e);
  },
  isForward(e) {
    return !Ut.isBackward(e);
  },
  isRange(e) {
    return Ao(e) && hr.isPoint(e.anchor) && hr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Ut.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return NL(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Ut.isCollapsed(r);
        Ut.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Ut.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = hr.transform(r.anchor, t, {
        affinity: i
      }), u = hr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, RD = (e) => Ao(e) && Et.isNodeList(e.children) && !Zn.isEditor(e), ea = {
  isAncestor(e) {
    return Ao(e) && Et.isNodeList(e.children);
  },
  isElement: RD,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => ea.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return RD(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Mne = ["children"], Dne = ["text"], FD = /* @__PURE__ */ new WeakMap(), Et = {
  ancestor(e, t) {
    var n = Et.get(e, t);
    if (no.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Pi.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Fe.ancestors(t, n)) {
        var o = Et.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (no.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Pi.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Pi.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Et.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Et.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Fe.common(t, n), o = Et.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Et.get(e, t);
    if (Zn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Pi.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Et.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Et.nodes(e, t))
        ea.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (ea.isAncestor(e)) {
      var t = hd(e, Mne);
      return t;
    } else {
      var t = hd(e, Dne);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Et.get(e, n); r && !(no.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (no.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Pi.stringify(e)));
    var n = NL({
      children: e.children
    }, (r) => {
      var [o, i] = Ut.edges(t), a = Et.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Ut.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Ut.includes(t, s)) {
          var l = Et.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Fe.equals(s, i.path)) {
          var c = Et.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Fe.equals(s, o.path)) {
          var p = Et.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Zn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (no.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Pi.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (no.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return no.isText(e) || ea.isElement(e) || Zn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = FD.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Et.isNode(r));
    return FD.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Et.get(e, n); r && !(no.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Et.get(e, t);
    if (!no.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Pi.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Fe.levels(t, n)) {
        var o = Et.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return ea.isElement(e) && ea.isElementProps(t) && ea.matches(e, t) || no.isText(e) && no.isTextProps(t) && no.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Fe.isBefore(s, i) : Fe.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !no.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Fe.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Et.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Fe.next(s);
          if (Et.has(e, c)) {
            s = c, l = Et.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Fe.previous(s);
          s = p, l = Et.get(e, s);
          continue;
        }
        s = Fe.parent(s), l = Et.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Fe.parent(t), r = Et.get(e, n);
    if (no.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return no.isText(e) ? e.text : e.children.map(Et.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Et.nodes(e, t))
        no.isText(n) && (yield [n, r]);
    }();
  }
};
function zD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zD(Object(n), !0).forEach(function(r) {
      fc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yp = {
  isNodeOperation(e) {
    return yp.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Ao(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Fe.isPath(e.path) && Et.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Fe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Fe.isPath(e.path) && Ao(e.properties);
      case "move_node":
        return Fe.isPath(e.path) && Fe.isPath(e.newPath);
      case "remove_node":
        return Fe.isPath(e.path) && Et.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Fe.isPath(e.path);
      case "set_node":
        return Fe.isPath(e.path) && Ao(e.properties) && Ao(e.newProperties);
      case "set_selection":
        return e.properties === null && Ut.isRange(e.newProperties) || e.newProperties === null && Ut.isRange(e.properties) || Ao(e.properties) && Ao(e.newProperties);
      case "split_node":
        return Fe.isPath(e.path) && typeof e.position == "number" && Ao(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => yp.isOperation(t));
  },
  isSelectionOperation(e) {
    return yp.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return yp.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Cr(Cr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Cr(Cr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Cr(Cr({}, e), {}, {
          type: "split_node",
          path: Fe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Fe.equals(t, n))
          return e;
        if (Fe.isSibling(n, t))
          return Cr(Cr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Fe.transform(n, e), o = Fe.transform(Fe.next(n), e);
        return Cr(Cr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Cr(Cr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Cr(Cr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Cr(Cr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Cr(Cr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Cr(Cr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Cr(Cr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Cr(Cr({}, e), {}, {
          type: "merge_node",
          path: Fe.next(e.path)
        });
    }
  }
}, UD = /* @__PURE__ */ new WeakMap(), _ne = (e) => {
  var t = UD.get(e);
  if (t !== void 0)
    return t;
  if (!Ao(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Ao(e.marks)) && (e.selection === null || Ut.isRange(e.selection)) && Et.isNodeList(e.children) && yp.isOperationList(e.operations);
  return UD.set(e, n), n;
}, Zn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return _ne(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function WD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $D(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WD(Object(n), !0).forEach(function(r) {
      fc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hr = {
  compare(e, t) {
    var n = Fe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return hr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return hr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Fe.equals(e.path, t.path);
  },
  isPoint(e) {
    return Ao(e) && typeof e.offset == "number" && Fe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return NL(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Fe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Fe.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Fe.equals(t.path, i) && (r.offset += t.position), r.path = Fe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Fe.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Fe.equals(t.path, i) || Fe.isAncestor(t.path, i))
            return null;
          r.path = Fe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Fe.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Fe.transform(i, t, $D($D({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Fe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, HD = void 0, Pi = {
  setScrubber(e) {
    HD = e;
  },
  stringify(e) {
    return JSON.stringify(e, HD);
  }
}, jne = ["text"], Tne = ["anchor", "focus"];
function VD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Us(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VD(Object(n), !0).forEach(function(r) {
      fc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var no = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = hd(i, jne);
      return a;
    }
    return l8(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Ao(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => no.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Us({}, e)];
    for (var r of t) {
      var o = hd(r, Tne), [i, a] = Ut.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, g = void 0;
        if (c < l) {
          var E = c - y;
          g = Us(Us({}, f), {}, {
            text: f.text.slice(E)
          }), f = Us(Us({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > y) {
          var w = u - y;
          v = Us(Us({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Us(Us({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, Ane = (e) => e.selection ? e.selection : e.children.length > 0 ? Zn.end(e, []) : [0], lr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(lr || (lr = {}));
lr.L, lr.L | lr.V | lr.LV | lr.LVT, lr.LV | lr.V, lr.V | lr.T, lr.LVT | lr.T, lr.T, lr.Any, lr.Extend | lr.ZWJ, lr.Any, lr.SpacingMark, lr.Prepend, lr.Any, lr.ZWJ, lr.ExtPict, lr.RI, lr.RI;
var Ine = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Zn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Ane(e)
      } = n;
      if (Fe.isPath(o) && (o = Zn.range(e, o)), Ut.isRange(o))
        if (Ut.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Ut.end(o);
          if (!r && Zn.void(e, {
            at: i
          }))
            return;
          var a = Ut.start(o), s = Zn.pointRef(e, a), l = Zn.pointRef(e, i);
          _m.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, _m.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Zn.void(e, {
        at: o
      }) || Zn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function ZD(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function th(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZD(Object(n), !0).forEach(function(r) {
      fc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZD(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _m = th(th(th(th({}, xne), Ene), Lne), Ine), u8 = {}, RL = {}, FL = {};
Object.defineProperty(FL, "__esModule", { value: !0 });
FL.default = Fne;
var qD = "html", KD = "head", nh = "body", Bne = /<([a-zA-Z]+[0-9]?)/, GD = /<head[^]*>/i, YD = /<body[^]*>/i, jm = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, tx = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, XD = typeof window == "object" && window.DOMParser;
if (typeof XD == "function") {
  var Nne = new XD(), Rne = "text/html";
  tx = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Nne.parseFromString(e, Rne);
  }, jm = tx;
}
if (typeof document == "object" && document.implementation) {
  var rh = document.implementation.createHTMLDocument();
  jm = function(e, t) {
    if (t) {
      var n = rh.documentElement.querySelector(t);
      return n && (n.innerHTML = e), rh;
    }
    return rh.documentElement.innerHTML = e, rh;
  };
}
var oh = typeof document == "object" && document.createElement("template"), nx;
oh && oh.content && (nx = function(e) {
  return oh.innerHTML = e, oh.content.childNodes;
});
function Fne(e) {
  var t, n, r = e.match(Bne), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case qD: {
      var i = tx(e);
      if (!GD.test(e)) {
        var a = i.querySelector(KD);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!YD.test(e)) {
        var a = i.querySelector(nh);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(qD);
    }
    case KD:
    case nh: {
      var s = jm(e).querySelectorAll(o);
      return YD.test(e) && GD.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (nx)
        return nx(e);
      var a = jm(e, nh).querySelector(nh);
      return a.childNodes;
    }
  }
}
var Zy = {}, zL = {}, UL = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(UL);
var Gt = {}, hl = Qn && Qn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Tp = Qn && Qn.__assign || function() {
  return Tp = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Tp.apply(this, arguments);
};
Object.defineProperty(Gt, "__esModule", { value: !0 });
Gt.cloneNode = Gt.hasChildren = Gt.isDocument = Gt.isDirective = Gt.isComment = Gt.isText = Gt.isCDATA = Gt.isTag = Gt.Element = Gt.Document = Gt.CDATA = Gt.NodeWithChildren = Gt.ProcessingInstruction = Gt.Comment = Gt.Text = Gt.DataNode = Gt.Node = void 0;
var ci = UL, WL = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), $L(this, t);
    }, e;
  }()
);
Gt.Node = WL;
var qy = (
  /** @class */
  function(e) {
    hl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(WL)
);
Gt.DataNode = qy;
var c8 = (
  /** @class */
  function(e) {
    hl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ci.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qy)
);
Gt.Text = c8;
var p8 = (
  /** @class */
  function(e) {
    hl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ci.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qy)
);
Gt.Comment = p8;
var d8 = (
  /** @class */
  function(e) {
    hl(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = ci.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qy)
);
Gt.ProcessingInstruction = d8;
var Ky = (
  /** @class */
  function(e) {
    hl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(WL)
);
Gt.NodeWithChildren = Ky;
var f8 = (
  /** @class */
  function(e) {
    hl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ci.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ky)
);
Gt.CDATA = f8;
var h8 = (
  /** @class */
  function(e) {
    hl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = ci.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ky)
);
Gt.Document = h8;
var g8 = (
  /** @class */
  function(e) {
    hl(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? ci.ElementType.Script : n === "style" ? ci.ElementType.Style : ci.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ky)
);
Gt.Element = g8;
function m8(e) {
  return (0, ci.isTag)(e);
}
Gt.isTag = m8;
function v8(e) {
  return e.type === ci.ElementType.CDATA;
}
Gt.isCDATA = v8;
function y8(e) {
  return e.type === ci.ElementType.Text;
}
Gt.isText = y8;
function b8(e) {
  return e.type === ci.ElementType.Comment;
}
Gt.isComment = b8;
function w8(e) {
  return e.type === ci.ElementType.Directive;
}
Gt.isDirective = w8;
function C8(e) {
  return e.type === ci.ElementType.Root;
}
Gt.isDocument = C8;
function zne(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Gt.hasChildren = zne;
function $L(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (y8(e))
    n = new c8(e.data);
  else if (b8(e))
    n = new p8(e.data);
  else if (m8(e)) {
    var r = t ? Ew(e.children) : [], o = new g8(e.name, Tp({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Tp({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Tp({}, e["x-attribsPrefix"])), n = o;
  } else if (v8(e)) {
    var r = t ? Ew(e.children) : [], i = new f8(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (C8(e)) {
    var r = t ? Ew(e.children) : [], a = new h8(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (w8(e)) {
    var s = new d8(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Gt.cloneNode = $L;
function Ew(e) {
  for (var t = e.map(function(r) {
    return $L(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = Qn && Qn.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = Qn && Qn.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = UL, o = Gt;
  n(Gt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(zL);
var O8 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(O8);
Object.defineProperty(Zy, "__esModule", { value: !0 });
Zy.formatAttributes = x8;
Zy.formatDOM = E8;
var ih = zL, Une = O8;
function Wne(e) {
  return Une.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function x8(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function $ne(e) {
  e = e.toLowerCase();
  var t = Wne(e);
  return t || e;
}
function E8(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = $ne(s.nodeName);
        o = new ih.Element(l, x8(s.attributes)), o.children = E8(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new ih.Text(s.nodeValue);
        break;
      case 8:
        o = new ih.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new ih.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var Hne = Qn && Qn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(RL, "__esModule", { value: !0 });
RL.default = Kne;
var Vne = Hne(FL), Zne = Zy, qne = /<(![a-zA-Z\s]+)>/;
function Kne(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(qne), n = t ? t[1] : void 0;
  return (0, Zne.formatDOM)((0, Vne.default)(e), null, n);
}
var Gy = {}, ps = {}, Yy = {}, Gne = 0;
Yy.SAME = Gne;
var Yne = 1;
Yy.CAMELCASE = Yne;
Yy.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const L8 = 0, gl = 1, Xy = 2, Jy = 3, HL = 4, P8 = 5, k8 = 6;
function Xne(e) {
  return ko.hasOwnProperty(e) ? ko[e] : null;
}
function Ho(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Xy || t === Jy || t === HL, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const ko = {}, Jne = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Jne.forEach((e) => {
  ko[e] = new Ho(
    e,
    L8,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  ko[e] = new Ho(
    e,
    gl,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  ko[e] = new Ho(
    e,
    Xy,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  ko[e] = new Ho(
    e,
    Xy,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  ko[e] = new Ho(
    e,
    Jy,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ko[e] = new Ho(
    e,
    Jy,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ko[e] = new Ho(
    e,
    HL,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  ko[e] = new Ho(
    e,
    k8,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  ko[e] = new Ho(
    e,
    P8,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const VL = /[\-\:]([a-z])/g, ZL = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(VL, ZL);
  ko[t] = new Ho(
    t,
    gl,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(VL, ZL);
  ko[t] = new Ho(
    t,
    gl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(VL, ZL);
  ko[t] = new Ho(
    t,
    gl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  ko[e] = new Ho(
    e,
    gl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Qne = "xlinkHref";
ko[Qne] = new Ho(
  "xlinkHref",
  gl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  ko[e] = new Ho(
    e,
    gl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: ere,
  SAME: tre,
  possibleStandardNames: JD
} = Yy, nre = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", rre = nre + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ore = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + rre + "]*$")
), ire = Object.keys(
  JD
).reduce((e, t) => {
  const n = JD[t];
  return n === tre ? e[t] = t : n === ere ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ps.BOOLEAN = Jy;
ps.BOOLEANISH_STRING = Xy;
ps.NUMERIC = P8;
ps.OVERLOADED_BOOLEAN = HL;
ps.POSITIVE_NUMERIC = k8;
ps.RESERVED = L8;
ps.STRING = gl;
ps.getPropertyInfo = Xne;
ps.isCustomAttribute = ore;
ps.possibleStandardNames = ire;
var qL = {}, KL = {}, QD = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, sre = /\n/g, are = /^\s*/, lre = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, ure = /^:\s*/, cre = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, pre = /^[;\s]*/, dre = /^\s+|\s+$/g, fre = `
`, e_ = "/", t_ = "*", ou = "", hre = "comment", gre = "declaration", mre = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(sre);
    v && (n += v.length);
    var g = f.lastIndexOf(fre);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var g = v[0];
      return o(g), e = e.slice(g.length), v;
    }
  }
  function u() {
    l(are);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(e_ != e.charAt(0) || t_ != e.charAt(1))) {
      for (var v = 2; ou != e.charAt(v) && (t_ != e.charAt(v) || e_ != e.charAt(v + 1)); )
        ++v;
      if (v += 2, ou === e.charAt(v - 1))
        return s("End of comment missing");
      var g = e.slice(2, v - 2);
      return r += 2, o(g), e = e.slice(v), r += 2, f({
        type: hre,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), v = l(lre);
    if (v) {
      if (p(), !l(ure)) return s("property missing ':'");
      var g = l(cre), E = f({
        type: gre,
        property: n_(v[0].replace(QD, ou)),
        value: g ? n_(g[0].replace(QD, ou)) : ou
      });
      return l(pre), E;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function n_(e) {
  return e ? e.replace(dre, ou) : ou;
}
var vre = Qn && Qn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(KL, "__esModule", { value: !0 });
KL.default = bre;
var yre = vre(mre);
function bre(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, yre.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Qy = {};
Object.defineProperty(Qy, "__esModule", { value: !0 });
Qy.camelCase = void 0;
var wre = /^--[a-zA-Z0-9_-]+$/, Cre = /-([a-z])/g, Ore = /^[^-]+$/, xre = /^-(webkit|moz|ms|o|khtml)-/, Ere = /^-(ms)-/, Lre = function(e) {
  return !e || Ore.test(e) || wre.test(e);
}, Pre = function(e, t) {
  return t.toUpperCase();
}, r_ = function(e, t) {
  return "".concat(t, "-");
}, kre = function(e, t) {
  return t === void 0 && (t = {}), Lre(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Ere, r_) : e = e.replace(xre, r_), e.replace(Cre, Pre));
};
Qy.camelCase = kre;
var Sre = Qn && Qn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Mre = Sre(KL), Dre = Qy;
function rx(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Mre.default)(e, function(r, o) {
    r && o && (n[(0, Dre.camelCase)(r, t)] = o);
  }), n;
}
rx.default = rx;
var _re = rx;
(function(e) {
  var t = Qn && Qn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Ce, r = t(_re), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(qL);
Object.defineProperty(Gy, "__esModule", { value: !0 });
Gy.default = Ire;
var bp = ps, o_ = qL, jre = ["checked", "value"], Tre = ["input", "select", "textarea"], Are = {
  reset: !0,
  submit: !0
};
function Ire(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Are[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, bp.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = i_(a);
    if (s) {
      var l = (0, bp.getPropertyInfo)(s);
      switch (jre.includes(s) && Tre.includes(t) && !r && (s = i_("default" + a)), n[s] = i, l && l.type) {
        case bp.BOOLEAN:
          n[s] = !0;
          break;
        case bp.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    o_.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, o_.setStyleProp)(e.style, n), n;
}
function i_(e) {
  return bp.possibleStandardNames[e];
}
var GL = {}, Bre = Qn && Qn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(GL, "__esModule", { value: !0 });
GL.default = S8;
var Lw = Ce, Nre = Bre(Gy), Ap = qL, Rre = {
  cloneElement: Lw.cloneElement,
  createElement: Lw.createElement,
  isValidElement: Lw.isValidElement
};
function S8(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Ap.returnFirstArg, i = t.library || Rre, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, Ap.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    Fre(f) ? ((0, Ap.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, Nre.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (g = S8(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Fre(e) {
  return Ap.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Ap.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = Qn && Qn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(RL);
  e.htmlToDOM = n.default;
  var r = t(Gy);
  e.attributesToProps = r.default;
  var o = t(GL);
  e.domToReact = o.default;
  var i = zL;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(u8);
const s_ = /* @__PURE__ */ sne(u8);
s_.default;
function zre(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ Vn.jsx("div", { className: o.trim(), ...r });
}
var er = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Ure(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var ox = { exports: {} }, Rc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var a_;
function Wre() {
  if (a_) return Rc;
  a_ = 1;
  var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return Rc.Fragment = n, Rc.jsx = a, Rc.jsxs = a, Rc;
}
var sh = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var l_;
function $re() {
  return l_ || (l_ = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[v];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, K = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          K[ne - 1] = arguments[ne];
        D("error", b, K);
      }
    }
    function D(b, I, K) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (I += "%s", K = K.concat([ae]));
        var ce = K.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function R(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || z || b === o || b === u || b === c || S || b === y || x || m || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function B(b, I, K) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var ae = I.displayName || I.name || "";
      return ae !== "" ? K + "(" + ae + ")" : K;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return H(I) + ".Consumer";
          case a:
            var K = b;
            return H(K._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var ae = b, ce = ae._payload, se = ae._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, q = 0, Y, X, ee, J, k, _, U;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function $() {
      {
        if (q === 0) {
          Y = console.log, X = console.info, ee = console.warn, J = console.error, k = console.group, _ = console.groupCollapsed, U = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, b, {
              value: Y
            }),
            info: W({}, b, {
              value: X
            }),
            warn: W({}, b, {
              value: ee
            }),
            error: W({}, b, {
              value: J
            }),
            group: W({}, b, {
              value: k
            }),
            groupCollapsed: W({}, b, {
              value: _
            }),
            groupEnd: W({}, b, {
              value: U
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, F;
    function T(b, I, K) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            F = ne && ne[1] || "";
          }
        return `
` + F + b;
      }
    }
    var Z = !1, A;
    {
      var G = typeof WeakMap == "function" ? WeakMap : Map;
      A = new G();
    }
    function N(b, I) {
      if (!b || Z)
        return "";
      {
        var K = A.get(b);
        if (K !== void 0)
          return K;
      }
      var ne;
      Z = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Te) {
              ne = Te;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (Te) {
              ne = Te;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Te) {
            ne = Te;
          }
          b();
        }
      } catch (Te) {
        if (Te && ne && typeof Te.stack == "string") {
          for (var ie = Te.stack.split(`
`), De = ne.stack.split(`
`), de = ie.length - 1, he = De.length - 1; de >= 1 && he >= 0 && ie[de] !== De[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== De[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== De[he]) {
                    var Ze = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ze.includes("<anonymous>") && (Ze = Ze.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ze), Ze;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        Z = !1, j.current = ce, O(), Error.prepareStackTrace = ae;
      }
      var Ot = b ? b.displayName || b.name : "", gt = Ot ? T(Ot) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, I, K) {
      return N(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, K) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, K);
          case d: {
            var ne = b, ae = ne._payload, ce = ne._init;
            try {
              return oe(ce(ae), I, K);
            } catch {
            }
          }
        }
      return "";
    }
    var Ie = Object.prototype.hasOwnProperty, qe = {}, Ge = E.ReactDebugCurrentFrame;
    function Be(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(K);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, K, ne, ae) {
      {
        var ce = Function.call.bind(Ie);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var De = Error((ne || "React class") + ": " + K + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              ie = b[se](I, se, ne, K, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Be(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", K, se, typeof ie), Be(null)), ie instanceof Error && !(ie.message in qe) && (qe[ie.message] = !0, Be(ae), w("Failed %s type: %s", K, ie.message), Be(null));
          }
      }
    }
    var Xe = Array.isArray;
    function Me(b) {
      return Xe(b);
    }
    function Je(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, K = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return K;
      }
    }
    function at(b) {
      try {
        return Se(b), !1;
      } catch {
        return !0;
      }
    }
    function Se(b) {
      return "" + b;
    }
    function _e(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Je(b)), Se(b);
    }
    var Ae = E.ReactCurrentOwner, Ve = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ne, nt, we;
    we = {};
    function mt(b) {
      if (Ie.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function ot(b) {
      if (Ie.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function st(b, I) {
      if (typeof b.ref == "string" && Ae.current && I && Ae.current.stateNode !== I) {
        var K = V(Ae.current.type);
        we[K] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Ae.current.type), b.ref), we[K] = !0);
      }
    }
    function ut(b, I) {
      {
        var K = function() {
          Ne || (Ne = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: K,
          configurable: !0
        });
      }
    }
    function vt(b, I) {
      {
        var K = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: K,
          configurable: !0
        });
      }
    }
    var ct = function(b, I, K, ne, ae, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: K,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function yt(b, I, K, ne, ae) {
      {
        var ce, se = {}, ie = null, De = null;
        K !== void 0 && (_e(K), ie = "" + K), ot(I) && (_e(I.key), ie = "" + I.key), mt(I) && (De = I.ref, st(I, ae));
        for (ce in I)
          Ie.call(I, ce) && !Ve.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || De) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && ut(se, he), De && vt(se, he);
        }
        return ct(b, ie, De, ae, ne, Ae.current, se);
      }
    }
    var Qe = E.ReactCurrentOwner, ft = E.ReactDebugCurrentFrame;
    function tt(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        ft.setExtraStackFrame(K);
      } else
        ft.setExtraStackFrame(null);
    }
    var bt;
    bt = !1;
    function pt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Dt() {
      {
        if (Qe.current) {
          var b = V(Qe.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function wt(b) {
      return "";
    }
    var _t = {};
    function Ct(b) {
      {
        var I = Dt();
        if (!I) {
          var K = typeof b == "string" ? b : b.displayName || b.name;
          K && (I = `

Check the top-level render call using <` + K + ">.");
        }
        return I;
      }
    }
    function jt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var K = Ct(I);
        if (_t[K])
          return;
        _t[K] = !0;
        var ne = "";
        b && b._owner && b._owner !== Qe.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), tt(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', K, ne), tt(null);
      }
    }
    function Cn(b, I) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var K = 0; K < b.length; K++) {
            var ne = b[K];
            pt(ne) && jt(ne, I);
          }
        else if (pt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ae = g(b);
          if (typeof ae == "function" && ae !== b.entries)
            for (var ce = ae.call(b), se; !(se = ce.next()).done; )
              pt(se.value) && jt(se.value, I);
        }
      }
    }
    function ht(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var K;
        if (typeof I == "function")
          K = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          K = I.propTypes;
        else
          return;
        if (K) {
          var ne = V(I);
          et(K, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !bt) {
          bt = !0;
          var ae = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function re(b) {
      {
        for (var I = Object.keys(b.props), K = 0; K < I.length; K++) {
          var ne = I[K];
          if (ne !== "children" && ne !== "key") {
            tt(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), tt(null);
            break;
          }
        }
        b.ref !== null && (tt(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var mo = {};
    function vo(b, I, K, ne, ae, ce) {
      {
        var se = R(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = wt();
          De ? ie += De : ie += Dt();
          var de;
          b === null ? de = "null" : Me(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = yt(b, I, K, ae, ce);
        if (he == null)
          return he;
        if (se) {
          var Ze = I.children;
          if (Ze !== void 0)
            if (ne)
              if (Me(Ze)) {
                for (var Ot = 0; Ot < Ze.length; Ot++)
                  Cn(Ze[Ot], b);
                Object.freeze && Object.freeze(Ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Cn(Ze, b);
        }
        if (Ie.call(I, "key")) {
          var gt = V(b), Te = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), ar = Te.length > 0 ? "{key: someKey, " + Te.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!mo[gt + ar]) {
            var Ei = Te.length > 0 ? "{" + Te.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ar, gt, Ei, gt), mo[gt + ar] = !0;
          }
        }
        return b === r ? re(he) : ht(he), he;
      }
    }
    function wi(b, I, K) {
      return vo(b, I, K, !0);
    }
    function Ci(b, I, K) {
      return vo(b, I, K, !1);
    }
    var Oi = Ci, xi = wi;
    sh.Fragment = r, sh.jsx = Oi, sh.jsxs = xi;
  }()), sh;
}
process.env.NODE_ENV === "production" ? ox.exports = Wre() : ox.exports = $re();
var oi = ox.exports;
Ye({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function u_(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Io(e) {
  var t, n;
  return u_(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(u_(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var M8 = Symbol.for("immer-nothing"), c_ = Symbol.for("immer-draftable"), Hi = Symbol.for("immer-state"), Hre = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Qo(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Hre[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var ic = Object.getPrototypeOf;
function Su(e) {
  return !!e && !!e[Hi];
}
function Mu(e) {
  var t;
  return e ? D8(e) || Array.isArray(e) || !!e[c_] || !!((t = e.constructor) != null && t[c_]) || tb(e) || nb(e) : !1;
}
var Vre = Object.prototype.constructor.toString();
function D8(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = ic(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Vre;
}
function Tm(e, t) {
  eb(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function eb(e) {
  const t = e[Hi];
  return t ? t.type_ : Array.isArray(e) ? 1 : tb(e) ? 2 : nb(e) ? 3 : 0;
}
function ix(e, t) {
  return eb(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function _8(e, t, n) {
  const r = eb(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Zre(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function tb(e) {
  return e instanceof Map;
}
function nb(e) {
  return e instanceof Set;
}
function Xl(e) {
  return e.copy_ || e.base_;
}
function sx(e, t) {
  if (tb(e))
    return new Map(e);
  if (nb(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = D8(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Hi];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(ic(e), r);
  } else {
    const r = ic(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function YL(e, t = !1) {
  return rb(e) || Su(e) || !Mu(e) || (eb(e) > 1 && (e.set = e.add = e.clear = e.delete = qre), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => YL(r, !0))), e;
}
function qre() {
  Qo(2);
}
function rb(e) {
  return Object.isFrozen(e);
}
var Kre = {};
function Du(e) {
  const t = Kre[e];
  return t || Qo(0, e), t;
}
var gd;
function j8() {
  return gd;
}
function Gre(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function p_(e, t) {
  t && (Du("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function ax(e) {
  lx(e), e.drafts_.forEach(Yre), e.drafts_ = null;
}
function lx(e) {
  e === gd && (gd = e.parent_);
}
function d_(e) {
  return gd = Gre(gd, e);
}
function Yre(e) {
  const t = e[Hi];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function f_(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Hi].modified_ && (ax(t), Qo(4)), Mu(e) && (e = Am(t, e), t.parent_ || Im(t, e)), t.patches_ && Du("Patches").generateReplacementPatches_(
    n[Hi].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Am(t, n, []), ax(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== M8 ? e : void 0;
}
function Am(e, t, n) {
  if (rb(t))
    return t;
  const r = t[Hi];
  if (!r)
    return Tm(
      t,
      (o, i) => h_(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Im(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Tm(
      i,
      (s, l) => h_(e, r, o, s, l, n, a)
    ), Im(e, o, !1), n && e.patches_ && Du("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function h_(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && Qo(5), Su(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !ix(t.assigned_, r) ? i.concat(r) : void 0, l = Am(e, o, s);
    if (_8(n, r, l), Su(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Mu(o) && !rb(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Am(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Im(e, o);
  }
}
function Im(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && YL(t, n);
}
function Xre(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : j8(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = XL;
  n && (o = [r], i = md);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var XL = {
  get(e, t) {
    if (t === Hi)
      return e;
    const n = Xl(e);
    if (!ix(n, t))
      return Jre(e, n, t);
    const r = n[t];
    return e.finalized_ || !Mu(r) ? r : r === Pw(e.base_, t) ? (kw(e), e.copy_[t] = cx(r, e)) : r;
  },
  has(e, t) {
    return t in Xl(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Xl(e));
  },
  set(e, t, n) {
    const r = T8(Xl(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Pw(Xl(e), t), i = o == null ? void 0 : o[Hi];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Zre(n, o) && (n !== void 0 || ix(e.base_, t)))
        return !0;
      kw(e), ux(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Pw(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, kw(e), ux(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Xl(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Qo(11);
  },
  getPrototypeOf(e) {
    return ic(e.base_);
  },
  setPrototypeOf() {
    Qo(12);
  }
}, md = {};
Tm(XL, (e, t) => {
  md[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
md.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Qo(13), md.set.call(this, e, t, void 0);
};
md.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Qo(14), XL.set.call(this, e[0], t, n, e[0]);
};
function Pw(e, t) {
  const n = e[Hi];
  return (n ? Xl(n) : e)[t];
}
function Jre(e, t, n) {
  var r;
  const o = T8(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function T8(e, t) {
  if (!(t in e))
    return;
  let n = ic(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = ic(n);
  }
}
function ux(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && ux(e.parent_));
}
function kw(e) {
  e.copy_ || (e.copy_ = sx(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Qre = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Qo(6), r !== void 0 && typeof r != "function" && Qo(7);
      let o;
      if (Mu(t)) {
        const i = d_(this), a = cx(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? ax(i) : lx(i);
        }
        return p_(i, r), f_(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === M8 && (o = void 0), this.autoFreeze_ && YL(o, !0), r) {
          const i = [], a = [];
          Du("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        Qo(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Mu(e) || Qo(8), Su(e) && (e = eoe(e));
    const t = d_(this), n = cx(e, void 0);
    return n[Hi].isManual_ = !0, lx(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Hi];
    (!n || !n.isManual_) && Qo(9);
    const { scope_: r } = n;
    return p_(r, t), f_(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Du("Patches").applyPatches_;
    return Su(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function cx(e, t) {
  const n = tb(e) ? Du("MapSet").proxyMap_(e, t) : nb(e) ? Du("MapSet").proxySet_(e, t) : Xre(e, t);
  return (t ? t.scope_ : j8()).drafts_.push(n), n;
}
function eoe(e) {
  return Su(e) || Qo(10, e), A8(e);
}
function A8(e) {
  if (!Mu(e) || rb(e))
    return e;
  const t = e[Hi];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = sx(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = sx(e, !0);
  return Tm(n, (r, o) => {
    _8(n, r, A8(o));
  }), t && (t.finalized_ = !1), n;
}
var Vi = new Qre(), JL = Vi.produce;
Vi.produceWithPatches.bind(
  Vi
);
Vi.setAutoFreeze.bind(Vi);
Vi.setUseStrictShallowCopy.bind(Vi);
Vi.applyPatches.bind(Vi);
var g_ = Vi.createDraft.bind(Vi), m_ = Vi.finishDraft.bind(Vi), ze = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = ze.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ze.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return ze.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return ze.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return ze.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && ze.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return ze.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && ze.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && ze.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && ze.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && ze.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && ze.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!ze.isAncestor(t, e) && !ze.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (ze.equals(i, r) || ze.endsBefore(i, r) || ze.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (ze.equals(a, r) || ze.isAncestor(a, r))
          return null;
        ze.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        ze.equals(s, r) || ze.endsBefore(s, r) ? r[s.length - 1] -= 1 : ze.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (ze.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ze.endsBefore(u, r) ? r[u.length - 1] += 1 : ze.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (ze.equals(p, d))
          return r;
        if (ze.isAncestor(p, r) || ze.equals(p, r)) {
          var y = d.slice();
          return ze.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else ze.isSibling(p, d) && (ze.isAncestor(d, r) || ze.equals(d, r)) ? ze.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : ze.endsBefore(d, r) || ze.equals(d, r) || ze.isAncestor(d, r) ? (ze.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : ze.endsBefore(p, r) && (ze.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function vd(e) {
  "@babel/helpers - typeof";
  return vd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, vd(e);
}
function toe(e, t) {
  if (vd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (vd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function noe(e) {
  var t = toe(e, "string");
  return vd(t) === "symbol" ? t : String(t);
}
function hc(e, t, n) {
  return t = noe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function v_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? v_(Object(n), !0).forEach(function(r) {
      hc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : v_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var roe = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Lt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Wt.points(t))
          t[l] = gr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Lt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, g] of Wt.points(t))
          t[g] = gr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Lt.get(e, E), D = ze.previous(E), x = Lt.get(e, D), m = Lt.parent(e, E), C = E[E.length - 1];
      if (ro.isText(w) && ro.isText(x))
        x.text += w.text;
      else if (!ro.isText(w) && !ro.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(ki.stringify(w), " ").concat(ki.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, z] of Wt.points(t))
          t[z] = gr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: R
      } = n;
      if (ze.isAncestor(L, R))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(R, "] because the destination is inside itself."));
      var B = Lt.get(e, L), H = Lt.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var W = ze.transform(L, n), q = Lt.get(e, ze.parent(W)), Y = W[W.length - 1];
      if (q.children.splice(Y, 0, B), t)
        for (var [X, ee] of Wt.points(t))
          t[ee] = gr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, k = J[J.length - 1], _ = Lt.parent(e, J);
      if (_.children.splice(k, 1), t)
        for (var [U, M] of Wt.points(t)) {
          var $ = gr.transform(U, n);
          if (t != null && $ != null)
            t[M] = $;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of Lt.texts(e))
              if (ze.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var Z = !1;
            O && j && (ze.equals(j[1], J) ? Z = !ze.hasPrevious(j[1]) : Z = ze.common(O[1], J).length < ze.common(j[1], J).length), O && !Z ? (U.path = O[1], U.offset = O[0].text.length) : j ? (U.path = j[1], U.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: G,
        text: N
      } = n;
      if (N.length === 0) break;
      var ue = Lt.leaf(e, A), fe = ue.text.slice(0, G), oe = ue.text.slice(G + N.length);
      if (ue.text = fe + oe, t)
        for (var [Ie, qe] of Wt.points(t))
          t[qe] = gr.transform(Ie, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Be,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Xe = Lt.get(e, Ge);
      for (var Me in et) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Je = et[Me];
        Je == null ? delete Xe[Me] : Xe[Me] = Je;
      }
      for (var at in Be)
        et.hasOwnProperty(at) || delete Xe[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Se
      } = n;
      if (Se == null)
        t = Se;
      else {
        if (t == null) {
          if (!Wt.isRange(Se))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(ki.stringify(Se), " when there is no current selection."));
          t = Fc({}, Se);
        }
        for (var _e in Se) {
          var Ae = Se[_e];
          if (Ae == null) {
            if (_e === "anchor" || _e === "focus")
              throw new Error('Cannot remove the "'.concat(_e, '" selection property'));
            delete t[_e];
          } else
            t[_e] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ve,
        position: Ne,
        properties: nt
      } = n;
      if (Ve.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ve, "] because the root node cannot be split."));
      var we = Lt.get(e, Ve), mt = Lt.parent(e, Ve), ot = Ve[Ve.length - 1], st;
      if (ro.isText(we)) {
        var ut = we.text.slice(0, Ne), vt = we.text.slice(Ne);
        we.text = ut, st = Fc(Fc({}, nt), {}, {
          text: vt
        });
      } else {
        var ct = we.children.slice(0, Ne), yt = we.children.slice(Ne);
        we.children = ct, st = Fc(Fc({}, nt), {}, {
          children: yt
        });
      }
      if (mt.children.splice(ot + 1, 0, st), t)
        for (var [Qe, ft] of Wt.points(t))
          t[ft] = gr.transform(Qe, n);
      break;
    }
  }
  return t;
}, ooe = {
  transform(e, t) {
    e.children = g_(e.children);
    var n = e.selection && g_(e.selection);
    try {
      n = roe(e, n, t);
    } finally {
      e.children = m_(e.children), n ? e.selection = Su(n) ? m_(n) : n : e.selection = null;
    }
  }
}, ioe = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, soe = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, I8 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Io(r) && Io(o)) {
      if (!I8(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function aoe(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function yd(e, t) {
  if (e == null) return {};
  var n = aoe(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var loe = ["anchor", "focus"];
function y_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uoe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? y_(Object(n), !0).forEach(function(r) {
      hc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Wt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Wt.edges(e);
    return t;
  },
  equals(e, t) {
    return gr.equals(e.anchor, t.anchor) && gr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Wt.isRange(t)) {
      if (Wt.includes(e, t.anchor) || Wt.includes(e, t.focus))
        return !0;
      var [n, r] = Wt.edges(e), [o, i] = Wt.edges(t);
      return gr.isBefore(n, o) && gr.isAfter(r, i);
    }
    var [a, s] = Wt.edges(e), l = !1, u = !1;
    return gr.isPoint(t) ? (l = gr.compare(t, a) >= 0, u = gr.compare(t, s) <= 0) : (l = ze.compare(t, a.path) >= 0, u = ze.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = yd(e, loe), [r, o] = Wt.edges(e), [i, a] = Wt.edges(t), s = gr.isBefore(r, i) ? i : r, l = gr.isBefore(o, a) ? o : a;
    return gr.isBefore(l, s) ? null : uoe({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return gr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return gr.equals(t, n);
  },
  isExpanded(e) {
    return !Wt.isCollapsed(e);
  },
  isForward(e) {
    return !Wt.isBackward(e);
  },
  isRange(e) {
    return Io(e) && gr.isPoint(e.anchor) && gr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Wt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return JL(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Wt.isCollapsed(r);
        Wt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Wt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = gr.transform(r.anchor, t, {
        affinity: i
      }), u = gr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, b_ = (e) => Io(e) && Lt.isNodeList(e.children) && !qn.isEditor(e), ta = {
  isAncestor(e) {
    return Io(e) && Lt.isNodeList(e.children);
  },
  isElement: b_,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => ta.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return b_(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, coe = ["children"], poe = ["text"], w_ = /* @__PURE__ */ new WeakMap(), Lt = {
  ancestor(e, t) {
    var n = Lt.get(e, t);
    if (ro.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(ki.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ze.ancestors(t, n)) {
        var o = Lt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (ro.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(ki.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(ki.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Lt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Lt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = ze.common(t, n), o = Lt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Lt.get(e, t);
    if (qn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(ki.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Lt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Lt.nodes(e, t))
        ta.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (ta.isAncestor(e)) {
      var t = yd(e, coe);
      return t;
    } else {
      var t = yd(e, poe);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Lt.get(e, n); r && !(ro.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (ro.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(ki.stringify(e)));
    var n = JL({
      children: e.children
    }, (r) => {
      var [o, i] = Wt.edges(t), a = Lt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Wt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Wt.includes(t, s)) {
          var l = Lt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (ze.equals(s, i.path)) {
          var c = Lt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (ze.equals(s, o.path)) {
          var p = Lt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      qn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ro.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(ki.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ro.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return ro.isText(e) || ta.isElement(e) || qn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = w_.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Lt.isNode(r));
    return w_.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Lt.get(e, n); r && !(ro.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Lt.get(e, t);
    if (!ro.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(ki.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ze.levels(t, n)) {
        var o = Lt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return ta.isElement(e) && ta.isElementProps(t) && ta.matches(e, t) || ro.isText(e) && ro.isTextProps(t) && ro.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? ze.isBefore(s, i) : ze.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !ro.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          ze.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Lt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = ze.next(s);
          if (Lt.has(e, c)) {
            s = c, l = Lt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = ze.previous(s);
          s = p, l = Lt.get(e, s);
          continue;
        }
        s = ze.parent(s), l = Lt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = ze.parent(t), r = Lt.get(e, n);
    if (ro.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return ro.isText(e) ? e.text : e.children.map(Lt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Lt.nodes(e, t))
        ro.isText(n) && (yield [n, r]);
    }();
  }
};
function C_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Or(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? C_(Object(n), !0).forEach(function(r) {
      hc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wp = {
  isNodeOperation(e) {
    return wp.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Io(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return ze.isPath(e.path) && Lt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ze.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && ze.isPath(e.path) && Io(e.properties);
      case "move_node":
        return ze.isPath(e.path) && ze.isPath(e.newPath);
      case "remove_node":
        return ze.isPath(e.path) && Lt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && ze.isPath(e.path);
      case "set_node":
        return ze.isPath(e.path) && Io(e.properties) && Io(e.newProperties);
      case "set_selection":
        return e.properties === null && Wt.isRange(e.newProperties) || e.newProperties === null && Wt.isRange(e.properties) || Io(e.properties) && Io(e.newProperties);
      case "split_node":
        return ze.isPath(e.path) && typeof e.position == "number" && Io(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => wp.isOperation(t));
  },
  isSelectionOperation(e) {
    return wp.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return wp.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Or(Or({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Or(Or({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Or(Or({}, e), {}, {
          type: "split_node",
          path: ze.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (ze.equals(t, n))
          return e;
        if (ze.isSibling(n, t))
          return Or(Or({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = ze.transform(n, e), o = ze.transform(ze.next(n), e);
        return Or(Or({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Or(Or({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Or(Or({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Or(Or({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Or(Or({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Or(Or({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Or(Or({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Or(Or({}, e), {}, {
          type: "merge_node",
          path: ze.next(e.path)
        });
    }
  }
}, O_ = /* @__PURE__ */ new WeakMap(), doe = (e) => {
  var t = O_.get(e);
  if (t !== void 0)
    return t;
  if (!Io(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Io(e.marks)) && (e.selection === null || Wt.isRange(e.selection)) && Lt.isNodeList(e.children) && wp.isOperationList(e.operations);
  return O_.set(e, n), n;
}, qn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return doe(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function x_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function E_(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x_(Object(n), !0).forEach(function(r) {
      hc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gr = {
  compare(e, t) {
    var n = ze.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return gr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return gr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && ze.equals(e.path, t.path);
  },
  isPoint(e) {
    return Io(e) && typeof e.offset == "number" && ze.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return JL(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = ze.transform(i, t, n);
          break;
        }
        case "insert_text": {
          ze.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          ze.equals(t.path, i) && (r.offset += t.position), r.path = ze.transform(i, t, n);
          break;
        }
        case "remove_text": {
          ze.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (ze.equals(t.path, i) || ze.isAncestor(t.path, i))
            return null;
          r.path = ze.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (ze.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = ze.transform(i, t, E_(E_({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ze.transform(i, t, n);
          break;
        }
      }
    });
  }
}, L_ = void 0, ki = {
  setScrubber(e) {
    L_ = e;
  },
  stringify(e) {
    return JSON.stringify(e, L_);
  }
}, foe = ["text"], hoe = ["anchor", "focus"];
function P_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ws(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? P_(Object(n), !0).forEach(function(r) {
      hc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : P_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ro = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = yd(i, foe);
      return a;
    }
    return I8(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Io(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => ro.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Ws({}, e)];
    for (var r of t) {
      var o = yd(r, hoe), [i, a] = Wt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, g = void 0;
        if (c < l) {
          var E = c - y;
          g = Ws(Ws({}, f), {}, {
            text: f.text.slice(E)
          }), f = Ws(Ws({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > y) {
          var w = u - y;
          v = Ws(Ws({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Ws(Ws({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, goe = (e) => e.selection ? e.selection : e.children.length > 0 ? qn.end(e, []) : [0], ur;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(ur || (ur = {}));
ur.L, ur.L | ur.V | ur.LV | ur.LVT, ur.LV | ur.V, ur.V | ur.T, ur.LVT | ur.T, ur.T, ur.Any, ur.Extend | ur.ZWJ, ur.Any, ur.SpacingMark, ur.Prepend, ur.Any, ur.ZWJ, ur.ExtPict, ur.RI, ur.RI;
var moe = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    qn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = goe(e)
      } = n;
      if (ze.isPath(o) && (o = qn.range(e, o)), Wt.isRange(o))
        if (Wt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Wt.end(o);
          if (!r && qn.void(e, {
            at: i
          }))
            return;
          var a = Wt.start(o), s = qn.pointRef(e, a), l = qn.pointRef(e, i);
          Bm.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Bm.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && qn.void(e, {
        at: o
      }) || qn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function k_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ah(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? k_(Object(n), !0).forEach(function(r) {
      hc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : k_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Bm = ah(ah(ah(ah({}, ooe), ioe), soe), moe), B8 = {}, QL = {}, eP = {};
Object.defineProperty(eP, "__esModule", { value: !0 });
eP.default = woe;
var S_ = "html", M_ = "head", lh = "body", voe = /<([a-zA-Z]+[0-9]?)/, D_ = /<head[^]*>/i, __ = /<body[^]*>/i, Nm = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, px = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, j_ = typeof window == "object" && window.DOMParser;
if (typeof j_ == "function") {
  var yoe = new j_(), boe = "text/html";
  px = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), yoe.parseFromString(e, boe);
  }, Nm = px;
}
if (typeof document == "object" && document.implementation) {
  var uh = document.implementation.createHTMLDocument();
  Nm = function(e, t) {
    if (t) {
      var n = uh.documentElement.querySelector(t);
      return n && (n.innerHTML = e), uh;
    }
    return uh.documentElement.innerHTML = e, uh;
  };
}
var ch = typeof document == "object" && document.createElement("template"), dx;
ch && ch.content && (dx = function(e) {
  return ch.innerHTML = e, ch.content.childNodes;
});
function woe(e) {
  var t, n, r = e.match(voe), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case S_: {
      var i = px(e);
      if (!D_.test(e)) {
        var a = i.querySelector(M_);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!__.test(e)) {
        var a = i.querySelector(lh);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(S_);
    }
    case M_:
    case lh: {
      var s = Nm(e).querySelectorAll(o);
      return __.test(e) && D_.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (dx)
        return dx(e);
      var a = Nm(e, lh).querySelector(lh);
      return a.childNodes;
    }
  }
}
var ob = {}, tP = {}, nP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(nP);
var Yt = {}, ml = er && er.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Ip = er && er.__assign || function() {
  return Ip = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ip.apply(this, arguments);
};
Object.defineProperty(Yt, "__esModule", { value: !0 });
Yt.cloneNode = Yt.hasChildren = Yt.isDocument = Yt.isDirective = Yt.isComment = Yt.isText = Yt.isCDATA = Yt.isTag = Yt.Element = Yt.Document = Yt.CDATA = Yt.NodeWithChildren = Yt.ProcessingInstruction = Yt.Comment = Yt.Text = Yt.DataNode = Yt.Node = void 0;
var pi = nP, rP = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), oP(this, t);
    }, e;
  }()
);
Yt.Node = rP;
var ib = (
  /** @class */
  function(e) {
    ml(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rP)
);
Yt.DataNode = ib;
var N8 = (
  /** @class */
  function(e) {
    ml(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = pi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ib)
);
Yt.Text = N8;
var R8 = (
  /** @class */
  function(e) {
    ml(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = pi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ib)
);
Yt.Comment = R8;
var F8 = (
  /** @class */
  function(e) {
    ml(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = pi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ib)
);
Yt.ProcessingInstruction = F8;
var sb = (
  /** @class */
  function(e) {
    ml(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(rP)
);
Yt.NodeWithChildren = sb;
var z8 = (
  /** @class */
  function(e) {
    ml(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = pi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(sb)
);
Yt.CDATA = z8;
var U8 = (
  /** @class */
  function(e) {
    ml(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = pi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(sb)
);
Yt.Document = U8;
var W8 = (
  /** @class */
  function(e) {
    ml(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? pi.ElementType.Script : n === "style" ? pi.ElementType.Style : pi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(sb)
);
Yt.Element = W8;
function $8(e) {
  return (0, pi.isTag)(e);
}
Yt.isTag = $8;
function H8(e) {
  return e.type === pi.ElementType.CDATA;
}
Yt.isCDATA = H8;
function V8(e) {
  return e.type === pi.ElementType.Text;
}
Yt.isText = V8;
function Z8(e) {
  return e.type === pi.ElementType.Comment;
}
Yt.isComment = Z8;
function q8(e) {
  return e.type === pi.ElementType.Directive;
}
Yt.isDirective = q8;
function K8(e) {
  return e.type === pi.ElementType.Root;
}
Yt.isDocument = K8;
function Coe(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Yt.hasChildren = Coe;
function oP(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (V8(e))
    n = new N8(e.data);
  else if (Z8(e))
    n = new R8(e.data);
  else if ($8(e)) {
    var r = t ? Sw(e.children) : [], o = new W8(e.name, Ip({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Ip({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Ip({}, e["x-attribsPrefix"])), n = o;
  } else if (H8(e)) {
    var r = t ? Sw(e.children) : [], i = new z8(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (K8(e)) {
    var r = t ? Sw(e.children) : [], a = new U8(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (q8(e)) {
    var s = new F8(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Yt.cloneNode = oP;
function Sw(e) {
  for (var t = e.map(function(r) {
    return oP(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = er && er.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = er && er.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = nP, o = Yt;
  n(Yt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(tP);
var G8 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(G8);
Object.defineProperty(ob, "__esModule", { value: !0 });
ob.formatAttributes = Y8;
ob.formatDOM = X8;
var ph = tP, Ooe = G8;
function xoe(e) {
  return Ooe.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Y8(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Eoe(e) {
  e = e.toLowerCase();
  var t = xoe(e);
  return t || e;
}
function X8(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Eoe(s.nodeName);
        o = new ph.Element(l, Y8(s.attributes)), o.children = X8(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new ph.Text(s.nodeValue);
        break;
      case 8:
        o = new ph.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new ph.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var Loe = er && er.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(QL, "__esModule", { value: !0 });
QL.default = Moe;
var Poe = Loe(eP), koe = ob, Soe = /<(![a-zA-Z\s]+)>/;
function Moe(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Soe), n = t ? t[1] : void 0;
  return (0, koe.formatDOM)((0, Poe.default)(e), null, n);
}
var ab = {}, ds = {}, lb = {}, Doe = 0;
lb.SAME = Doe;
var _oe = 1;
lb.CAMELCASE = _oe;
lb.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const J8 = 0, vl = 1, ub = 2, cb = 3, iP = 4, Q8 = 5, e5 = 6;
function joe(e) {
  return So.hasOwnProperty(e) ? So[e] : null;
}
function Vo(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === ub || t === cb || t === iP, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const So = {}, Toe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Toe.forEach((e) => {
  So[e] = new Vo(
    e,
    J8,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  So[e] = new Vo(
    e,
    vl,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  So[e] = new Vo(
    e,
    ub,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  So[e] = new Vo(
    e,
    ub,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  So[e] = new Vo(
    e,
    cb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  So[e] = new Vo(
    e,
    cb,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  So[e] = new Vo(
    e,
    iP,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  So[e] = new Vo(
    e,
    e5,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  So[e] = new Vo(
    e,
    Q8,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const sP = /[\-\:]([a-z])/g, aP = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(sP, aP);
  So[t] = new Vo(
    t,
    vl,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(sP, aP);
  So[t] = new Vo(
    t,
    vl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(sP, aP);
  So[t] = new Vo(
    t,
    vl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  So[e] = new Vo(
    e,
    vl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Aoe = "xlinkHref";
So[Aoe] = new Vo(
  "xlinkHref",
  vl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  So[e] = new Vo(
    e,
    vl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Ioe,
  SAME: Boe,
  possibleStandardNames: T_
} = lb, Noe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Roe = Noe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Foe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Roe + "]*$")
), zoe = Object.keys(
  T_
).reduce((e, t) => {
  const n = T_[t];
  return n === Boe ? e[t] = t : n === Ioe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ds.BOOLEAN = cb;
ds.BOOLEANISH_STRING = ub;
ds.NUMERIC = Q8;
ds.OVERLOADED_BOOLEAN = iP;
ds.POSITIVE_NUMERIC = e5;
ds.RESERVED = J8;
ds.STRING = vl;
ds.getPropertyInfo = joe;
ds.isCustomAttribute = Foe;
ds.possibleStandardNames = zoe;
var lP = {}, uP = {}, A_ = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Uoe = /\n/g, Woe = /^\s*/, $oe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Hoe = /^:\s*/, Voe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Zoe = /^[;\s]*/, qoe = /^\s+|\s+$/g, Koe = `
`, I_ = "/", B_ = "*", iu = "", Goe = "comment", Yoe = "declaration", Xoe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(Uoe);
    v && (n += v.length);
    var g = f.lastIndexOf(Koe);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var g = v[0];
      return o(g), e = e.slice(g.length), v;
    }
  }
  function u() {
    l(Woe);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(I_ != e.charAt(0) || B_ != e.charAt(1))) {
      for (var v = 2; iu != e.charAt(v) && (B_ != e.charAt(v) || I_ != e.charAt(v + 1)); )
        ++v;
      if (v += 2, iu === e.charAt(v - 1))
        return s("End of comment missing");
      var g = e.slice(2, v - 2);
      return r += 2, o(g), e = e.slice(v), r += 2, f({
        type: Goe,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), v = l($oe);
    if (v) {
      if (p(), !l(Hoe)) return s("property missing ':'");
      var g = l(Voe), E = f({
        type: Yoe,
        property: N_(v[0].replace(A_, iu)),
        value: g ? N_(g[0].replace(A_, iu)) : iu
      });
      return l(Zoe), E;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function N_(e) {
  return e ? e.replace(qoe, iu) : iu;
}
var Joe = er && er.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(uP, "__esModule", { value: !0 });
uP.default = eie;
var Qoe = Joe(Xoe);
function eie(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Qoe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var pb = {};
Object.defineProperty(pb, "__esModule", { value: !0 });
pb.camelCase = void 0;
var tie = /^--[a-zA-Z0-9_-]+$/, nie = /-([a-z])/g, rie = /^[^-]+$/, oie = /^-(webkit|moz|ms|o|khtml)-/, iie = /^-(ms)-/, sie = function(e) {
  return !e || rie.test(e) || tie.test(e);
}, aie = function(e, t) {
  return t.toUpperCase();
}, R_ = function(e, t) {
  return "".concat(t, "-");
}, lie = function(e, t) {
  return t === void 0 && (t = {}), sie(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(iie, R_) : e = e.replace(oie, R_), e.replace(nie, aie));
};
pb.camelCase = lie;
var uie = er && er.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, cie = uie(uP), pie = pb;
function fx(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, cie.default)(e, function(r, o) {
    r && o && (n[(0, pie.camelCase)(r, t)] = o);
  }), n;
}
fx.default = fx;
var die = fx;
(function(e) {
  var t = er && er.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Ce, r = t(die), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(lP);
Object.defineProperty(ab, "__esModule", { value: !0 });
ab.default = mie;
var Cp = ds, F_ = lP, fie = ["checked", "value"], hie = ["input", "select", "textarea"], gie = {
  reset: !0,
  submit: !0
};
function mie(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && gie[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Cp.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = z_(a);
    if (s) {
      var l = (0, Cp.getPropertyInfo)(s);
      switch (fie.includes(s) && hie.includes(t) && !r && (s = z_("default" + a)), n[s] = i, l && l.type) {
        case Cp.BOOLEAN:
          n[s] = !0;
          break;
        case Cp.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    F_.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, F_.setStyleProp)(e.style, n), n;
}
function z_(e) {
  return Cp.possibleStandardNames[e];
}
var cP = {}, vie = er && er.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(cP, "__esModule", { value: !0 });
cP.default = t5;
var Mw = Ce, yie = vie(ab), Bp = lP, bie = {
  cloneElement: Mw.cloneElement,
  createElement: Mw.createElement,
  isValidElement: Mw.isValidElement
};
function t5(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Bp.returnFirstArg, i = t.library || bie, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, Bp.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    wie(f) ? ((0, Bp.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, yie.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (g = t5(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function wie(e) {
  return Bp.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Bp.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = er && er.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(QL);
  e.htmlToDOM = n.default;
  var r = t(ab);
  e.attributesToProps = r.default;
  var o = t(cP);
  e.domToReact = o.default;
  var i = tP;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(B8);
const Cie = /* @__PURE__ */ Ure(B8);
Cie.default;
var tr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Oie(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var hx = { exports: {} }, zc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var U_;
function xie() {
  if (U_) return zc;
  U_ = 1;
  var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return zc.Fragment = n, zc.jsx = a, zc.jsxs = a, zc;
}
var dh = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var W_;
function Eie() {
  return W_ || (W_ = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[v];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, K = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          K[ne - 1] = arguments[ne];
        D("error", b, K);
      }
    }
    function D(b, I, K) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (I += "%s", K = K.concat([ae]));
        var ce = K.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function R(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || z || b === o || b === u || b === c || S || b === y || x || m || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function B(b, I, K) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var ae = I.displayName || I.name || "";
      return ae !== "" ? K + "(" + ae + ")" : K;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return H(I) + ".Consumer";
          case a:
            var K = b;
            return H(K._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var ae = b, ce = ae._payload, se = ae._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, q = 0, Y, X, ee, J, k, _, U;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function $() {
      {
        if (q === 0) {
          Y = console.log, X = console.info, ee = console.warn, J = console.error, k = console.group, _ = console.groupCollapsed, U = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, b, {
              value: Y
            }),
            info: W({}, b, {
              value: X
            }),
            warn: W({}, b, {
              value: ee
            }),
            error: W({}, b, {
              value: J
            }),
            group: W({}, b, {
              value: k
            }),
            groupCollapsed: W({}, b, {
              value: _
            }),
            groupEnd: W({}, b, {
              value: U
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, F;
    function T(b, I, K) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            F = ne && ne[1] || "";
          }
        return `
` + F + b;
      }
    }
    var Z = !1, A;
    {
      var G = typeof WeakMap == "function" ? WeakMap : Map;
      A = new G();
    }
    function N(b, I) {
      if (!b || Z)
        return "";
      {
        var K = A.get(b);
        if (K !== void 0)
          return K;
      }
      var ne;
      Z = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Te) {
              ne = Te;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (Te) {
              ne = Te;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Te) {
            ne = Te;
          }
          b();
        }
      } catch (Te) {
        if (Te && ne && typeof Te.stack == "string") {
          for (var ie = Te.stack.split(`
`), De = ne.stack.split(`
`), de = ie.length - 1, he = De.length - 1; de >= 1 && he >= 0 && ie[de] !== De[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== De[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== De[he]) {
                    var Ze = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ze.includes("<anonymous>") && (Ze = Ze.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ze), Ze;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        Z = !1, j.current = ce, O(), Error.prepareStackTrace = ae;
      }
      var Ot = b ? b.displayName || b.name : "", gt = Ot ? T(Ot) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, I, K) {
      return N(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, K) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, K);
          case d: {
            var ne = b, ae = ne._payload, ce = ne._init;
            try {
              return oe(ce(ae), I, K);
            } catch {
            }
          }
        }
      return "";
    }
    var Ie = Object.prototype.hasOwnProperty, qe = {}, Ge = E.ReactDebugCurrentFrame;
    function Be(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(K);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, K, ne, ae) {
      {
        var ce = Function.call.bind(Ie);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var De = Error((ne || "React class") + ": " + K + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              ie = b[se](I, se, ne, K, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Be(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", K, se, typeof ie), Be(null)), ie instanceof Error && !(ie.message in qe) && (qe[ie.message] = !0, Be(ae), w("Failed %s type: %s", K, ie.message), Be(null));
          }
      }
    }
    var Xe = Array.isArray;
    function Me(b) {
      return Xe(b);
    }
    function Je(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, K = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return K;
      }
    }
    function at(b) {
      try {
        return Se(b), !1;
      } catch {
        return !0;
      }
    }
    function Se(b) {
      return "" + b;
    }
    function _e(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Je(b)), Se(b);
    }
    var Ae = E.ReactCurrentOwner, Ve = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ne, nt, we;
    we = {};
    function mt(b) {
      if (Ie.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function ot(b) {
      if (Ie.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function st(b, I) {
      if (typeof b.ref == "string" && Ae.current && I && Ae.current.stateNode !== I) {
        var K = V(Ae.current.type);
        we[K] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Ae.current.type), b.ref), we[K] = !0);
      }
    }
    function ut(b, I) {
      {
        var K = function() {
          Ne || (Ne = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: K,
          configurable: !0
        });
      }
    }
    function vt(b, I) {
      {
        var K = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: K,
          configurable: !0
        });
      }
    }
    var ct = function(b, I, K, ne, ae, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: K,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function yt(b, I, K, ne, ae) {
      {
        var ce, se = {}, ie = null, De = null;
        K !== void 0 && (_e(K), ie = "" + K), ot(I) && (_e(I.key), ie = "" + I.key), mt(I) && (De = I.ref, st(I, ae));
        for (ce in I)
          Ie.call(I, ce) && !Ve.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || De) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && ut(se, he), De && vt(se, he);
        }
        return ct(b, ie, De, ae, ne, Ae.current, se);
      }
    }
    var Qe = E.ReactCurrentOwner, ft = E.ReactDebugCurrentFrame;
    function tt(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        ft.setExtraStackFrame(K);
      } else
        ft.setExtraStackFrame(null);
    }
    var bt;
    bt = !1;
    function pt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Dt() {
      {
        if (Qe.current) {
          var b = V(Qe.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function wt(b) {
      return "";
    }
    var _t = {};
    function Ct(b) {
      {
        var I = Dt();
        if (!I) {
          var K = typeof b == "string" ? b : b.displayName || b.name;
          K && (I = `

Check the top-level render call using <` + K + ">.");
        }
        return I;
      }
    }
    function jt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var K = Ct(I);
        if (_t[K])
          return;
        _t[K] = !0;
        var ne = "";
        b && b._owner && b._owner !== Qe.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), tt(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', K, ne), tt(null);
      }
    }
    function Cn(b, I) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var K = 0; K < b.length; K++) {
            var ne = b[K];
            pt(ne) && jt(ne, I);
          }
        else if (pt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ae = g(b);
          if (typeof ae == "function" && ae !== b.entries)
            for (var ce = ae.call(b), se; !(se = ce.next()).done; )
              pt(se.value) && jt(se.value, I);
        }
      }
    }
    function ht(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var K;
        if (typeof I == "function")
          K = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          K = I.propTypes;
        else
          return;
        if (K) {
          var ne = V(I);
          et(K, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !bt) {
          bt = !0;
          var ae = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function re(b) {
      {
        for (var I = Object.keys(b.props), K = 0; K < I.length; K++) {
          var ne = I[K];
          if (ne !== "children" && ne !== "key") {
            tt(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), tt(null);
            break;
          }
        }
        b.ref !== null && (tt(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var mo = {};
    function vo(b, I, K, ne, ae, ce) {
      {
        var se = R(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = wt();
          De ? ie += De : ie += Dt();
          var de;
          b === null ? de = "null" : Me(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = yt(b, I, K, ae, ce);
        if (he == null)
          return he;
        if (se) {
          var Ze = I.children;
          if (Ze !== void 0)
            if (ne)
              if (Me(Ze)) {
                for (var Ot = 0; Ot < Ze.length; Ot++)
                  Cn(Ze[Ot], b);
                Object.freeze && Object.freeze(Ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Cn(Ze, b);
        }
        if (Ie.call(I, "key")) {
          var gt = V(b), Te = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), ar = Te.length > 0 ? "{key: someKey, " + Te.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!mo[gt + ar]) {
            var Ei = Te.length > 0 ? "{" + Te.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ar, gt, Ei, gt), mo[gt + ar] = !0;
          }
        }
        return b === r ? re(he) : ht(he), he;
      }
    }
    function wi(b, I, K) {
      return vo(b, I, K, !0);
    }
    function Ci(b, I, K) {
      return vo(b, I, K, !1);
    }
    var Oi = Ci, xi = wi;
    dh.Fragment = r, dh.jsx = Oi, dh.jsxs = xi;
  }()), dh;
}
process.env.NODE_ENV === "production" ? hx.exports = xie() : hx.exports = Eie();
var ii = hx.exports;
Ye({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function $_(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Bo(e) {
  var t, n;
  return $_(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !($_(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var n5 = Symbol.for("immer-nothing"), H_ = Symbol.for("immer-draftable"), Zi = Symbol.for("immer-state"), Lie = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ei(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Lie[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var sc = Object.getPrototypeOf;
function _u(e) {
  return !!e && !!e[Zi];
}
function ju(e) {
  var t;
  return e ? r5(e) || Array.isArray(e) || !!e[H_] || !!((t = e.constructor) != null && t[H_]) || fb(e) || hb(e) : !1;
}
var Pie = Object.prototype.constructor.toString();
function r5(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = sc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Pie;
}
function Rm(e, t) {
  db(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function db(e) {
  const t = e[Zi];
  return t ? t.type_ : Array.isArray(e) ? 1 : fb(e) ? 2 : hb(e) ? 3 : 0;
}
function gx(e, t) {
  return db(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function o5(e, t, n) {
  const r = db(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function kie(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function fb(e) {
  return e instanceof Map;
}
function hb(e) {
  return e instanceof Set;
}
function Jl(e) {
  return e.copy_ || e.base_;
}
function mx(e, t) {
  if (fb(e))
    return new Map(e);
  if (hb(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = r5(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Zi];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(sc(e), r);
  } else {
    const r = sc(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function pP(e, t = !1) {
  return gb(e) || _u(e) || !ju(e) || (db(e) > 1 && (e.set = e.add = e.clear = e.delete = Sie), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => pP(r, !0))), e;
}
function Sie() {
  ei(2);
}
function gb(e) {
  return Object.isFrozen(e);
}
var Mie = {};
function Tu(e) {
  const t = Mie[e];
  return t || ei(0, e), t;
}
var bd;
function i5() {
  return bd;
}
function Die(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function V_(e, t) {
  t && (Tu("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function vx(e) {
  yx(e), e.drafts_.forEach(_ie), e.drafts_ = null;
}
function yx(e) {
  e === bd && (bd = e.parent_);
}
function Z_(e) {
  return bd = Die(bd, e);
}
function _ie(e) {
  const t = e[Zi];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function q_(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Zi].modified_ && (vx(t), ei(4)), ju(e) && (e = Fm(t, e), t.parent_ || zm(t, e)), t.patches_ && Tu("Patches").generateReplacementPatches_(
    n[Zi].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Fm(t, n, []), vx(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== n5 ? e : void 0;
}
function Fm(e, t, n) {
  if (gb(t))
    return t;
  const r = t[Zi];
  if (!r)
    return Rm(
      t,
      (o, i) => K_(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return zm(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Rm(
      i,
      (s, l) => K_(e, r, o, s, l, n, a)
    ), zm(e, o, !1), n && e.patches_ && Tu("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function K_(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ei(5), _u(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !gx(t.assigned_, r) ? i.concat(r) : void 0, l = Fm(e, o, s);
    if (o5(n, r, l), _u(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (ju(o) && !gb(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Fm(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && zm(e, o);
  }
}
function zm(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && pP(t, n);
}
function jie(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : i5(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = dP;
  n && (o = [r], i = wd);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var dP = {
  get(e, t) {
    if (t === Zi)
      return e;
    const n = Jl(e);
    if (!gx(n, t))
      return Tie(e, n, t);
    const r = n[t];
    return e.finalized_ || !ju(r) ? r : r === Dw(e.base_, t) ? (_w(e), e.copy_[t] = wx(r, e)) : r;
  },
  has(e, t) {
    return t in Jl(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Jl(e));
  },
  set(e, t, n) {
    const r = s5(Jl(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Dw(Jl(e), t), i = o == null ? void 0 : o[Zi];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (kie(n, o) && (n !== void 0 || gx(e.base_, t)))
        return !0;
      _w(e), bx(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Dw(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, _w(e), bx(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Jl(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ei(11);
  },
  getPrototypeOf(e) {
    return sc(e.base_);
  },
  setPrototypeOf() {
    ei(12);
  }
}, wd = {};
Rm(dP, (e, t) => {
  wd[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
wd.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ei(13), wd.set.call(this, e, t, void 0);
};
wd.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ei(14), dP.set.call(this, e[0], t, n, e[0]);
};
function Dw(e, t) {
  const n = e[Zi];
  return (n ? Jl(n) : e)[t];
}
function Tie(e, t, n) {
  var r;
  const o = s5(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function s5(e, t) {
  if (!(t in e))
    return;
  let n = sc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = sc(n);
  }
}
function bx(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && bx(e.parent_));
}
function _w(e) {
  e.copy_ || (e.copy_ = mx(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Aie = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ei(6), r !== void 0 && typeof r != "function" && ei(7);
      let o;
      if (ju(t)) {
        const i = Z_(this), a = wx(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? vx(i) : yx(i);
        }
        return V_(i, r), q_(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === n5 && (o = void 0), this.autoFreeze_ && pP(o, !0), r) {
          const i = [], a = [];
          Tu("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ei(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ju(e) || ei(8), _u(e) && (e = Iie(e));
    const t = Z_(this), n = wx(e, void 0);
    return n[Zi].isManual_ = !0, yx(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Zi];
    (!n || !n.isManual_) && ei(9);
    const { scope_: r } = n;
    return V_(r, t), q_(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Tu("Patches").applyPatches_;
    return _u(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function wx(e, t) {
  const n = fb(e) ? Tu("MapSet").proxyMap_(e, t) : hb(e) ? Tu("MapSet").proxySet_(e, t) : jie(e, t);
  return (t ? t.scope_ : i5()).drafts_.push(n), n;
}
function Iie(e) {
  return _u(e) || ei(10, e), a5(e);
}
function a5(e) {
  if (!ju(e) || gb(e))
    return e;
  const t = e[Zi];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = mx(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = mx(e, !0);
  return Rm(n, (r, o) => {
    o5(n, r, a5(o));
  }), t && (t.finalized_ = !1), n;
}
var qi = new Aie(), fP = qi.produce;
qi.produceWithPatches.bind(
  qi
);
qi.setAutoFreeze.bind(qi);
qi.setUseStrictShallowCopy.bind(qi);
qi.applyPatches.bind(qi);
var G_ = qi.createDraft.bind(qi), Y_ = qi.finishDraft.bind(qi), Ue = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Ue.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ue.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Ue.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return Ue.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Ue.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Ue.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Ue.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Ue.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Ue.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Ue.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Ue.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Ue.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Ue.isAncestor(t, e) && !Ue.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Ue.equals(i, r) || Ue.endsBefore(i, r) || Ue.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (Ue.equals(a, r) || Ue.isAncestor(a, r))
          return null;
        Ue.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        Ue.equals(s, r) || Ue.endsBefore(s, r) ? r[s.length - 1] -= 1 : Ue.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Ue.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Ue.endsBefore(u, r) ? r[u.length - 1] += 1 : Ue.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Ue.equals(p, d))
          return r;
        if (Ue.isAncestor(p, r) || Ue.equals(p, r)) {
          var y = d.slice();
          return Ue.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else Ue.isSibling(p, d) && (Ue.isAncestor(d, r) || Ue.equals(d, r)) ? Ue.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Ue.endsBefore(d, r) || Ue.equals(d, r) || Ue.isAncestor(d, r) ? (Ue.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Ue.endsBefore(p, r) && (Ue.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Cd(e) {
  "@babel/helpers - typeof";
  return Cd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Cd(e);
}
function Bie(e, t) {
  if (Cd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Cd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Nie(e) {
  var t = Bie(e, "string");
  return Cd(t) === "symbol" ? t : String(t);
}
function gc(e, t, n) {
  return t = Nie(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function X_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? X_(Object(n), !0).forEach(function(r) {
      gc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : X_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Rie = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Pt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of $t.points(t))
          t[l] = mr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Pt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, g] of $t.points(t))
          t[g] = mr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Pt.get(e, E), D = Ue.previous(E), x = Pt.get(e, D), m = Pt.parent(e, E), C = E[E.length - 1];
      if (oo.isText(w) && oo.isText(x))
        x.text += w.text;
      else if (!oo.isText(w) && !oo.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Si.stringify(w), " ").concat(Si.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, z] of $t.points(t))
          t[z] = mr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: R
      } = n;
      if (Ue.isAncestor(L, R))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(R, "] because the destination is inside itself."));
      var B = Pt.get(e, L), H = Pt.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var W = Ue.transform(L, n), q = Pt.get(e, Ue.parent(W)), Y = W[W.length - 1];
      if (q.children.splice(Y, 0, B), t)
        for (var [X, ee] of $t.points(t))
          t[ee] = mr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, k = J[J.length - 1], _ = Pt.parent(e, J);
      if (_.children.splice(k, 1), t)
        for (var [U, M] of $t.points(t)) {
          var $ = mr.transform(U, n);
          if (t != null && $ != null)
            t[M] = $;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of Pt.texts(e))
              if (Ue.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var Z = !1;
            O && j && (Ue.equals(j[1], J) ? Z = !Ue.hasPrevious(j[1]) : Z = Ue.common(O[1], J).length < Ue.common(j[1], J).length), O && !Z ? (U.path = O[1], U.offset = O[0].text.length) : j ? (U.path = j[1], U.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: G,
        text: N
      } = n;
      if (N.length === 0) break;
      var ue = Pt.leaf(e, A), fe = ue.text.slice(0, G), oe = ue.text.slice(G + N.length);
      if (ue.text = fe + oe, t)
        for (var [Ie, qe] of $t.points(t))
          t[qe] = mr.transform(Ie, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Be,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Xe = Pt.get(e, Ge);
      for (var Me in et) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Je = et[Me];
        Je == null ? delete Xe[Me] : Xe[Me] = Je;
      }
      for (var at in Be)
        et.hasOwnProperty(at) || delete Xe[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Se
      } = n;
      if (Se == null)
        t = Se;
      else {
        if (t == null) {
          if (!$t.isRange(Se))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Si.stringify(Se), " when there is no current selection."));
          t = Uc({}, Se);
        }
        for (var _e in Se) {
          var Ae = Se[_e];
          if (Ae == null) {
            if (_e === "anchor" || _e === "focus")
              throw new Error('Cannot remove the "'.concat(_e, '" selection property'));
            delete t[_e];
          } else
            t[_e] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ve,
        position: Ne,
        properties: nt
      } = n;
      if (Ve.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ve, "] because the root node cannot be split."));
      var we = Pt.get(e, Ve), mt = Pt.parent(e, Ve), ot = Ve[Ve.length - 1], st;
      if (oo.isText(we)) {
        var ut = we.text.slice(0, Ne), vt = we.text.slice(Ne);
        we.text = ut, st = Uc(Uc({}, nt), {}, {
          text: vt
        });
      } else {
        var ct = we.children.slice(0, Ne), yt = we.children.slice(Ne);
        we.children = ct, st = Uc(Uc({}, nt), {}, {
          children: yt
        });
      }
      if (mt.children.splice(ot + 1, 0, st), t)
        for (var [Qe, ft] of $t.points(t))
          t[ft] = mr.transform(Qe, n);
      break;
    }
  }
  return t;
}, Fie = {
  transform(e, t) {
    e.children = G_(e.children);
    var n = e.selection && G_(e.selection);
    try {
      n = Rie(e, n, t);
    } finally {
      e.children = Y_(e.children), n ? e.selection = _u(n) ? Y_(n) : n : e.selection = null;
    }
  }
}, zie = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Uie = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, l5 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Bo(r) && Bo(o)) {
      if (!l5(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Wie(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Od(e, t) {
  if (e == null) return {};
  var n = Wie(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var $ie = ["anchor", "focus"];
function J_(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hie(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? J_(Object(n), !0).forEach(function(r) {
      gc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : J_(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $t = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return $t.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = $t.edges(e);
    return t;
  },
  equals(e, t) {
    return mr.equals(e.anchor, t.anchor) && mr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if ($t.isRange(t)) {
      if ($t.includes(e, t.anchor) || $t.includes(e, t.focus))
        return !0;
      var [n, r] = $t.edges(e), [o, i] = $t.edges(t);
      return mr.isBefore(n, o) && mr.isAfter(r, i);
    }
    var [a, s] = $t.edges(e), l = !1, u = !1;
    return mr.isPoint(t) ? (l = mr.compare(t, a) >= 0, u = mr.compare(t, s) <= 0) : (l = Ue.compare(t, a.path) >= 0, u = Ue.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Od(e, $ie), [r, o] = $t.edges(e), [i, a] = $t.edges(t), s = mr.isBefore(r, i) ? i : r, l = mr.isBefore(o, a) ? o : a;
    return mr.isBefore(l, s) ? null : Hie({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return mr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return mr.equals(t, n);
  },
  isExpanded(e) {
    return !$t.isCollapsed(e);
  },
  isForward(e) {
    return !$t.isBackward(e);
  },
  isRange(e) {
    return Bo(e) && mr.isPoint(e.anchor) && mr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = $t.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fP(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = $t.isCollapsed(r);
        $t.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? $t.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = mr.transform(r.anchor, t, {
        affinity: i
      }), u = mr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, Q_ = (e) => Bo(e) && Pt.isNodeList(e.children) && !Kn.isEditor(e), na = {
  isAncestor(e) {
    return Bo(e) && Pt.isNodeList(e.children);
  },
  isElement: Q_,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => na.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Q_(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Vie = ["children"], Zie = ["text"], ej = /* @__PURE__ */ new WeakMap(), Pt = {
  ancestor(e, t) {
    var n = Pt.get(e, t);
    if (oo.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Si.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ue.ancestors(t, n)) {
        var o = Pt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (oo.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Si.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Si.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Pt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Pt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Ue.common(t, n), o = Pt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Pt.get(e, t);
    if (Kn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Si.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Pt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Pt.nodes(e, t))
        na.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (na.isAncestor(e)) {
      var t = Od(e, Vie);
      return t;
    } else {
      var t = Od(e, Zie);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Pt.get(e, n); r && !(oo.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (oo.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Si.stringify(e)));
    var n = fP({
      children: e.children
    }, (r) => {
      var [o, i] = $t.edges(t), a = Pt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !$t.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!$t.includes(t, s)) {
          var l = Pt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (Ue.equals(s, i.path)) {
          var c = Pt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (Ue.equals(s, o.path)) {
          var p = Pt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Kn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (oo.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Si.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (oo.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return oo.isText(e) || na.isElement(e) || Kn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = ej.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Pt.isNode(r));
    return ej.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Pt.get(e, n); r && !(oo.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Pt.get(e, t);
    if (!oo.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Si.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Ue.levels(t, n)) {
        var o = Pt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return na.isElement(e) && na.isElementProps(t) && na.matches(e, t) || oo.isText(e) && oo.isTextProps(t) && oo.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? Ue.isBefore(s, i) : Ue.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !oo.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          Ue.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Pt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = Ue.next(s);
          if (Pt.has(e, c)) {
            s = c, l = Pt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = Ue.previous(s);
          s = p, l = Pt.get(e, s);
          continue;
        }
        s = Ue.parent(s), l = Pt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Ue.parent(t), r = Pt.get(e, n);
    if (oo.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return oo.isText(e) ? e.text : e.children.map(Pt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Pt.nodes(e, t))
        oo.isText(n) && (yield [n, r]);
    }();
  }
};
function tj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tj(Object(n), !0).forEach(function(r) {
      gc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Op = {
  isNodeOperation(e) {
    return Op.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Bo(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Ue.isPath(e.path) && Pt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ue.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Ue.isPath(e.path) && Bo(e.properties);
      case "move_node":
        return Ue.isPath(e.path) && Ue.isPath(e.newPath);
      case "remove_node":
        return Ue.isPath(e.path) && Pt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Ue.isPath(e.path);
      case "set_node":
        return Ue.isPath(e.path) && Bo(e.properties) && Bo(e.newProperties);
      case "set_selection":
        return e.properties === null && $t.isRange(e.newProperties) || e.newProperties === null && $t.isRange(e.properties) || Bo(e.properties) && Bo(e.newProperties);
      case "split_node":
        return Ue.isPath(e.path) && typeof e.position == "number" && Bo(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Op.isOperation(t));
  },
  isSelectionOperation(e) {
    return Op.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Op.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return xr(xr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return xr(xr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return xr(xr({}, e), {}, {
          type: "split_node",
          path: Ue.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Ue.equals(t, n))
          return e;
        if (Ue.isSibling(n, t))
          return xr(xr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Ue.transform(n, e), o = Ue.transform(Ue.next(n), e);
        return xr(xr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return xr(xr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return xr(xr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return xr(xr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? xr(xr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? xr(xr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : xr(xr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return xr(xr({}, e), {}, {
          type: "merge_node",
          path: Ue.next(e.path)
        });
    }
  }
}, nj = /* @__PURE__ */ new WeakMap(), qie = (e) => {
  var t = nj.get(e);
  if (t !== void 0)
    return t;
  if (!Bo(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Bo(e.marks)) && (e.selection === null || $t.isRange(e.selection)) && Pt.isNodeList(e.children) && Op.isOperationList(e.operations);
  return nj.set(e, n), n;
}, Kn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return qie(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function rj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rj(Object(n), !0).forEach(function(r) {
      gc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var mr = {
  compare(e, t) {
    var n = Ue.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return mr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return mr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Ue.equals(e.path, t.path);
  },
  isPoint(e) {
    return Bo(e) && typeof e.offset == "number" && Ue.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return fP(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Ue.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Ue.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Ue.equals(t.path, i) && (r.offset += t.position), r.path = Ue.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Ue.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Ue.equals(t.path, i) || Ue.isAncestor(t.path, i))
            return null;
          r.path = Ue.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Ue.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = Ue.transform(i, t, oj(oj({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Ue.transform(i, t, n);
          break;
        }
      }
    });
  }
}, ij = void 0, Si = {
  setScrubber(e) {
    ij = e;
  },
  stringify(e) {
    return JSON.stringify(e, ij);
  }
}, Kie = ["text"], Gie = ["anchor", "focus"];
function sj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $s(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sj(Object(n), !0).forEach(function(r) {
      gc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var oo = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Od(i, Kie);
      return a;
    }
    return l5(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Bo(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => oo.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [$s({}, e)];
    for (var r of t) {
      var o = Od(r, Gie), [i, a] = $t.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, g = void 0;
        if (c < l) {
          var E = c - y;
          g = $s($s({}, f), {}, {
            text: f.text.slice(E)
          }), f = $s($s({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > y) {
          var w = u - y;
          v = $s($s({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = $s($s({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, Yie = (e) => e.selection ? e.selection : e.children.length > 0 ? Kn.end(e, []) : [0], cr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(cr || (cr = {}));
cr.L, cr.L | cr.V | cr.LV | cr.LVT, cr.LV | cr.V, cr.V | cr.T, cr.LVT | cr.T, cr.T, cr.Any, cr.Extend | cr.ZWJ, cr.Any, cr.SpacingMark, cr.Prepend, cr.Any, cr.ZWJ, cr.ExtPict, cr.RI, cr.RI;
var Xie = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Kn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Yie(e)
      } = n;
      if (Ue.isPath(o) && (o = Kn.range(e, o)), $t.isRange(o))
        if ($t.isCollapsed(o))
          o = o.anchor;
        else {
          var i = $t.end(o);
          if (!r && Kn.void(e, {
            at: i
          }))
            return;
          var a = $t.start(o), s = Kn.pointRef(e, a), l = Kn.pointRef(e, i);
          Um.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Um.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Kn.void(e, {
        at: o
      }) || Kn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function aj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aj(Object(n), !0).forEach(function(r) {
      gc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Um = fh(fh(fh(fh({}, Fie), zie), Uie), Xie), u5 = {}, hP = {}, gP = {};
Object.defineProperty(gP, "__esModule", { value: !0 });
gP.default = tse;
var lj = "html", uj = "head", hh = "body", Jie = /<([a-zA-Z]+[0-9]?)/, cj = /<head[^]*>/i, pj = /<body[^]*>/i, Wm = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Cx = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, dj = typeof window == "object" && window.DOMParser;
if (typeof dj == "function") {
  var Qie = new dj(), ese = "text/html";
  Cx = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Qie.parseFromString(e, ese);
  }, Wm = Cx;
}
if (typeof document == "object" && document.implementation) {
  var gh = document.implementation.createHTMLDocument();
  Wm = function(e, t) {
    if (t) {
      var n = gh.documentElement.querySelector(t);
      return n && (n.innerHTML = e), gh;
    }
    return gh.documentElement.innerHTML = e, gh;
  };
}
var mh = typeof document == "object" && document.createElement("template"), Ox;
mh && mh.content && (Ox = function(e) {
  return mh.innerHTML = e, mh.content.childNodes;
});
function tse(e) {
  var t, n, r = e.match(Jie), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case lj: {
      var i = Cx(e);
      if (!cj.test(e)) {
        var a = i.querySelector(uj);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!pj.test(e)) {
        var a = i.querySelector(hh);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(lj);
    }
    case uj:
    case hh: {
      var s = Wm(e).querySelectorAll(o);
      return pj.test(e) && cj.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (Ox)
        return Ox(e);
      var a = Wm(e, hh).querySelector(hh);
      return a.childNodes;
    }
  }
}
var mb = {}, mP = {}, vP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(vP);
var Xt = {}, yl = tr && tr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Np = tr && tr.__assign || function() {
  return Np = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Np.apply(this, arguments);
};
Object.defineProperty(Xt, "__esModule", { value: !0 });
Xt.cloneNode = Xt.hasChildren = Xt.isDocument = Xt.isDirective = Xt.isComment = Xt.isText = Xt.isCDATA = Xt.isTag = Xt.Element = Xt.Document = Xt.CDATA = Xt.NodeWithChildren = Xt.ProcessingInstruction = Xt.Comment = Xt.Text = Xt.DataNode = Xt.Node = void 0;
var di = vP, yP = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), bP(this, t);
    }, e;
  }()
);
Xt.Node = yP;
var vb = (
  /** @class */
  function(e) {
    yl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(yP)
);
Xt.DataNode = vb;
var c5 = (
  /** @class */
  function(e) {
    yl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = di.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(vb)
);
Xt.Text = c5;
var p5 = (
  /** @class */
  function(e) {
    yl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = di.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(vb)
);
Xt.Comment = p5;
var d5 = (
  /** @class */
  function(e) {
    yl(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = di.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(vb)
);
Xt.ProcessingInstruction = d5;
var yb = (
  /** @class */
  function(e) {
    yl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(yP)
);
Xt.NodeWithChildren = yb;
var f5 = (
  /** @class */
  function(e) {
    yl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = di.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(yb)
);
Xt.CDATA = f5;
var h5 = (
  /** @class */
  function(e) {
    yl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = di.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(yb)
);
Xt.Document = h5;
var g5 = (
  /** @class */
  function(e) {
    yl(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? di.ElementType.Script : n === "style" ? di.ElementType.Style : di.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(yb)
);
Xt.Element = g5;
function m5(e) {
  return (0, di.isTag)(e);
}
Xt.isTag = m5;
function v5(e) {
  return e.type === di.ElementType.CDATA;
}
Xt.isCDATA = v5;
function y5(e) {
  return e.type === di.ElementType.Text;
}
Xt.isText = y5;
function b5(e) {
  return e.type === di.ElementType.Comment;
}
Xt.isComment = b5;
function w5(e) {
  return e.type === di.ElementType.Directive;
}
Xt.isDirective = w5;
function C5(e) {
  return e.type === di.ElementType.Root;
}
Xt.isDocument = C5;
function nse(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Xt.hasChildren = nse;
function bP(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (y5(e))
    n = new c5(e.data);
  else if (b5(e))
    n = new p5(e.data);
  else if (m5(e)) {
    var r = t ? jw(e.children) : [], o = new g5(e.name, Np({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Np({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Np({}, e["x-attribsPrefix"])), n = o;
  } else if (v5(e)) {
    var r = t ? jw(e.children) : [], i = new f5(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (C5(e)) {
    var r = t ? jw(e.children) : [], a = new h5(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (w5(e)) {
    var s = new d5(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Xt.cloneNode = bP;
function jw(e) {
  for (var t = e.map(function(r) {
    return bP(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = tr && tr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = tr && tr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = vP, o = Xt;
  n(Xt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(mP);
var O5 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(O5);
Object.defineProperty(mb, "__esModule", { value: !0 });
mb.formatAttributes = x5;
mb.formatDOM = E5;
var vh = mP, rse = O5;
function ose(e) {
  return rse.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function x5(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function ise(e) {
  e = e.toLowerCase();
  var t = ose(e);
  return t || e;
}
function E5(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = ise(s.nodeName);
        o = new vh.Element(l, x5(s.attributes)), o.children = E5(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new vh.Text(s.nodeValue);
        break;
      case 8:
        o = new vh.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new vh.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var sse = tr && tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(hP, "__esModule", { value: !0 });
hP.default = cse;
var ase = sse(gP), lse = mb, use = /<(![a-zA-Z\s]+)>/;
function cse(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(use), n = t ? t[1] : void 0;
  return (0, lse.formatDOM)((0, ase.default)(e), null, n);
}
var bb = {}, fs = {}, wb = {}, pse = 0;
wb.SAME = pse;
var dse = 1;
wb.CAMELCASE = dse;
wb.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const L5 = 0, bl = 1, Cb = 2, Ob = 3, wP = 4, P5 = 5, k5 = 6;
function fse(e) {
  return Mo.hasOwnProperty(e) ? Mo[e] : null;
}
function Zo(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Cb || t === Ob || t === wP, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Mo = {}, hse = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
hse.forEach((e) => {
  Mo[e] = new Zo(
    e,
    L5,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Mo[e] = new Zo(
    e,
    bl,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Mo[e] = new Zo(
    e,
    Cb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Mo[e] = new Zo(
    e,
    Cb,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Mo[e] = new Zo(
    e,
    Ob,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Mo[e] = new Zo(
    e,
    Ob,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Mo[e] = new Zo(
    e,
    wP,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Mo[e] = new Zo(
    e,
    k5,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Mo[e] = new Zo(
    e,
    P5,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const CP = /[\-\:]([a-z])/g, OP = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(CP, OP);
  Mo[t] = new Zo(
    t,
    bl,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(CP, OP);
  Mo[t] = new Zo(
    t,
    bl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(CP, OP);
  Mo[t] = new Zo(
    t,
    bl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Mo[e] = new Zo(
    e,
    bl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const gse = "xlinkHref";
Mo[gse] = new Zo(
  "xlinkHref",
  bl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Mo[e] = new Zo(
    e,
    bl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: mse,
  SAME: vse,
  possibleStandardNames: fj
} = wb, yse = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", bse = yse + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", wse = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + bse + "]*$")
), Cse = Object.keys(
  fj
).reduce((e, t) => {
  const n = fj[t];
  return n === vse ? e[t] = t : n === mse ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
fs.BOOLEAN = Ob;
fs.BOOLEANISH_STRING = Cb;
fs.NUMERIC = P5;
fs.OVERLOADED_BOOLEAN = wP;
fs.POSITIVE_NUMERIC = k5;
fs.RESERVED = L5;
fs.STRING = bl;
fs.getPropertyInfo = fse;
fs.isCustomAttribute = wse;
fs.possibleStandardNames = Cse;
var xP = {}, EP = {}, hj = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Ose = /\n/g, xse = /^\s*/, Ese = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Lse = /^:\s*/, Pse = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, kse = /^[;\s]*/, Sse = /^\s+|\s+$/g, Mse = `
`, gj = "/", mj = "*", su = "", Dse = "comment", _se = "declaration", jse = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(Ose);
    v && (n += v.length);
    var g = f.lastIndexOf(Mse);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var g = v[0];
      return o(g), e = e.slice(g.length), v;
    }
  }
  function u() {
    l(xse);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(gj != e.charAt(0) || mj != e.charAt(1))) {
      for (var v = 2; su != e.charAt(v) && (mj != e.charAt(v) || gj != e.charAt(v + 1)); )
        ++v;
      if (v += 2, su === e.charAt(v - 1))
        return s("End of comment missing");
      var g = e.slice(2, v - 2);
      return r += 2, o(g), e = e.slice(v), r += 2, f({
        type: Dse,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), v = l(Ese);
    if (v) {
      if (p(), !l(Lse)) return s("property missing ':'");
      var g = l(Pse), E = f({
        type: _se,
        property: vj(v[0].replace(hj, su)),
        value: g ? vj(g[0].replace(hj, su)) : su
      });
      return l(kse), E;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function vj(e) {
  return e ? e.replace(Sse, su) : su;
}
var Tse = tr && tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(EP, "__esModule", { value: !0 });
EP.default = Ise;
var Ase = Tse(jse);
function Ise(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Ase.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var xb = {};
Object.defineProperty(xb, "__esModule", { value: !0 });
xb.camelCase = void 0;
var Bse = /^--[a-zA-Z0-9_-]+$/, Nse = /-([a-z])/g, Rse = /^[^-]+$/, Fse = /^-(webkit|moz|ms|o|khtml)-/, zse = /^-(ms)-/, Use = function(e) {
  return !e || Rse.test(e) || Bse.test(e);
}, Wse = function(e, t) {
  return t.toUpperCase();
}, yj = function(e, t) {
  return "".concat(t, "-");
}, $se = function(e, t) {
  return t === void 0 && (t = {}), Use(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(zse, yj) : e = e.replace(Fse, yj), e.replace(Nse, Wse));
};
xb.camelCase = $se;
var Hse = tr && tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Vse = Hse(EP), Zse = xb;
function xx(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Vse.default)(e, function(r, o) {
    r && o && (n[(0, Zse.camelCase)(r, t)] = o);
  }), n;
}
xx.default = xx;
var qse = xx;
(function(e) {
  var t = tr && tr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Ce, r = t(qse), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(xP);
Object.defineProperty(bb, "__esModule", { value: !0 });
bb.default = Xse;
var xp = fs, bj = xP, Kse = ["checked", "value"], Gse = ["input", "select", "textarea"], Yse = {
  reset: !0,
  submit: !0
};
function Xse(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && Yse[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, xp.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = wj(a);
    if (s) {
      var l = (0, xp.getPropertyInfo)(s);
      switch (Kse.includes(s) && Gse.includes(t) && !r && (s = wj("default" + a)), n[s] = i, l && l.type) {
        case xp.BOOLEAN:
          n[s] = !0;
          break;
        case xp.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    bj.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, bj.setStyleProp)(e.style, n), n;
}
function wj(e) {
  return xp.possibleStandardNames[e];
}
var LP = {}, Jse = tr && tr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(LP, "__esModule", { value: !0 });
LP.default = S5;
var Tw = Ce, Qse = Jse(bb), Rp = xP, eae = {
  cloneElement: Tw.cloneElement,
  createElement: Tw.createElement,
  isValidElement: Tw.isValidElement
};
function S5(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Rp.returnFirstArg, i = t.library || eae, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, Rp.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    tae(f) ? ((0, Rp.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, Qse.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (g = S5(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function tae(e) {
  return Rp.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Rp.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = tr && tr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(hP);
  e.htmlToDOM = n.default;
  var r = t(bb);
  e.attributesToProps = r.default;
  var o = t(LP);
  e.domToReact = o.default;
  var i = mP;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(u5);
const nae = /* @__PURE__ */ Oie(u5);
nae.default;
var nr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function rae(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ex = { exports: {} }, Wc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cj;
function oae() {
  if (Cj) return Wc;
  Cj = 1;
  var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return Wc.Fragment = n, Wc.jsx = a, Wc.jsxs = a, Wc;
}
var yh = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Oj;
function iae() {
  return Oj || (Oj = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[v];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, K = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          K[ne - 1] = arguments[ne];
        D("error", b, K);
      }
    }
    function D(b, I, K) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (I += "%s", K = K.concat([ae]));
        var ce = K.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function R(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || z || b === o || b === u || b === c || S || b === y || x || m || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function B(b, I, K) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var ae = I.displayName || I.name || "";
      return ae !== "" ? K + "(" + ae + ")" : K;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return H(I) + ".Consumer";
          case a:
            var K = b;
            return H(K._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var ae = b, ce = ae._payload, se = ae._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, q = 0, Y, X, ee, J, k, _, U;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function $() {
      {
        if (q === 0) {
          Y = console.log, X = console.info, ee = console.warn, J = console.error, k = console.group, _ = console.groupCollapsed, U = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, b, {
              value: Y
            }),
            info: W({}, b, {
              value: X
            }),
            warn: W({}, b, {
              value: ee
            }),
            error: W({}, b, {
              value: J
            }),
            group: W({}, b, {
              value: k
            }),
            groupCollapsed: W({}, b, {
              value: _
            }),
            groupEnd: W({}, b, {
              value: U
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, F;
    function T(b, I, K) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            F = ne && ne[1] || "";
          }
        return `
` + F + b;
      }
    }
    var Z = !1, A;
    {
      var G = typeof WeakMap == "function" ? WeakMap : Map;
      A = new G();
    }
    function N(b, I) {
      if (!b || Z)
        return "";
      {
        var K = A.get(b);
        if (K !== void 0)
          return K;
      }
      var ne;
      Z = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Te) {
              ne = Te;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (Te) {
              ne = Te;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Te) {
            ne = Te;
          }
          b();
        }
      } catch (Te) {
        if (Te && ne && typeof Te.stack == "string") {
          for (var ie = Te.stack.split(`
`), De = ne.stack.split(`
`), de = ie.length - 1, he = De.length - 1; de >= 1 && he >= 0 && ie[de] !== De[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== De[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== De[he]) {
                    var Ze = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ze.includes("<anonymous>") && (Ze = Ze.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ze), Ze;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        Z = !1, j.current = ce, O(), Error.prepareStackTrace = ae;
      }
      var Ot = b ? b.displayName || b.name : "", gt = Ot ? T(Ot) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, I, K) {
      return N(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, K) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, K);
          case d: {
            var ne = b, ae = ne._payload, ce = ne._init;
            try {
              return oe(ce(ae), I, K);
            } catch {
            }
          }
        }
      return "";
    }
    var Ie = Object.prototype.hasOwnProperty, qe = {}, Ge = E.ReactDebugCurrentFrame;
    function Be(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(K);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, K, ne, ae) {
      {
        var ce = Function.call.bind(Ie);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var De = Error((ne || "React class") + ": " + K + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              ie = b[se](I, se, ne, K, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Be(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", K, se, typeof ie), Be(null)), ie instanceof Error && !(ie.message in qe) && (qe[ie.message] = !0, Be(ae), w("Failed %s type: %s", K, ie.message), Be(null));
          }
      }
    }
    var Xe = Array.isArray;
    function Me(b) {
      return Xe(b);
    }
    function Je(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, K = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return K;
      }
    }
    function at(b) {
      try {
        return Se(b), !1;
      } catch {
        return !0;
      }
    }
    function Se(b) {
      return "" + b;
    }
    function _e(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Je(b)), Se(b);
    }
    var Ae = E.ReactCurrentOwner, Ve = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ne, nt, we;
    we = {};
    function mt(b) {
      if (Ie.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function ot(b) {
      if (Ie.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function st(b, I) {
      if (typeof b.ref == "string" && Ae.current && I && Ae.current.stateNode !== I) {
        var K = V(Ae.current.type);
        we[K] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Ae.current.type), b.ref), we[K] = !0);
      }
    }
    function ut(b, I) {
      {
        var K = function() {
          Ne || (Ne = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: K,
          configurable: !0
        });
      }
    }
    function vt(b, I) {
      {
        var K = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: K,
          configurable: !0
        });
      }
    }
    var ct = function(b, I, K, ne, ae, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: K,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function yt(b, I, K, ne, ae) {
      {
        var ce, se = {}, ie = null, De = null;
        K !== void 0 && (_e(K), ie = "" + K), ot(I) && (_e(I.key), ie = "" + I.key), mt(I) && (De = I.ref, st(I, ae));
        for (ce in I)
          Ie.call(I, ce) && !Ve.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || De) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && ut(se, he), De && vt(se, he);
        }
        return ct(b, ie, De, ae, ne, Ae.current, se);
      }
    }
    var Qe = E.ReactCurrentOwner, ft = E.ReactDebugCurrentFrame;
    function tt(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        ft.setExtraStackFrame(K);
      } else
        ft.setExtraStackFrame(null);
    }
    var bt;
    bt = !1;
    function pt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Dt() {
      {
        if (Qe.current) {
          var b = V(Qe.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function wt(b) {
      return "";
    }
    var _t = {};
    function Ct(b) {
      {
        var I = Dt();
        if (!I) {
          var K = typeof b == "string" ? b : b.displayName || b.name;
          K && (I = `

Check the top-level render call using <` + K + ">.");
        }
        return I;
      }
    }
    function jt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var K = Ct(I);
        if (_t[K])
          return;
        _t[K] = !0;
        var ne = "";
        b && b._owner && b._owner !== Qe.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), tt(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', K, ne), tt(null);
      }
    }
    function Cn(b, I) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var K = 0; K < b.length; K++) {
            var ne = b[K];
            pt(ne) && jt(ne, I);
          }
        else if (pt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ae = g(b);
          if (typeof ae == "function" && ae !== b.entries)
            for (var ce = ae.call(b), se; !(se = ce.next()).done; )
              pt(se.value) && jt(se.value, I);
        }
      }
    }
    function ht(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var K;
        if (typeof I == "function")
          K = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          K = I.propTypes;
        else
          return;
        if (K) {
          var ne = V(I);
          et(K, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !bt) {
          bt = !0;
          var ae = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function re(b) {
      {
        for (var I = Object.keys(b.props), K = 0; K < I.length; K++) {
          var ne = I[K];
          if (ne !== "children" && ne !== "key") {
            tt(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), tt(null);
            break;
          }
        }
        b.ref !== null && (tt(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var mo = {};
    function vo(b, I, K, ne, ae, ce) {
      {
        var se = R(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = wt();
          De ? ie += De : ie += Dt();
          var de;
          b === null ? de = "null" : Me(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = yt(b, I, K, ae, ce);
        if (he == null)
          return he;
        if (se) {
          var Ze = I.children;
          if (Ze !== void 0)
            if (ne)
              if (Me(Ze)) {
                for (var Ot = 0; Ot < Ze.length; Ot++)
                  Cn(Ze[Ot], b);
                Object.freeze && Object.freeze(Ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Cn(Ze, b);
        }
        if (Ie.call(I, "key")) {
          var gt = V(b), Te = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), ar = Te.length > 0 ? "{key: someKey, " + Te.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!mo[gt + ar]) {
            var Ei = Te.length > 0 ? "{" + Te.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ar, gt, Ei, gt), mo[gt + ar] = !0;
          }
        }
        return b === r ? re(he) : ht(he), he;
      }
    }
    function wi(b, I, K) {
      return vo(b, I, K, !0);
    }
    function Ci(b, I, K) {
      return vo(b, I, K, !1);
    }
    var Oi = Ci, xi = wi;
    yh.Fragment = r, yh.jsx = Oi, yh.jsxs = xi;
  }()), yh;
}
process.env.NODE_ENV === "production" ? Ex.exports = oae() : Ex.exports = iae();
var si = Ex.exports;
Ye({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function xj(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function No(e) {
  var t, n;
  return xj(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(xj(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var M5 = Symbol.for("immer-nothing"), Ej = Symbol.for("immer-draftable"), Ki = Symbol.for("immer-state"), sae = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ti(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = sae[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var ac = Object.getPrototypeOf;
function Au(e) {
  return !!e && !!e[Ki];
}
function Iu(e) {
  var t;
  return e ? D5(e) || Array.isArray(e) || !!e[Ej] || !!((t = e.constructor) != null && t[Ej]) || Lb(e) || Pb(e) : !1;
}
var aae = Object.prototype.constructor.toString();
function D5(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = ac(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === aae;
}
function $m(e, t) {
  Eb(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Eb(e) {
  const t = e[Ki];
  return t ? t.type_ : Array.isArray(e) ? 1 : Lb(e) ? 2 : Pb(e) ? 3 : 0;
}
function Lx(e, t) {
  return Eb(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function _5(e, t, n) {
  const r = Eb(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function lae(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Lb(e) {
  return e instanceof Map;
}
function Pb(e) {
  return e instanceof Set;
}
function Ql(e) {
  return e.copy_ || e.base_;
}
function Px(e, t) {
  if (Lb(e))
    return new Map(e);
  if (Pb(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = D5(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ki];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(ac(e), r);
  } else {
    const r = ac(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function PP(e, t = !1) {
  return kb(e) || Au(e) || !Iu(e) || (Eb(e) > 1 && (e.set = e.add = e.clear = e.delete = uae), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => PP(r, !0))), e;
}
function uae() {
  ti(2);
}
function kb(e) {
  return Object.isFrozen(e);
}
var cae = {};
function Bu(e) {
  const t = cae[e];
  return t || ti(0, e), t;
}
var xd;
function j5() {
  return xd;
}
function pae(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Lj(e, t) {
  t && (Bu("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function kx(e) {
  Sx(e), e.drafts_.forEach(dae), e.drafts_ = null;
}
function Sx(e) {
  e === xd && (xd = e.parent_);
}
function Pj(e) {
  return xd = pae(xd, e);
}
function dae(e) {
  const t = e[Ki];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function kj(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ki].modified_ && (kx(t), ti(4)), Iu(e) && (e = Hm(t, e), t.parent_ || Vm(t, e)), t.patches_ && Bu("Patches").generateReplacementPatches_(
    n[Ki].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Hm(t, n, []), kx(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== M5 ? e : void 0;
}
function Hm(e, t, n) {
  if (kb(t))
    return t;
  const r = t[Ki];
  if (!r)
    return $m(
      t,
      (o, i) => Sj(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Vm(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), $m(
      i,
      (s, l) => Sj(e, r, o, s, l, n, a)
    ), Vm(e, o, !1), n && e.patches_ && Bu("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function Sj(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ti(5), Au(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Lx(t.assigned_, r) ? i.concat(r) : void 0, l = Hm(e, o, s);
    if (_5(n, r, l), Au(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Iu(o) && !kb(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Hm(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Vm(e, o);
  }
}
function Vm(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && PP(t, n);
}
function fae(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : j5(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = kP;
  n && (o = [r], i = Ed);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var kP = {
  get(e, t) {
    if (t === Ki)
      return e;
    const n = Ql(e);
    if (!Lx(n, t))
      return hae(e, n, t);
    const r = n[t];
    return e.finalized_ || !Iu(r) ? r : r === Aw(e.base_, t) ? (Iw(e), e.copy_[t] = Dx(r, e)) : r;
  },
  has(e, t) {
    return t in Ql(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ql(e));
  },
  set(e, t, n) {
    const r = T5(Ql(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Aw(Ql(e), t), i = o == null ? void 0 : o[Ki];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (lae(n, o) && (n !== void 0 || Lx(e.base_, t)))
        return !0;
      Iw(e), Mx(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Aw(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Iw(e), Mx(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ql(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ti(11);
  },
  getPrototypeOf(e) {
    return ac(e.base_);
  },
  setPrototypeOf() {
    ti(12);
  }
}, Ed = {};
$m(kP, (e, t) => {
  Ed[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Ed.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ti(13), Ed.set.call(this, e, t, void 0);
};
Ed.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ti(14), kP.set.call(this, e[0], t, n, e[0]);
};
function Aw(e, t) {
  const n = e[Ki];
  return (n ? Ql(n) : e)[t];
}
function hae(e, t, n) {
  var r;
  const o = T5(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function T5(e, t) {
  if (!(t in e))
    return;
  let n = ac(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = ac(n);
  }
}
function Mx(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Mx(e.parent_));
}
function Iw(e) {
  e.copy_ || (e.copy_ = Px(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var gae = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ti(6), r !== void 0 && typeof r != "function" && ti(7);
      let o;
      if (Iu(t)) {
        const i = Pj(this), a = Dx(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? kx(i) : Sx(i);
        }
        return Lj(i, r), kj(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === M5 && (o = void 0), this.autoFreeze_ && PP(o, !0), r) {
          const i = [], a = [];
          Bu("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ti(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Iu(e) || ti(8), Au(e) && (e = mae(e));
    const t = Pj(this), n = Dx(e, void 0);
    return n[Ki].isManual_ = !0, Sx(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ki];
    (!n || !n.isManual_) && ti(9);
    const { scope_: r } = n;
    return Lj(r, t), kj(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Bu("Patches").applyPatches_;
    return Au(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Dx(e, t) {
  const n = Lb(e) ? Bu("MapSet").proxyMap_(e, t) : Pb(e) ? Bu("MapSet").proxySet_(e, t) : fae(e, t);
  return (t ? t.scope_ : j5()).drafts_.push(n), n;
}
function mae(e) {
  return Au(e) || ti(10, e), A5(e);
}
function A5(e) {
  if (!Iu(e) || kb(e))
    return e;
  const t = e[Ki];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Px(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Px(e, !0);
  return $m(n, (r, o) => {
    _5(n, r, A5(o));
  }), t && (t.finalized_ = !1), n;
}
var Gi = new gae(), SP = Gi.produce;
Gi.produceWithPatches.bind(
  Gi
);
Gi.setAutoFreeze.bind(Gi);
Gi.setUseStrictShallowCopy.bind(Gi);
Gi.applyPatches.bind(Gi);
var Mj = Gi.createDraft.bind(Gi), Dj = Gi.finishDraft.bind(Gi), We = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = We.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return We.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return We.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return We.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return We.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && We.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return We.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && We.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && We.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && We.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && We.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && We.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!We.isAncestor(t, e) && !We.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (We.equals(i, r) || We.endsBefore(i, r) || We.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (We.equals(a, r) || We.isAncestor(a, r))
          return null;
        We.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        We.equals(s, r) || We.endsBefore(s, r) ? r[s.length - 1] -= 1 : We.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (We.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else We.endsBefore(u, r) ? r[u.length - 1] += 1 : We.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (We.equals(p, d))
          return r;
        if (We.isAncestor(p, r) || We.equals(p, r)) {
          var y = d.slice();
          return We.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else We.isSibling(p, d) && (We.isAncestor(d, r) || We.equals(d, r)) ? We.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : We.endsBefore(d, r) || We.equals(d, r) || We.isAncestor(d, r) ? (We.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : We.endsBefore(p, r) && (We.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Ld(e) {
  "@babel/helpers - typeof";
  return Ld = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ld(e);
}
function vae(e, t) {
  if (Ld(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ld(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function yae(e) {
  var t = vae(e, "string");
  return Ld(t) === "symbol" ? t : String(t);
}
function mc(e, t, n) {
  return t = yae(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function _j(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $c(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _j(Object(n), !0).forEach(function(r) {
      mc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _j(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var bae = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = kt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Ht.points(t))
          t[l] = vr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = kt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, g] of Ht.points(t))
          t[g] = vr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = kt.get(e, E), D = We.previous(E), x = kt.get(e, D), m = kt.parent(e, E), C = E[E.length - 1];
      if (io.isText(w) && io.isText(x))
        x.text += w.text;
      else if (!io.isText(w) && !io.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Mi.stringify(w), " ").concat(Mi.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, z] of Ht.points(t))
          t[z] = vr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: R
      } = n;
      if (We.isAncestor(L, R))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(R, "] because the destination is inside itself."));
      var B = kt.get(e, L), H = kt.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var W = We.transform(L, n), q = kt.get(e, We.parent(W)), Y = W[W.length - 1];
      if (q.children.splice(Y, 0, B), t)
        for (var [X, ee] of Ht.points(t))
          t[ee] = vr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, k = J[J.length - 1], _ = kt.parent(e, J);
      if (_.children.splice(k, 1), t)
        for (var [U, M] of Ht.points(t)) {
          var $ = vr.transform(U, n);
          if (t != null && $ != null)
            t[M] = $;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of kt.texts(e))
              if (We.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var Z = !1;
            O && j && (We.equals(j[1], J) ? Z = !We.hasPrevious(j[1]) : Z = We.common(O[1], J).length < We.common(j[1], J).length), O && !Z ? (U.path = O[1], U.offset = O[0].text.length) : j ? (U.path = j[1], U.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: G,
        text: N
      } = n;
      if (N.length === 0) break;
      var ue = kt.leaf(e, A), fe = ue.text.slice(0, G), oe = ue.text.slice(G + N.length);
      if (ue.text = fe + oe, t)
        for (var [Ie, qe] of Ht.points(t))
          t[qe] = vr.transform(Ie, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Be,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Xe = kt.get(e, Ge);
      for (var Me in et) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Je = et[Me];
        Je == null ? delete Xe[Me] : Xe[Me] = Je;
      }
      for (var at in Be)
        et.hasOwnProperty(at) || delete Xe[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Se
      } = n;
      if (Se == null)
        t = Se;
      else {
        if (t == null) {
          if (!Ht.isRange(Se))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Mi.stringify(Se), " when there is no current selection."));
          t = $c({}, Se);
        }
        for (var _e in Se) {
          var Ae = Se[_e];
          if (Ae == null) {
            if (_e === "anchor" || _e === "focus")
              throw new Error('Cannot remove the "'.concat(_e, '" selection property'));
            delete t[_e];
          } else
            t[_e] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ve,
        position: Ne,
        properties: nt
      } = n;
      if (Ve.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ve, "] because the root node cannot be split."));
      var we = kt.get(e, Ve), mt = kt.parent(e, Ve), ot = Ve[Ve.length - 1], st;
      if (io.isText(we)) {
        var ut = we.text.slice(0, Ne), vt = we.text.slice(Ne);
        we.text = ut, st = $c($c({}, nt), {}, {
          text: vt
        });
      } else {
        var ct = we.children.slice(0, Ne), yt = we.children.slice(Ne);
        we.children = ct, st = $c($c({}, nt), {}, {
          children: yt
        });
      }
      if (mt.children.splice(ot + 1, 0, st), t)
        for (var [Qe, ft] of Ht.points(t))
          t[ft] = vr.transform(Qe, n);
      break;
    }
  }
  return t;
}, wae = {
  transform(e, t) {
    e.children = Mj(e.children);
    var n = e.selection && Mj(e.selection);
    try {
      n = bae(e, n, t);
    } finally {
      e.children = Dj(e.children), n ? e.selection = Au(n) ? Dj(n) : n : e.selection = null;
    }
  }
}, Cae = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Oae = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, I5 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (No(r) && No(o)) {
      if (!I5(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function xae(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Pd(e, t) {
  if (e == null) return {};
  var n = xae(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var Eae = ["anchor", "focus"];
function jj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lae(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jj(Object(n), !0).forEach(function(r) {
      mc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ht = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Ht.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Ht.edges(e);
    return t;
  },
  equals(e, t) {
    return vr.equals(e.anchor, t.anchor) && vr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Ht.isRange(t)) {
      if (Ht.includes(e, t.anchor) || Ht.includes(e, t.focus))
        return !0;
      var [n, r] = Ht.edges(e), [o, i] = Ht.edges(t);
      return vr.isBefore(n, o) && vr.isAfter(r, i);
    }
    var [a, s] = Ht.edges(e), l = !1, u = !1;
    return vr.isPoint(t) ? (l = vr.compare(t, a) >= 0, u = vr.compare(t, s) <= 0) : (l = We.compare(t, a.path) >= 0, u = We.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Pd(e, Eae), [r, o] = Ht.edges(e), [i, a] = Ht.edges(t), s = vr.isBefore(r, i) ? i : r, l = vr.isBefore(o, a) ? o : a;
    return vr.isBefore(l, s) ? null : Lae({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return vr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return vr.equals(t, n);
  },
  isExpanded(e) {
    return !Ht.isCollapsed(e);
  },
  isForward(e) {
    return !Ht.isBackward(e);
  },
  isRange(e) {
    return No(e) && vr.isPoint(e.anchor) && vr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Ht.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return SP(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Ht.isCollapsed(r);
        Ht.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Ht.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = vr.transform(r.anchor, t, {
        affinity: i
      }), u = vr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, Tj = (e) => No(e) && kt.isNodeList(e.children) && !Gn.isEditor(e), ra = {
  isAncestor(e) {
    return No(e) && kt.isNodeList(e.children);
  },
  isElement: Tj,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => ra.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Tj(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Pae = ["children"], kae = ["text"], Aj = /* @__PURE__ */ new WeakMap(), kt = {
  ancestor(e, t) {
    var n = kt.get(e, t);
    if (io.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Mi.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of We.ancestors(t, n)) {
        var o = kt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (io.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Mi.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Mi.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = kt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = kt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = We.common(t, n), o = kt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = kt.get(e, t);
    if (Gn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Mi.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of kt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of kt.nodes(e, t))
        ra.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (ra.isAncestor(e)) {
      var t = Pd(e, Pae);
      return t;
    } else {
      var t = Pd(e, kae);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = kt.get(e, n); r && !(io.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (io.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Mi.stringify(e)));
    var n = SP({
      children: e.children
    }, (r) => {
      var [o, i] = Ht.edges(t), a = kt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Ht.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Ht.includes(t, s)) {
          var l = kt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (We.equals(s, i.path)) {
          var c = kt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (We.equals(s, o.path)) {
          var p = kt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Gn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (io.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Mi.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (io.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return io.isText(e) || ra.isElement(e) || Gn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = Aj.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => kt.isNode(r));
    return Aj.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = kt.get(e, n); r && !(io.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = kt.get(e, t);
    if (!io.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Mi.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of We.levels(t, n)) {
        var o = kt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return ra.isElement(e) && ra.isElementProps(t) && ra.matches(e, t) || io.isText(e) && io.isTextProps(t) && io.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? We.isBefore(s, i) : We.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !io.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          We.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = kt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = We.next(s);
          if (kt.has(e, c)) {
            s = c, l = kt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = We.previous(s);
          s = p, l = kt.get(e, s);
          continue;
        }
        s = We.parent(s), l = kt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = We.parent(t), r = kt.get(e, n);
    if (io.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return io.isText(e) ? e.text : e.children.map(kt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of kt.nodes(e, t))
        io.isText(n) && (yield [n, r]);
    }();
  }
};
function Ij(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Er(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ij(Object(n), !0).forEach(function(r) {
      mc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ij(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ep = {
  isNodeOperation(e) {
    return Ep.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!No(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return We.isPath(e.path) && kt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && We.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && We.isPath(e.path) && No(e.properties);
      case "move_node":
        return We.isPath(e.path) && We.isPath(e.newPath);
      case "remove_node":
        return We.isPath(e.path) && kt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && We.isPath(e.path);
      case "set_node":
        return We.isPath(e.path) && No(e.properties) && No(e.newProperties);
      case "set_selection":
        return e.properties === null && Ht.isRange(e.newProperties) || e.newProperties === null && Ht.isRange(e.properties) || No(e.properties) && No(e.newProperties);
      case "split_node":
        return We.isPath(e.path) && typeof e.position == "number" && No(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Ep.isOperation(t));
  },
  isSelectionOperation(e) {
    return Ep.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Ep.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Er(Er({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Er(Er({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Er(Er({}, e), {}, {
          type: "split_node",
          path: We.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (We.equals(t, n))
          return e;
        if (We.isSibling(n, t))
          return Er(Er({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = We.transform(n, e), o = We.transform(We.next(n), e);
        return Er(Er({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Er(Er({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Er(Er({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Er(Er({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Er(Er({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Er(Er({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Er(Er({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Er(Er({}, e), {}, {
          type: "merge_node",
          path: We.next(e.path)
        });
    }
  }
}, Bj = /* @__PURE__ */ new WeakMap(), Sae = (e) => {
  var t = Bj.get(e);
  if (t !== void 0)
    return t;
  if (!No(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || No(e.marks)) && (e.selection === null || Ht.isRange(e.selection)) && kt.isNodeList(e.children) && Ep.isOperationList(e.operations);
  return Bj.set(e, n), n;
}, Gn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Sae(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function Nj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rj(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Nj(Object(n), !0).forEach(function(r) {
      mc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Nj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vr = {
  compare(e, t) {
    var n = We.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return vr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return vr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && We.equals(e.path, t.path);
  },
  isPoint(e) {
    return No(e) && typeof e.offset == "number" && We.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return SP(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = We.transform(i, t, n);
          break;
        }
        case "insert_text": {
          We.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          We.equals(t.path, i) && (r.offset += t.position), r.path = We.transform(i, t, n);
          break;
        }
        case "remove_text": {
          We.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (We.equals(t.path, i) || We.isAncestor(t.path, i))
            return null;
          r.path = We.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (We.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = We.transform(i, t, Rj(Rj({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = We.transform(i, t, n);
          break;
        }
      }
    });
  }
}, Fj = void 0, Mi = {
  setScrubber(e) {
    Fj = e;
  },
  stringify(e) {
    return JSON.stringify(e, Fj);
  }
}, Mae = ["text"], Dae = ["anchor", "focus"];
function zj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zj(Object(n), !0).forEach(function(r) {
      mc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var io = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Pd(i, Mae);
      return a;
    }
    return I5(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return No(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => io.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Hs({}, e)];
    for (var r of t) {
      var o = Pd(r, Dae), [i, a] = Ht.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, g = void 0;
        if (c < l) {
          var E = c - y;
          g = Hs(Hs({}, f), {}, {
            text: f.text.slice(E)
          }), f = Hs(Hs({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > y) {
          var w = u - y;
          v = Hs(Hs({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Hs(Hs({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, _ae = (e) => e.selection ? e.selection : e.children.length > 0 ? Gn.end(e, []) : [0], pr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(pr || (pr = {}));
pr.L, pr.L | pr.V | pr.LV | pr.LVT, pr.LV | pr.V, pr.V | pr.T, pr.LVT | pr.T, pr.T, pr.Any, pr.Extend | pr.ZWJ, pr.Any, pr.SpacingMark, pr.Prepend, pr.Any, pr.ZWJ, pr.ExtPict, pr.RI, pr.RI;
var jae = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Gn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = _ae(e)
      } = n;
      if (We.isPath(o) && (o = Gn.range(e, o)), Ht.isRange(o))
        if (Ht.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Ht.end(o);
          if (!r && Gn.void(e, {
            at: i
          }))
            return;
          var a = Ht.start(o), s = Gn.pointRef(e, a), l = Gn.pointRef(e, i);
          Zm.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Zm.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Gn.void(e, {
        at: o
      }) || Gn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function Uj(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Uj(Object(n), !0).forEach(function(r) {
      mc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Uj(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zm = bh(bh(bh(bh({}, wae), Cae), Oae), jae), B5 = {}, MP = {}, DP = {};
Object.defineProperty(DP, "__esModule", { value: !0 });
DP.default = Bae;
var Wj = "html", $j = "head", wh = "body", Tae = /<([a-zA-Z]+[0-9]?)/, Hj = /<head[^]*>/i, Vj = /<body[^]*>/i, qm = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, _x = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, Zj = typeof window == "object" && window.DOMParser;
if (typeof Zj == "function") {
  var Aae = new Zj(), Iae = "text/html";
  _x = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Aae.parseFromString(e, Iae);
  }, qm = _x;
}
if (typeof document == "object" && document.implementation) {
  var Ch = document.implementation.createHTMLDocument();
  qm = function(e, t) {
    if (t) {
      var n = Ch.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Ch;
    }
    return Ch.documentElement.innerHTML = e, Ch;
  };
}
var Oh = typeof document == "object" && document.createElement("template"), jx;
Oh && Oh.content && (jx = function(e) {
  return Oh.innerHTML = e, Oh.content.childNodes;
});
function Bae(e) {
  var t, n, r = e.match(Tae), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case Wj: {
      var i = _x(e);
      if (!Hj.test(e)) {
        var a = i.querySelector($j);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!Vj.test(e)) {
        var a = i.querySelector(wh);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(Wj);
    }
    case $j:
    case wh: {
      var s = qm(e).querySelectorAll(o);
      return Vj.test(e) && Hj.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (jx)
        return jx(e);
      var a = qm(e, wh).querySelector(wh);
      return a.childNodes;
    }
  }
}
var Sb = {}, _P = {}, jP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(jP);
var Jt = {}, wl = nr && nr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Fp = nr && nr.__assign || function() {
  return Fp = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Fp.apply(this, arguments);
};
Object.defineProperty(Jt, "__esModule", { value: !0 });
Jt.cloneNode = Jt.hasChildren = Jt.isDocument = Jt.isDirective = Jt.isComment = Jt.isText = Jt.isCDATA = Jt.isTag = Jt.Element = Jt.Document = Jt.CDATA = Jt.NodeWithChildren = Jt.ProcessingInstruction = Jt.Comment = Jt.Text = Jt.DataNode = Jt.Node = void 0;
var fi = jP, TP = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), AP(this, t);
    }, e;
  }()
);
Jt.Node = TP;
var Mb = (
  /** @class */
  function(e) {
    wl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(TP)
);
Jt.DataNode = Mb;
var N5 = (
  /** @class */
  function(e) {
    wl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = fi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mb)
);
Jt.Text = N5;
var R5 = (
  /** @class */
  function(e) {
    wl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = fi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mb)
);
Jt.Comment = R5;
var F5 = (
  /** @class */
  function(e) {
    wl(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = fi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mb)
);
Jt.ProcessingInstruction = F5;
var Db = (
  /** @class */
  function(e) {
    wl(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(TP)
);
Jt.NodeWithChildren = Db;
var z5 = (
  /** @class */
  function(e) {
    wl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = fi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Db)
);
Jt.CDATA = z5;
var U5 = (
  /** @class */
  function(e) {
    wl(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = fi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Db)
);
Jt.Document = U5;
var W5 = (
  /** @class */
  function(e) {
    wl(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? fi.ElementType.Script : n === "style" ? fi.ElementType.Style : fi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Db)
);
Jt.Element = W5;
function $5(e) {
  return (0, fi.isTag)(e);
}
Jt.isTag = $5;
function H5(e) {
  return e.type === fi.ElementType.CDATA;
}
Jt.isCDATA = H5;
function V5(e) {
  return e.type === fi.ElementType.Text;
}
Jt.isText = V5;
function Z5(e) {
  return e.type === fi.ElementType.Comment;
}
Jt.isComment = Z5;
function q5(e) {
  return e.type === fi.ElementType.Directive;
}
Jt.isDirective = q5;
function K5(e) {
  return e.type === fi.ElementType.Root;
}
Jt.isDocument = K5;
function Nae(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Jt.hasChildren = Nae;
function AP(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (V5(e))
    n = new N5(e.data);
  else if (Z5(e))
    n = new R5(e.data);
  else if ($5(e)) {
    var r = t ? Bw(e.children) : [], o = new W5(e.name, Fp({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Fp({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Fp({}, e["x-attribsPrefix"])), n = o;
  } else if (H5(e)) {
    var r = t ? Bw(e.children) : [], i = new z5(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (K5(e)) {
    var r = t ? Bw(e.children) : [], a = new U5(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (q5(e)) {
    var s = new F5(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Jt.cloneNode = AP;
function Bw(e) {
  for (var t = e.map(function(r) {
    return AP(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = nr && nr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = nr && nr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = jP, o = Jt;
  n(Jt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(_P);
var G5 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(G5);
Object.defineProperty(Sb, "__esModule", { value: !0 });
Sb.formatAttributes = Y5;
Sb.formatDOM = X5;
var xh = _P, Rae = G5;
function Fae(e) {
  return Rae.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Y5(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function zae(e) {
  e = e.toLowerCase();
  var t = Fae(e);
  return t || e;
}
function X5(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = zae(s.nodeName);
        o = new xh.Element(l, Y5(s.attributes)), o.children = X5(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new xh.Text(s.nodeValue);
        break;
      case 8:
        o = new xh.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new xh.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var Uae = nr && nr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(MP, "__esModule", { value: !0 });
MP.default = Vae;
var Wae = Uae(DP), $ae = Sb, Hae = /<(![a-zA-Z\s]+)>/;
function Vae(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Hae), n = t ? t[1] : void 0;
  return (0, $ae.formatDOM)((0, Wae.default)(e), null, n);
}
var _b = {}, hs = {}, jb = {}, Zae = 0;
jb.SAME = Zae;
var qae = 1;
jb.CAMELCASE = qae;
jb.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const J5 = 0, Cl = 1, Tb = 2, Ab = 3, IP = 4, Q5 = 5, e4 = 6;
function Kae(e) {
  return Do.hasOwnProperty(e) ? Do[e] : null;
}
function qo(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Tb || t === Ab || t === IP, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Do = {}, Gae = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Gae.forEach((e) => {
  Do[e] = new qo(
    e,
    J5,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  Do[e] = new qo(
    e,
    Cl,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  Do[e] = new qo(
    e,
    Tb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  Do[e] = new qo(
    e,
    Tb,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  Do[e] = new qo(
    e,
    Ab,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Do[e] = new qo(
    e,
    Ab,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Do[e] = new qo(
    e,
    IP,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  Do[e] = new qo(
    e,
    e4,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  Do[e] = new qo(
    e,
    Q5,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const BP = /[\-\:]([a-z])/g, NP = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(BP, NP);
  Do[t] = new qo(
    t,
    Cl,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(BP, NP);
  Do[t] = new qo(
    t,
    Cl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(BP, NP);
  Do[t] = new qo(
    t,
    Cl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  Do[e] = new qo(
    e,
    Cl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Yae = "xlinkHref";
Do[Yae] = new qo(
  "xlinkHref",
  Cl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  Do[e] = new qo(
    e,
    Cl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: Xae,
  SAME: Jae,
  possibleStandardNames: qj
} = jb, Qae = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", ele = Qae + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", tle = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + ele + "]*$")
), nle = Object.keys(
  qj
).reduce((e, t) => {
  const n = qj[t];
  return n === Jae ? e[t] = t : n === Xae ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
hs.BOOLEAN = Ab;
hs.BOOLEANISH_STRING = Tb;
hs.NUMERIC = Q5;
hs.OVERLOADED_BOOLEAN = IP;
hs.POSITIVE_NUMERIC = e4;
hs.RESERVED = J5;
hs.STRING = Cl;
hs.getPropertyInfo = Kae;
hs.isCustomAttribute = tle;
hs.possibleStandardNames = nle;
var RP = {}, FP = {}, Kj = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, rle = /\n/g, ole = /^\s*/, ile = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, sle = /^:\s*/, ale = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, lle = /^[;\s]*/, ule = /^\s+|\s+$/g, cle = `
`, Gj = "/", Yj = "*", au = "", ple = "comment", dle = "declaration", fle = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(rle);
    v && (n += v.length);
    var g = f.lastIndexOf(cle);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var g = v[0];
      return o(g), e = e.slice(g.length), v;
    }
  }
  function u() {
    l(ole);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(Gj != e.charAt(0) || Yj != e.charAt(1))) {
      for (var v = 2; au != e.charAt(v) && (Yj != e.charAt(v) || Gj != e.charAt(v + 1)); )
        ++v;
      if (v += 2, au === e.charAt(v - 1))
        return s("End of comment missing");
      var g = e.slice(2, v - 2);
      return r += 2, o(g), e = e.slice(v), r += 2, f({
        type: ple,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), v = l(ile);
    if (v) {
      if (p(), !l(sle)) return s("property missing ':'");
      var g = l(ale), E = f({
        type: dle,
        property: Xj(v[0].replace(Kj, au)),
        value: g ? Xj(g[0].replace(Kj, au)) : au
      });
      return l(lle), E;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function Xj(e) {
  return e ? e.replace(ule, au) : au;
}
var hle = nr && nr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(FP, "__esModule", { value: !0 });
FP.default = mle;
var gle = hle(fle);
function mle(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, gle.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Ib = {};
Object.defineProperty(Ib, "__esModule", { value: !0 });
Ib.camelCase = void 0;
var vle = /^--[a-zA-Z0-9_-]+$/, yle = /-([a-z])/g, ble = /^[^-]+$/, wle = /^-(webkit|moz|ms|o|khtml)-/, Cle = /^-(ms)-/, Ole = function(e) {
  return !e || ble.test(e) || vle.test(e);
}, xle = function(e, t) {
  return t.toUpperCase();
}, Jj = function(e, t) {
  return "".concat(t, "-");
}, Ele = function(e, t) {
  return t === void 0 && (t = {}), Ole(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Cle, Jj) : e = e.replace(wle, Jj), e.replace(yle, xle));
};
Ib.camelCase = Ele;
var Lle = nr && nr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Ple = Lle(FP), kle = Ib;
function Tx(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Ple.default)(e, function(r, o) {
    r && o && (n[(0, kle.camelCase)(r, t)] = o);
  }), n;
}
Tx.default = Tx;
var Sle = Tx;
(function(e) {
  var t = nr && nr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Ce, r = t(Sle), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(RP);
Object.defineProperty(_b, "__esModule", { value: !0 });
_b.default = jle;
var Lp = hs, Qj = RP, Mle = ["checked", "value"], Dle = ["input", "select", "textarea"], _le = {
  reset: !0,
  submit: !0
};
function jle(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && _le[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Lp.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = eT(a);
    if (s) {
      var l = (0, Lp.getPropertyInfo)(s);
      switch (Mle.includes(s) && Dle.includes(t) && !r && (s = eT("default" + a)), n[s] = i, l && l.type) {
        case Lp.BOOLEAN:
          n[s] = !0;
          break;
        case Lp.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    Qj.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, Qj.setStyleProp)(e.style, n), n;
}
function eT(e) {
  return Lp.possibleStandardNames[e];
}
var zP = {}, Tle = nr && nr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(zP, "__esModule", { value: !0 });
zP.default = t4;
var Nw = Ce, Ale = Tle(_b), zp = RP, Ile = {
  cloneElement: Nw.cloneElement,
  createElement: Nw.createElement,
  isValidElement: Nw.isValidElement
};
function t4(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || zp.returnFirstArg, i = t.library || Ile, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, zp.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    Ble(f) ? ((0, zp.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, Ale.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (g = t4(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Ble(e) {
  return zp.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, zp.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = nr && nr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(MP);
  e.htmlToDOM = n.default;
  var r = t(_b);
  e.attributesToProps = r.default;
  var o = t(zP);
  e.domToReact = o.default;
  var i = _P;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(B5);
const Nle = /* @__PURE__ */ rae(B5);
Nle.default;
var rr = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Rle(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Ax = { exports: {} }, Hc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var tT;
function Fle() {
  if (tT) return Hc;
  tT = 1;
  var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return Hc.Fragment = n, Hc.jsx = a, Hc.jsxs = a, Hc;
}
var Eh = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var nT;
function zle() {
  return nT || (nT = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[v];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, K = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          K[ne - 1] = arguments[ne];
        D("error", b, K);
      }
    }
    function D(b, I, K) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (I += "%s", K = K.concat([ae]));
        var ce = K.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function R(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || z || b === o || b === u || b === c || S || b === y || x || m || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function B(b, I, K) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var ae = I.displayName || I.name || "";
      return ae !== "" ? K + "(" + ae + ")" : K;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return H(I) + ".Consumer";
          case a:
            var K = b;
            return H(K._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var ae = b, ce = ae._payload, se = ae._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, q = 0, Y, X, ee, J, k, _, U;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function $() {
      {
        if (q === 0) {
          Y = console.log, X = console.info, ee = console.warn, J = console.error, k = console.group, _ = console.groupCollapsed, U = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, b, {
              value: Y
            }),
            info: W({}, b, {
              value: X
            }),
            warn: W({}, b, {
              value: ee
            }),
            error: W({}, b, {
              value: J
            }),
            group: W({}, b, {
              value: k
            }),
            groupCollapsed: W({}, b, {
              value: _
            }),
            groupEnd: W({}, b, {
              value: U
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, F;
    function T(b, I, K) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            F = ne && ne[1] || "";
          }
        return `
` + F + b;
      }
    }
    var Z = !1, A;
    {
      var G = typeof WeakMap == "function" ? WeakMap : Map;
      A = new G();
    }
    function N(b, I) {
      if (!b || Z)
        return "";
      {
        var K = A.get(b);
        if (K !== void 0)
          return K;
      }
      var ne;
      Z = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Te) {
              ne = Te;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (Te) {
              ne = Te;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Te) {
            ne = Te;
          }
          b();
        }
      } catch (Te) {
        if (Te && ne && typeof Te.stack == "string") {
          for (var ie = Te.stack.split(`
`), De = ne.stack.split(`
`), de = ie.length - 1, he = De.length - 1; de >= 1 && he >= 0 && ie[de] !== De[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== De[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== De[he]) {
                    var Ze = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ze.includes("<anonymous>") && (Ze = Ze.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ze), Ze;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        Z = !1, j.current = ce, O(), Error.prepareStackTrace = ae;
      }
      var Ot = b ? b.displayName || b.name : "", gt = Ot ? T(Ot) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, I, K) {
      return N(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, K) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, K);
          case d: {
            var ne = b, ae = ne._payload, ce = ne._init;
            try {
              return oe(ce(ae), I, K);
            } catch {
            }
          }
        }
      return "";
    }
    var Ie = Object.prototype.hasOwnProperty, qe = {}, Ge = E.ReactDebugCurrentFrame;
    function Be(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(K);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, K, ne, ae) {
      {
        var ce = Function.call.bind(Ie);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var De = Error((ne || "React class") + ": " + K + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              ie = b[se](I, se, ne, K, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Be(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", K, se, typeof ie), Be(null)), ie instanceof Error && !(ie.message in qe) && (qe[ie.message] = !0, Be(ae), w("Failed %s type: %s", K, ie.message), Be(null));
          }
      }
    }
    var Xe = Array.isArray;
    function Me(b) {
      return Xe(b);
    }
    function Je(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, K = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return K;
      }
    }
    function at(b) {
      try {
        return Se(b), !1;
      } catch {
        return !0;
      }
    }
    function Se(b) {
      return "" + b;
    }
    function _e(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Je(b)), Se(b);
    }
    var Ae = E.ReactCurrentOwner, Ve = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ne, nt, we;
    we = {};
    function mt(b) {
      if (Ie.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function ot(b) {
      if (Ie.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function st(b, I) {
      if (typeof b.ref == "string" && Ae.current && I && Ae.current.stateNode !== I) {
        var K = V(Ae.current.type);
        we[K] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Ae.current.type), b.ref), we[K] = !0);
      }
    }
    function ut(b, I) {
      {
        var K = function() {
          Ne || (Ne = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: K,
          configurable: !0
        });
      }
    }
    function vt(b, I) {
      {
        var K = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: K,
          configurable: !0
        });
      }
    }
    var ct = function(b, I, K, ne, ae, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: K,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function yt(b, I, K, ne, ae) {
      {
        var ce, se = {}, ie = null, De = null;
        K !== void 0 && (_e(K), ie = "" + K), ot(I) && (_e(I.key), ie = "" + I.key), mt(I) && (De = I.ref, st(I, ae));
        for (ce in I)
          Ie.call(I, ce) && !Ve.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || De) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && ut(se, he), De && vt(se, he);
        }
        return ct(b, ie, De, ae, ne, Ae.current, se);
      }
    }
    var Qe = E.ReactCurrentOwner, ft = E.ReactDebugCurrentFrame;
    function tt(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        ft.setExtraStackFrame(K);
      } else
        ft.setExtraStackFrame(null);
    }
    var bt;
    bt = !1;
    function pt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Dt() {
      {
        if (Qe.current) {
          var b = V(Qe.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function wt(b) {
      return "";
    }
    var _t = {};
    function Ct(b) {
      {
        var I = Dt();
        if (!I) {
          var K = typeof b == "string" ? b : b.displayName || b.name;
          K && (I = `

Check the top-level render call using <` + K + ">.");
        }
        return I;
      }
    }
    function jt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var K = Ct(I);
        if (_t[K])
          return;
        _t[K] = !0;
        var ne = "";
        b && b._owner && b._owner !== Qe.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), tt(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', K, ne), tt(null);
      }
    }
    function Cn(b, I) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var K = 0; K < b.length; K++) {
            var ne = b[K];
            pt(ne) && jt(ne, I);
          }
        else if (pt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ae = g(b);
          if (typeof ae == "function" && ae !== b.entries)
            for (var ce = ae.call(b), se; !(se = ce.next()).done; )
              pt(se.value) && jt(se.value, I);
        }
      }
    }
    function ht(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var K;
        if (typeof I == "function")
          K = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          K = I.propTypes;
        else
          return;
        if (K) {
          var ne = V(I);
          et(K, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !bt) {
          bt = !0;
          var ae = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function re(b) {
      {
        for (var I = Object.keys(b.props), K = 0; K < I.length; K++) {
          var ne = I[K];
          if (ne !== "children" && ne !== "key") {
            tt(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), tt(null);
            break;
          }
        }
        b.ref !== null && (tt(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var mo = {};
    function vo(b, I, K, ne, ae, ce) {
      {
        var se = R(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = wt();
          De ? ie += De : ie += Dt();
          var de;
          b === null ? de = "null" : Me(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = yt(b, I, K, ae, ce);
        if (he == null)
          return he;
        if (se) {
          var Ze = I.children;
          if (Ze !== void 0)
            if (ne)
              if (Me(Ze)) {
                for (var Ot = 0; Ot < Ze.length; Ot++)
                  Cn(Ze[Ot], b);
                Object.freeze && Object.freeze(Ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Cn(Ze, b);
        }
        if (Ie.call(I, "key")) {
          var gt = V(b), Te = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), ar = Te.length > 0 ? "{key: someKey, " + Te.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!mo[gt + ar]) {
            var Ei = Te.length > 0 ? "{" + Te.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ar, gt, Ei, gt), mo[gt + ar] = !0;
          }
        }
        return b === r ? re(he) : ht(he), he;
      }
    }
    function wi(b, I, K) {
      return vo(b, I, K, !0);
    }
    function Ci(b, I, K) {
      return vo(b, I, K, !1);
    }
    var Oi = Ci, xi = wi;
    Eh.Fragment = r, Eh.jsx = Oi, Eh.jsxs = xi;
  }()), Eh;
}
process.env.NODE_ENV === "production" ? Ax.exports = Fle() : Ax.exports = zle();
var ai = Ax.exports;
Ye({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function rT(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Ro(e) {
  var t, n;
  return rT(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(rT(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var n4 = Symbol.for("immer-nothing"), oT = Symbol.for("immer-draftable"), Yi = Symbol.for("immer-state"), Ule = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ni(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Ule[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var lc = Object.getPrototypeOf;
function Nu(e) {
  return !!e && !!e[Yi];
}
function Ru(e) {
  var t;
  return e ? r4(e) || Array.isArray(e) || !!e[oT] || !!((t = e.constructor) != null && t[oT]) || Nb(e) || Rb(e) : !1;
}
var Wle = Object.prototype.constructor.toString();
function r4(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = lc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === Wle;
}
function Km(e, t) {
  Bb(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Bb(e) {
  const t = e[Yi];
  return t ? t.type_ : Array.isArray(e) ? 1 : Nb(e) ? 2 : Rb(e) ? 3 : 0;
}
function Ix(e, t) {
  return Bb(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function o4(e, t, n) {
  const r = Bb(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function $le(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Nb(e) {
  return e instanceof Map;
}
function Rb(e) {
  return e instanceof Set;
}
function eu(e) {
  return e.copy_ || e.base_;
}
function Bx(e, t) {
  if (Nb(e))
    return new Map(e);
  if (Rb(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = r4(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Yi];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(lc(e), r);
  } else {
    const r = lc(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function UP(e, t = !1) {
  return Fb(e) || Nu(e) || !Ru(e) || (Bb(e) > 1 && (e.set = e.add = e.clear = e.delete = Hle), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => UP(r, !0))), e;
}
function Hle() {
  ni(2);
}
function Fb(e) {
  return Object.isFrozen(e);
}
var Vle = {};
function Fu(e) {
  const t = Vle[e];
  return t || ni(0, e), t;
}
var kd;
function i4() {
  return kd;
}
function Zle(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function iT(e, t) {
  t && (Fu("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Nx(e) {
  Rx(e), e.drafts_.forEach(qle), e.drafts_ = null;
}
function Rx(e) {
  e === kd && (kd = e.parent_);
}
function sT(e) {
  return kd = Zle(kd, e);
}
function qle(e) {
  const t = e[Yi];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function aT(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Yi].modified_ && (Nx(t), ni(4)), Ru(e) && (e = Gm(t, e), t.parent_ || Ym(t, e)), t.patches_ && Fu("Patches").generateReplacementPatches_(
    n[Yi].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Gm(t, n, []), Nx(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== n4 ? e : void 0;
}
function Gm(e, t, n) {
  if (Fb(t))
    return t;
  const r = t[Yi];
  if (!r)
    return Km(
      t,
      (o, i) => lT(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Ym(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Km(
      i,
      (s, l) => lT(e, r, o, s, l, n, a)
    ), Ym(e, o, !1), n && e.patches_ && Fu("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function lT(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ni(5), Nu(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Ix(t.assigned_, r) ? i.concat(r) : void 0, l = Gm(e, o, s);
    if (o4(n, r, l), Nu(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Ru(o) && !Fb(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Gm(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Ym(e, o);
  }
}
function Ym(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && UP(t, n);
}
function Kle(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : i4(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = WP;
  n && (o = [r], i = Sd);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var WP = {
  get(e, t) {
    if (t === Yi)
      return e;
    const n = eu(e);
    if (!Ix(n, t))
      return Gle(e, n, t);
    const r = n[t];
    return e.finalized_ || !Ru(r) ? r : r === Rw(e.base_, t) ? (Fw(e), e.copy_[t] = zx(r, e)) : r;
  },
  has(e, t) {
    return t in eu(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(eu(e));
  },
  set(e, t, n) {
    const r = s4(eu(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Rw(eu(e), t), i = o == null ? void 0 : o[Yi];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if ($le(n, o) && (n !== void 0 || Ix(e.base_, t)))
        return !0;
      Fw(e), Fx(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Rw(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Fw(e), Fx(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = eu(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ni(11);
  },
  getPrototypeOf(e) {
    return lc(e.base_);
  },
  setPrototypeOf() {
    ni(12);
  }
}, Sd = {};
Km(WP, (e, t) => {
  Sd[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Sd.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ni(13), Sd.set.call(this, e, t, void 0);
};
Sd.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ni(14), WP.set.call(this, e[0], t, n, e[0]);
};
function Rw(e, t) {
  const n = e[Yi];
  return (n ? eu(n) : e)[t];
}
function Gle(e, t, n) {
  var r;
  const o = s4(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function s4(e, t) {
  if (!(t in e))
    return;
  let n = lc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = lc(n);
  }
}
function Fx(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Fx(e.parent_));
}
function Fw(e) {
  e.copy_ || (e.copy_ = Bx(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var Yle = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ni(6), r !== void 0 && typeof r != "function" && ni(7);
      let o;
      if (Ru(t)) {
        const i = sT(this), a = zx(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? Nx(i) : Rx(i);
        }
        return iT(i, r), aT(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === n4 && (o = void 0), this.autoFreeze_ && UP(o, !0), r) {
          const i = [], a = [];
          Fu("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ni(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Ru(e) || ni(8), Nu(e) && (e = Xle(e));
    const t = sT(this), n = zx(e, void 0);
    return n[Yi].isManual_ = !0, Rx(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Yi];
    (!n || !n.isManual_) && ni(9);
    const { scope_: r } = n;
    return iT(r, t), aT(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Fu("Patches").applyPatches_;
    return Nu(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function zx(e, t) {
  const n = Nb(e) ? Fu("MapSet").proxyMap_(e, t) : Rb(e) ? Fu("MapSet").proxySet_(e, t) : Kle(e, t);
  return (t ? t.scope_ : i4()).drafts_.push(n), n;
}
function Xle(e) {
  return Nu(e) || ni(10, e), a4(e);
}
function a4(e) {
  if (!Ru(e) || Fb(e))
    return e;
  const t = e[Yi];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Bx(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Bx(e, !0);
  return Km(n, (r, o) => {
    o4(n, r, a4(o));
  }), t && (t.finalized_ = !1), n;
}
var Xi = new Yle(), $P = Xi.produce;
Xi.produceWithPatches.bind(
  Xi
);
Xi.setAutoFreeze.bind(Xi);
Xi.setUseStrictShallowCopy.bind(Xi);
Xi.applyPatches.bind(Xi);
var uT = Xi.createDraft.bind(Xi), cT = Xi.finishDraft.bind(Xi), $e = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = $e.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return $e.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return $e.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return $e.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return $e.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && $e.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return $e.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && $e.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && $e.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && $e.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && $e.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && $e.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!$e.isAncestor(t, e) && !$e.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        ($e.equals(i, r) || $e.endsBefore(i, r) || $e.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if ($e.equals(a, r) || $e.isAncestor(a, r))
          return null;
        $e.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        $e.equals(s, r) || $e.endsBefore(s, r) ? r[s.length - 1] -= 1 : $e.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if ($e.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else $e.endsBefore(u, r) ? r[u.length - 1] += 1 : $e.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if ($e.equals(p, d))
          return r;
        if ($e.isAncestor(p, r) || $e.equals(p, r)) {
          var y = d.slice();
          return $e.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else $e.isSibling(p, d) && ($e.isAncestor(d, r) || $e.equals(d, r)) ? $e.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : $e.endsBefore(d, r) || $e.equals(d, r) || $e.isAncestor(d, r) ? ($e.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : $e.endsBefore(p, r) && ($e.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Md(e) {
  "@babel/helpers - typeof";
  return Md = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Md(e);
}
function Jle(e, t) {
  if (Md(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Md(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Qle(e) {
  var t = Jle(e, "string");
  return Md(t) === "symbol" ? t : String(t);
}
function vc(e, t, n) {
  return t = Qle(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function pT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pT(Object(n), !0).forEach(function(r) {
      vc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var eue = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = St.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Vt.points(t))
          t[l] = yr.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = St.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, g] of Vt.points(t))
          t[g] = yr.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = St.get(e, E), D = $e.previous(E), x = St.get(e, D), m = St.parent(e, E), C = E[E.length - 1];
      if (so.isText(w) && so.isText(x))
        x.text += w.text;
      else if (!so.isText(w) && !so.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Di.stringify(w), " ").concat(Di.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, z] of Vt.points(t))
          t[z] = yr.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: R
      } = n;
      if ($e.isAncestor(L, R))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(R, "] because the destination is inside itself."));
      var B = St.get(e, L), H = St.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var W = $e.transform(L, n), q = St.get(e, $e.parent(W)), Y = W[W.length - 1];
      if (q.children.splice(Y, 0, B), t)
        for (var [X, ee] of Vt.points(t))
          t[ee] = yr.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, k = J[J.length - 1], _ = St.parent(e, J);
      if (_.children.splice(k, 1), t)
        for (var [U, M] of Vt.points(t)) {
          var $ = yr.transform(U, n);
          if (t != null && $ != null)
            t[M] = $;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of St.texts(e))
              if ($e.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var Z = !1;
            O && j && ($e.equals(j[1], J) ? Z = !$e.hasPrevious(j[1]) : Z = $e.common(O[1], J).length < $e.common(j[1], J).length), O && !Z ? (U.path = O[1], U.offset = O[0].text.length) : j ? (U.path = j[1], U.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: G,
        text: N
      } = n;
      if (N.length === 0) break;
      var ue = St.leaf(e, A), fe = ue.text.slice(0, G), oe = ue.text.slice(G + N.length);
      if (ue.text = fe + oe, t)
        for (var [Ie, qe] of Vt.points(t))
          t[qe] = yr.transform(Ie, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Be,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Xe = St.get(e, Ge);
      for (var Me in et) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Je = et[Me];
        Je == null ? delete Xe[Me] : Xe[Me] = Je;
      }
      for (var at in Be)
        et.hasOwnProperty(at) || delete Xe[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Se
      } = n;
      if (Se == null)
        t = Se;
      else {
        if (t == null) {
          if (!Vt.isRange(Se))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Di.stringify(Se), " when there is no current selection."));
          t = Vc({}, Se);
        }
        for (var _e in Se) {
          var Ae = Se[_e];
          if (Ae == null) {
            if (_e === "anchor" || _e === "focus")
              throw new Error('Cannot remove the "'.concat(_e, '" selection property'));
            delete t[_e];
          } else
            t[_e] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ve,
        position: Ne,
        properties: nt
      } = n;
      if (Ve.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ve, "] because the root node cannot be split."));
      var we = St.get(e, Ve), mt = St.parent(e, Ve), ot = Ve[Ve.length - 1], st;
      if (so.isText(we)) {
        var ut = we.text.slice(0, Ne), vt = we.text.slice(Ne);
        we.text = ut, st = Vc(Vc({}, nt), {}, {
          text: vt
        });
      } else {
        var ct = we.children.slice(0, Ne), yt = we.children.slice(Ne);
        we.children = ct, st = Vc(Vc({}, nt), {}, {
          children: yt
        });
      }
      if (mt.children.splice(ot + 1, 0, st), t)
        for (var [Qe, ft] of Vt.points(t))
          t[ft] = yr.transform(Qe, n);
      break;
    }
  }
  return t;
}, tue = {
  transform(e, t) {
    e.children = uT(e.children);
    var n = e.selection && uT(e.selection);
    try {
      n = eue(e, n, t);
    } finally {
      e.children = cT(e.children), n ? e.selection = Nu(n) ? cT(n) : n : e.selection = null;
    }
  }
}, nue = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, rue = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, l4 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Ro(r) && Ro(o)) {
      if (!l4(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function oue(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Dd(e, t) {
  if (e == null) return {};
  var n = oue(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var iue = ["anchor", "focus"];
function dT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sue(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dT(Object(n), !0).forEach(function(r) {
      vc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Vt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Vt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Vt.edges(e);
    return t;
  },
  equals(e, t) {
    return yr.equals(e.anchor, t.anchor) && yr.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Vt.isRange(t)) {
      if (Vt.includes(e, t.anchor) || Vt.includes(e, t.focus))
        return !0;
      var [n, r] = Vt.edges(e), [o, i] = Vt.edges(t);
      return yr.isBefore(n, o) && yr.isAfter(r, i);
    }
    var [a, s] = Vt.edges(e), l = !1, u = !1;
    return yr.isPoint(t) ? (l = yr.compare(t, a) >= 0, u = yr.compare(t, s) <= 0) : (l = $e.compare(t, a.path) >= 0, u = $e.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Dd(e, iue), [r, o] = Vt.edges(e), [i, a] = Vt.edges(t), s = yr.isBefore(r, i) ? i : r, l = yr.isBefore(o, a) ? o : a;
    return yr.isBefore(l, s) ? null : sue({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return yr.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return yr.equals(t, n);
  },
  isExpanded(e) {
    return !Vt.isCollapsed(e);
  },
  isForward(e) {
    return !Vt.isBackward(e);
  },
  isRange(e) {
    return Ro(e) && yr.isPoint(e.anchor) && yr.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Vt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return $P(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Vt.isCollapsed(r);
        Vt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Vt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = yr.transform(r.anchor, t, {
        affinity: i
      }), u = yr.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, fT = (e) => Ro(e) && St.isNodeList(e.children) && !Yn.isEditor(e), oa = {
  isAncestor(e) {
    return Ro(e) && St.isNodeList(e.children);
  },
  isElement: fT,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => oa.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return fT(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, aue = ["children"], lue = ["text"], hT = /* @__PURE__ */ new WeakMap(), St = {
  ancestor(e, t) {
    var n = St.get(e, t);
    if (so.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Di.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of $e.ancestors(t, n)) {
        var o = St.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (so.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Di.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Di.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = St.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = St.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = $e.common(t, n), o = St.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = St.get(e, t);
    if (Yn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Di.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of St.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of St.nodes(e, t))
        oa.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (oa.isAncestor(e)) {
      var t = Dd(e, aue);
      return t;
    } else {
      var t = Dd(e, lue);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = St.get(e, n); r && !(so.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (so.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Di.stringify(e)));
    var n = $P({
      children: e.children
    }, (r) => {
      var [o, i] = Vt.edges(t), a = St.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Vt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Vt.includes(t, s)) {
          var l = St.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if ($e.equals(s, i.path)) {
          var c = St.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if ($e.equals(s, o.path)) {
          var p = St.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Yn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (so.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Di.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (so.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return so.isText(e) || oa.isElement(e) || Yn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = hT.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => St.isNode(r));
    return hT.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = St.get(e, n); r && !(so.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = St.get(e, t);
    if (!so.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Di.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of $e.levels(t, n)) {
        var o = St.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return oa.isElement(e) && oa.isElementProps(t) && oa.matches(e, t) || so.isText(e) && so.isTextProps(t) && so.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? $e.isBefore(s, i) : $e.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !so.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          $e.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = St.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = $e.next(s);
          if (St.has(e, c)) {
            s = c, l = St.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = $e.previous(s);
          s = p, l = St.get(e, s);
          continue;
        }
        s = $e.parent(s), l = St.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = $e.parent(t), r = St.get(e, n);
    if (so.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return so.isText(e) ? e.text : e.children.map(St.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of St.nodes(e, t))
        so.isText(n) && (yield [n, r]);
    }();
  }
};
function gT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gT(Object(n), !0).forEach(function(r) {
      vc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Pp = {
  isNodeOperation(e) {
    return Pp.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Ro(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return $e.isPath(e.path) && St.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && $e.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && $e.isPath(e.path) && Ro(e.properties);
      case "move_node":
        return $e.isPath(e.path) && $e.isPath(e.newPath);
      case "remove_node":
        return $e.isPath(e.path) && St.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && $e.isPath(e.path);
      case "set_node":
        return $e.isPath(e.path) && Ro(e.properties) && Ro(e.newProperties);
      case "set_selection":
        return e.properties === null && Vt.isRange(e.newProperties) || e.newProperties === null && Vt.isRange(e.properties) || Ro(e.properties) && Ro(e.newProperties);
      case "split_node":
        return $e.isPath(e.path) && typeof e.position == "number" && Ro(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Pp.isOperation(t));
  },
  isSelectionOperation(e) {
    return Pp.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Pp.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Lr(Lr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Lr(Lr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Lr(Lr({}, e), {}, {
          type: "split_node",
          path: $e.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if ($e.equals(t, n))
          return e;
        if ($e.isSibling(n, t))
          return Lr(Lr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = $e.transform(n, e), o = $e.transform($e.next(n), e);
        return Lr(Lr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Lr(Lr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Lr(Lr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Lr(Lr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Lr(Lr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Lr(Lr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Lr(Lr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Lr(Lr({}, e), {}, {
          type: "merge_node",
          path: $e.next(e.path)
        });
    }
  }
}, mT = /* @__PURE__ */ new WeakMap(), uue = (e) => {
  var t = mT.get(e);
  if (t !== void 0)
    return t;
  if (!Ro(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Ro(e.marks)) && (e.selection === null || Vt.isRange(e.selection)) && St.isNodeList(e.children) && Pp.isOperationList(e.operations);
  return mT.set(e, n), n;
}, Yn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return uue(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function vT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vT(Object(n), !0).forEach(function(r) {
      vc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yr = {
  compare(e, t) {
    var n = $e.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return yr.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return yr.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && $e.equals(e.path, t.path);
  },
  isPoint(e) {
    return Ro(e) && typeof e.offset == "number" && $e.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return $P(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = $e.transform(i, t, n);
          break;
        }
        case "insert_text": {
          $e.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          $e.equals(t.path, i) && (r.offset += t.position), r.path = $e.transform(i, t, n);
          break;
        }
        case "remove_text": {
          $e.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if ($e.equals(t.path, i) || $e.isAncestor(t.path, i))
            return null;
          r.path = $e.transform(i, t, n);
          break;
        }
        case "split_node": {
          if ($e.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = $e.transform(i, t, yT(yT({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = $e.transform(i, t, n);
          break;
        }
      }
    });
  }
}, bT = void 0, Di = {
  setScrubber(e) {
    bT = e;
  },
  stringify(e) {
    return JSON.stringify(e, bT);
  }
}, cue = ["text"], pue = ["anchor", "focus"];
function wT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wT(Object(n), !0).forEach(function(r) {
      vc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var so = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Dd(i, cue);
      return a;
    }
    return l4(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Ro(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => so.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Vs({}, e)];
    for (var r of t) {
      var o = Dd(r, pue), [i, a] = Vt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, g = void 0;
        if (c < l) {
          var E = c - y;
          g = Vs(Vs({}, f), {}, {
            text: f.text.slice(E)
          }), f = Vs(Vs({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > y) {
          var w = u - y;
          v = Vs(Vs({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Vs(Vs({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, due = (e) => e.selection ? e.selection : e.children.length > 0 ? Yn.end(e, []) : [0], dr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(dr || (dr = {}));
dr.L, dr.L | dr.V | dr.LV | dr.LVT, dr.LV | dr.V, dr.V | dr.T, dr.LVT | dr.T, dr.T, dr.Any, dr.Extend | dr.ZWJ, dr.Any, dr.SpacingMark, dr.Prepend, dr.Any, dr.ZWJ, dr.ExtPict, dr.RI, dr.RI;
var fue = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Yn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = due(e)
      } = n;
      if ($e.isPath(o) && (o = Yn.range(e, o)), Vt.isRange(o))
        if (Vt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Vt.end(o);
          if (!r && Yn.void(e, {
            at: i
          }))
            return;
          var a = Vt.start(o), s = Yn.pointRef(e, a), l = Yn.pointRef(e, i);
          Xm.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Xm.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Yn.void(e, {
        at: o
      }) || Yn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function CT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lh(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CT(Object(n), !0).forEach(function(r) {
      vc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xm = Lh(Lh(Lh(Lh({}, tue), nue), rue), fue), u4 = {}, HP = {}, VP = {};
Object.defineProperty(VP, "__esModule", { value: !0 });
VP.default = vue;
var OT = "html", xT = "head", Ph = "body", hue = /<([a-zA-Z]+[0-9]?)/, ET = /<head[^]*>/i, LT = /<body[^]*>/i, Jm = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Ux = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, PT = typeof window == "object" && window.DOMParser;
if (typeof PT == "function") {
  var gue = new PT(), mue = "text/html";
  Ux = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), gue.parseFromString(e, mue);
  }, Jm = Ux;
}
if (typeof document == "object" && document.implementation) {
  var kh = document.implementation.createHTMLDocument();
  Jm = function(e, t) {
    if (t) {
      var n = kh.documentElement.querySelector(t);
      return n && (n.innerHTML = e), kh;
    }
    return kh.documentElement.innerHTML = e, kh;
  };
}
var Sh = typeof document == "object" && document.createElement("template"), Wx;
Sh && Sh.content && (Wx = function(e) {
  return Sh.innerHTML = e, Sh.content.childNodes;
});
function vue(e) {
  var t, n, r = e.match(hue), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case OT: {
      var i = Ux(e);
      if (!ET.test(e)) {
        var a = i.querySelector(xT);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!LT.test(e)) {
        var a = i.querySelector(Ph);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(OT);
    }
    case xT:
    case Ph: {
      var s = Jm(e).querySelectorAll(o);
      return LT.test(e) && ET.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (Wx)
        return Wx(e);
      var a = Jm(e, Ph).querySelector(Ph);
      return a.childNodes;
    }
  }
}
var zb = {}, ZP = {}, qP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(qP);
var Qt = {}, Ol = rr && rr.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Up = rr && rr.__assign || function() {
  return Up = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Up.apply(this, arguments);
};
Object.defineProperty(Qt, "__esModule", { value: !0 });
Qt.cloneNode = Qt.hasChildren = Qt.isDocument = Qt.isDirective = Qt.isComment = Qt.isText = Qt.isCDATA = Qt.isTag = Qt.Element = Qt.Document = Qt.CDATA = Qt.NodeWithChildren = Qt.ProcessingInstruction = Qt.Comment = Qt.Text = Qt.DataNode = Qt.Node = void 0;
var hi = qP, KP = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), GP(this, t);
    }, e;
  }()
);
Qt.Node = KP;
var Ub = (
  /** @class */
  function(e) {
    Ol(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(KP)
);
Qt.DataNode = Ub;
var c4 = (
  /** @class */
  function(e) {
    Ol(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = hi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ub)
);
Qt.Text = c4;
var p4 = (
  /** @class */
  function(e) {
    Ol(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = hi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ub)
);
Qt.Comment = p4;
var d4 = (
  /** @class */
  function(e) {
    Ol(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = hi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Ub)
);
Qt.ProcessingInstruction = d4;
var Wb = (
  /** @class */
  function(e) {
    Ol(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(KP)
);
Qt.NodeWithChildren = Wb;
var f4 = (
  /** @class */
  function(e) {
    Ol(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = hi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Wb)
);
Qt.CDATA = f4;
var h4 = (
  /** @class */
  function(e) {
    Ol(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = hi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Wb)
);
Qt.Document = h4;
var g4 = (
  /** @class */
  function(e) {
    Ol(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? hi.ElementType.Script : n === "style" ? hi.ElementType.Style : hi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Wb)
);
Qt.Element = g4;
function m4(e) {
  return (0, hi.isTag)(e);
}
Qt.isTag = m4;
function v4(e) {
  return e.type === hi.ElementType.CDATA;
}
Qt.isCDATA = v4;
function y4(e) {
  return e.type === hi.ElementType.Text;
}
Qt.isText = y4;
function b4(e) {
  return e.type === hi.ElementType.Comment;
}
Qt.isComment = b4;
function w4(e) {
  return e.type === hi.ElementType.Directive;
}
Qt.isDirective = w4;
function C4(e) {
  return e.type === hi.ElementType.Root;
}
Qt.isDocument = C4;
function yue(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Qt.hasChildren = yue;
function GP(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (y4(e))
    n = new c4(e.data);
  else if (b4(e))
    n = new p4(e.data);
  else if (m4(e)) {
    var r = t ? zw(e.children) : [], o = new g4(e.name, Up({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Up({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Up({}, e["x-attribsPrefix"])), n = o;
  } else if (v4(e)) {
    var r = t ? zw(e.children) : [], i = new f4(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (C4(e)) {
    var r = t ? zw(e.children) : [], a = new h4(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (w4(e)) {
    var s = new d4(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Qt.cloneNode = GP;
function zw(e) {
  for (var t = e.map(function(r) {
    return GP(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = rr && rr.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = rr && rr.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = qP, o = Qt;
  n(Qt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(ZP);
var O4 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(O4);
Object.defineProperty(zb, "__esModule", { value: !0 });
zb.formatAttributes = x4;
zb.formatDOM = E4;
var Mh = ZP, bue = O4;
function wue(e) {
  return bue.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function x4(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function Cue(e) {
  e = e.toLowerCase();
  var t = wue(e);
  return t || e;
}
function E4(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = Cue(s.nodeName);
        o = new Mh.Element(l, x4(s.attributes)), o.children = E4(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Mh.Text(s.nodeValue);
        break;
      case 8:
        o = new Mh.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Mh.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var Oue = rr && rr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(HP, "__esModule", { value: !0 });
HP.default = Pue;
var xue = Oue(VP), Eue = zb, Lue = /<(![a-zA-Z\s]+)>/;
function Pue(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(Lue), n = t ? t[1] : void 0;
  return (0, Eue.formatDOM)((0, xue.default)(e), null, n);
}
var $b = {}, gs = {}, Hb = {}, kue = 0;
Hb.SAME = kue;
var Sue = 1;
Hb.CAMELCASE = Sue;
Hb.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const L4 = 0, xl = 1, Vb = 2, Zb = 3, YP = 4, P4 = 5, k4 = 6;
function Mue(e) {
  return _o.hasOwnProperty(e) ? _o[e] : null;
}
function Ko(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === Vb || t === Zb || t === YP, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const _o = {}, Due = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
Due.forEach((e) => {
  _o[e] = new Ko(
    e,
    L4,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  _o[e] = new Ko(
    e,
    xl,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  _o[e] = new Ko(
    e,
    Vb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  _o[e] = new Ko(
    e,
    Vb,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  _o[e] = new Ko(
    e,
    Zb,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  _o[e] = new Ko(
    e,
    Zb,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  _o[e] = new Ko(
    e,
    YP,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  _o[e] = new Ko(
    e,
    k4,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  _o[e] = new Ko(
    e,
    P4,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const XP = /[\-\:]([a-z])/g, JP = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(XP, JP);
  _o[t] = new Ko(
    t,
    xl,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(XP, JP);
  _o[t] = new Ko(
    t,
    xl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(XP, JP);
  _o[t] = new Ko(
    t,
    xl,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  _o[e] = new Ko(
    e,
    xl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const _ue = "xlinkHref";
_o[_ue] = new Ko(
  "xlinkHref",
  xl,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  _o[e] = new Ko(
    e,
    xl,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: jue,
  SAME: Tue,
  possibleStandardNames: kT
} = Hb, Aue = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Iue = Aue + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", Bue = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Iue + "]*$")
), Nue = Object.keys(
  kT
).reduce((e, t) => {
  const n = kT[t];
  return n === Tue ? e[t] = t : n === jue ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
gs.BOOLEAN = Zb;
gs.BOOLEANISH_STRING = Vb;
gs.NUMERIC = P4;
gs.OVERLOADED_BOOLEAN = YP;
gs.POSITIVE_NUMERIC = k4;
gs.RESERVED = L4;
gs.STRING = xl;
gs.getPropertyInfo = Mue;
gs.isCustomAttribute = Bue;
gs.possibleStandardNames = Nue;
var QP = {}, ek = {}, ST = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, Rue = /\n/g, Fue = /^\s*/, zue = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Uue = /^:\s*/, Wue = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, $ue = /^[;\s]*/, Hue = /^\s+|\s+$/g, Vue = `
`, MT = "/", DT = "*", lu = "", Zue = "comment", que = "declaration", Kue = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(Rue);
    v && (n += v.length);
    var g = f.lastIndexOf(Vue);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var g = v[0];
      return o(g), e = e.slice(g.length), v;
    }
  }
  function u() {
    l(Fue);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(MT != e.charAt(0) || DT != e.charAt(1))) {
      for (var v = 2; lu != e.charAt(v) && (DT != e.charAt(v) || MT != e.charAt(v + 1)); )
        ++v;
      if (v += 2, lu === e.charAt(v - 1))
        return s("End of comment missing");
      var g = e.slice(2, v - 2);
      return r += 2, o(g), e = e.slice(v), r += 2, f({
        type: Zue,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), v = l(zue);
    if (v) {
      if (p(), !l(Uue)) return s("property missing ':'");
      var g = l(Wue), E = f({
        type: que,
        property: _T(v[0].replace(ST, lu)),
        value: g ? _T(g[0].replace(ST, lu)) : lu
      });
      return l($ue), E;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function _T(e) {
  return e ? e.replace(Hue, lu) : lu;
}
var Gue = rr && rr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ek, "__esModule", { value: !0 });
ek.default = Xue;
var Yue = Gue(Kue);
function Xue(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, Yue.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var qb = {};
Object.defineProperty(qb, "__esModule", { value: !0 });
qb.camelCase = void 0;
var Jue = /^--[a-zA-Z0-9_-]+$/, Que = /-([a-z])/g, ece = /^[^-]+$/, tce = /^-(webkit|moz|ms|o|khtml)-/, nce = /^-(ms)-/, rce = function(e) {
  return !e || ece.test(e) || Jue.test(e);
}, oce = function(e, t) {
  return t.toUpperCase();
}, jT = function(e, t) {
  return "".concat(t, "-");
}, ice = function(e, t) {
  return t === void 0 && (t = {}), rce(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(nce, jT) : e = e.replace(tce, jT), e.replace(Que, oce));
};
qb.camelCase = ice;
var sce = rr && rr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, ace = sce(ek), lce = qb;
function $x(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, ace.default)(e, function(r, o) {
    r && o && (n[(0, lce.camelCase)(r, t)] = o);
  }), n;
}
$x.default = $x;
var uce = $x;
(function(e) {
  var t = rr && rr.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Ce, r = t(uce), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(QP);
Object.defineProperty($b, "__esModule", { value: !0 });
$b.default = fce;
var kp = gs, TT = QP, cce = ["checked", "value"], pce = ["input", "select", "textarea"], dce = {
  reset: !0,
  submit: !0
};
function fce(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && dce[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, kp.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = AT(a);
    if (s) {
      var l = (0, kp.getPropertyInfo)(s);
      switch (cce.includes(s) && pce.includes(t) && !r && (s = AT("default" + a)), n[s] = i, l && l.type) {
        case kp.BOOLEAN:
          n[s] = !0;
          break;
        case kp.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    TT.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, TT.setStyleProp)(e.style, n), n;
}
function AT(e) {
  return kp.possibleStandardNames[e];
}
var tk = {}, hce = rr && rr.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(tk, "__esModule", { value: !0 });
tk.default = S4;
var Uw = Ce, gce = hce($b), Wp = QP, mce = {
  cloneElement: Uw.cloneElement,
  createElement: Uw.createElement,
  isValidElement: Uw.isValidElement
};
function S4(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Wp.returnFirstArg, i = t.library || mce, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, Wp.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    vce(f) ? ((0, Wp.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, gce.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (g = S4(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function vce(e) {
  return Wp.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Wp.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = rr && rr.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(HP);
  e.htmlToDOM = n.default;
  var r = t($b);
  e.attributesToProps = r.default;
  var o = t(tk);
  e.domToReact = o.default;
  var i = ZP;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(u4);
const yce = /* @__PURE__ */ Rle(u4);
yce.default;
var or = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function bce(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Hx = { exports: {} }, Zc = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var IT;
function wce() {
  if (IT) return Zc;
  IT = 1;
  var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, p = {}, d = null, y = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (y = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: s, key: d, ref: y, props: p, _owner: o.current };
  }
  return Zc.Fragment = n, Zc.jsx = a, Zc.jsxs = a, Zc;
}
var Dh = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var BT;
function Cce() {
  return BT || (BT = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Ce, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), y = Symbol.for("react.offscreen"), f = Symbol.iterator, v = "@@iterator";
    function g(b) {
      if (b === null || typeof b != "object")
        return null;
      var I = f && b[f] || b[v];
      return typeof I == "function" ? I : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w(b) {
      {
        for (var I = arguments.length, K = new Array(I > 1 ? I - 1 : 0), ne = 1; ne < I; ne++)
          K[ne - 1] = arguments[ne];
        D("error", b, K);
      }
    }
    function D(b, I, K) {
      {
        var ne = E.ReactDebugCurrentFrame, ae = ne.getStackAddendum();
        ae !== "" && (I += "%s", K = K.concat([ae]));
        var ce = K.map(function(se) {
          return String(se);
        });
        ce.unshift("Warning: " + I), Function.prototype.apply.call(console[b], console, ce);
      }
    }
    var x = !1, m = !1, C = !1, S = !1, z = !1, L;
    L = Symbol.for("react.module.reference");
    function R(b) {
      return !!(typeof b == "string" || typeof b == "function" || b === r || b === i || z || b === o || b === u || b === c || S || b === y || x || m || C || typeof b == "object" && b !== null && (b.$$typeof === d || b.$$typeof === p || b.$$typeof === a || b.$$typeof === s || b.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      b.$$typeof === L || b.getModuleId !== void 0));
    }
    function B(b, I, K) {
      var ne = b.displayName;
      if (ne)
        return ne;
      var ae = I.displayName || I.name || "";
      return ae !== "" ? K + "(" + ae + ")" : K;
    }
    function H(b) {
      return b.displayName || "Context";
    }
    function V(b) {
      if (b == null)
        return null;
      if (typeof b.tag == "number" && w("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof b == "function")
        return b.displayName || b.name || null;
      if (typeof b == "string")
        return b;
      switch (b) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case s:
            var I = b;
            return H(I) + ".Consumer";
          case a:
            var K = b;
            return H(K._context) + ".Provider";
          case l:
            return B(b, b.render, "ForwardRef");
          case p:
            var ne = b.displayName || null;
            return ne !== null ? ne : V(b.type) || "Memo";
          case d: {
            var ae = b, ce = ae._payload, se = ae._init;
            try {
              return V(se(ce));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var W = Object.assign, q = 0, Y, X, ee, J, k, _, U;
    function M() {
    }
    M.__reactDisabledLog = !0;
    function $() {
      {
        if (q === 0) {
          Y = console.log, X = console.info, ee = console.warn, J = console.error, k = console.group, _ = console.groupCollapsed, U = console.groupEnd;
          var b = {
            configurable: !0,
            enumerable: !0,
            value: M,
            writable: !0
          };
          Object.defineProperties(console, {
            info: b,
            log: b,
            warn: b,
            error: b,
            group: b,
            groupCollapsed: b,
            groupEnd: b
          });
        }
        q++;
      }
    }
    function O() {
      {
        if (q--, q === 0) {
          var b = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: W({}, b, {
              value: Y
            }),
            info: W({}, b, {
              value: X
            }),
            warn: W({}, b, {
              value: ee
            }),
            error: W({}, b, {
              value: J
            }),
            group: W({}, b, {
              value: k
            }),
            groupCollapsed: W({}, b, {
              value: _
            }),
            groupEnd: W({}, b, {
              value: U
            })
          });
        }
        q < 0 && w("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var j = E.ReactCurrentDispatcher, F;
    function T(b, I, K) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ae) {
            var ne = ae.stack.trim().match(/\n( *(at )?)/);
            F = ne && ne[1] || "";
          }
        return `
` + F + b;
      }
    }
    var Z = !1, A;
    {
      var G = typeof WeakMap == "function" ? WeakMap : Map;
      A = new G();
    }
    function N(b, I) {
      if (!b || Z)
        return "";
      {
        var K = A.get(b);
        if (K !== void 0)
          return K;
      }
      var ne;
      Z = !0;
      var ae = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var ce;
      ce = j.current, j.current = null, $();
      try {
        if (I) {
          var se = function() {
            throw Error();
          };
          if (Object.defineProperty(se.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(se, []);
            } catch (Te) {
              ne = Te;
            }
            Reflect.construct(b, [], se);
          } else {
            try {
              se.call();
            } catch (Te) {
              ne = Te;
            }
            b.call(se.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (Te) {
            ne = Te;
          }
          b();
        }
      } catch (Te) {
        if (Te && ne && typeof Te.stack == "string") {
          for (var ie = Te.stack.split(`
`), De = ne.stack.split(`
`), de = ie.length - 1, he = De.length - 1; de >= 1 && he >= 0 && ie[de] !== De[he]; )
            he--;
          for (; de >= 1 && he >= 0; de--, he--)
            if (ie[de] !== De[he]) {
              if (de !== 1 || he !== 1)
                do
                  if (de--, he--, he < 0 || ie[de] !== De[he]) {
                    var Ze = `
` + ie[de].replace(" at new ", " at ");
                    return b.displayName && Ze.includes("<anonymous>") && (Ze = Ze.replace("<anonymous>", b.displayName)), typeof b == "function" && A.set(b, Ze), Ze;
                  }
                while (de >= 1 && he >= 0);
              break;
            }
        }
      } finally {
        Z = !1, j.current = ce, O(), Error.prepareStackTrace = ae;
      }
      var Ot = b ? b.displayName || b.name : "", gt = Ot ? T(Ot) : "";
      return typeof b == "function" && A.set(b, gt), gt;
    }
    function ue(b, I, K) {
      return N(b, !1);
    }
    function fe(b) {
      var I = b.prototype;
      return !!(I && I.isReactComponent);
    }
    function oe(b, I, K) {
      if (b == null)
        return "";
      if (typeof b == "function")
        return N(b, fe(b));
      if (typeof b == "string")
        return T(b);
      switch (b) {
        case u:
          return T("Suspense");
        case c:
          return T("SuspenseList");
      }
      if (typeof b == "object")
        switch (b.$$typeof) {
          case l:
            return ue(b.render);
          case p:
            return oe(b.type, I, K);
          case d: {
            var ne = b, ae = ne._payload, ce = ne._init;
            try {
              return oe(ce(ae), I, K);
            } catch {
            }
          }
        }
      return "";
    }
    var Ie = Object.prototype.hasOwnProperty, qe = {}, Ge = E.ReactDebugCurrentFrame;
    function Be(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        Ge.setExtraStackFrame(K);
      } else
        Ge.setExtraStackFrame(null);
    }
    function et(b, I, K, ne, ae) {
      {
        var ce = Function.call.bind(Ie);
        for (var se in b)
          if (ce(b, se)) {
            var ie = void 0;
            try {
              if (typeof b[se] != "function") {
                var De = Error((ne || "React class") + ": " + K + " type `" + se + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof b[se] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw De.name = "Invariant Violation", De;
              }
              ie = b[se](I, se, ne, K, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (de) {
              ie = de;
            }
            ie && !(ie instanceof Error) && (Be(ae), w("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ne || "React class", K, se, typeof ie), Be(null)), ie instanceof Error && !(ie.message in qe) && (qe[ie.message] = !0, Be(ae), w("Failed %s type: %s", K, ie.message), Be(null));
          }
      }
    }
    var Xe = Array.isArray;
    function Me(b) {
      return Xe(b);
    }
    function Je(b) {
      {
        var I = typeof Symbol == "function" && Symbol.toStringTag, K = I && b[Symbol.toStringTag] || b.constructor.name || "Object";
        return K;
      }
    }
    function at(b) {
      try {
        return Se(b), !1;
      } catch {
        return !0;
      }
    }
    function Se(b) {
      return "" + b;
    }
    function _e(b) {
      if (at(b))
        return w("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Je(b)), Se(b);
    }
    var Ae = E.ReactCurrentOwner, Ve = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Ne, nt, we;
    we = {};
    function mt(b) {
      if (Ie.call(b, "ref")) {
        var I = Object.getOwnPropertyDescriptor(b, "ref").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.ref !== void 0;
    }
    function ot(b) {
      if (Ie.call(b, "key")) {
        var I = Object.getOwnPropertyDescriptor(b, "key").get;
        if (I && I.isReactWarning)
          return !1;
      }
      return b.key !== void 0;
    }
    function st(b, I) {
      if (typeof b.ref == "string" && Ae.current && I && Ae.current.stateNode !== I) {
        var K = V(Ae.current.type);
        we[K] || (w('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', V(Ae.current.type), b.ref), we[K] = !0);
      }
    }
    function ut(b, I) {
      {
        var K = function() {
          Ne || (Ne = !0, w("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "key", {
          get: K,
          configurable: !0
        });
      }
    }
    function vt(b, I) {
      {
        var K = function() {
          nt || (nt = !0, w("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", I));
        };
        K.isReactWarning = !0, Object.defineProperty(b, "ref", {
          get: K,
          configurable: !0
        });
      }
    }
    var ct = function(b, I, K, ne, ae, ce, se) {
      var ie = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: b,
        key: I,
        ref: K,
        props: se,
        // Record the component responsible for creating this element.
        _owner: ce
      };
      return ie._store = {}, Object.defineProperty(ie._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ie, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ne
      }), Object.defineProperty(ie, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ae
      }), Object.freeze && (Object.freeze(ie.props), Object.freeze(ie)), ie;
    };
    function yt(b, I, K, ne, ae) {
      {
        var ce, se = {}, ie = null, De = null;
        K !== void 0 && (_e(K), ie = "" + K), ot(I) && (_e(I.key), ie = "" + I.key), mt(I) && (De = I.ref, st(I, ae));
        for (ce in I)
          Ie.call(I, ce) && !Ve.hasOwnProperty(ce) && (se[ce] = I[ce]);
        if (b && b.defaultProps) {
          var de = b.defaultProps;
          for (ce in de)
            se[ce] === void 0 && (se[ce] = de[ce]);
        }
        if (ie || De) {
          var he = typeof b == "function" ? b.displayName || b.name || "Unknown" : b;
          ie && ut(se, he), De && vt(se, he);
        }
        return ct(b, ie, De, ae, ne, Ae.current, se);
      }
    }
    var Qe = E.ReactCurrentOwner, ft = E.ReactDebugCurrentFrame;
    function tt(b) {
      if (b) {
        var I = b._owner, K = oe(b.type, b._source, I ? I.type : null);
        ft.setExtraStackFrame(K);
      } else
        ft.setExtraStackFrame(null);
    }
    var bt;
    bt = !1;
    function pt(b) {
      return typeof b == "object" && b !== null && b.$$typeof === t;
    }
    function Dt() {
      {
        if (Qe.current) {
          var b = V(Qe.current.type);
          if (b)
            return `

Check the render method of \`` + b + "`.";
        }
        return "";
      }
    }
    function wt(b) {
      return "";
    }
    var _t = {};
    function Ct(b) {
      {
        var I = Dt();
        if (!I) {
          var K = typeof b == "string" ? b : b.displayName || b.name;
          K && (I = `

Check the top-level render call using <` + K + ">.");
        }
        return I;
      }
    }
    function jt(b, I) {
      {
        if (!b._store || b._store.validated || b.key != null)
          return;
        b._store.validated = !0;
        var K = Ct(I);
        if (_t[K])
          return;
        _t[K] = !0;
        var ne = "";
        b && b._owner && b._owner !== Qe.current && (ne = " It was passed a child from " + V(b._owner.type) + "."), tt(b), w('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', K, ne), tt(null);
      }
    }
    function Cn(b, I) {
      {
        if (typeof b != "object")
          return;
        if (Me(b))
          for (var K = 0; K < b.length; K++) {
            var ne = b[K];
            pt(ne) && jt(ne, I);
          }
        else if (pt(b))
          b._store && (b._store.validated = !0);
        else if (b) {
          var ae = g(b);
          if (typeof ae == "function" && ae !== b.entries)
            for (var ce = ae.call(b), se; !(se = ce.next()).done; )
              pt(se.value) && jt(se.value, I);
        }
      }
    }
    function ht(b) {
      {
        var I = b.type;
        if (I == null || typeof I == "string")
          return;
        var K;
        if (typeof I == "function")
          K = I.propTypes;
        else if (typeof I == "object" && (I.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        I.$$typeof === p))
          K = I.propTypes;
        else
          return;
        if (K) {
          var ne = V(I);
          et(K, b.props, "prop", ne, b);
        } else if (I.PropTypes !== void 0 && !bt) {
          bt = !0;
          var ae = V(I);
          w("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ae || "Unknown");
        }
        typeof I.getDefaultProps == "function" && !I.getDefaultProps.isReactClassApproved && w("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function re(b) {
      {
        for (var I = Object.keys(b.props), K = 0; K < I.length; K++) {
          var ne = I[K];
          if (ne !== "children" && ne !== "key") {
            tt(b), w("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ne), tt(null);
            break;
          }
        }
        b.ref !== null && (tt(b), w("Invalid attribute `ref` supplied to `React.Fragment`."), tt(null));
      }
    }
    var mo = {};
    function vo(b, I, K, ne, ae, ce) {
      {
        var se = R(b);
        if (!se) {
          var ie = "";
          (b === void 0 || typeof b == "object" && b !== null && Object.keys(b).length === 0) && (ie += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var De = wt();
          De ? ie += De : ie += Dt();
          var de;
          b === null ? de = "null" : Me(b) ? de = "array" : b !== void 0 && b.$$typeof === t ? (de = "<" + (V(b.type) || "Unknown") + " />", ie = " Did you accidentally export a JSX literal instead of a component?") : de = typeof b, w("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", de, ie);
        }
        var he = yt(b, I, K, ae, ce);
        if (he == null)
          return he;
        if (se) {
          var Ze = I.children;
          if (Ze !== void 0)
            if (ne)
              if (Me(Ze)) {
                for (var Ot = 0; Ot < Ze.length; Ot++)
                  Cn(Ze[Ot], b);
                Object.freeze && Object.freeze(Ze);
              } else
                w("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Cn(Ze, b);
        }
        if (Ie.call(I, "key")) {
          var gt = V(b), Te = Object.keys(I).filter(function(Li) {
            return Li !== "key";
          }), ar = Te.length > 0 ? "{key: someKey, " + Te.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!mo[gt + ar]) {
            var Ei = Te.length > 0 ? "{" + Te.join(": ..., ") + ": ...}" : "{}";
            w(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, ar, gt, Ei, gt), mo[gt + ar] = !0;
          }
        }
        return b === r ? re(he) : ht(he), he;
      }
    }
    function wi(b, I, K) {
      return vo(b, I, K, !0);
    }
    function Ci(b, I, K) {
      return vo(b, I, K, !1);
    }
    var Oi = Ci, xi = wi;
    Dh.Fragment = r, Dh.jsx = Oi, Dh.jsxs = xi;
  }()), Dh;
}
process.env.NODE_ENV === "production" ? Hx.exports = wce() : Hx.exports = Cce();
var li = Hx.exports;
Ye({});
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function NT(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Fo(e) {
  var t, n;
  return NT(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(NT(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var M4 = Symbol.for("immer-nothing"), RT = Symbol.for("immer-draftable"), Ji = Symbol.for("immer-state"), Oce = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ri(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = Oce[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var uc = Object.getPrototypeOf;
function zu(e) {
  return !!e && !!e[Ji];
}
function Uu(e) {
  var t;
  return e ? D4(e) || Array.isArray(e) || !!e[RT] || !!((t = e.constructor) != null && t[RT]) || Gb(e) || Yb(e) : !1;
}
var xce = Object.prototype.constructor.toString();
function D4(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = uc(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === xce;
}
function Qm(e, t) {
  Kb(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Kb(e) {
  const t = e[Ji];
  return t ? t.type_ : Array.isArray(e) ? 1 : Gb(e) ? 2 : Yb(e) ? 3 : 0;
}
function Vx(e, t) {
  return Kb(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function _4(e, t, n) {
  const r = Kb(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function Ece(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Gb(e) {
  return e instanceof Map;
}
function Yb(e) {
  return e instanceof Set;
}
function tu(e) {
  return e.copy_ || e.base_;
}
function Zx(e, t) {
  if (Gb(e))
    return new Map(e);
  if (Yb(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = D4(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Ji];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: e[a]
      });
    }
    return Object.create(uc(e), r);
  } else {
    const r = uc(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function nk(e, t = !1) {
  return Xb(e) || zu(e) || !Uu(e) || (Kb(e) > 1 && (e.set = e.add = e.clear = e.delete = Lce), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => nk(r, !0))), e;
}
function Lce() {
  ri(2);
}
function Xb(e) {
  return Object.isFrozen(e);
}
var Pce = {};
function Wu(e) {
  const t = Pce[e];
  return t || ri(0, e), t;
}
var _d;
function j4() {
  return _d;
}
function kce(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function FT(e, t) {
  t && (Wu("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function qx(e) {
  Kx(e), e.drafts_.forEach(Sce), e.drafts_ = null;
}
function Kx(e) {
  e === _d && (_d = e.parent_);
}
function zT(e) {
  return _d = kce(_d, e);
}
function Sce(e) {
  const t = e[Ji];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function UT(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Ji].modified_ && (qx(t), ri(4)), Uu(e) && (e = ev(t, e), t.parent_ || tv(t, e)), t.patches_ && Wu("Patches").generateReplacementPatches_(
    n[Ji].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = ev(t, n, []), qx(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== M4 ? e : void 0;
}
function ev(e, t, n) {
  if (Xb(t))
    return t;
  const r = t[Ji];
  if (!r)
    return Qm(
      t,
      (o, i) => WT(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return tv(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), Qm(
      i,
      (s, l) => WT(e, r, o, s, l, n, a)
    ), tv(e, o, !1), n && e.patches_ && Wu("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function WT(e, t, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ri(5), zu(o)) {
    const s = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Vx(t.assigned_, r) ? i.concat(r) : void 0, l = ev(e, o, s);
    if (_4(n, r, l), zu(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Uu(o) && !Xb(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    ev(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && tv(e, o);
  }
}
function tv(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && nk(t, n);
}
function Mce(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : j4(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = rk;
  n && (o = [r], i = jd);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var rk = {
  get(e, t) {
    if (t === Ji)
      return e;
    const n = tu(e);
    if (!Vx(n, t))
      return Dce(e, n, t);
    const r = n[t];
    return e.finalized_ || !Uu(r) ? r : r === Ww(e.base_, t) ? ($w(e), e.copy_[t] = Yx(r, e)) : r;
  },
  has(e, t) {
    return t in tu(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(tu(e));
  },
  set(e, t, n) {
    const r = T4(tu(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Ww(tu(e), t), i = o == null ? void 0 : o[Ji];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (Ece(n, o) && (n !== void 0 || Vx(e.base_, t)))
        return !0;
      $w(e), Gx(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Ww(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, $w(e), Gx(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = tu(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    ri(11);
  },
  getPrototypeOf(e) {
    return uc(e.base_);
  },
  setPrototypeOf() {
    ri(12);
  }
}, jd = {};
Qm(rk, (e, t) => {
  jd[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
jd.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && ri(13), jd.set.call(this, e, t, void 0);
};
jd.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && ri(14), rk.set.call(this, e[0], t, n, e[0]);
};
function Ww(e, t) {
  const n = e[Ji];
  return (n ? tu(n) : e)[t];
}
function Dce(e, t, n) {
  var r;
  const o = T4(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function T4(e, t) {
  if (!(t in e))
    return;
  let n = uc(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = uc(n);
  }
}
function Gx(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Gx(e.parent_));
}
function $w(e) {
  e.copy_ || (e.copy_ = Zx(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var _ce = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ri(6), r !== void 0 && typeof r != "function" && ri(7);
      let o;
      if (Uu(t)) {
        const i = zT(this), a = Yx(t, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? qx(i) : Kx(i);
        }
        return FT(i, r), UT(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === M4 && (o = void 0), this.autoFreeze_ && nk(o, !0), r) {
          const i = [], a = [];
          Wu("Patches").generateReplacementPatches_(t, o, i, a), r(i, a);
        }
        return o;
      } else
        ri(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => t(s, ...a));
      let r, o;
      return [this.produce(t, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Uu(e) || ri(8), zu(e) && (e = jce(e));
    const t = zT(this), n = Yx(e, void 0);
    return n[Ji].isManual_ = !0, Kx(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Ji];
    (!n || !n.isManual_) && ri(9);
    const { scope_: r } = n;
    return FT(r, t), UT(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Wu("Patches").applyPatches_;
    return zu(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Yx(e, t) {
  const n = Gb(e) ? Wu("MapSet").proxyMap_(e, t) : Yb(e) ? Wu("MapSet").proxySet_(e, t) : Mce(e, t);
  return (t ? t.scope_ : j4()).drafts_.push(n), n;
}
function jce(e) {
  return zu(e) || ri(10, e), A4(e);
}
function A4(e) {
  if (!Uu(e) || Xb(e))
    return e;
  const t = e[Ji];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Zx(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Zx(e, !0);
  return Qm(n, (r, o) => {
    _4(n, r, A4(o));
  }), t && (t.finalized_ = !1), n;
}
var Qi = new _ce(), ok = Qi.produce;
Qi.produceWithPatches.bind(
  Qi
);
Qi.setAutoFreeze.bind(Qi);
Qi.setUseStrictShallowCopy.bind(Qi);
Qi.applyPatches.bind(Qi);
var $T = Qi.createDraft.bind(Qi), HT = Qi.finishDraft.bind(Qi), He = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = He.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return He.equals(r, o) && i > a;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return He.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], a = t[n];
    return He.equals(r, o) && i < a;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return He.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && He.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return He.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && He.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && He.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && He.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && He.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && He.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!He.isAncestor(t, e) && !He.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (He.equals(i, r) || He.endsBefore(i, r) || He.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = t;
        if (He.equals(a, r) || He.isAncestor(a, r))
          return null;
        He.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = t;
        He.equals(s, r) || He.endsBefore(s, r) ? r[s.length - 1] -= 1 : He.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (He.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else He.endsBefore(u, r) ? r[u.length - 1] += 1 : He.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (He.equals(p, d))
          return r;
        if (He.isAncestor(p, r) || He.equals(p, r)) {
          var y = d.slice();
          return He.endsBefore(p, d) && p.length < d.length && (y[p.length - 1] -= 1), y.concat(r.slice(p.length));
        } else He.isSibling(p, d) && (He.isAncestor(d, r) || He.equals(d, r)) ? He.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : He.endsBefore(d, r) || He.equals(d, r) || He.isAncestor(d, r) ? (He.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : He.endsBefore(p, r) && (He.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Td(e) {
  "@babel/helpers - typeof";
  return Td = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Td(e);
}
function Tce(e, t) {
  if (Td(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Td(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Ace(e) {
  var t = Tce(e, "string");
  return Td(t) === "symbol" ? t : String(t);
}
function yc(e, t, n) {
  return t = Ace(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function VT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VT(Object(n), !0).forEach(function(r) {
      yc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Ice = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Mt.parent(e, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), t)
        for (var [s, l] of Zt.points(t))
          t[l] = br.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Mt.leaf(e, u), y = d.text.slice(0, c), f = d.text.slice(c);
      if (d.text = y + p + f, t)
        for (var [v, g] of Zt.points(t))
          t[g] = br.transform(v, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, w = Mt.get(e, E), D = He.previous(E), x = Mt.get(e, D), m = Mt.parent(e, E), C = E[E.length - 1];
      if (ao.isText(w) && ao.isText(x))
        x.text += w.text;
      else if (!ao.isText(w) && !ao.isText(x))
        x.children.push(...w.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(_i.stringify(w), " ").concat(_i.stringify(x)));
      if (m.children.splice(C, 1), t)
        for (var [S, z] of Zt.points(t))
          t[z] = br.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: L,
        newPath: R
      } = n;
      if (He.isAncestor(L, R))
        throw new Error("Cannot move a path [".concat(L, "] to new path [").concat(R, "] because the destination is inside itself."));
      var B = Mt.get(e, L), H = Mt.parent(e, L), V = L[L.length - 1];
      H.children.splice(V, 1);
      var W = He.transform(L, n), q = Mt.get(e, He.parent(W)), Y = W[W.length - 1];
      if (q.children.splice(Y, 0, B), t)
        for (var [X, ee] of Zt.points(t))
          t[ee] = br.transform(X, n);
      break;
    }
    case "remove_node": {
      var {
        path: J
      } = n, k = J[J.length - 1], _ = Mt.parent(e, J);
      if (_.children.splice(k, 1), t)
        for (var [U, M] of Zt.points(t)) {
          var $ = br.transform(U, n);
          if (t != null && $ != null)
            t[M] = $;
          else {
            var O = void 0, j = void 0;
            for (var [F, T] of Mt.texts(e))
              if (He.compare(T, J) === -1)
                O = [F, T];
              else {
                j = [F, T];
                break;
              }
            var Z = !1;
            O && j && (He.equals(j[1], J) ? Z = !He.hasPrevious(j[1]) : Z = He.common(O[1], J).length < He.common(j[1], J).length), O && !Z ? (U.path = O[1], U.offset = O[0].text.length) : j ? (U.path = j[1], U.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: A,
        offset: G,
        text: N
      } = n;
      if (N.length === 0) break;
      var ue = Mt.leaf(e, A), fe = ue.text.slice(0, G), oe = ue.text.slice(G + N.length);
      if (ue.text = fe + oe, t)
        for (var [Ie, qe] of Zt.points(t))
          t[qe] = br.transform(Ie, n);
      break;
    }
    case "set_node": {
      var {
        path: Ge,
        properties: Be,
        newProperties: et
      } = n;
      if (Ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var Xe = Mt.get(e, Ge);
      for (var Me in et) {
        if (Me === "children" || Me === "text")
          throw new Error('Cannot set the "'.concat(Me, '" property of nodes!'));
        var Je = et[Me];
        Je == null ? delete Xe[Me] : Xe[Me] = Je;
      }
      for (var at in Be)
        et.hasOwnProperty(at) || delete Xe[at];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Se
      } = n;
      if (Se == null)
        t = Se;
      else {
        if (t == null) {
          if (!Zt.isRange(Se))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(_i.stringify(Se), " when there is no current selection."));
          t = qc({}, Se);
        }
        for (var _e in Se) {
          var Ae = Se[_e];
          if (Ae == null) {
            if (_e === "anchor" || _e === "focus")
              throw new Error('Cannot remove the "'.concat(_e, '" selection property'));
            delete t[_e];
          } else
            t[_e] = Ae;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ve,
        position: Ne,
        properties: nt
      } = n;
      if (Ve.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ve, "] because the root node cannot be split."));
      var we = Mt.get(e, Ve), mt = Mt.parent(e, Ve), ot = Ve[Ve.length - 1], st;
      if (ao.isText(we)) {
        var ut = we.text.slice(0, Ne), vt = we.text.slice(Ne);
        we.text = ut, st = qc(qc({}, nt), {}, {
          text: vt
        });
      } else {
        var ct = we.children.slice(0, Ne), yt = we.children.slice(Ne);
        we.children = ct, st = qc(qc({}, nt), {}, {
          children: yt
        });
      }
      if (mt.children.splice(ot + 1, 0, st), t)
        for (var [Qe, ft] of Zt.points(t))
          t[ft] = br.transform(Qe, n);
      break;
    }
  }
  return t;
}, Bce = {
  transform(e, t) {
    e.children = $T(e.children);
    var n = e.selection && $T(e.selection);
    try {
      n = Ice(e, n, t);
    } finally {
      e.children = HT(e.children), n ? e.selection = zu(n) ? HT(n) : n : e.selection = null;
    }
  }
}, Nce = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, Rce = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, I4 = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Fo(r) && Fo(o)) {
      if (!I4(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in t)
    if (e[a] === void 0 && t[a] !== void 0)
      return !1;
  return !0;
};
function Fce(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Ad(e, t) {
  if (e == null) return {};
  var n = Fce(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var zce = ["anchor", "focus"];
function ZT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uce(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZT(Object(n), !0).forEach(function(r) {
      yc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Zt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return Zt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = Zt.edges(e);
    return t;
  },
  equals(e, t) {
    return br.equals(e.anchor, t.anchor) && br.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (Zt.isRange(t)) {
      if (Zt.includes(e, t.anchor) || Zt.includes(e, t.focus))
        return !0;
      var [n, r] = Zt.edges(e), [o, i] = Zt.edges(t);
      return br.isBefore(n, o) && br.isAfter(r, i);
    }
    var [a, s] = Zt.edges(e), l = !1, u = !1;
    return br.isPoint(t) ? (l = br.compare(t, a) >= 0, u = br.compare(t, s) <= 0) : (l = He.compare(t, a.path) >= 0, u = He.compare(t, s.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Ad(e, zce), [r, o] = Zt.edges(e), [i, a] = Zt.edges(t), s = br.isBefore(r, i) ? i : r, l = br.isBefore(o, a) ? o : a;
    return br.isBefore(l, s) ? null : Uce({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return br.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return br.equals(t, n);
  },
  isExpanded(e) {
    return !Zt.isCollapsed(e);
  },
  isForward(e) {
    return !Zt.isBackward(e);
  },
  isRange(e) {
    return Fo(e) && br.isPoint(e.anchor) && br.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = Zt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ok(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Zt.isCollapsed(r);
        Zt.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Zt.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = br.transform(r.anchor, t, {
        affinity: i
      }), u = br.transform(r.focus, t, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, qT = (e) => Fo(e) && Mt.isNodeList(e.children) && !Xn.isEditor(e), ia = {
  isAncestor(e) {
    return Fo(e) && Mt.isNodeList(e.children);
  },
  isElement: qT,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => ia.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return qT(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, Wce = ["children"], $ce = ["text"], KT = /* @__PURE__ */ new WeakMap(), Mt = {
  ancestor(e, t) {
    var n = Mt.get(e, t);
    if (ao.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(_i.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of He.ancestors(t, n)) {
        var o = Mt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (ao.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(_i.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(_i.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Mt.ancestor(e, t), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Mt.child(o, a), l = t.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = He.common(t, n), o = Mt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Mt.get(e, t);
    if (Xn.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(_i.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Mt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Mt.nodes(e, t))
        ia.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (ia.isAncestor(e)) {
      var t = Ad(e, Wce);
      return t;
    } else {
      var t = Ad(e, $ce);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Mt.get(e, n); r && !(ao.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (ao.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(_i.stringify(e)));
    var n = ok({
      children: e.children
    }, (r) => {
      var [o, i] = Zt.edges(t), a = Mt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, y] = d;
          return !Zt.includes(t, y);
        }
      });
      for (var [, s] of a) {
        if (!Zt.includes(t, s)) {
          var l = Mt.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (He.equals(s, i.path)) {
          var c = Mt.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (He.equals(s, o.path)) {
          var p = Mt.leaf(r, s);
          p.text = p.text.slice(o.offset);
        }
      }
      Xn.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ao.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(_i.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (ao.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return ao.isText(e) || ia.isElement(e) || Xn.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = KT.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Mt.isNode(r));
    return KT.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Mt.get(e, n); r && !(ao.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Mt.get(e, t);
    if (!ao.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(_i.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of He.levels(t, n)) {
        var o = Mt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return ia.isElement(e) && ia.isElementProps(t) && ia.matches(e, t) || ao.isText(e) && ao.isTextProps(t) && ao.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, a = /* @__PURE__ */ new Set(), s = [], l = e; !(i && (r ? He.isBefore(s, i) : He.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !ao.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          He.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Mt.get(e, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = He.next(s);
          if (Mt.has(e, c)) {
            s = c, l = Mt.get(e, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var p = He.previous(s);
          s = p, l = Mt.get(e, s);
          continue;
        }
        s = He.parent(s), l = Mt.get(e, s), a.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = He.parent(t), r = Mt.get(e, n);
    if (ao.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return ao.isText(e) ? e.text : e.children.map(Mt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Mt.nodes(e, t))
        ao.isText(n) && (yield [n, r]);
    }();
  }
};
function GT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pr(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GT(Object(n), !0).forEach(function(r) {
      yc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Sp = {
  isNodeOperation(e) {
    return Sp.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Fo(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return He.isPath(e.path) && Mt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && He.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && He.isPath(e.path) && Fo(e.properties);
      case "move_node":
        return He.isPath(e.path) && He.isPath(e.newPath);
      case "remove_node":
        return He.isPath(e.path) && Mt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && He.isPath(e.path);
      case "set_node":
        return He.isPath(e.path) && Fo(e.properties) && Fo(e.newProperties);
      case "set_selection":
        return e.properties === null && Zt.isRange(e.newProperties) || e.newProperties === null && Zt.isRange(e.properties) || Fo(e.properties) && Fo(e.newProperties);
      case "split_node":
        return He.isPath(e.path) && typeof e.position == "number" && Fo(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => Sp.isOperation(t));
  },
  isSelectionOperation(e) {
    return Sp.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return Sp.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Pr(Pr({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Pr(Pr({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Pr(Pr({}, e), {}, {
          type: "split_node",
          path: He.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (He.equals(t, n))
          return e;
        if (He.isSibling(n, t))
          return Pr(Pr({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = He.transform(n, e), o = He.transform(He.next(n), e);
        return Pr(Pr({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Pr(Pr({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Pr(Pr({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = e;
        return Pr(Pr({}, e), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = e;
        return s == null ? Pr(Pr({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Pr(Pr({}, e), {}, {
          properties: null,
          newProperties: s
        }) : Pr(Pr({}, e), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Pr(Pr({}, e), {}, {
          type: "merge_node",
          path: He.next(e.path)
        });
    }
  }
}, YT = /* @__PURE__ */ new WeakMap(), Hce = (e) => {
  var t = YT.get(e);
  if (t !== void 0)
    return t;
  if (!Fo(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Fo(e.marks)) && (e.selection === null || Zt.isRange(e.selection)) && Mt.isNodeList(e.children) && Sp.isOperationList(e.operations);
  return YT.set(e, n), n;
}, Xn = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return Hce(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function XT(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function JT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XT(Object(n), !0).forEach(function(r) {
      yc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XT(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var br = {
  compare(e, t) {
    var n = He.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return br.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return br.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && He.equals(e.path, t.path);
  },
  isPoint(e) {
    return Fo(e) && typeof e.offset == "number" && He.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ok(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = He.transform(i, t, n);
          break;
        }
        case "insert_text": {
          He.equals(t.path, i) && (t.offset < a || t.offset === a && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          He.equals(t.path, i) && (r.offset += t.position), r.path = He.transform(i, t, n);
          break;
        }
        case "remove_text": {
          He.equals(t.path, i) && t.offset <= a && (r.offset -= Math.min(a - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (He.equals(t.path, i) || He.isAncestor(t.path, i))
            return null;
          r.path = He.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (He.equals(t.path, i)) {
            if (t.position === a && o == null)
              return null;
            (t.position < a || t.position === a && o === "forward") && (r.offset -= t.position, r.path = He.transform(i, t, JT(JT({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = He.transform(i, t, n);
          break;
        }
      }
    });
  }
}, QT = void 0, _i = {
  setScrubber(e) {
    QT = e;
  },
  stringify(e) {
    return JSON.stringify(e, QT);
  }
}, Vce = ["text"], Zce = ["anchor", "focus"];
function eA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zs(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eA(Object(n), !0).forEach(function(r) {
      yc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ao = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Ad(i, Vce);
      return a;
    }
    return I4(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Fo(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => ao.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Zs({}, e)];
    for (var r of t) {
      var o = Ad(r, Zce), [i, a] = Zt.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, y = l;
        if (l += d, u <= y && l <= c) {
          Object.assign(p, o), s.push(p);
          continue;
        }
        if (u !== c && (u === l || c === y) || u > l || c < y || c === y && y !== 0) {
          s.push(p);
          continue;
        }
        var f = p, v = void 0, g = void 0;
        if (c < l) {
          var E = c - y;
          g = Zs(Zs({}, f), {}, {
            text: f.text.slice(E)
          }), f = Zs(Zs({}, f), {}, {
            text: f.text.slice(0, E)
          });
        }
        if (u > y) {
          var w = u - y;
          v = Zs(Zs({}, f), {}, {
            text: f.text.slice(0, w)
          }), f = Zs(Zs({}, f), {}, {
            text: f.text.slice(w)
          });
        }
        Object.assign(f, o), v && s.push(v), s.push(f), g && s.push(g);
      }
      n = s;
    }
    return n;
  }
}, qce = (e) => e.selection ? e.selection : e.children.length > 0 ? Xn.end(e, []) : [0], fr;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(fr || (fr = {}));
fr.L, fr.L | fr.V | fr.LV | fr.LVT, fr.LV | fr.V, fr.V | fr.T, fr.LVT | fr.T, fr.T, fr.Any, fr.Extend | fr.ZWJ, fr.Any, fr.SpacingMark, fr.Prepend, fr.Any, fr.ZWJ, fr.ExtPict, fr.RI, fr.RI;
var Kce = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Xn.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = qce(e)
      } = n;
      if (He.isPath(o) && (o = Xn.range(e, o)), Zt.isRange(o))
        if (Zt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Zt.end(o);
          if (!r && Xn.void(e, {
            at: i
          }))
            return;
          var a = Zt.start(o), s = Xn.pointRef(e, a), l = Xn.pointRef(e, i);
          nv.delete(e, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, nv.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Xn.void(e, {
        at: o
      }) || Xn.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function tA(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _h(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tA(Object(n), !0).forEach(function(r) {
      yc(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tA(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nv = _h(_h(_h(_h({}, Bce), Nce), Rce), Kce), B4 = {}, ik = {}, sk = {};
Object.defineProperty(sk, "__esModule", { value: !0 });
sk.default = Jce;
var nA = "html", rA = "head", jh = "body", Gce = /<([a-zA-Z]+[0-9]?)/, oA = /<head[^]*>/i, iA = /<body[^]*>/i, rv = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Xx = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, sA = typeof window == "object" && window.DOMParser;
if (typeof sA == "function") {
  var Yce = new sA(), Xce = "text/html";
  Xx = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), Yce.parseFromString(e, Xce);
  }, rv = Xx;
}
if (typeof document == "object" && document.implementation) {
  var Th = document.implementation.createHTMLDocument();
  rv = function(e, t) {
    if (t) {
      var n = Th.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Th;
    }
    return Th.documentElement.innerHTML = e, Th;
  };
}
var Ah = typeof document == "object" && document.createElement("template"), Jx;
Ah && Ah.content && (Jx = function(e) {
  return Ah.innerHTML = e, Ah.content.childNodes;
});
function Jce(e) {
  var t, n, r = e.match(Gce), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case nA: {
      var i = Xx(e);
      if (!oA.test(e)) {
        var a = i.querySelector(rA);
        (t = a == null ? void 0 : a.parentNode) === null || t === void 0 || t.removeChild(a);
      }
      if (!iA.test(e)) {
        var a = i.querySelector(jh);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(nA);
    }
    case rA:
    case jh: {
      var s = rv(e).querySelectorAll(o);
      return iA.test(e) && oA.test(e) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (Jx)
        return Jx(e);
      var a = rv(e, jh).querySelector(jh);
      return a.childNodes;
    }
  }
}
var Jb = {}, ak = {}, lk = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(lk);
var en = {}, El = or && or.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), $p = or && or.__assign || function() {
  return $p = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, $p.apply(this, arguments);
};
Object.defineProperty(en, "__esModule", { value: !0 });
en.cloneNode = en.hasChildren = en.isDocument = en.isDirective = en.isComment = en.isText = en.isCDATA = en.isTag = en.Element = en.Document = en.CDATA = en.NodeWithChildren = en.ProcessingInstruction = en.Comment = en.Text = en.DataNode = en.Node = void 0;
var gi = lk, uk = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), ck(this, t);
    }, e;
  }()
);
en.Node = uk;
var Qb = (
  /** @class */
  function(e) {
    El(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uk)
);
en.DataNode = Qb;
var N4 = (
  /** @class */
  function(e) {
    El(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = gi.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qb)
);
en.Text = N4;
var R4 = (
  /** @class */
  function(e) {
    El(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = gi.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qb)
);
en.Comment = R4;
var F4 = (
  /** @class */
  function(e) {
    El(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = gi.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Qb)
);
en.ProcessingInstruction = F4;
var e0 = (
  /** @class */
  function(e) {
    El(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(uk)
);
en.NodeWithChildren = e0;
var z4 = (
  /** @class */
  function(e) {
    El(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = gi.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(e0)
);
en.CDATA = z4;
var U4 = (
  /** @class */
  function(e) {
    El(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = gi.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(e0)
);
en.Document = U4;
var W4 = (
  /** @class */
  function(e) {
    El(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? gi.ElementType.Script : n === "style" ? gi.ElementType.Style : gi.ElementType.Tag);
      var a = e.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(e0)
);
en.Element = W4;
function $4(e) {
  return (0, gi.isTag)(e);
}
en.isTag = $4;
function H4(e) {
  return e.type === gi.ElementType.CDATA;
}
en.isCDATA = H4;
function V4(e) {
  return e.type === gi.ElementType.Text;
}
en.isText = V4;
function Z4(e) {
  return e.type === gi.ElementType.Comment;
}
en.isComment = Z4;
function q4(e) {
  return e.type === gi.ElementType.Directive;
}
en.isDirective = q4;
function K4(e) {
  return e.type === gi.ElementType.Root;
}
en.isDocument = K4;
function Qce(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
en.hasChildren = Qce;
function ck(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (V4(e))
    n = new N4(e.data);
  else if (Z4(e))
    n = new R4(e.data);
  else if ($4(e)) {
    var r = t ? Hw(e.children) : [], o = new W4(e.name, $p({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = $p({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = $p({}, e["x-attribsPrefix"])), n = o;
  } else if (H4(e)) {
    var r = t ? Hw(e.children) : [], i = new z4(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (K4(e)) {
    var r = t ? Hw(e.children) : [], a = new U4(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), e["x-mode"] && (a["x-mode"] = e["x-mode"]), n = a;
  } else if (q4(e)) {
    var s = new F4(e.name, e.data);
    e["x-name"] != null && (s["x-name"] = e["x-name"], s["x-publicId"] = e["x-publicId"], s["x-systemId"] = e["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
en.cloneNode = ck;
function Hw(e) {
  for (var t = e.map(function(r) {
    return ck(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = or && or.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, p);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = or && or.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, s, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = lk, o = en;
  n(en, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  e.DomHandler = a, e.default = a;
})(ak);
var G4 = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(G4);
Object.defineProperty(Jb, "__esModule", { value: !0 });
Jb.formatAttributes = Y4;
Jb.formatDOM = X4;
var Ih = ak, epe = G4;
function tpe(e) {
  return epe.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function Y4(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function npe(e) {
  e = e.toLowerCase();
  var t = tpe(e);
  return t || e;
}
function X4(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, a = e.length; i < a; i++) {
    var s = e[i];
    switch (s.nodeType) {
      case 1: {
        var l = npe(s.nodeName);
        o = new Ih.Element(l, Y4(s.attributes)), o.children = X4(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Ih.Text(s.nodeValue);
        break;
      case 8:
        o = new Ih.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Ih.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var rpe = or && or.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(ik, "__esModule", { value: !0 });
ik.default = ape;
var ope = rpe(sk), ipe = Jb, spe = /<(![a-zA-Z\s]+)>/;
function ape(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(spe), n = t ? t[1] : void 0;
  return (0, ipe.formatDOM)((0, ope.default)(e), null, n);
}
var t0 = {}, ms = {}, n0 = {}, lpe = 0;
n0.SAME = lpe;
var upe = 1;
n0.CAMELCASE = upe;
n0.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const J4 = 0, Ll = 1, r0 = 2, o0 = 3, pk = 4, Q4 = 5, e7 = 6;
function cpe(e) {
  return jo.hasOwnProperty(e) ? jo[e] : null;
}
function Go(e, t, n, r, o, i, a) {
  this.acceptsBooleans = t === r0 || t === o0 || t === pk, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = a;
}
const jo = {}, ppe = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
ppe.forEach((e) => {
  jo[e] = new Go(
    e,
    J4,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  jo[e] = new Go(
    e,
    Ll,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  jo[e] = new Go(
    e,
    r0,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  jo[e] = new Go(
    e,
    r0,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  jo[e] = new Go(
    e,
    o0,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  jo[e] = new Go(
    e,
    o0,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  jo[e] = new Go(
    e,
    pk,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  jo[e] = new Go(
    e,
    e7,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  jo[e] = new Go(
    e,
    Q4,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const dk = /[\-\:]([a-z])/g, fk = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dk, fk);
  jo[t] = new Go(
    t,
    Ll,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dk, fk);
  jo[t] = new Go(
    t,
    Ll,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(dk, fk);
  jo[t] = new Go(
    t,
    Ll,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  jo[e] = new Go(
    e,
    Ll,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const dpe = "xlinkHref";
jo[dpe] = new Go(
  "xlinkHref",
  Ll,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  jo[e] = new Go(
    e,
    Ll,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: fpe,
  SAME: hpe,
  possibleStandardNames: aA
} = n0, gpe = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", mpe = gpe + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", vpe = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + mpe + "]*$")
), ype = Object.keys(
  aA
).reduce((e, t) => {
  const n = aA[t];
  return n === hpe ? e[t] = t : n === fpe ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ms.BOOLEAN = o0;
ms.BOOLEANISH_STRING = r0;
ms.NUMERIC = Q4;
ms.OVERLOADED_BOOLEAN = pk;
ms.POSITIVE_NUMERIC = e7;
ms.RESERVED = J4;
ms.STRING = Ll;
ms.getPropertyInfo = cpe;
ms.isCustomAttribute = vpe;
ms.possibleStandardNames = ype;
var hk = {}, gk = {}, lA = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, bpe = /\n/g, wpe = /^\s*/, Cpe = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, Ope = /^:\s*/, xpe = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, Epe = /^[;\s]*/, Lpe = /^\s+|\s+$/g, Ppe = `
`, uA = "/", cA = "*", uu = "", kpe = "comment", Spe = "declaration", Mpe = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(f) {
    var v = f.match(bpe);
    v && (n += v.length);
    var g = f.lastIndexOf(Ppe);
    r = ~g ? f.length - g : r + f.length;
  }
  function i() {
    var f = { line: n, column: r };
    return function(v) {
      return v.position = new a(f), u(), v;
    };
  }
  function a(f) {
    this.start = f, this.end = { line: n, column: r }, this.source = t.source;
  }
  a.prototype.content = e;
  function s(f) {
    var v = new Error(
      t.source + ":" + n + ":" + r + ": " + f
    );
    if (v.reason = f, v.filename = t.source, v.line = n, v.column = r, v.source = e, !t.silent) throw v;
  }
  function l(f) {
    var v = f.exec(e);
    if (v) {
      var g = v[0];
      return o(g), e = e.slice(g.length), v;
    }
  }
  function u() {
    l(wpe);
  }
  function c(f) {
    var v;
    for (f = f || []; v = p(); )
      v !== !1 && f.push(v);
    return f;
  }
  function p() {
    var f = i();
    if (!(uA != e.charAt(0) || cA != e.charAt(1))) {
      for (var v = 2; uu != e.charAt(v) && (cA != e.charAt(v) || uA != e.charAt(v + 1)); )
        ++v;
      if (v += 2, uu === e.charAt(v - 1))
        return s("End of comment missing");
      var g = e.slice(2, v - 2);
      return r += 2, o(g), e = e.slice(v), r += 2, f({
        type: kpe,
        comment: g
      });
    }
  }
  function d() {
    var f = i(), v = l(Cpe);
    if (v) {
      if (p(), !l(Ope)) return s("property missing ':'");
      var g = l(xpe), E = f({
        type: Spe,
        property: pA(v[0].replace(lA, uu)),
        value: g ? pA(g[0].replace(lA, uu)) : uu
      });
      return l(Epe), E;
    }
  }
  function y() {
    var f = [];
    c(f);
    for (var v; v = d(); )
      v !== !1 && (f.push(v), c(f));
    return f;
  }
  return u(), y();
};
function pA(e) {
  return e ? e.replace(Lpe, uu) : uu;
}
var Dpe = or && or.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(gk, "__esModule", { value: !0 });
gk.default = jpe;
var _pe = Dpe(Mpe);
function jpe(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, _pe.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? t(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var i0 = {};
Object.defineProperty(i0, "__esModule", { value: !0 });
i0.camelCase = void 0;
var Tpe = /^--[a-zA-Z0-9_-]+$/, Ape = /-([a-z])/g, Ipe = /^[^-]+$/, Bpe = /^-(webkit|moz|ms|o|khtml)-/, Npe = /^-(ms)-/, Rpe = function(e) {
  return !e || Ipe.test(e) || Tpe.test(e);
}, Fpe = function(e, t) {
  return t.toUpperCase();
}, dA = function(e, t) {
  return "".concat(t, "-");
}, zpe = function(e, t) {
  return t === void 0 && (t = {}), Rpe(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(Npe, dA) : e = e.replace(Bpe, dA), e.replace(Ape, Fpe));
};
i0.camelCase = zpe;
var Upe = or && or.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, Wpe = Upe(gk), $pe = i0;
function Qx(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, Wpe.default)(e, function(r, o) {
    r && o && (n[(0, $pe.camelCase)(r, t)] = o);
  }), n;
}
Qx.default = Qx;
var Hpe = Qx;
(function(e) {
  var t = or && or.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = s;
  var n = Ce, r = t(Hpe), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, a);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(hk);
Object.defineProperty(t0, "__esModule", { value: !0 });
t0.default = Kpe;
var Mp = ms, fA = hk, Vpe = ["checked", "value"], Zpe = ["input", "select", "textarea"], qpe = {
  reset: !0,
  submit: !0
};
function Kpe(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && qpe[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Mp.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = hA(a);
    if (s) {
      var l = (0, Mp.getPropertyInfo)(s);
      switch (Vpe.includes(s) && Zpe.includes(t) && !r && (s = hA("default" + a)), n[s] = i, l && l.type) {
        case Mp.BOOLEAN:
          n[s] = !0;
          break;
        case Mp.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    fA.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, fA.setStyleProp)(e.style, n), n;
}
function hA(e) {
  return Mp.possibleStandardNames[e];
}
var mk = {}, Gpe = or && or.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(mk, "__esModule", { value: !0 });
mk.default = t7;
var Vw = Ce, Ype = Gpe(t0), Hp = hk, Xpe = {
  cloneElement: Vw.cloneElement,
  createElement: Vw.createElement,
  isValidElement: Vw.isValidElement
};
function t7(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Hp.returnFirstArg, i = t.library || Xpe, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = a(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var y = !p.data.trim().length;
      if (y && p.parent && !(0, Hp.canTextBeChildOfNode)(p.parent) || t.trim && y)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var f = p, v = {};
    Jpe(f) ? ((0, Hp.setStyleProp)(f.attribs.style, f.attribs), v = f.attribs) : f.attribs && (v = (0, Ype.default)(f.attribs, f.name));
    var g = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (v.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? v.defaultValue = p.children[0].data : p.children && p.children.length && (g = t7(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (v.key = c), n.push(o(s(p.name, v, g), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Jpe(e) {
  return Hp.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Hp.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = or && or.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = s;
  var n = t(ik);
  e.htmlToDOM = n.default;
  var r = t(t0);
  e.attributesToProps = r.default;
  var o = t(mk);
  e.domToReact = o.default;
  var i = ak;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(B4);
const Qpe = /* @__PURE__ */ bce(B4);
Qpe.default;
Ye({});
function ede(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const tde = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
ede(tde.CNPJ).length;
ga((e, t) => /* @__PURE__ */ li.jsx("input", { ref: t, ...e }));
Ye({});
var ma = {};
Object.defineProperty(ma, "__esModule", {
  value: !0
});
var nde = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Zw = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, n7 = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: nde ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, vk = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Bh = 1; Bh < 20; Bh++)
  vk["f" + Bh] = 111 + Bh;
function s0(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return r7(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return o7(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function rde(e, t) {
  return s0(e, t);
}
function ode(e, t) {
  return s0(e, { byKey: !0 }, t);
}
function r7(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in Zw)
    r[Zw[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = yk(d), v = Zw[f];
      if (d.length > 1 && !v && !n7[d] && !vk[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = i7(d)), v && (r[v] = y ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function o7(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function i7(e) {
  e = yk(e);
  var t = vk[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function yk(e) {
  return e = e.toLowerCase(), e = n7[e] || e, e;
}
ma.default = s0;
var qw = ma.isHotkey = s0;
ma.isCodeHotkey = rde;
ma.isKeyHotkey = ode;
ma.parseHotkey = r7;
ma.compareHotkey = o7;
ma.toKeyCode = i7;
ma.toKeyName = yk;
var ide = typeof or == "object" && or && or.Object === Object && or, sde = ide, ade = sde, lde = typeof self == "object" && self && self.Object === Object && self, ude = ade || lde || Function("return this")(), cde = ude, pde = cde, dde = pde.Symbol, s7 = dde, gA = s7;
gA && gA.toStringTag;
var mA = s7;
mA && mA.toStringTag;
var vA;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(vA || (vA = {}));
var bk = function(e) {
  return Object.freeze(e);
}, fde = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, bk(this);
  }
  return e;
}(), hde = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, bk(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), yA = typeof window < "u" ? window : {};
/msie|trident/i.test(yA.navigator && yA.navigator.userAgent);
var Kw = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new fde((n ? t : e) || 0, (n ? e : t) || 0);
};
bk({
  devicePixelContentBoxSize: Kw(),
  borderBoxSize: Kw(),
  contentBoxSize: Kw(),
  contentRect: new hde(0, 0, 0, 0)
});
function Id(e) {
  "@babel/helpers - typeof";
  return Id = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Id(e);
}
function gde(e, t) {
  if (Id(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Id(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function mde(e) {
  var t = gde(e, "string");
  return Id(t) === "symbol" ? t : String(t);
}
function Vp(e, t, n) {
  return t = mde(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var vde = /* @__PURE__ */ Ye(null), Gw, Yw;
parseInt(Ce.version.split(".")[0], 10);
var bA = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Xw = typeof navigator < "u" && /Android/.test(navigator.userAgent), Nh = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), yde = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Gw = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Gw !== void 0 && Gw[1] && parseInt((Yw = navigator.userAgent.match(/Version\/(\d+)/)) === null || Yw === void 0 ? void 0 : Yw[1], 10) < 17;
var bde = /* @__PURE__ */ new WeakMap(), wde = /* @__PURE__ */ new WeakMap(), Cde = /* @__PURE__ */ new WeakMap(), Ode = /* @__PURE__ */ new WeakMap(), xde = /* @__PURE__ */ new WeakMap(), wA = /* @__PURE__ */ new WeakMap(), Ede = /* @__PURE__ */ new WeakMap(), CA = /* @__PURE__ */ new WeakMap(), Rh = /* @__PURE__ */ new WeakMap(), Lde = /* @__PURE__ */ new WeakMap(), Pde = /* @__PURE__ */ new WeakMap(), kde = /* @__PURE__ */ new WeakMap(), a7 = globalThis.Node, Sde = globalThis.Text, l7 = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, Mde = (e) => ov(e) && e.nodeType === 8, Ps = (e) => ov(e) && e.nodeType === 1, ov = (e) => {
  var t = l7(e);
  return !!t && e instanceof t.Node;
}, OA = (e) => {
  var t = e && e.anchorNode && l7(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Dde = (e) => {
  var [t, n] = e;
  if (Ps(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = u7(t, o, r ? "backward" : "forward"), r = o < n; Ps(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = jde(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, _de = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, u7 = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (Mde(o) || Ps(o) && o.childNodes.length === 0 || Ps(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, jde = (e, t, n) => {
  var [r] = u7(e, t, n);
  return r;
}, xA = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), c7 = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ps(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = nn.getWindow(e);
  if (o.contains(r))
    return nn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : c7(e, i, n);
}, EA = (e, t) => !!(e.compareDocumentPosition(t) & a7.DOCUMENT_POSITION_PRECEDING), Tde = (e, t) => !!(e.compareDocumentPosition(t) & a7.DOCUMENT_POSITION_FOLLOWING), Ade = 0;
class Ide {
  constructor() {
    Vp(this, "id", void 0), this.id = "".concat(Ade++);
  }
}
var nn = {
  androidPendingDiffs: (e) => kde.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = Pde.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = nn.toDOMNode(e, e), n = nn.findDocumentOrShadowRoot(e);
    Rh.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = nn.findDocumentOrShadowRoot(e), r = xA(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && nv.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = nn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = nn.toSlateNode(e, t.target), a = nn.findPath(e, i);
    if (ia.isElement(i) && Xn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Xn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Xn.before(e, u) : Xn.after(e, u);
      if (c) {
        var p = Xn.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = nn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = nn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = wA.get(t);
    return n || (n = new Ide(), wA.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = wde.get(r);
      if (o == null) {
        if (Xn.isEditor(r))
          return n;
        break;
      }
      var i = bde.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(_i.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Rh.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          nn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = nn.toDOMNode(e, e), r = nn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = xA(r), i = nn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || nv.select(e, Xn.start(e, [])), Rh.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Cde.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = nn.toDOMNode(e, e), i;
    try {
      i = Ps(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => ov(t) && nn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Xn.hasPath(e, n.path) && Xn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => nn.hasEditableTarget(e, t) || nn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => ov(t) && nn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Lde.get(e),
  isFocused: (e) => !!Rh.get(e),
  isReadOnly: (e) => !!CA.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (CA.get(e)) return !1;
    var n = nn.hasTarget(e, t) && nn.toSlateNode(e, t);
    return ia.isElement(n) && Xn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Ede.get(e), r = Xn.isEditor(t) ? Ode.get(e) : n == null ? void 0 : n.get(nn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(_i.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Xn.node(e, t.path), r = nn.toDOMNode(e, n), o;
    Xn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof Sde ? E : v,
            (g = v.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(_i.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Zt.isBackward(t), i = nn.toDOMPoint(e, n), a = Zt.isCollapsed(t) ? i : nn.toDOMPoint(e, r), s = nn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = Ps(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = Ps(p) ? p : p.parentElement, g = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ps(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? xde.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Dde(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = nn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && y.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = nn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (Xw && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var z = v.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var R = z[L];
          if (nn.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (E) {
        var B = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, W = [...B(H), ...B(H == null ? void 0 : H.nextElementSibling)];
          w = (V = W.find((M) => Tde(E, M))) !== null && V !== void 0 ? V : null;
        } else {
          var q, Y = [...B(H == null ? void 0 : H.previousElementSibling), ...B(H)];
          w = (q = Y.findLast((M) => EA(E, M))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Xw && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Nh && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Xw && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && nn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var ee = nn.toSlateNode(e, X), {
          path: J,
          offset: k
        } = Xn.start(e, nn.findPath(e, ee));
        return X.querySelector("[data-slate-leaf]") || (k = s), {
          path: J,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = nn.toSlateNode(e, u), U = nn.findPath(e, _);
    return {
      path: U,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = OA(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (OA(t)) {
        if (Nh && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, g = C(f.children[d.startOffset]), E = C(v.children[y.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        yde && _de(s) || Nh ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Nh && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = nn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = EA(s, u) || s === u && c < l, x = p ? w : nn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Zt.isExpanded(m) && Zt.isForward(m) && Ps(u) && Xn.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = Xn.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, Bde = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Nde = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Rde = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, kr = (e) => {
  var t = Bde[e], n = Nde[e], r = Rde[e], o = t && qw(t), i = n && qw(n), a = r && qw(r);
  return (s) => !!(o && o(s) || bA && i && i(s) || !bA && a && a(s));
};
kr("bold"), kr("compose"), kr("moveBackward"), kr("moveForward"), kr("deleteBackward"), kr("deleteForward"), kr("deleteLineBackward"), kr("deleteLineForward"), kr("deleteWordBackward"), kr("deleteWordForward"), kr("extendBackward"), kr("extendForward"), kr("extendLineBackward"), kr("extendLineForward"), kr("italic"), kr("moveLineBackward"), kr("moveLineForward"), kr("moveWordBackward"), kr("moveWordForward"), kr("redo"), kr("insertSoftBreak"), kr("splitBlock"), kr("transposeCharacter"), kr("undo");
var Fde = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => c7(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, zde = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class Ude extends $u {
  constructor() {
    super(...arguments), Vp(this, "context", null), Vp(this, "manager", null), Vp(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, zde);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Fde(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Vp(Ude, "contextType", vde);
Ye({});
Ye({});
Ye({});
var lo = {}, wk = {}, Jd = {}, Qd = {}, p7 = "Expected a function", LA = NaN, Wde = "[object Symbol]", $de = /^\s+|\s+$/g, Hde = /^[-+]0x[0-9a-f]+$/i, Vde = /^0b[01]+$/i, Zde = /^0o[0-7]+$/i, qde = parseInt, Kde = typeof or == "object" && or && or.Object === Object && or, Gde = typeof self == "object" && self && self.Object === Object && self, Yde = Kde || Gde || Function("return this")(), Xde = Object.prototype, Jde = Xde.toString, Qde = Math.max, efe = Math.min, Jw = function() {
  return Yde.Date.now();
};
function tfe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(p7);
  t = PA(t) || 0, iv(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Qde(PA(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, z = o;
    return r = o = void 0, u = C, a = e.apply(z, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, z = C - u, L = t - S;
    return p ? efe(L, i - z) : L;
  }
  function g(C) {
    var S = C - l, z = C - u;
    return l === void 0 || S >= t || S < 0 || p && z >= i;
  }
  function E() {
    var C = Jw();
    if (g(C))
      return w(C);
    s = setTimeout(E, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(Jw());
  }
  function m() {
    var C = Jw(), S = g(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), y(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function nfe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(p7);
  return iv(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), tfe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function iv(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function rfe(e) {
  return !!e && typeof e == "object";
}
function ofe(e) {
  return typeof e == "symbol" || rfe(e) && Jde.call(e) == Wde;
}
function PA(e) {
  if (typeof e == "number")
    return e;
  if (ofe(e))
    return LA;
  if (iv(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = iv(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace($de, "");
  var n = Vde.test(e);
  return n || Zde.test(e) ? qde(e.slice(2), n ? 2 : 8) : Hde.test(e) ? LA : +e;
}
var ife = nfe, ef = {};
Object.defineProperty(ef, "__esModule", {
  value: !0
});
ef.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), am.has(t) || am.set(t, /* @__PURE__ */ new Set());
  var o = am.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
ef.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), am.get(t).delete(n.name || t);
};
var am = /* @__PURE__ */ new Map();
Object.defineProperty(Qd, "__esModule", {
  value: !0
});
var sfe = ife, afe = ufe(sfe), lfe = ef;
function ufe(e) {
  return e && e.__esModule ? e : { default: e };
}
var cfe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, afe.default)(e, t);
}, Wr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = cfe(function(r) {
        Wr.scrollHandler(e);
      }, t);
      Wr.scrollSpyContainers.push(e), (0, lfe.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Wr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Wr.scrollSpyContainers[Wr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Wr.currentPositionX(e), Wr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Wr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Wr.scrollSpyContainers[Wr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Wr.currentPositionX(t), Wr.currentPositionY(t));
  },
  updateStates: function() {
    Wr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Wr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Wr.spySetState && Wr.spySetState.length && Wr.spySetState.indexOf(e) > -1 && Wr.spySetState.splice(Wr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Wr.scrollHandler);
  },
  update: function() {
    return Wr.scrollSpyContainers.forEach(function(e) {
      return Wr.scrollHandler(e);
    });
  }
};
Qd.default = Wr;
var bc = {}, tf = {};
Object.defineProperty(tf, "__esModule", {
  value: !0
});
var pfe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, dfe = function() {
  return window.location.hash.replace(/^#/, "");
}, ffe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, hfe = function(e) {
  return getComputedStyle(e).position !== "static";
}, Qw = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, gfe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (hfe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Qw(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return Qw(t, s).offsetTop - Qw(e, s).offsetTop;
};
tf.default = {
  updateHash: pfe,
  getHash: dfe,
  filterElementInContainer: ffe,
  scrollOffset: gfe
};
var a0 = {}, Ck = {};
Object.defineProperty(Ck, "__esModule", {
  value: !0
});
Ck.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Ok = {};
Object.defineProperty(Ok, "__esModule", {
  value: !0
});
var mfe = ef, vfe = ["mousedown", "mousewheel", "touchmove", "keydown"];
Ok.default = {
  subscribe: function(e) {
    return typeof document < "u" && vfe.forEach(function(t) {
      return (0, mfe.addPassiveEventListener)(document, t, e);
    });
  }
};
var nf = {};
Object.defineProperty(nf, "__esModule", {
  value: !0
});
var eE = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      eE.registered[e] = t;
    },
    remove: function(e) {
      eE.registered[e] = null;
    }
  }
};
nf.default = eE;
Object.defineProperty(a0, "__esModule", {
  value: !0
});
var yfe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, bfe = tf;
l0(bfe);
var wfe = Ck, kA = l0(wfe), Cfe = Ok, Ofe = l0(Cfe), xfe = nf, bs = l0(xfe);
function l0(e) {
  return e && e.__esModule ? e : { default: e };
}
var d7 = function(e) {
  return kA.default[e.smooth] || kA.default.defaultEasing;
}, Efe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Lfe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, tE = function() {
  return Lfe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), f7 = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, h7 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, g7 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, Pfe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, kfe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Sfe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    bs.default.registered.end && bs.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    tE.call(window, i);
    return;
  }
  bs.default.registered.end && bs.default.registered.end(o.to, o.target, o.currentPosition);
}, xk = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, rf = function(e, t, n, r) {
  t.data = t.data || f7(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (Ofe.default.subscribe(o), xk(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? h7(t) : g7(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    bs.default.registered.end && bs.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = Efe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = d7(t), a = Sfe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      bs.default.registered.begin && bs.default.registered.begin(t.data.to, t.data.target), tE.call(window, a);
    }, t.delay);
    return;
  }
  bs.default.registered.begin && bs.default.registered.begin(t.data.to, t.data.target), tE.call(window, a);
}, u0 = function(e) {
  return e = yfe({}, e), e.data = e.data || f7(), e.absolute = !0, e;
}, Mfe = function(e) {
  rf(0, u0(e));
}, Dfe = function(e, t) {
  rf(e, u0(t));
}, _fe = function(e) {
  e = u0(e), xk(e), rf(e.horizontal ? Pfe(e) : kfe(e), e);
}, jfe = function(e, t) {
  t = u0(t), xk(t);
  var n = t.horizontal ? h7(t) : g7(t);
  rf(e + n, t);
};
a0.default = {
  animateTopScroll: rf,
  getAnimationType: d7,
  scrollToTop: Mfe,
  scrollToBottom: _fe,
  scrollTo: Dfe,
  scrollMore: jfe
};
Object.defineProperty(bc, "__esModule", {
  value: !0
});
var Tfe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Afe = tf, Ife = Ek(Afe), Bfe = a0, Nfe = Ek(Bfe), Rfe = nf, Fh = Ek(Rfe);
function Ek(e) {
  return e && e.__esModule ? e : { default: e };
}
var zh = {}, SA = void 0;
bc.default = {
  unmount: function() {
    zh = {};
  },
  register: function(e, t) {
    zh[e] = t;
  },
  unregister: function(e) {
    delete zh[e];
  },
  get: function(e) {
    return zh[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return SA = e;
  },
  getActiveLink: function() {
    return SA;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Tfe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = Ife.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Fh.default.registered.begin && Fh.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Fh.default.registered.end && Fh.default.registered.end(e, n);
      return;
    }
    Nfe.default.animateTopScroll(s, t, e, n);
  }
};
var nE = { exports: {} }, e1 = { exports: {} }, Dn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var MA;
function Ffe() {
  if (MA) return Dn;
  MA = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return Dn.AsyncMode = l, Dn.ConcurrentMode = u, Dn.ContextConsumer = s, Dn.ContextProvider = a, Dn.Element = t, Dn.ForwardRef = c, Dn.Fragment = r, Dn.Lazy = f, Dn.Memo = y, Dn.Portal = n, Dn.Profiler = i, Dn.StrictMode = o, Dn.Suspense = p, Dn.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, Dn.isConcurrentMode = x, Dn.isContextConsumer = function(m) {
    return D(m) === s;
  }, Dn.isContextProvider = function(m) {
    return D(m) === a;
  }, Dn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, Dn.isForwardRef = function(m) {
    return D(m) === c;
  }, Dn.isFragment = function(m) {
    return D(m) === r;
  }, Dn.isLazy = function(m) {
    return D(m) === f;
  }, Dn.isMemo = function(m) {
    return D(m) === y;
  }, Dn.isPortal = function(m) {
    return D(m) === n;
  }, Dn.isProfiler = function(m) {
    return D(m) === i;
  }, Dn.isStrictMode = function(m) {
    return D(m) === o;
  }, Dn.isSuspense = function(m) {
    return D(m) === p;
  }, Dn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === g || m.$$typeof === E || m.$$typeof === w || m.$$typeof === v);
  }, Dn.typeOf = D, Dn;
}
var Fn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var DA;
function zfe() {
  return DA || (DA = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === y || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === g || N.$$typeof === E || N.$$typeof === w || N.$$typeof === v);
    }
    function x(N) {
      if (typeof N == "object" && N !== null) {
        var ue = N.$$typeof;
        switch (ue) {
          case t:
            var fe = N.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var m = l, C = u, S = s, z = a, L = t, R = c, B = r, H = f, V = y, W = n, q = i, Y = o, X = p, ee = !1;
    function J(N) {
      return ee || (ee = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || x(N) === l;
    }
    function k(N) {
      return x(N) === u;
    }
    function _(N) {
      return x(N) === s;
    }
    function U(N) {
      return x(N) === a;
    }
    function M(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function $(N) {
      return x(N) === c;
    }
    function O(N) {
      return x(N) === r;
    }
    function j(N) {
      return x(N) === f;
    }
    function F(N) {
      return x(N) === y;
    }
    function T(N) {
      return x(N) === n;
    }
    function Z(N) {
      return x(N) === i;
    }
    function A(N) {
      return x(N) === o;
    }
    function G(N) {
      return x(N) === p;
    }
    Fn.AsyncMode = m, Fn.ConcurrentMode = C, Fn.ContextConsumer = S, Fn.ContextProvider = z, Fn.Element = L, Fn.ForwardRef = R, Fn.Fragment = B, Fn.Lazy = H, Fn.Memo = V, Fn.Portal = W, Fn.Profiler = q, Fn.StrictMode = Y, Fn.Suspense = X, Fn.isAsyncMode = J, Fn.isConcurrentMode = k, Fn.isContextConsumer = _, Fn.isContextProvider = U, Fn.isElement = M, Fn.isForwardRef = $, Fn.isFragment = O, Fn.isLazy = j, Fn.isMemo = F, Fn.isPortal = T, Fn.isProfiler = Z, Fn.isStrictMode = A, Fn.isSuspense = G, Fn.isValidElementType = D, Fn.typeOf = x;
  }()), Fn;
}
var _A;
function m7() {
  return _A || (_A = 1, process.env.NODE_ENV === "production" ? e1.exports = Ffe() : e1.exports = zfe()), e1.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var t1, jA;
function Ufe() {
  if (jA) return t1;
  jA = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return t1 = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, t1;
}
var n1, TA;
function Lk() {
  if (TA) return n1;
  TA = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return n1 = e, n1;
}
var AA, IA;
function v7() {
  return IA || (IA = 1, AA = Function.call.bind(Object.prototype.hasOwnProperty)), AA;
}
var r1, BA;
function Wfe() {
  if (BA) return r1;
  BA = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Lk(), n = {}, r = v7();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, r1 = o, r1;
}
var o1, NA;
function $fe() {
  if (NA) return o1;
  NA = 1;
  var e = m7(), t = Ufe(), n = Lk(), r = v7(), o = Wfe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return o1 = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var _ = k && (u && k[u] || k[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: z,
      oneOf: S,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(k, _) {
      return k === _ ? k !== 0 || 1 / k === 1 / _ : k !== k && _ !== _;
    }
    function v(k, _) {
      this.message = k, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function g(k) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, U = 0;
      function M(O, j, F, T, Z, A, G) {
        if (T = T || d, A = A || F, G !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + F;
            !_[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            U < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[ue] = !0, U++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + Z + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + Z + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : k(j, F, T, Z, A);
      }
      var $ = M.bind(null, !1);
      return $.isRequired = M.bind(null, !0), $;
    }
    function E(k) {
      function _(U, M, $, O, j, F) {
        var T = U[M], Z = Y(T);
        if (Z !== k) {
          var A = X(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return g(_);
    }
    function w() {
      return g(a);
    }
    function D(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var F = U[M];
        if (!Array.isArray(F)) {
          var T = Y(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var Z = 0; Z < F.length; Z++) {
          var A = k(F, Z, $, O, j + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(_);
    }
    function x() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!s(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(k);
    }
    function m() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!e.isValidElementType(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(k);
    }
    function C(k) {
      function _(U, M, $, O, j) {
        if (!(U[M] instanceof k)) {
          var F = k.name || d, T = J(U[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return g(_);
    }
    function S(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(U, M, $, O, j) {
        for (var F = U[M], T = 0; T < k.length; T++)
          if (f(F, k[T]))
            return null;
        var Z = JSON.stringify(k, function(A, G) {
          var N = X(G);
          return N === "symbol" ? String(G) : G;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + $ + "`, expected one of " + Z + "."));
      }
      return g(_);
    }
    function z(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var Z in F)
          if (r(F, Z)) {
            var A = k(F, Z, $, O, j + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(_);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < k.length; _++) {
        var U = k[_];
        if (typeof U != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ee(U) + " at index " + _ + "."
          ), a;
      }
      function M($, O, j, F, T) {
        for (var Z = [], A = 0; A < k.length; A++) {
          var G = k[A], N = G($, O, j, F, T, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && Z.push(N.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return g(M);
    }
    function R() {
      function k(_, U, M, $, O) {
        return W(_[U]) ? null : new v("Invalid " + $ + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return g(k);
    }
    function B(k, _, U, M, $) {
      return new v(
        (k || "React class") + ": " + _ + " type `" + U + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function H(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var Z in k) {
          var A = k[Z];
          if (typeof A != "function")
            return B($, O, j, Z, X(A));
          var G = A(F, Z, $, O, j + "." + Z, n);
          if (G)
            return G;
        }
        return null;
      }
      return g(_);
    }
    function V(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var Z = t({}, U[M], k);
        for (var A in Z) {
          var G = k[A];
          if (r(k, A) && typeof G != "function")
            return B($, O, j, A, X(G));
          if (!G)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(U[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = G(F, A, $, O, j + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return g(_);
    }
    function W(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(W);
          if (k === null || s(k))
            return !0;
          var _ = p(k);
          if (_) {
            var U = _.call(k), M;
            if (_ !== k.entries) {
              for (; !(M = U.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = U.next()).done; ) {
                var $ = M.value;
                if ($ && !W($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(k, _) {
      return k === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function Y(k) {
      var _ = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : q(_, k) ? "symbol" : _;
    }
    function X(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var _ = Y(k);
      if (_ === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function ee(k) {
      var _ = X(k);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, o1;
}
var i1, RA;
function Hfe() {
  if (RA) return i1;
  RA = 1;
  var e = Lk();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, i1 = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, i1;
}
if (process.env.NODE_ENV !== "production") {
  var Vfe = m7(), Zfe = !0;
  nE.exports = $fe()(Vfe.isElement, Zfe);
} else
  nE.exports = Hfe()();
var c0 = nE.exports, p0 = {};
Object.defineProperty(p0, "__esModule", {
  value: !0
});
var qfe = tf, s1 = Kfe(qfe);
function Kfe(e) {
  return e && e.__esModule ? e : { default: e };
}
var Gfe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return s1.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && s1.default.getHash() !== e && s1.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
p0.default = Gfe;
Object.defineProperty(Jd, "__esModule", {
  value: !0
});
var Uh = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Yfe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Xfe = Ce, FA = of(Xfe), Jfe = Qd, Wh = of(Jfe), Qfe = bc, ehe = of(Qfe), the = c0, Sr = of(the), nhe = p0, xa = of(nhe);
function of(e) {
  return e && e.__esModule ? e : { default: e };
}
function rhe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ohe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ihe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var zA = {
  to: Sr.default.string.isRequired,
  containerId: Sr.default.string,
  container: Sr.default.object,
  activeClass: Sr.default.string,
  activeStyle: Sr.default.object,
  spy: Sr.default.bool,
  horizontal: Sr.default.bool,
  smooth: Sr.default.oneOfType([Sr.default.bool, Sr.default.string]),
  offset: Sr.default.number,
  delay: Sr.default.number,
  isDynamic: Sr.default.bool,
  onClick: Sr.default.func,
  duration: Sr.default.oneOfType([Sr.default.number, Sr.default.func]),
  absolute: Sr.default.bool,
  onSetActive: Sr.default.func,
  onSetInactive: Sr.default.func,
  ignoreCancelEvents: Sr.default.bool,
  hashSpy: Sr.default.bool,
  saveHashHistory: Sr.default.bool,
  spyThrottle: Sr.default.number
};
Jd.default = function(e, t) {
  var n = t || ehe.default, r = function(i) {
    ihe(a, i);
    function a(s) {
      rhe(this, a);
      var l = ohe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return Yfe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Wh.default.isMounted(s) || Wh.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (xa.default.isMounted() || xa.default.mount(n), xa.default.mapContainer(this.props.to, s)), Wh.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Wh.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Uh({}, this.props.style, this.props.activeStyle) : l = Uh({}, this.props.style);
        var u = Uh({}, this.props);
        for (var c in zA)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, FA.default.createElement(e, u);
      }
    }]), a;
  }(FA.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Uh({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(xa.default.isMounted() && !xa.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, g = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            g = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - g + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            x = z.top - C + s, m = x + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(m), y = L < Math.floor(x) || L >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && xa.default.getHash() === c) {
            var B = i.props.saveHashHistory, H = B === void 0 ? !1 : B;
            xa.default.changeHash("", H);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, W = V === void 0 ? !1 : V;
          i.props.hashSpy && xa.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = zA, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(wk, "__esModule", {
  value: !0
});
var she = Ce, UA = y7(she), ahe = Jd, lhe = y7(ahe);
function y7(e) {
  return e && e.__esModule ? e : { default: e };
}
function uhe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function WA(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function che(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var phe = function(e) {
  che(t, e);
  function t() {
    var n, r, o, i;
    uhe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = WA(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return UA.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), WA(o, i);
  }
  return t;
}(UA.default.Component);
wk.default = (0, lhe.default)(phe);
var Pk = {};
Object.defineProperty(Pk, "__esModule", {
  value: !0
});
var dhe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), fhe = Ce, $A = b7(fhe), hhe = Jd, ghe = b7(hhe);
function b7(e) {
  return e && e.__esModule ? e : { default: e };
}
function mhe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vhe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function yhe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var bhe = function(e) {
  yhe(t, e);
  function t() {
    return mhe(this, t), vhe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return dhe(t, [{
    key: "render",
    value: function() {
      return $A.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}($A.default.Component);
Pk.default = (0, ghe.default)(bhe);
var kk = {}, d0 = {};
Object.defineProperty(d0, "__esModule", {
  value: !0
});
var whe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Che = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Ohe = Ce, HA = f0(Ohe), xhe = pl;
f0(xhe);
var Ehe = bc, VA = f0(Ehe), Lhe = c0, ZA = f0(Lhe);
function f0(e) {
  return e && e.__esModule ? e : { default: e };
}
function Phe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function khe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function She(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
d0.default = function(e) {
  var t = function(n) {
    She(r, n);
    function r(o) {
      Phe(this, r);
      var i = khe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Che(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        VA.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        VA.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return HA.default.createElement(e, whe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(HA.default.Component);
  return t.propTypes = {
    name: ZA.default.string,
    id: ZA.default.string
  }, t;
};
Object.defineProperty(kk, "__esModule", {
  value: !0
});
var qA = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Mhe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Dhe = Ce, KA = Sk(Dhe), _he = d0, jhe = Sk(_he), The = c0, GA = Sk(The);
function Sk(e) {
  return e && e.__esModule ? e : { default: e };
}
function Ahe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ihe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Bhe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var w7 = function(e) {
  Bhe(t, e);
  function t() {
    return Ahe(this, t), Ihe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Mhe(t, [{
    key: "render",
    value: function() {
      var n = this, r = qA({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, KA.default.createElement(
        "div",
        qA({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(KA.default.Component);
w7.propTypes = {
  name: GA.default.string,
  id: GA.default.string
};
kk.default = (0, jhe.default)(w7);
var a1 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, YA = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function XA(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function JA(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function QA(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var $h = Ce, Al = Qd, l1 = bc, Gr = c0, Ea = p0, eI = {
  to: Gr.string.isRequired,
  containerId: Gr.string,
  container: Gr.object,
  activeClass: Gr.string,
  spy: Gr.bool,
  smooth: Gr.oneOfType([Gr.bool, Gr.string]),
  offset: Gr.number,
  delay: Gr.number,
  isDynamic: Gr.bool,
  onClick: Gr.func,
  duration: Gr.oneOfType([Gr.number, Gr.func]),
  absolute: Gr.bool,
  onSetActive: Gr.func,
  onSetInactive: Gr.func,
  ignoreCancelEvents: Gr.bool,
  hashSpy: Gr.bool,
  spyThrottle: Gr.number
}, Nhe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || l1, r = function(i) {
      QA(a, i);
      function a(s) {
        XA(this, a);
        var l = JA(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return YA(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Al.isMounted(s) || Al.mount(s, this.props.spyThrottle), this.props.hashSpy && (Ea.isMounted() || Ea.mount(n), Ea.mapContainer(this.props.to, s)), this.props.spy && Al.addStateHandler(this.stateHandler), Al.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Al.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = a1({}, this.props);
          for (var u in eI)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, $h.createElement(e, l);
        }
      }]), a;
    }($h.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, a1({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Ea.isMounted() && !Ea.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, g = v >= Math.floor(c) && v < Math.floor(p), E = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Ea.getHash() === l && Ea.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Al.updateStates();
          if (g && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Ea.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Al.updateStates();
        }
      };
    };
    return r.propTypes = eI, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      QA(r, n);
      function r(o) {
        XA(this, r);
        var i = JA(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return YA(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          l1.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          l1.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return $h.createElement(e, a1({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }($h.Component);
    return t.propTypes = {
      name: Gr.string,
      id: Gr.string
    }, t;
  }
}, Rhe = Nhe;
Object.defineProperty(lo, "__esModule", {
  value: !0
});
lo.Helpers = lo.ScrollElement = lo.ScrollLink = lo.animateScroll = lo.scrollSpy = lo.Events = lo.scroller = lo.Element = lo.Button = lo.Link = void 0;
var Fhe = wk, C7 = Ts(Fhe), zhe = Pk, O7 = Ts(zhe), Uhe = kk, x7 = Ts(Uhe), Whe = bc, E7 = Ts(Whe), $he = nf, L7 = Ts($he), Hhe = Qd, P7 = Ts(Hhe), Vhe = a0, k7 = Ts(Vhe), Zhe = Jd, S7 = Ts(Zhe), qhe = d0, M7 = Ts(qhe), Khe = Rhe, D7 = Ts(Khe);
function Ts(e) {
  return e && e.__esModule ? e : { default: e };
}
lo.Link = C7.default;
lo.Button = O7.default;
lo.Element = x7.default;
lo.scroller = E7.default;
lo.Events = L7.default;
lo.scrollSpy = P7.default;
lo.animateScroll = k7.default;
lo.ScrollLink = S7.default;
lo.ScrollElement = M7.default;
lo.Helpers = D7.default;
lo.default = { Link: C7.default, Button: O7.default, Element: x7.default, scroller: E7.default, Events: L7.default, scrollSpy: P7.default, animateScroll: k7.default, ScrollLink: S7.default, ScrollElement: M7.default, Helpers: D7.default };
Ye({});
Ye({});
Ye({});
function Bd(e) {
  "@babel/helpers - typeof";
  return Bd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Bd(e);
}
function Ghe(e, t) {
  if (Bd(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Bd(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Yhe(e) {
  var t = Ghe(e, "string");
  return Bd(t) == "symbol" ? t : t + "";
}
function Oe(e, t, n) {
  return (t = Yhe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function _7(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var u1, tI;
function Xhe() {
  if (tI) return u1;
  tI = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return u1 = t, u1;
}
var Jhe = Xhe(), yo = /* @__PURE__ */ _7(Jhe), At = Ye(null);
function Qhe() {
  yo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(At);
  return yo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function ege(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function tge(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function nge(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return tge(e, i), o;
}
function rge(e, t, n) {
  var r = ege(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function oge(e) {
  google.maps.event.removeListener(e);
}
function gn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(oge);
}
function un(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = rge(o, i, n);
  return nge(t, r, o, i), a;
}
function ige(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = P(null), S = dt(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null), [A, G] = P(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && g && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(m, "mouseup", g)));
  }, [g]), h(() => {
    m && E && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", E)));
  }, [E]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), G(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var N = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(N), N !== null && D && D(N), () => {
      N !== null && x && x(N);
    };
  }, []), li.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: li.jsx(At.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
ve(ige);
function nI(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function j7(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        nI(i, r, o, a, s, "next", l);
      }
      function s(l) {
        nI(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function T7(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return yo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var cu = typeof document < "u";
function A7(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return cu ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function rI(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function I7() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return rI(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return rI(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Kc = !1;
function B7() {
  return li.jsx("div", {
    children: "Loading..."
  });
}
var rE = {
  id: "script-loader",
  version: "weekly"
};
class sge extends pe {
  constructor() {
    super(...arguments), Oe(this, "check", ir()), Oe(this, "state", {
      loaded: !1
    }), Oe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Oe(this, "isCleaningUp", /* @__PURE__ */ j7(function* () {
      function t(n) {
        if (!Kc)
          n();
        else if (cu)
          var r = window.setInterval(function() {
            Kc || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Oe(this, "cleanup", () => {
      Kc = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Oe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && I7(), yo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: T7(this.props)
      };
      A7(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (cu) {
      if (window.google && window.google.maps && !Kc) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), cu && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (cu) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Kc = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return li.jsxs(li.Fragment, {
      children: [li.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || li.jsx(B7, {})]
    });
  }
}
Oe(sge, "defaultProps", rE);
function age(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Mk(e, t) {
  if (e == null) return {};
  var n, r, o = age(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var oI;
function lge(e) {
  var {
    id: t = rE.id,
    version: n = rE.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = dt(!1), [f, v] = P(!1), [g, E] = P(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    cu && u && I7();
  }, [u]), h(function() {
    f && yo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = T7({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!cu)
      return;
    function x() {
      y.current && (v(!0), oI = w);
    }
    if (window.google && window.google.maps && oI === w) {
      x();
      return;
    }
    A7({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && E(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = dt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var uge = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], cge = li.jsx(B7, {});
function pge(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = Mk(e, uge), {
    isLoaded: s,
    loadError: l
  } = lge(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || cge;
}
ve(pge);
var iI;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(iI || (iI = {}));
function sI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var aI = {}, lI = {
  options(e, t) {
    e.setOptions(t);
  }
};
function dge(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(At), [i, a] = P(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(sv(sv({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(dge);
class fge extends pe {
  constructor() {
    super(...arguments), Oe(this, "state", {
      trafficLayer: null
    }), Oe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Oe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(sv(sv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: lI,
      eventMap: aI,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: lI,
      eventMap: aI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), gn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(fge, "contextType", At);
function hge(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(At), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(hge);
class gge extends pe {
  constructor() {
    super(...arguments), Oe(this, "state", {
      bicyclingLayer: null
    }), Oe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(gge, "contextType", At);
function mge(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(At), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(mge);
class vge extends pe {
  constructor() {
    super(...arguments), Oe(this, "state", {
      transitLayer: null
    }), Oe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(vge, "contextType", At);
function uI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function av(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cI = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, pI = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function yge(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(At), [d, y] = P(null), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    yo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(av(av({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && E(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && L(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(yge);
class bge extends pe {
  constructor(t) {
    super(t), Oe(this, "registeredEvents", []), Oe(this, "state", {
      drawingManager: null
    }), Oe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), yo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(av(av({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: pI,
      eventMap: cI,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: pI,
      eventMap: cI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), gn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(bge, "contextType", At);
function dI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ku(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? dI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : dI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var fI = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, hI = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, lv = {};
function wge(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: R,
    onClickableChanged: B,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: W,
    onFlatChanged: q,
    onIconChanged: Y,
    onPositionChanged: X,
    onShapeChanged: ee,
    onTitleChanged: J,
    onVisibleChanged: k,
    onZindexChanged: _,
    onLoad: U,
    onUnmount: M
  } = e, $ = ge(At), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null), [oe, Ie] = P(null), [qe, Ge] = P(null), [Be, et] = P(null), [Xe, Me] = P(null), [Je, at] = P(null), [Se, _e] = P(null), [Ae, Ve] = P(null), [Ne, nt] = P(null), [we, mt] = P(null), [ot, st] = P(null), [ut, vt] = P(null), [ct, yt] = P(null), [Qe, ft] = P(null), [tt, bt] = P(null), [pt, Dt] = P(null), [wt, _t] = P(null), [Ct, jt] = P(null);
  h(() => {
    O !== null && O.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ie(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (qe !== null && google.maps.event.removeListener(qe), Ge(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && z && (Be !== null && google.maps.event.removeListener(Be), et(google.maps.event.addListener(O, "mouseup", z)));
  }, [z]), h(() => {
    O && R && (Xe !== null && google.maps.event.removeListener(Xe), Me(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && E && (Je !== null && google.maps.event.removeListener(Je), at(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && D && (Se !== null && google.maps.event.removeListener(Se), _e(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && B && (Ae !== null && google.maps.event.removeListener(Ae), Ve(google.maps.event.addListener(O, "clickable_changed", B)));
  }, [B]), h(() => {
    O && H && (Ne !== null && google.maps.event.removeListener(Ne), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), h(() => {
    O && V && (we !== null && google.maps.event.removeListener(we), mt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && W && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && q && (ut !== null && google.maps.event.removeListener(ut), vt(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), h(() => {
    O && Y && (ct !== null && google.maps.event.removeListener(ct), yt(google.maps.event.addListener(O, "icon_changed", Y)));
  }, [Y]), h(() => {
    O && X && (Qe !== null && google.maps.event.removeListener(Qe), ft(google.maps.event.addListener(O, "position_changed", X)));
  }, [X]), h(() => {
    O && ee && (tt !== null && google.maps.event.removeListener(tt), bt(google.maps.event.addListener(O, "shape_changed", ee)));
  }, [ee]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Dt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && k && (wt !== null && google.maps.event.removeListener(wt), _t(google.maps.event.addListener(O, "visible_changed", k)));
  }, [k]), h(() => {
    O && _ && (Ct !== null && google.maps.event.removeListener(Ct), jt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var ht = Ku(Ku(Ku({}, n || lv), r ? lv : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof y < "u" && re.setOpacity(y), f && re.setShape(f), typeof v == "string" && re.setTitle(v), typeof g == "number" && re.setZIndex(g), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), m && N(google.maps.event.addListener(re, "dragstart", m)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ie(google.maps.event.addListener(re, "mouseout", C)), S && Ge(google.maps.event.addListener(re, "mouseover", S)), z && et(google.maps.event.addListener(re, "mouseup", z)), R && Me(google.maps.event.addListener(re, "rightclick", R)), E && at(google.maps.event.addListener(re, "click", E)), D && _e(google.maps.event.addListener(re, "drag", D)), B && Ve(google.maps.event.addListener(re, "clickable_changed", B)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && mt(google.maps.event.addListener(re, "animation_changed", V)), W && st(google.maps.event.addListener(re, "draggable_changed", W)), q && vt(google.maps.event.addListener(re, "flat_changed", q)), Y && yt(google.maps.event.addListener(re, "icon_changed", Y)), X && ft(google.maps.event.addListener(re, "position_changed", X)), ee && bt(google.maps.event.addListener(re, "shape_changed", ee)), J && Dt(google.maps.event.addListener(re, "title_changed", J)), k && _t(google.maps.event.addListener(re, "visible_changed", k)), _ && jt(google.maps.event.addListener(re, "zindex_changed", _)), j(re), U && U(re), () => {
      F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), qe !== null && google.maps.event.removeListener(qe), Be !== null && google.maps.event.removeListener(Be), Xe !== null && google.maps.event.removeListener(Xe), Je !== null && google.maps.event.removeListener(Je), Ae !== null && google.maps.event.removeListener(Ae), Ne !== null && google.maps.event.removeListener(Ne), we !== null && google.maps.event.removeListener(we), ot !== null && google.maps.event.removeListener(ot), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), Qe !== null && google.maps.event.removeListener(Qe), pt !== null && google.maps.event.removeListener(pt), wt !== null && google.maps.event.removeListener(wt), Ct !== null && google.maps.event.removeListener(Ct), M && M(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Cn = On(() => i ? lt.map(i, (ht) => {
    if (!mi(ht))
      return ht;
    var re = ht;
    return vi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return li.jsx(li.Fragment, {
    children: Cn
  }) || null;
}
ve(wge);
class Cge extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return j7(function* () {
      var n = Ku(Ku(Ku({}, t.props.options || lv), t.props.clusterer ? lv : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = un({
        updaterMap: hI,
        eventMap: fI,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: hI,
      eventMap: fI,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), gn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Oe(Cge, "contextType", At);
var Oge = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), xge = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Oge(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Ege(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Lge = 2e3, Pge = 500, kge = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", Sge = "png", Mge = [53, 56, 66, 78, 90], Dge = "cluster", N7 = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || kge, this.imageExtension = r.imageExtension || Sge, this.imageSizes = r.imageSizes || Mge, this.calculator = r.calculator || Ege, this.batchSize = r.batchSize || Lge, this.batchSizeIE = r.batchSizeIE || Pge, this.clusterClass = r.clusterClass || Dge, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new xge(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function gI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _ge(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? gI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : gI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var es = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, xn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, jge = {};
function Tge(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: z
  } = e, [L, R] = P(null), B = ge(At), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null);
  return h(() => {
    L && C && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(L, es.onMouseOut, C)));
  }, [C]), h(() => {
    L && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(L, es.onMouseOver, m)));
  }, [m]), h(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, es.onClick, w)));
  }, [w]), h(() => {
    L && D && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(L, es.onClusteringBegin, D)));
  }, [D]), h(() => {
    L && x && (Y !== null && google.maps.event.removeListener(Y), q(google.maps.event.addListener(L, es.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && xn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && xn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && xn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && xn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && xn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && xn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && xn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && xn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && xn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && xn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof y < "u" && L !== null && xn.maxZoom(L, y);
  }, [L, y]), h(() => {
    typeof f < "u" && L !== null && xn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof v < "u" && L !== null && xn.styles(L, v);
  }, [L, v]), h(() => {
    typeof g < "u" && L !== null && xn.title(L, g);
  }, [L, g]), h(() => {
    typeof E < "u" && L !== null && xn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (B) {
      var U = _ge({}, n || jge), M = new N7(B, [], U);
      return r && xn.averageCenter(M, r), o && xn.batchSizeIE(M, o), i && xn.calculator(M, i), a && xn.clusterClass(M, a), s && xn.enableRetinaIcons(M, s), l && xn.gridSize(M, l), u && xn.ignoreHidden(M, u), c && xn.imageExtension(M, c), p && xn.imagePath(M, p), d && xn.imageSizes(M, d), y && xn.maxZoom(M, y), f && xn.minimumClusterSize(M, f), v && xn.styles(M, v), g && xn.title(M, g), E && xn.zoomOnClick(M, E), C && J(google.maps.event.addListener(M, es.onMouseOut, C)), m && _(google.maps.event.addListener(M, es.onMouseOver, m)), w && V(google.maps.event.addListener(M, es.onClick, w)), D && q(google.maps.event.addListener(M, es.onClusteringBegin, D)), x && X(google.maps.event.addListener(M, es.onClusteringEnd, x)), R(M), S && S(M), () => {
        ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), z && z(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(Tge);
class Age extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      markerClusterer: null
    }), Oe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new N7(this.context, [], this.props.options);
      this.registeredEvents = un({
        updaterMap: xn,
        eventMap: es,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: xn,
      eventMap: es,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), gn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Oe(Age, "contextType", At);
function mI(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var R7 = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || mI(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, mI));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), g = v.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + y ? r = g.x + u - y : g.x + p + u + y > s && (r = g.x + p + u + y - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Ige = ["position"], Bge = ["position"];
function vI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function uv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yI = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, bI = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Nge = {};
function Rge(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(At), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var B = r || Nge, {
        position: H
      } = B, V = Mk(B, Ige), W;
      H && !(H instanceof google.maps.LatLng) && (W = new google.maps.LatLng(H.lat, H.lng));
      var q = new R7(uv(uv({}, V), W ? {
        position: W
      } : {}));
      R.current = document.createElement("div"), v(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && D(google.maps.event.addListener(q, "domready", s)), l && m(google.maps.event.addListener(q, "content_changed", l)), u && S(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(R.current), n ? q.open(y, n) : q.getPosition() ? q.open(y) : yo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(Rge);
class Fge extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "containerElement", null), Oe(this, "state", {
      infoBox: null
    }), Oe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : yo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Oe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Mk(t, Bge), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new R7(uv(uv({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = un({
      updaterMap: bI,
      eventMap: yI,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: bI,
      eventMap: yI,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), gn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
Oe(Fge, "contextType", At);
var wI, CI;
function zge() {
  return CI || (CI = 1, wI = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), wI;
}
var Uge = zge(), OI = /* @__PURE__ */ _7(Uge), xI = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], c1 = 1, Gc = 8;
class Dk {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== c1)
      throw new Error("Got v".concat(o, " data when expected v").concat(c1, "."));
    var i = xI[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new Dk(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = xI.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Gc, t), this.coords = new this.ArrayType(this.data, Gc + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Gc + a + s + l), this.ids = new this.IndexArrayType(this.data, Gc, t), this.coords = new this.ArrayType(this.data, Gc + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (c1 << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return oE(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          EI(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], g = i[2 * f + 1];
      EI(v, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function oE(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    F7(e, t, a, r, o, i), oE(e, t, n, r, a - 1, 1 - i), oE(e, t, n, a + 1, o, 1 - i);
  }
}
function F7(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      F7(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (Yc(e, t, r, n), t[2 * o + i] > y && Yc(e, t, r, o); f < v; ) {
      for (Yc(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? Yc(e, t, r, v) : (v++, Yc(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function Yc(e, t, n, r) {
  p1(e, n, r), p1(t, 2 * n, 2 * r), p1(t, 2 * n + 1, 2 * r + 1);
}
function p1(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function EI(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var Wge = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, LI = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Il = 2, Va = 3, d1 = 4, Ra = 5, z7 = 6;
class $ge {
  constructor(t) {
    this.options = Object.assign(Object.create(Wge), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = LI(Hh(u)), d = LI(Vh(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Hh(r), Vh(a), Hh(i), Vh(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Ra] > 1 ? PI(p, f, this.clusterProps) : this.points[p[f + Va]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + d1] === t && p.push(a[y + Ra] > 1 ? PI(a, y, this.clusterProps) : this.points[a[y + Va]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Dk(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Ra] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = U7(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Va]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = Hh(f), d = Vh(v);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Va] : E = this.points[n[l + Va]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Il] <= n)) {
        l[p + Il] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Ra], g = v;
        for (var E of f) {
          var w = E * c;
          l[w + Il] > n && (g += l[w + Ra]);
        }
        if (g > v && g >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Il] <= n)) {
              l[L + Il] = n;
              var R = l[L + Ra];
              D += l[L] * R, x += l[L + 1] * R, l[L + d1] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, L)));
            }
          }
          l[p + d1] = S, u.push(D / g, x / g, 1 / 0, S, -1, g), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + Il] <= n)) {
                l[V + Il] = n;
                for (var W = 0; W < c; W++) u.push(l[V + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Ra] > 1) {
      var o = this.clusterProps[t[n + z7]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Va]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function PI(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Va],
    properties: U7(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [Hge(e[t]), Vge(e[t + 1])]
    }
  };
}
function U7(e, t, n) {
  var r = e[t + Ra], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + z7], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Va],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Hh(e) {
  return e / 360 + 0.5;
}
function Vh(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function Hge(e) {
  return (e - 0.5) * 360;
}
function Vge(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Zge(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class ji {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class iE {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(ji.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => ji.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (ji.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class qge {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return Kge(n);
  }
}
var Kge = (e) => {
  var t = e.map((n) => new iE({
    position: ji.getPosition(n),
    markers: [n]
  }));
  return t;
};
class Gge extends qge {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = Zge(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new $ge(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!OI(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = ji.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !OI(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new iE({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new iE({
      markers: [i],
      position: ji.getPosition(i)
    });
  }
}
class Yge {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Xge {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (ji.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function Jge(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class _k {
  constructor() {
    Jge(_k, google.maps.OverlayView);
  }
}
var Zp;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Zp || (Zp = {}));
var Qge = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class eme extends _k {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new Gge(o),
      renderer: a = new Xge(),
      onClusterClick: s = Qge
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (ji.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Zp.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || ji.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => ji.setMap(l, null)));
      }
      google.maps.event.trigger(this, Zp.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => ji.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new Yge(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => ji.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Zp.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), ji.setMap(r.marker, n);
    });
  }
}
function kI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function SI(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function tme(e) {
  var t = Qhe(), [n, r] = P(null);
  return h(() => {
    if (t && n === null) {
      var o = new eme(SI(SI({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function nme(e) {
  var {
    children: t,
    options: n
  } = e, r = tme(n);
  return r !== null ? t(r) : null;
}
ve(nme);
var MI = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, DI = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function rme(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(At), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var B = new google.maps.InfoWindow(r);
    return v(B), R.current = document.createElement("div"), a && E(google.maps.event.addListener(B, "closeclick", a)), s && D(google.maps.event.addListener(B, "domready", s)), l && m(google.maps.event.addListener(B, "content_changed", l)), u && S(google.maps.event.addListener(B, "position_changed", u)), c && L(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(R.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(y, n) : B.getPosition() ? B.open(y) : yo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(B), B.close();
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(rme);
class ome extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "containerElement", null), Oe(this, "state", {
      infoWindow: null
    }), Oe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : yo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Oe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = un({
      updaterMap: DI,
      eventMap: MI,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: DI,
      eventMap: MI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (gn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
Oe(ome, "contextType", At);
function _I(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _I(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _I(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jI = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, TI = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, ime = {};
function sme(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, D = ge(At), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && g && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", g)));
  }, [g]), h(() => {
    var T = new google.maps.Polyline(cv(cv({}, t || ime), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && B(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && q(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), g && F(google.maps.event.addListener(T, "drag", g)), m(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(sme);
class ame extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      polyline: null
    }), Oe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(cv(cv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: TI,
      eventMap: jI,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: TI,
      eventMap: jI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), gn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(ame, "contextType", At);
function AI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function II(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? AI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : AI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var BI = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, NI = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function lme(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(At), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof g == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", g)));
  }, [g]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(II(II({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), g && F(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), S(A), w && w(A), () => {
      z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), D && D(A), A.setMap(null);
    };
  }, []), null;
}
ve(lme);
class ume extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = un({
      updaterMap: NI,
      eventMap: BI,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: NI,
      eventMap: BI,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), gn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(ume, "contextType", At);
function RI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var FI = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, zI = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function cme(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(At), [m, C] = P(null), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), z(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", g)));
  }, [g]), h(() => {
    m && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(m, "bounds_changed", E)));
  }, [E]), h(() => {
    var G = new google.maps.Rectangle(pv(pv({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && G.setVisible(i), typeof o < "u" && G.setEditable(o), typeof r < "u" && G.setDraggable(r), typeof n < "u" && G.setBounds(n), a && z(google.maps.event.addListener(G, "dblclick", a)), s && R(google.maps.event.addListener(G, "dragend", s)), l && H(google.maps.event.addListener(G, "dragstart", l)), u && W(google.maps.event.addListener(G, "mousedown", u)), c && Y(google.maps.event.addListener(G, "mousemove", c)), p && ee(google.maps.event.addListener(G, "mouseout", p)), d && k(google.maps.event.addListener(G, "mouseover", d)), y && U(google.maps.event.addListener(G, "mouseup", y)), f && $(google.maps.event.addListener(G, "rightclick", f)), v && j(google.maps.event.addListener(G, "click", v)), g && T(google.maps.event.addListener(G, "drag", g)), E && A(google.maps.event.addListener(G, "bounds_changed", E)), C(G), w && w(G), () => {
      S !== null && google.maps.event.removeListener(S), L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), D && D(G), G.setMap(null);
    };
  }, []), null;
}
ve(cme);
class pme extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      rectangle: null
    }), Oe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(pv(pv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: zI,
      eventMap: FI,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: zI,
      eventMap: FI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), gn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(pme, "contextType", At);
function UI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WI = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, $I = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, dme = {};
function fme(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(At), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", g)));
  }, [g]), h(() => {
    S && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(S, "drag", E)));
  }, [E]), h(() => {
    S && w && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(S, "center_changed", w)));
  }, [g]), h(() => {
    S && D && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(dv(dv({}, t || dme), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && R(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && Y(google.maps.event.addListener(oe, "mousedown", c)), p && ee(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), y && U(google.maps.event.addListener(oe, "mouseover", y)), f && $(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), g && T(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && N(google.maps.event.addListener(oe, "center_changed", w)), D && fe(google.maps.event.addListener(oe, "radius_changed", D)), z(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(fme);
class hme extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      circle: null
    }), Oe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(dv(dv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: $I,
      eventMap: WI,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: $I,
      eventMap: WI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), gn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Oe(hme, "contextType", At);
function HI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var VI = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, ZI = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function gme(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: g
  } = e, E = ge(At), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(fv(fv({}, t), {}, {
        map: E
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && B(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && Z(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), g && g(w), w.setMap(null));
    };
  }, []), null;
}
ve(gme);
class mme extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      data: null
    }), Oe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(fv(fv({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = un({
        updaterMap: ZI,
        eventMap: VI,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: ZI,
      eventMap: VI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), gn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(mme, "contextType", At);
function qI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KI(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? qI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : qI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GI = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, YI = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class vme extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      kmlLayer: null
    }), Oe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(KI(KI({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: YI,
      eventMap: GI,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: YI,
      eventMap: GI,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), gn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(vme, "contextType", At);
function W7(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function yme(e, t) {
  return new t(e.lat, e.lng);
}
function bme(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function wme(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Cme(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Ome(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function xme(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function $7(e, t, n, r) {
  return n !== void 0 ? Ome(e, t, Cme(n, google.maps.LatLngBounds, bme)) : xme(e, t, wme(r, google.maps.LatLng, yme));
}
function Eme(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function XI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lme(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Pme(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Lme({}, this.container ? W7(this.container, o) : {
        x: 0,
        y: 0
      }), u = $7(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function JI(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function kme(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JI(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JI(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function QI(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function eB(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Sme(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(At), c = On(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = On(() => Pme(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
ve(Sme);
class wc extends pe {
  constructor(t) {
    super(t), Oe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Oe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      yo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Oe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Oe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = kme({
        x: 0,
        y: 0
      }, this.containerRef.current ? W7(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = $7(r, o, this.props.bounds, this.props.position);
      if (!Eme(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Oe(this, "draw", () => {
      this.onPositionElement();
    }), Oe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = ir();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = QI(t.position), r = QI(this.props.position), o = eB(t.bounds), i = eB(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(li.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
Oe(wc, "FLOAT_PANE", "floatPane");
Oe(wc, "MAP_PANE", "mapPane");
Oe(wc, "MARKER_LAYER", "markerLayer");
Oe(wc, "OVERLAY_LAYER", "overlayLayer");
Oe(wc, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Oe(wc, "contextType", At);
function Mme() {
}
function tB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nB(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tB(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rB = {
  onDblClick: "dblclick",
  onClick: "click"
}, oB = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Dme(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(At), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = On(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(Dme);
class H7 extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      groundOverlay: null
    }), Oe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    yo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, nB(nB({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: oB,
      eventMap: rB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: oB,
      eventMap: rB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(H7, "defaultProps", {
  onLoad: Mme
});
Oe(H7, "contextType", At);
function iB(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iB(Object(n), !0).forEach(function(r) {
      Oe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iB(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sB = {}, aB = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function _me(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(At), [a, s] = P(null);
  return h(() => {
    google.maps.visualization || yo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    yo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(hv(hv({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(_me);
class jme extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      heatmapLayer: null
    }), Oe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    yo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), yo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(hv(hv({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = un({
      updaterMap: aB,
      eventMap: sB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: aB,
      eventMap: sB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), gn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(jme, "contextType", At);
var lB = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, uB = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Tme extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      streetViewPanorama: null
    }), Oe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = un({
      updaterMap: uB,
      eventMap: lB,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: uB,
      eventMap: lB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), gn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Oe(Tme, "contextType", At);
class Ame extends pe {
  constructor() {
    super(...arguments), Oe(this, "state", {
      streetViewService: null
    }), Oe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Oe(Ame, "contextType", At);
var cB = {
  onDirectionsChanged: "directions_changed"
}, pB = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Ime extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "state", {
      directionsRenderer: null
    }), Oe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = un({
      updaterMap: pB,
      eventMap: cB,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: pB,
      eventMap: cB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), gn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Oe(Ime, "contextType", At);
var dB = {
  onPlacesChanged: "places_changed"
}, fB = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Bme extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "containerElement", ir()), Oe(this, "state", {
      searchBox: null
    }), Oe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (yo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = un({
          updaterMap: fB,
          eventMap: dB,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: fB,
      eventMap: dB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), gn(this.registeredEvents));
  }
  render() {
    return li.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
Oe(Bme, "contextType", At);
var hB = {
  onPlaceChanged: "place_changed"
}, gB = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class V7 extends pe {
  constructor() {
    super(...arguments), Oe(this, "registeredEvents", []), Oe(this, "containerElement", ir()), Oe(this, "state", {
      autocomplete: null
    }), Oe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    yo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = un({
        updaterMap: gB,
        eventMap: hB,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    gn(this.registeredEvents), this.registeredEvents = un({
      updaterMap: gB,
      eventMap: hB,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && gn(this.registeredEvents);
  }
  render() {
    return li.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
Oe(V7, "defaultProps", {
  className: ""
});
Oe(V7, "contextType", At);
let Nme = { data: "" }, Rme = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Nme, Fme = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, zme = /\/\*[^]*?\*\/|  +/g, mB = /\n+/g, el = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? el(a, i) : i + "{" + el(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += el(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += el.p ? el.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, qs = {}, Z7 = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Z7(e[n]);
    return t;
  }
  return e;
}, Ume = (e, t, n, r, o) => {
  let i = Z7(e), a = qs[i] || (qs[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!qs[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Fme.exec(u.replace(zme, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(mB, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(mB, " ").trim();
      return d[0];
    })(e);
    qs[a] = el(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && qs.g ? qs.g : null;
  return n && (qs.g = qs[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(qs[a], t, r, s), a;
}, Wme = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : el(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function h0(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Ume(n.unshift ? n.raw ? Wme(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Rme(t.target), t.g, t.o, t.k);
}
let q7, sE, aE;
h0.bind({ g: 1 });
let la = h0.bind({ k: 1 });
function $me(e, t, n, r) {
  el.p = t, q7 = e, sE = n, aE = r;
}
function Pl(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: sE && sE() }, s), n.o = / *go\d+/.test(l), s.className = h0.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), aE && u[0] && aE(s), q7(u, s);
    }
    return o;
  };
}
var Hme = (e) => typeof e == "function", Vme = (e, t) => Hme(e) ? e(t) : e, Zme = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), qme = la`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Kme = la`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, Gme = la`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, Yme = Pl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${qme} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Kme} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${Gme} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, Xme = la`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, Jme = Pl("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${Xme} 1s linear infinite;
`, Qme = la`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, eve = la`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, tve = Pl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Qme} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${eve} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, nve = Pl("div")`
  position: absolute;
`, rve = Pl("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, ove = la`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, ive = Pl("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${ove} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, sve = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Re.createElement(ive, null, t) : t : n === "blank" ? null : Re.createElement(rve, null, Re.createElement(Jme, { ...r }), n !== "loading" && Re.createElement(nve, null, n === "error" ? Re.createElement(Yme, { ...r }) : Re.createElement(tve, { ...r })));
}, ave = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, lve = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, uve = "0%{opacity:0;} 100%{opacity:1;}", cve = "0%{opacity:1;} 100%{opacity:0;}", pve = Pl("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, dve = Pl("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, fve = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Zme() ? [uve, cve] : [ave(n), lve(n)];
  return { animation: t ? `${la(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${la(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Re.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? fve(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Re.createElement(sve, { toast: e }), a = Re.createElement(dve, { ...e.ariaProps }, Vme(e.message, e));
  return Re.createElement(pve, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Re.createElement(Re.Fragment, null, i, a));
});
$me(Re.createElement);
h0`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ye({});
function hve(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const gve = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
hve(gve.CNPJ).length;
ga((e, t) => /* @__PURE__ */ ai.jsx("input", { ref: t, ...e }));
Ye({});
var va = {};
Object.defineProperty(va, "__esModule", {
  value: !0
});
var mve = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), f1 = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, K7 = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: mve ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, jk = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Zh = 1; Zh < 20; Zh++)
  jk["f" + Zh] = 111 + Zh;
function g0(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return G7(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Y7(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function vve(e, t) {
  return g0(e, t);
}
function yve(e, t) {
  return g0(e, { byKey: !0 }, t);
}
function G7(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in f1)
    r[f1[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = Tk(d), v = f1[f];
      if (d.length > 1 && !v && !K7[d] && !jk[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = X7(d)), v && (r[v] = y ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Y7(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function X7(e) {
  e = Tk(e);
  var t = jk[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function Tk(e) {
  return e = e.toLowerCase(), e = K7[e] || e, e;
}
va.default = g0;
var h1 = va.isHotkey = g0;
va.isCodeHotkey = vve;
va.isKeyHotkey = yve;
va.parseHotkey = G7;
va.compareHotkey = Y7;
va.toKeyCode = X7;
va.toKeyName = Tk;
var bve = typeof rr == "object" && rr && rr.Object === Object && rr, wve = bve, Cve = wve, Ove = typeof self == "object" && self && self.Object === Object && self, xve = Cve || Ove || Function("return this")(), Eve = xve, Lve = Eve, Pve = Lve.Symbol, J7 = Pve, vB = J7;
vB && vB.toStringTag;
var yB = J7;
yB && yB.toStringTag;
var bB;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(bB || (bB = {}));
var Ak = function(e) {
  return Object.freeze(e);
}, kve = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Ak(this);
  }
  return e;
}(), Sve = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Ak(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), wB = typeof window < "u" ? window : {};
/msie|trident/i.test(wB.navigator && wB.navigator.userAgent);
var g1 = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new kve((n ? t : e) || 0, (n ? e : t) || 0);
};
Ak({
  devicePixelContentBoxSize: g1(),
  borderBoxSize: g1(),
  contentBoxSize: g1(),
  contentRect: new Sve(0, 0, 0, 0)
});
function Nd(e) {
  "@babel/helpers - typeof";
  return Nd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Nd(e);
}
function Mve(e, t) {
  if (Nd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Nd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Dve(e) {
  var t = Mve(e, "string");
  return Nd(t) === "symbol" ? t : String(t);
}
function qp(e, t, n) {
  return t = Dve(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var _ve = /* @__PURE__ */ Ye(null), m1, v1;
parseInt(Ce.version.split(".")[0], 10);
var CB = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), y1 = typeof navigator < "u" && /Android/.test(navigator.userAgent), qh = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), jve = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (m1 = navigator.userAgent.match(/Version\/(\d+)/)) !== null && m1 !== void 0 && m1[1] && parseInt((v1 = navigator.userAgent.match(/Version\/(\d+)/)) === null || v1 === void 0 ? void 0 : v1[1], 10) < 17;
var Tve = /* @__PURE__ */ new WeakMap(), Ave = /* @__PURE__ */ new WeakMap(), Ive = /* @__PURE__ */ new WeakMap(), Bve = /* @__PURE__ */ new WeakMap(), Nve = /* @__PURE__ */ new WeakMap(), OB = /* @__PURE__ */ new WeakMap(), Rve = /* @__PURE__ */ new WeakMap(), xB = /* @__PURE__ */ new WeakMap(), Kh = /* @__PURE__ */ new WeakMap(), Fve = /* @__PURE__ */ new WeakMap(), zve = /* @__PURE__ */ new WeakMap(), Uve = /* @__PURE__ */ new WeakMap(), Q7 = globalThis.Node, Wve = globalThis.Text, eZ = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, $ve = (e) => gv(e) && e.nodeType === 8, ks = (e) => gv(e) && e.nodeType === 1, gv = (e) => {
  var t = eZ(e);
  return !!t && e instanceof t.Node;
}, EB = (e) => {
  var t = e && e.anchorNode && eZ(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, Hve = (e) => {
  var [t, n] = e;
  if (ks(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = tZ(t, o, r ? "backward" : "forward"), r = o < n; ks(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = Zve(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, Vve = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, tZ = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; ($ve(o) || ks(o) && o.childNodes.length === 0 || ks(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, Zve = (e, t, n) => {
  var [r] = tZ(e, t, n);
  return r;
}, LB = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), nZ = (e, t, n) => {
  var {
    target: r
  } = t;
  if (ks(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = rn.getWindow(e);
  if (o.contains(r))
    return rn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : nZ(e, i, n);
}, PB = (e, t) => !!(e.compareDocumentPosition(t) & Q7.DOCUMENT_POSITION_PRECEDING), qve = (e, t) => !!(e.compareDocumentPosition(t) & Q7.DOCUMENT_POSITION_FOLLOWING), Kve = 0;
class Gve {
  constructor() {
    qp(this, "id", void 0), this.id = "".concat(Kve++);
  }
}
var rn = {
  androidPendingDiffs: (e) => Uve.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = zve.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = rn.toDOMNode(e, e), n = rn.findDocumentOrShadowRoot(e);
    Kh.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = rn.findDocumentOrShadowRoot(e), r = LB(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Xm.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = rn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = rn.toSlateNode(e, t.target), a = rn.findPath(e, i);
    if (oa.isElement(i) && Yn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Yn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Yn.before(e, u) : Yn.after(e, u);
      if (c) {
        var p = Yn.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = rn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = rn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = OB.get(t);
    return n || (n = new Gve(), OB.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = Ave.get(r);
      if (o == null) {
        if (Yn.isEditor(r))
          return n;
        break;
      }
      var i = Tve.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Di.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Kh.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          rn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = rn.toDOMNode(e, e), r = rn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = LB(r), i = rn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Xm.select(e, Yn.start(e, [])), Kh.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = Ive.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = rn.toDOMNode(e, e), i;
    try {
      i = ks(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => gv(t) && rn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Yn.hasPath(e, n.path) && Yn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => rn.hasEditableTarget(e, t) || rn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => gv(t) && rn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Fve.get(e),
  isFocused: (e) => !!Kh.get(e),
  isReadOnly: (e) => !!xB.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (xB.get(e)) return !1;
    var n = rn.hasTarget(e, t) && rn.toSlateNode(e, t);
    return oa.isElement(n) && Yn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = Rve.get(e), r = Yn.isEditor(t) ? Bve.get(e) : n == null ? void 0 : n.get(rn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Di.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Yn.node(e, t.path), r = rn.toDOMNode(e, n), o;
    Yn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof Wve ? E : v,
            (g = v.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Di.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Vt.isBackward(t), i = rn.toDOMPoint(e, n), a = Vt.isCollapsed(t) ? i : rn.toDOMPoint(e, r), s = rn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = ks(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = ks(p) ? p : p.parentElement, g = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = ks(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Nve.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : Hve(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = rn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && y.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = rn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (y1 && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var z = v.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var R = z[L];
          if (rn.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (E) {
        var B = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, W = [...B(H), ...B(H == null ? void 0 : H.nextElementSibling)];
          w = (V = W.find((M) => qve(E, M))) !== null && V !== void 0 ? V : null;
        } else {
          var q, Y = [...B(H == null ? void 0 : H.previousElementSibling), ...B(H)];
          w = (q = Y.findLast((M) => PB(E, M))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      y1 && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      qh && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (y1 && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && rn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var ee = rn.toSlateNode(e, X), {
          path: J,
          offset: k
        } = Yn.start(e, rn.findPath(e, ee));
        return X.querySelector("[data-slate-leaf]") || (k = s), {
          path: J,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = rn.toSlateNode(e, u), U = rn.findPath(e, _);
    return {
      path: U,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = EB(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (EB(t)) {
        if (qh && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, g = C(f.children[d.startOffset]), E = C(v.children[y.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        jve && Vve(s) || qh ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    qh && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = rn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = PB(s, u) || s === u && c < l, x = p ? w : rn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Vt.isExpanded(m) && Vt.isForward(m) && ks(u) && Yn.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = Yn.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, Yve = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Xve = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Jve = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Mr = (e) => {
  var t = Yve[e], n = Xve[e], r = Jve[e], o = t && h1(t), i = n && h1(n), a = r && h1(r);
  return (s) => !!(o && o(s) || CB && i && i(s) || !CB && a && a(s));
};
Mr("bold"), Mr("compose"), Mr("moveBackward"), Mr("moveForward"), Mr("deleteBackward"), Mr("deleteForward"), Mr("deleteLineBackward"), Mr("deleteLineForward"), Mr("deleteWordBackward"), Mr("deleteWordForward"), Mr("extendBackward"), Mr("extendForward"), Mr("extendLineBackward"), Mr("extendLineForward"), Mr("italic"), Mr("moveLineBackward"), Mr("moveLineForward"), Mr("moveWordBackward"), Mr("moveWordForward"), Mr("redo"), Mr("insertSoftBreak"), Mr("splitBlock"), Mr("transposeCharacter"), Mr("undo");
var Qve = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => nZ(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, eye = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class tye extends $u {
  constructor() {
    super(...arguments), qp(this, "context", null), qp(this, "manager", null), qp(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, eye);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = Qve(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
qp(tye, "contextType", _ve);
Ye({});
Ye({});
Ye({});
var uo = {}, Ik = {}, sf = {}, af = {}, rZ = "Expected a function", kB = NaN, nye = "[object Symbol]", rye = /^\s+|\s+$/g, oye = /^[-+]0x[0-9a-f]+$/i, iye = /^0b[01]+$/i, sye = /^0o[0-7]+$/i, aye = parseInt, lye = typeof rr == "object" && rr && rr.Object === Object && rr, uye = typeof self == "object" && self && self.Object === Object && self, cye = lye || uye || Function("return this")(), pye = Object.prototype, dye = pye.toString, fye = Math.max, hye = Math.min, b1 = function() {
  return cye.Date.now();
};
function gye(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(rZ);
  t = SB(t) || 0, mv(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? fye(SB(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, z = o;
    return r = o = void 0, u = C, a = e.apply(z, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, z = C - u, L = t - S;
    return p ? hye(L, i - z) : L;
  }
  function g(C) {
    var S = C - l, z = C - u;
    return l === void 0 || S >= t || S < 0 || p && z >= i;
  }
  function E() {
    var C = b1();
    if (g(C))
      return w(C);
    s = setTimeout(E, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(b1());
  }
  function m() {
    var C = b1(), S = g(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), y(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function mye(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(rZ);
  return mv(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), gye(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function mv(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function vye(e) {
  return !!e && typeof e == "object";
}
function yye(e) {
  return typeof e == "symbol" || vye(e) && dye.call(e) == nye;
}
function SB(e) {
  if (typeof e == "number")
    return e;
  if (yye(e))
    return kB;
  if (mv(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = mv(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(rye, "");
  var n = iye.test(e);
  return n || sye.test(e) ? aye(e.slice(2), n ? 2 : 8) : oye.test(e) ? kB : +e;
}
var bye = mye, lf = {};
Object.defineProperty(lf, "__esModule", {
  value: !0
});
lf.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), lm.has(t) || lm.set(t, /* @__PURE__ */ new Set());
  var o = lm.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
lf.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), lm.get(t).delete(n.name || t);
};
var lm = /* @__PURE__ */ new Map();
Object.defineProperty(af, "__esModule", {
  value: !0
});
var wye = bye, Cye = xye(wye), Oye = lf;
function xye(e) {
  return e && e.__esModule ? e : { default: e };
}
var Eye = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Cye.default)(e, t);
}, $r = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = Eye(function(r) {
        $r.scrollHandler(e);
      }, t);
      $r.scrollSpyContainers.push(e), (0, Oye.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return $r.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = $r.scrollSpyContainers[$r.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n($r.currentPositionX(e), $r.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    $r.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = $r.scrollSpyContainers[$r.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e($r.currentPositionX(t), $r.currentPositionY(t));
  },
  updateStates: function() {
    $r.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    $r.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), $r.spySetState && $r.spySetState.length && $r.spySetState.indexOf(e) > -1 && $r.spySetState.splice($r.spySetState.indexOf(e), 1), document.removeEventListener("scroll", $r.scrollHandler);
  },
  update: function() {
    return $r.scrollSpyContainers.forEach(function(e) {
      return $r.scrollHandler(e);
    });
  }
};
af.default = $r;
var Cc = {}, uf = {};
Object.defineProperty(uf, "__esModule", {
  value: !0
});
var Lye = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, Pye = function() {
  return window.location.hash.replace(/^#/, "");
}, kye = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, Sye = function(e) {
  return getComputedStyle(e).position !== "static";
}, w1 = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, Mye = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (Sye(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = w1(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return w1(t, s).offsetTop - w1(e, s).offsetTop;
};
uf.default = {
  updateHash: Lye,
  getHash: Pye,
  filterElementInContainer: kye,
  scrollOffset: Mye
};
var m0 = {}, Bk = {};
Object.defineProperty(Bk, "__esModule", {
  value: !0
});
Bk.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Nk = {};
Object.defineProperty(Nk, "__esModule", {
  value: !0
});
var Dye = lf, _ye = ["mousedown", "mousewheel", "touchmove", "keydown"];
Nk.default = {
  subscribe: function(e) {
    return typeof document < "u" && _ye.forEach(function(t) {
      return (0, Dye.addPassiveEventListener)(document, t, e);
    });
  }
};
var cf = {};
Object.defineProperty(cf, "__esModule", {
  value: !0
});
var lE = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      lE.registered[e] = t;
    },
    remove: function(e) {
      lE.registered[e] = null;
    }
  }
};
cf.default = lE;
Object.defineProperty(m0, "__esModule", {
  value: !0
});
var jye = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Tye = uf;
v0(Tye);
var Aye = Bk, MB = v0(Aye), Iye = Nk, Bye = v0(Iye), Nye = cf, ws = v0(Nye);
function v0(e) {
  return e && e.__esModule ? e : { default: e };
}
var oZ = function(e) {
  return MB.default[e.smooth] || MB.default.defaultEasing;
}, Rye = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Fye = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, uE = function() {
  return Fye() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), iZ = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, sZ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, aZ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, zye = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, Uye = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, Wye = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    ws.default.registered.end && ws.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    uE.call(window, i);
    return;
  }
  ws.default.registered.end && ws.default.registered.end(o.to, o.target, o.currentPosition);
}, Rk = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, pf = function(e, t, n, r) {
  t.data = t.data || iZ(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (Bye.default.subscribe(o), Rk(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? sZ(t) : aZ(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    ws.default.registered.end && ws.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = Rye(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = oZ(t), a = Wye.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      ws.default.registered.begin && ws.default.registered.begin(t.data.to, t.data.target), uE.call(window, a);
    }, t.delay);
    return;
  }
  ws.default.registered.begin && ws.default.registered.begin(t.data.to, t.data.target), uE.call(window, a);
}, y0 = function(e) {
  return e = jye({}, e), e.data = e.data || iZ(), e.absolute = !0, e;
}, $ye = function(e) {
  pf(0, y0(e));
}, Hye = function(e, t) {
  pf(e, y0(t));
}, Vye = function(e) {
  e = y0(e), Rk(e), pf(e.horizontal ? zye(e) : Uye(e), e);
}, Zye = function(e, t) {
  t = y0(t), Rk(t);
  var n = t.horizontal ? sZ(t) : aZ(t);
  pf(e + n, t);
};
m0.default = {
  animateTopScroll: pf,
  getAnimationType: oZ,
  scrollToTop: $ye,
  scrollToBottom: Vye,
  scrollTo: Hye,
  scrollMore: Zye
};
Object.defineProperty(Cc, "__esModule", {
  value: !0
});
var qye = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Kye = uf, Gye = Fk(Kye), Yye = m0, Xye = Fk(Yye), Jye = cf, Gh = Fk(Jye);
function Fk(e) {
  return e && e.__esModule ? e : { default: e };
}
var Yh = {}, DB = void 0;
Cc.default = {
  unmount: function() {
    Yh = {};
  },
  register: function(e, t) {
    Yh[e] = t;
  },
  unregister: function(e) {
    delete Yh[e];
  },
  get: function(e) {
    return Yh[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return DB = e;
  },
  getActiveLink: function() {
    return DB;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = qye({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = Gye.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Gh.default.registered.begin && Gh.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Gh.default.registered.end && Gh.default.registered.end(e, n);
      return;
    }
    Xye.default.animateTopScroll(s, t, e, n);
  }
};
var cE = { exports: {} }, C1 = { exports: {} }, _n = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var _B;
function Qye() {
  if (_B) return _n;
  _B = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return _n.AsyncMode = l, _n.ConcurrentMode = u, _n.ContextConsumer = s, _n.ContextProvider = a, _n.Element = t, _n.ForwardRef = c, _n.Fragment = r, _n.Lazy = f, _n.Memo = y, _n.Portal = n, _n.Profiler = i, _n.StrictMode = o, _n.Suspense = p, _n.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, _n.isConcurrentMode = x, _n.isContextConsumer = function(m) {
    return D(m) === s;
  }, _n.isContextProvider = function(m) {
    return D(m) === a;
  }, _n.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, _n.isForwardRef = function(m) {
    return D(m) === c;
  }, _n.isFragment = function(m) {
    return D(m) === r;
  }, _n.isLazy = function(m) {
    return D(m) === f;
  }, _n.isMemo = function(m) {
    return D(m) === y;
  }, _n.isPortal = function(m) {
    return D(m) === n;
  }, _n.isProfiler = function(m) {
    return D(m) === i;
  }, _n.isStrictMode = function(m) {
    return D(m) === o;
  }, _n.isSuspense = function(m) {
    return D(m) === p;
  }, _n.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === g || m.$$typeof === E || m.$$typeof === w || m.$$typeof === v);
  }, _n.typeOf = D, _n;
}
var zn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jB;
function ebe() {
  return jB || (jB = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === y || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === g || N.$$typeof === E || N.$$typeof === w || N.$$typeof === v);
    }
    function x(N) {
      if (typeof N == "object" && N !== null) {
        var ue = N.$$typeof;
        switch (ue) {
          case t:
            var fe = N.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var m = l, C = u, S = s, z = a, L = t, R = c, B = r, H = f, V = y, W = n, q = i, Y = o, X = p, ee = !1;
    function J(N) {
      return ee || (ee = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || x(N) === l;
    }
    function k(N) {
      return x(N) === u;
    }
    function _(N) {
      return x(N) === s;
    }
    function U(N) {
      return x(N) === a;
    }
    function M(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function $(N) {
      return x(N) === c;
    }
    function O(N) {
      return x(N) === r;
    }
    function j(N) {
      return x(N) === f;
    }
    function F(N) {
      return x(N) === y;
    }
    function T(N) {
      return x(N) === n;
    }
    function Z(N) {
      return x(N) === i;
    }
    function A(N) {
      return x(N) === o;
    }
    function G(N) {
      return x(N) === p;
    }
    zn.AsyncMode = m, zn.ConcurrentMode = C, zn.ContextConsumer = S, zn.ContextProvider = z, zn.Element = L, zn.ForwardRef = R, zn.Fragment = B, zn.Lazy = H, zn.Memo = V, zn.Portal = W, zn.Profiler = q, zn.StrictMode = Y, zn.Suspense = X, zn.isAsyncMode = J, zn.isConcurrentMode = k, zn.isContextConsumer = _, zn.isContextProvider = U, zn.isElement = M, zn.isForwardRef = $, zn.isFragment = O, zn.isLazy = j, zn.isMemo = F, zn.isPortal = T, zn.isProfiler = Z, zn.isStrictMode = A, zn.isSuspense = G, zn.isValidElementType = D, zn.typeOf = x;
  }()), zn;
}
var TB;
function lZ() {
  return TB || (TB = 1, process.env.NODE_ENV === "production" ? C1.exports = Qye() : C1.exports = ebe()), C1.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var O1, AB;
function tbe() {
  if (AB) return O1;
  AB = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return O1 = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, O1;
}
var x1, IB;
function zk() {
  if (IB) return x1;
  IB = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return x1 = e, x1;
}
var BB, NB;
function uZ() {
  return NB || (NB = 1, BB = Function.call.bind(Object.prototype.hasOwnProperty)), BB;
}
var E1, RB;
function nbe() {
  if (RB) return E1;
  RB = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = zk(), n = {}, r = uZ();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, E1 = o, E1;
}
var L1, FB;
function rbe() {
  if (FB) return L1;
  FB = 1;
  var e = lZ(), t = tbe(), n = zk(), r = uZ(), o = nbe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return L1 = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var _ = k && (u && k[u] || k[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: z,
      oneOf: S,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(k, _) {
      return k === _ ? k !== 0 || 1 / k === 1 / _ : k !== k && _ !== _;
    }
    function v(k, _) {
      this.message = k, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function g(k) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, U = 0;
      function M(O, j, F, T, Z, A, G) {
        if (T = T || d, A = A || F, G !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + F;
            !_[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            U < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[ue] = !0, U++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + Z + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + Z + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : k(j, F, T, Z, A);
      }
      var $ = M.bind(null, !1);
      return $.isRequired = M.bind(null, !0), $;
    }
    function E(k) {
      function _(U, M, $, O, j, F) {
        var T = U[M], Z = Y(T);
        if (Z !== k) {
          var A = X(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return g(_);
    }
    function w() {
      return g(a);
    }
    function D(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var F = U[M];
        if (!Array.isArray(F)) {
          var T = Y(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var Z = 0; Z < F.length; Z++) {
          var A = k(F, Z, $, O, j + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(_);
    }
    function x() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!s(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(k);
    }
    function m() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!e.isValidElementType(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(k);
    }
    function C(k) {
      function _(U, M, $, O, j) {
        if (!(U[M] instanceof k)) {
          var F = k.name || d, T = J(U[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return g(_);
    }
    function S(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(U, M, $, O, j) {
        for (var F = U[M], T = 0; T < k.length; T++)
          if (f(F, k[T]))
            return null;
        var Z = JSON.stringify(k, function(A, G) {
          var N = X(G);
          return N === "symbol" ? String(G) : G;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + $ + "`, expected one of " + Z + "."));
      }
      return g(_);
    }
    function z(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var Z in F)
          if (r(F, Z)) {
            var A = k(F, Z, $, O, j + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(_);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < k.length; _++) {
        var U = k[_];
        if (typeof U != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ee(U) + " at index " + _ + "."
          ), a;
      }
      function M($, O, j, F, T) {
        for (var Z = [], A = 0; A < k.length; A++) {
          var G = k[A], N = G($, O, j, F, T, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && Z.push(N.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return g(M);
    }
    function R() {
      function k(_, U, M, $, O) {
        return W(_[U]) ? null : new v("Invalid " + $ + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return g(k);
    }
    function B(k, _, U, M, $) {
      return new v(
        (k || "React class") + ": " + _ + " type `" + U + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function H(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var Z in k) {
          var A = k[Z];
          if (typeof A != "function")
            return B($, O, j, Z, X(A));
          var G = A(F, Z, $, O, j + "." + Z, n);
          if (G)
            return G;
        }
        return null;
      }
      return g(_);
    }
    function V(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var Z = t({}, U[M], k);
        for (var A in Z) {
          var G = k[A];
          if (r(k, A) && typeof G != "function")
            return B($, O, j, A, X(G));
          if (!G)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(U[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = G(F, A, $, O, j + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return g(_);
    }
    function W(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(W);
          if (k === null || s(k))
            return !0;
          var _ = p(k);
          if (_) {
            var U = _.call(k), M;
            if (_ !== k.entries) {
              for (; !(M = U.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = U.next()).done; ) {
                var $ = M.value;
                if ($ && !W($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(k, _) {
      return k === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function Y(k) {
      var _ = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : q(_, k) ? "symbol" : _;
    }
    function X(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var _ = Y(k);
      if (_ === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function ee(k) {
      var _ = X(k);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, L1;
}
var P1, zB;
function obe() {
  if (zB) return P1;
  zB = 1;
  var e = zk();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, P1 = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, P1;
}
if (process.env.NODE_ENV !== "production") {
  var ibe = lZ(), sbe = !0;
  cE.exports = rbe()(ibe.isElement, sbe);
} else
  cE.exports = obe()();
var b0 = cE.exports, w0 = {};
Object.defineProperty(w0, "__esModule", {
  value: !0
});
var abe = uf, k1 = lbe(abe);
function lbe(e) {
  return e && e.__esModule ? e : { default: e };
}
var ube = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return k1.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && k1.default.getHash() !== e && k1.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
w0.default = ube;
Object.defineProperty(sf, "__esModule", {
  value: !0
});
var Xh = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, cbe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), pbe = Ce, UB = df(pbe), dbe = af, Jh = df(dbe), fbe = Cc, hbe = df(fbe), gbe = b0, Dr = df(gbe), mbe = w0, La = df(mbe);
function df(e) {
  return e && e.__esModule ? e : { default: e };
}
function vbe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ybe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function bbe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var WB = {
  to: Dr.default.string.isRequired,
  containerId: Dr.default.string,
  container: Dr.default.object,
  activeClass: Dr.default.string,
  activeStyle: Dr.default.object,
  spy: Dr.default.bool,
  horizontal: Dr.default.bool,
  smooth: Dr.default.oneOfType([Dr.default.bool, Dr.default.string]),
  offset: Dr.default.number,
  delay: Dr.default.number,
  isDynamic: Dr.default.bool,
  onClick: Dr.default.func,
  duration: Dr.default.oneOfType([Dr.default.number, Dr.default.func]),
  absolute: Dr.default.bool,
  onSetActive: Dr.default.func,
  onSetInactive: Dr.default.func,
  ignoreCancelEvents: Dr.default.bool,
  hashSpy: Dr.default.bool,
  saveHashHistory: Dr.default.bool,
  spyThrottle: Dr.default.number
};
sf.default = function(e, t) {
  var n = t || hbe.default, r = function(i) {
    bbe(a, i);
    function a(s) {
      vbe(this, a);
      var l = ybe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return cbe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Jh.default.isMounted(s) || Jh.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (La.default.isMounted() || La.default.mount(n), La.default.mapContainer(this.props.to, s)), Jh.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Jh.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Xh({}, this.props.style, this.props.activeStyle) : l = Xh({}, this.props.style);
        var u = Xh({}, this.props);
        for (var c in WB)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, UB.default.createElement(e, u);
      }
    }]), a;
  }(UB.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Xh({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(La.default.isMounted() && !La.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, g = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            g = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - g + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            x = z.top - C + s, m = x + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(m), y = L < Math.floor(x) || L >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && La.default.getHash() === c) {
            var B = i.props.saveHashHistory, H = B === void 0 ? !1 : B;
            La.default.changeHash("", H);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, W = V === void 0 ? !1 : V;
          i.props.hashSpy && La.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = WB, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Ik, "__esModule", {
  value: !0
});
var wbe = Ce, $B = cZ(wbe), Cbe = sf, Obe = cZ(Cbe);
function cZ(e) {
  return e && e.__esModule ? e : { default: e };
}
function xbe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HB(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Ebe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Lbe = function(e) {
  Ebe(t, e);
  function t() {
    var n, r, o, i;
    xbe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = HB(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return $B.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), HB(o, i);
  }
  return t;
}($B.default.Component);
Ik.default = (0, Obe.default)(Lbe);
var Uk = {};
Object.defineProperty(Uk, "__esModule", {
  value: !0
});
var Pbe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), kbe = Ce, VB = pZ(kbe), Sbe = sf, Mbe = pZ(Sbe);
function pZ(e) {
  return e && e.__esModule ? e : { default: e };
}
function Dbe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function _be(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function jbe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Tbe = function(e) {
  jbe(t, e);
  function t() {
    return Dbe(this, t), _be(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return Pbe(t, [{
    key: "render",
    value: function() {
      return VB.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(VB.default.Component);
Uk.default = (0, Mbe.default)(Tbe);
var Wk = {}, C0 = {};
Object.defineProperty(C0, "__esModule", {
  value: !0
});
var Abe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Ibe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Bbe = Ce, ZB = O0(Bbe), Nbe = pl;
O0(Nbe);
var Rbe = Cc, qB = O0(Rbe), Fbe = b0, KB = O0(Fbe);
function O0(e) {
  return e && e.__esModule ? e : { default: e };
}
function zbe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Ube(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Wbe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
C0.default = function(e) {
  var t = function(n) {
    Wbe(r, n);
    function r(o) {
      zbe(this, r);
      var i = Ube(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return Ibe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        qB.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        qB.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return ZB.default.createElement(e, Abe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(ZB.default.Component);
  return t.propTypes = {
    name: KB.default.string,
    id: KB.default.string
  }, t;
};
Object.defineProperty(Wk, "__esModule", {
  value: !0
});
var GB = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, $be = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Hbe = Ce, YB = $k(Hbe), Vbe = C0, Zbe = $k(Vbe), qbe = b0, XB = $k(qbe);
function $k(e) {
  return e && e.__esModule ? e : { default: e };
}
function Kbe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Gbe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Ybe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var dZ = function(e) {
  Ybe(t, e);
  function t() {
    return Kbe(this, t), Gbe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return $be(t, [{
    key: "render",
    value: function() {
      var n = this, r = GB({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, YB.default.createElement(
        "div",
        GB({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(YB.default.Component);
dZ.propTypes = {
  name: XB.default.string,
  id: XB.default.string
};
Wk.default = (0, Zbe.default)(dZ);
var S1 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, JB = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function QB(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function eN(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function tN(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Qh = Ce, Bl = af, M1 = Cc, Yr = b0, Pa = w0, nN = {
  to: Yr.string.isRequired,
  containerId: Yr.string,
  container: Yr.object,
  activeClass: Yr.string,
  spy: Yr.bool,
  smooth: Yr.oneOfType([Yr.bool, Yr.string]),
  offset: Yr.number,
  delay: Yr.number,
  isDynamic: Yr.bool,
  onClick: Yr.func,
  duration: Yr.oneOfType([Yr.number, Yr.func]),
  absolute: Yr.bool,
  onSetActive: Yr.func,
  onSetInactive: Yr.func,
  ignoreCancelEvents: Yr.bool,
  hashSpy: Yr.bool,
  spyThrottle: Yr.number
}, Xbe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || M1, r = function(i) {
      tN(a, i);
      function a(s) {
        QB(this, a);
        var l = eN(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return JB(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Bl.isMounted(s) || Bl.mount(s, this.props.spyThrottle), this.props.hashSpy && (Pa.isMounted() || Pa.mount(n), Pa.mapContainer(this.props.to, s)), this.props.spy && Bl.addStateHandler(this.stateHandler), Bl.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Bl.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = S1({}, this.props);
          for (var u in nN)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Qh.createElement(e, l);
        }
      }]), a;
    }(Qh.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, S1({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Pa.isMounted() && !Pa.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, g = v >= Math.floor(c) && v < Math.floor(p), E = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Pa.getHash() === l && Pa.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Bl.updateStates();
          if (g && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Pa.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Bl.updateStates();
        }
      };
    };
    return r.propTypes = nN, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      tN(r, n);
      function r(o) {
        QB(this, r);
        var i = eN(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return JB(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          M1.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          M1.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Qh.createElement(e, S1({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Qh.Component);
    return t.propTypes = {
      name: Yr.string,
      id: Yr.string
    }, t;
  }
}, Jbe = Xbe;
Object.defineProperty(uo, "__esModule", {
  value: !0
});
uo.Helpers = uo.ScrollElement = uo.ScrollLink = uo.animateScroll = uo.scrollSpy = uo.Events = uo.scroller = uo.Element = uo.Button = uo.Link = void 0;
var Qbe = Ik, fZ = As(Qbe), e0e = Uk, hZ = As(e0e), t0e = Wk, gZ = As(t0e), n0e = Cc, mZ = As(n0e), r0e = cf, vZ = As(r0e), o0e = af, yZ = As(o0e), i0e = m0, bZ = As(i0e), s0e = sf, wZ = As(s0e), a0e = C0, CZ = As(a0e), l0e = Jbe, OZ = As(l0e);
function As(e) {
  return e && e.__esModule ? e : { default: e };
}
uo.Link = fZ.default;
uo.Button = hZ.default;
uo.Element = gZ.default;
uo.scroller = mZ.default;
uo.Events = vZ.default;
uo.scrollSpy = yZ.default;
uo.animateScroll = bZ.default;
uo.ScrollLink = wZ.default;
uo.ScrollElement = CZ.default;
uo.Helpers = OZ.default;
uo.default = { Link: fZ.default, Button: hZ.default, Element: gZ.default, scroller: mZ.default, Events: vZ.default, scrollSpy: yZ.default, animateScroll: bZ.default, ScrollLink: wZ.default, ScrollElement: CZ.default, Helpers: OZ.default };
Ye({});
Ye({});
Ye({});
function Rd(e) {
  "@babel/helpers - typeof";
  return Rd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Rd(e);
}
function u0e(e, t) {
  if (Rd(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Rd(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function c0e(e) {
  var t = u0e(e, "string");
  return Rd(t) == "symbol" ? t : t + "";
}
function xe(e, t, n) {
  return (t = c0e(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function xZ(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var D1, rN;
function p0e() {
  if (rN) return D1;
  rN = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return D1 = t, D1;
}
var d0e = p0e(), bo = /* @__PURE__ */ xZ(d0e), It = Ye(null);
function f0e() {
  bo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(It);
  return bo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function h0e(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function g0e(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function m0e(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return g0e(e, i), o;
}
function v0e(e, t, n) {
  var r = h0e(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function y0e(e) {
  google.maps.event.removeListener(e);
}
function mn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(y0e);
}
function cn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = v0e(o, i, n);
  return m0e(t, r, o, i), a;
}
function b0e(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = P(null), S = dt(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null), [A, G] = P(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && g && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(m, "mouseup", g)));
  }, [g]), h(() => {
    m && E && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", E)));
  }, [E]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), G(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var N = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(N), N !== null && D && D(N), () => {
      N !== null && x && x(N);
    };
  }, []), ai.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: ai.jsx(It.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
ve(b0e);
function oN(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function EZ(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        oN(i, r, o, a, s, "next", l);
      }
      function s(l) {
        oN(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function LZ(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return bo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var pu = typeof document < "u";
function PZ(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return pu ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function iN(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function kZ() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return iN(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return iN(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var Xc = !1;
function SZ() {
  return ai.jsx("div", {
    children: "Loading..."
  });
}
var pE = {
  id: "script-loader",
  version: "weekly"
};
class w0e extends pe {
  constructor() {
    super(...arguments), xe(this, "check", ir()), xe(this, "state", {
      loaded: !1
    }), xe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), xe(this, "isCleaningUp", /* @__PURE__ */ EZ(function* () {
      function t(n) {
        if (!Xc)
          n();
        else if (pu)
          var r = window.setInterval(function() {
            Xc || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), xe(this, "cleanup", () => {
      Xc = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), xe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && kZ(), bo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: LZ(this.props)
      };
      PZ(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (pu) {
      if (window.google && window.google.maps && !Xc) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), pu && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (pu) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, Xc = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ai.jsxs(ai.Fragment, {
      children: [ai.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ai.jsx(SZ, {})]
    });
  }
}
xe(w0e, "defaultProps", pE);
function C0e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function Hk(e, t) {
  if (e == null) return {};
  var n, r, o = C0e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var sN;
function O0e(e) {
  var {
    id: t = pE.id,
    version: n = pE.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = dt(!1), [f, v] = P(!1), [g, E] = P(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    pu && u && kZ();
  }, [u]), h(function() {
    f && bo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = LZ({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!pu)
      return;
    function x() {
      y.current && (v(!0), sN = w);
    }
    if (window.google && window.google.maps && sN === w) {
      x();
      return;
    }
    PZ({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && E(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = dt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var x0e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], E0e = ai.jsx(SZ, {});
function L0e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = Hk(e, x0e), {
    isLoaded: s,
    loadError: l
  } = O0e(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || E0e;
}
ve(L0e);
var aN;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(aN || (aN = {}));
function lN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uN = {}, cN = {
  options(e, t) {
    e.setOptions(t);
  }
};
function P0e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(It), [i, a] = P(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(vv(vv({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(P0e);
class k0e extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      trafficLayer: null
    }), xe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), xe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(vv(vv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: cN,
      eventMap: uN,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: cN,
      eventMap: uN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), mn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(k0e, "contextType", It);
function S0e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(It), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(S0e);
class M0e extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      bicyclingLayer: null
    }), xe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(M0e, "contextType", It);
function D0e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(It), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(D0e);
class _0e extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      transitLayer: null
    }), xe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(_0e, "contextType", It);
function pN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function yv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dN = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, fN = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function j0e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(It), [d, y] = P(null), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    bo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(yv(yv({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && E(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && L(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(j0e);
class T0e extends pe {
  constructor(t) {
    super(t), xe(this, "registeredEvents", []), xe(this, "state", {
      drawingManager: null
    }), xe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), bo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(yv(yv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: fN,
      eventMap: dN,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: fN,
      eventMap: dN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), mn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
xe(T0e, "contextType", It);
function hN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gN = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, mN = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, bv = {};
function A0e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: R,
    onClickableChanged: B,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: W,
    onFlatChanged: q,
    onIconChanged: Y,
    onPositionChanged: X,
    onShapeChanged: ee,
    onTitleChanged: J,
    onVisibleChanged: k,
    onZindexChanged: _,
    onLoad: U,
    onUnmount: M
  } = e, $ = ge(It), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null), [oe, Ie] = P(null), [qe, Ge] = P(null), [Be, et] = P(null), [Xe, Me] = P(null), [Je, at] = P(null), [Se, _e] = P(null), [Ae, Ve] = P(null), [Ne, nt] = P(null), [we, mt] = P(null), [ot, st] = P(null), [ut, vt] = P(null), [ct, yt] = P(null), [Qe, ft] = P(null), [tt, bt] = P(null), [pt, Dt] = P(null), [wt, _t] = P(null), [Ct, jt] = P(null);
  h(() => {
    O !== null && O.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ie(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (qe !== null && google.maps.event.removeListener(qe), Ge(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && z && (Be !== null && google.maps.event.removeListener(Be), et(google.maps.event.addListener(O, "mouseup", z)));
  }, [z]), h(() => {
    O && R && (Xe !== null && google.maps.event.removeListener(Xe), Me(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && E && (Je !== null && google.maps.event.removeListener(Je), at(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && D && (Se !== null && google.maps.event.removeListener(Se), _e(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && B && (Ae !== null && google.maps.event.removeListener(Ae), Ve(google.maps.event.addListener(O, "clickable_changed", B)));
  }, [B]), h(() => {
    O && H && (Ne !== null && google.maps.event.removeListener(Ne), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), h(() => {
    O && V && (we !== null && google.maps.event.removeListener(we), mt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && W && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && q && (ut !== null && google.maps.event.removeListener(ut), vt(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), h(() => {
    O && Y && (ct !== null && google.maps.event.removeListener(ct), yt(google.maps.event.addListener(O, "icon_changed", Y)));
  }, [Y]), h(() => {
    O && X && (Qe !== null && google.maps.event.removeListener(Qe), ft(google.maps.event.addListener(O, "position_changed", X)));
  }, [X]), h(() => {
    O && ee && (tt !== null && google.maps.event.removeListener(tt), bt(google.maps.event.addListener(O, "shape_changed", ee)));
  }, [ee]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Dt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && k && (wt !== null && google.maps.event.removeListener(wt), _t(google.maps.event.addListener(O, "visible_changed", k)));
  }, [k]), h(() => {
    O && _ && (Ct !== null && google.maps.event.removeListener(Ct), jt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var ht = Gu(Gu(Gu({}, n || bv), r ? bv : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof y < "u" && re.setOpacity(y), f && re.setShape(f), typeof v == "string" && re.setTitle(v), typeof g == "number" && re.setZIndex(g), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), m && N(google.maps.event.addListener(re, "dragstart", m)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ie(google.maps.event.addListener(re, "mouseout", C)), S && Ge(google.maps.event.addListener(re, "mouseover", S)), z && et(google.maps.event.addListener(re, "mouseup", z)), R && Me(google.maps.event.addListener(re, "rightclick", R)), E && at(google.maps.event.addListener(re, "click", E)), D && _e(google.maps.event.addListener(re, "drag", D)), B && Ve(google.maps.event.addListener(re, "clickable_changed", B)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && mt(google.maps.event.addListener(re, "animation_changed", V)), W && st(google.maps.event.addListener(re, "draggable_changed", W)), q && vt(google.maps.event.addListener(re, "flat_changed", q)), Y && yt(google.maps.event.addListener(re, "icon_changed", Y)), X && ft(google.maps.event.addListener(re, "position_changed", X)), ee && bt(google.maps.event.addListener(re, "shape_changed", ee)), J && Dt(google.maps.event.addListener(re, "title_changed", J)), k && _t(google.maps.event.addListener(re, "visible_changed", k)), _ && jt(google.maps.event.addListener(re, "zindex_changed", _)), j(re), U && U(re), () => {
      F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), qe !== null && google.maps.event.removeListener(qe), Be !== null && google.maps.event.removeListener(Be), Xe !== null && google.maps.event.removeListener(Xe), Je !== null && google.maps.event.removeListener(Je), Ae !== null && google.maps.event.removeListener(Ae), Ne !== null && google.maps.event.removeListener(Ne), we !== null && google.maps.event.removeListener(we), ot !== null && google.maps.event.removeListener(ot), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), Qe !== null && google.maps.event.removeListener(Qe), pt !== null && google.maps.event.removeListener(pt), wt !== null && google.maps.event.removeListener(wt), Ct !== null && google.maps.event.removeListener(Ct), M && M(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Cn = On(() => i ? lt.map(i, (ht) => {
    if (!mi(ht))
      return ht;
    var re = ht;
    return vi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return ai.jsx(ai.Fragment, {
    children: Cn
  }) || null;
}
ve(A0e);
class I0e extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return EZ(function* () {
      var n = Gu(Gu(Gu({}, t.props.options || bv), t.props.clusterer ? bv : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = cn({
        updaterMap: mN,
        eventMap: gN,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: mN,
      eventMap: gN,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), mn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
xe(I0e, "contextType", It);
var B0e = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), N0e = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new B0e(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function R0e(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var F0e = 2e3, z0e = 500, U0e = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", W0e = "png", $0e = [53, 56, 66, 78, 90], H0e = "cluster", MZ = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || U0e, this.imageExtension = r.imageExtension || W0e, this.imageSizes = r.imageSizes || $0e, this.calculator = r.calculator || R0e, this.batchSize = r.batchSize || F0e, this.batchSizeIE = r.batchSizeIE || z0e, this.clusterClass = r.clusterClass || H0e, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new N0e(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function vN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function V0e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ts = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, En = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, Z0e = {};
function q0e(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: z
  } = e, [L, R] = P(null), B = ge(It), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null);
  return h(() => {
    L && C && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(L, ts.onMouseOut, C)));
  }, [C]), h(() => {
    L && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(L, ts.onMouseOver, m)));
  }, [m]), h(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, ts.onClick, w)));
  }, [w]), h(() => {
    L && D && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(L, ts.onClusteringBegin, D)));
  }, [D]), h(() => {
    L && x && (Y !== null && google.maps.event.removeListener(Y), q(google.maps.event.addListener(L, ts.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && En.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && En.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && En.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && En.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && En.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && En.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && En.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && En.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && En.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && En.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof y < "u" && L !== null && En.maxZoom(L, y);
  }, [L, y]), h(() => {
    typeof f < "u" && L !== null && En.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof v < "u" && L !== null && En.styles(L, v);
  }, [L, v]), h(() => {
    typeof g < "u" && L !== null && En.title(L, g);
  }, [L, g]), h(() => {
    typeof E < "u" && L !== null && En.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (B) {
      var U = V0e({}, n || Z0e), M = new MZ(B, [], U);
      return r && En.averageCenter(M, r), o && En.batchSizeIE(M, o), i && En.calculator(M, i), a && En.clusterClass(M, a), s && En.enableRetinaIcons(M, s), l && En.gridSize(M, l), u && En.ignoreHidden(M, u), c && En.imageExtension(M, c), p && En.imagePath(M, p), d && En.imageSizes(M, d), y && En.maxZoom(M, y), f && En.minimumClusterSize(M, f), v && En.styles(M, v), g && En.title(M, g), E && En.zoomOnClick(M, E), C && J(google.maps.event.addListener(M, ts.onMouseOut, C)), m && _(google.maps.event.addListener(M, ts.onMouseOver, m)), w && V(google.maps.event.addListener(M, ts.onClick, w)), D && q(google.maps.event.addListener(M, ts.onClusteringBegin, D)), x && X(google.maps.event.addListener(M, ts.onClusteringEnd, x)), R(M), S && S(M), () => {
        ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), z && z(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(q0e);
class K0e extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      markerClusterer: null
    }), xe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new MZ(this.context, [], this.props.options);
      this.registeredEvents = cn({
        updaterMap: En,
        eventMap: ts,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: En,
      eventMap: ts,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), mn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
xe(K0e, "contextType", It);
function yN(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var DZ = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || yN(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, yN));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), g = v.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + y ? r = g.x + u - y : g.x + p + u + y > s && (r = g.x + p + u + y - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), G0e = ["position"], Y0e = ["position"];
function bN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wN = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, CN = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, X0e = {};
function J0e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(It), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var B = r || X0e, {
        position: H
      } = B, V = Hk(B, G0e), W;
      H && !(H instanceof google.maps.LatLng) && (W = new google.maps.LatLng(H.lat, H.lng));
      var q = new DZ(wv(wv({}, V), W ? {
        position: W
      } : {}));
      R.current = document.createElement("div"), v(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && D(google.maps.event.addListener(q, "domready", s)), l && m(google.maps.event.addListener(q, "content_changed", l)), u && S(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(R.current), n ? q.open(y, n) : q.getPosition() ? q.open(y) : bo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(J0e);
class Q0e extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", null), xe(this, "state", {
      infoBox: null
    }), xe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : bo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), xe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = Hk(t, Y0e), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new DZ(wv(wv({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = cn({
      updaterMap: CN,
      eventMap: wN,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: CN,
      eventMap: wN,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), mn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
xe(Q0e, "contextType", It);
var ON, xN;
function ewe() {
  return xN || (xN = 1, ON = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), ON;
}
var twe = ewe(), EN = /* @__PURE__ */ xZ(twe), LN = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], _1 = 1, Jc = 8;
class Vk {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== _1)
      throw new Error("Got v".concat(o, " data when expected v").concat(_1, "."));
    var i = LN[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new Vk(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = LN.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Jc, t), this.coords = new this.ArrayType(this.data, Jc + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Jc + a + s + l), this.ids = new this.IndexArrayType(this.data, Jc, t), this.coords = new this.ArrayType(this.data, Jc + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (_1 << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return dE(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          PN(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], g = i[2 * f + 1];
      PN(v, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function dE(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    _Z(e, t, a, r, o, i), dE(e, t, n, r, a - 1, 1 - i), dE(e, t, n, a + 1, o, 1 - i);
  }
}
function _Z(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      _Z(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (Qc(e, t, r, n), t[2 * o + i] > y && Qc(e, t, r, o); f < v; ) {
      for (Qc(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? Qc(e, t, r, v) : (v++, Qc(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function Qc(e, t, n, r) {
  j1(e, n, r), j1(t, 2 * n, 2 * r), j1(t, 2 * n + 1, 2 * r + 1);
}
function j1(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function PN(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var nwe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, kN = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Nl = 2, Za = 3, T1 = 4, Fa = 5, jZ = 6;
class rwe {
  constructor(t) {
    this.options = Object.assign(Object.create(nwe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = kN(eg(u)), d = kN(tg(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(eg(r), tg(a), eg(i), tg(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Fa] > 1 ? SN(p, f, this.clusterProps) : this.points[p[f + Za]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + T1] === t && p.push(a[y + Fa] > 1 ? SN(a, y, this.clusterProps) : this.points[a[y + Za]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new Vk(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Fa] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = TZ(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Za]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = eg(f), d = tg(v);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Za] : E = this.points[n[l + Za]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Nl] <= n)) {
        l[p + Nl] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Fa], g = v;
        for (var E of f) {
          var w = E * c;
          l[w + Nl] > n && (g += l[w + Fa]);
        }
        if (g > v && g >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Nl] <= n)) {
              l[L + Nl] = n;
              var R = l[L + Fa];
              D += l[L] * R, x += l[L + 1] * R, l[L + T1] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, L)));
            }
          }
          l[p + T1] = S, u.push(D / g, x / g, 1 / 0, S, -1, g), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + Nl] <= n)) {
                l[V + Nl] = n;
                for (var W = 0; W < c; W++) u.push(l[V + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Fa] > 1) {
      var o = this.clusterProps[t[n + jZ]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Za]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function SN(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Za],
    properties: TZ(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [owe(e[t]), iwe(e[t + 1])]
    }
  };
}
function TZ(e, t, n) {
  var r = e[t + Fa], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + jZ], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Za],
    point_count: r,
    point_count_abbreviated: o
  });
}
function eg(e) {
  return e / 360 + 0.5;
}
function tg(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function owe(e) {
  return (e - 0.5) * 360;
}
function iwe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function swe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ti {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class fE {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ti.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ti.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ti.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class awe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return lwe(n);
  }
}
var lwe = (e) => {
  var t = e.map((n) => new fE({
    position: Ti.getPosition(n),
    markers: [n]
  }));
  return t;
};
class uwe extends awe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = swe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new rwe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!EN(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ti.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !EN(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new fE({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new fE({
      markers: [i],
      position: Ti.getPosition(i)
    });
  }
}
class cwe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class pwe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ti.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function dwe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class Zk {
  constructor() {
    dwe(Zk, google.maps.OverlayView);
  }
}
var Kp;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Kp || (Kp = {}));
var fwe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class hwe extends Zk {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new uwe(o),
      renderer: a = new pwe(),
      onClusterClick: s = fwe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ti.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Kp.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ti.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ti.setMap(l, null)));
      }
      google.maps.event.trigger(this, Kp.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ti.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new cwe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ti.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Kp.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ti.setMap(r.marker, n);
    });
  }
}
function MN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function DN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? MN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : MN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function gwe(e) {
  var t = f0e(), [n, r] = P(null);
  return h(() => {
    if (t && n === null) {
      var o = new hwe(DN(DN({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function mwe(e) {
  var {
    children: t,
    options: n
  } = e, r = gwe(n);
  return r !== null ? t(r) : null;
}
ve(mwe);
var _N = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, jN = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function vwe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(It), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var B = new google.maps.InfoWindow(r);
    return v(B), R.current = document.createElement("div"), a && E(google.maps.event.addListener(B, "closeclick", a)), s && D(google.maps.event.addListener(B, "domready", s)), l && m(google.maps.event.addListener(B, "content_changed", l)), u && S(google.maps.event.addListener(B, "position_changed", u)), c && L(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(R.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(y, n) : B.getPosition() ? B.open(y) : bo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(B), B.close();
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(vwe);
class ywe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", null), xe(this, "state", {
      infoWindow: null
    }), xe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : bo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), xe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = cn({
      updaterMap: jN,
      eventMap: _N,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: jN,
      eventMap: _N,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (mn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
xe(ywe, "contextType", It);
function TN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Cv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var AN = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, IN = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, bwe = {};
function wwe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, D = ge(It), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && g && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", g)));
  }, [g]), h(() => {
    var T = new google.maps.Polyline(Cv(Cv({}, t || bwe), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && B(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && q(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), g && F(google.maps.event.addListener(T, "drag", g)), m(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(wwe);
class Cwe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      polyline: null
    }), xe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(Cv(Cv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: IN,
      eventMap: AN,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: IN,
      eventMap: AN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), mn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Cwe, "contextType", It);
function BN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function NN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? BN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : BN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var RN = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, FN = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Owe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(It), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof g == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", g)));
  }, [g]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(NN(NN({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), g && F(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), S(A), w && w(A), () => {
      z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), D && D(A), A.setMap(null);
    };
  }, []), null;
}
ve(Owe);
class xwe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = cn({
      updaterMap: FN,
      eventMap: RN,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: FN,
      eventMap: RN,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), mn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
xe(xwe, "contextType", It);
function zN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ov(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? zN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : zN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var UN = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, WN = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Ewe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(It), [m, C] = P(null), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), z(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", g)));
  }, [g]), h(() => {
    m && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(m, "bounds_changed", E)));
  }, [E]), h(() => {
    var G = new google.maps.Rectangle(Ov(Ov({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && G.setVisible(i), typeof o < "u" && G.setEditable(o), typeof r < "u" && G.setDraggable(r), typeof n < "u" && G.setBounds(n), a && z(google.maps.event.addListener(G, "dblclick", a)), s && R(google.maps.event.addListener(G, "dragend", s)), l && H(google.maps.event.addListener(G, "dragstart", l)), u && W(google.maps.event.addListener(G, "mousedown", u)), c && Y(google.maps.event.addListener(G, "mousemove", c)), p && ee(google.maps.event.addListener(G, "mouseout", p)), d && k(google.maps.event.addListener(G, "mouseover", d)), y && U(google.maps.event.addListener(G, "mouseup", y)), f && $(google.maps.event.addListener(G, "rightclick", f)), v && j(google.maps.event.addListener(G, "click", v)), g && T(google.maps.event.addListener(G, "drag", g)), E && A(google.maps.event.addListener(G, "bounds_changed", E)), C(G), w && w(G), () => {
      S !== null && google.maps.event.removeListener(S), L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), D && D(G), G.setMap(null);
    };
  }, []), null;
}
ve(Ewe);
class Lwe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      rectangle: null
    }), xe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Ov(Ov({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: WN,
      eventMap: UN,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: WN,
      eventMap: UN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), mn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Lwe, "contextType", It);
function $N(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $N(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $N(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var HN = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, VN = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Pwe = {};
function kwe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(It), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", g)));
  }, [g]), h(() => {
    S && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(S, "drag", E)));
  }, [E]), h(() => {
    S && w && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(S, "center_changed", w)));
  }, [g]), h(() => {
    S && D && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(xv(xv({}, t || Pwe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && R(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && Y(google.maps.event.addListener(oe, "mousedown", c)), p && ee(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), y && U(google.maps.event.addListener(oe, "mouseover", y)), f && $(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), g && T(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && N(google.maps.event.addListener(oe, "center_changed", w)), D && fe(google.maps.event.addListener(oe, "radius_changed", D)), z(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(kwe);
class Swe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      circle: null
    }), xe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(xv(xv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: VN,
      eventMap: HN,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: VN,
      eventMap: HN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), mn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
xe(Swe, "contextType", It);
function ZN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ev(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qN = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, KN = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Mwe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: g
  } = e, E = ge(It), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Ev(Ev({}, t), {}, {
        map: E
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && B(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && Z(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), g && g(w), w.setMap(null));
    };
  }, []), null;
}
ve(Mwe);
class Dwe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      data: null
    }), xe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Ev(Ev({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = cn({
        updaterMap: KN,
        eventMap: qN,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: KN,
      eventMap: qN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), mn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Dwe, "contextType", It);
function GN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function YN(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var XN = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, JN = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class _we extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      kmlLayer: null
    }), xe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(YN(YN({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: JN,
      eventMap: XN,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: JN,
      eventMap: XN,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), mn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(_we, "contextType", It);
function AZ(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function jwe(e, t) {
  return new t(e.lat, e.lng);
}
function Twe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function Awe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Iwe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Bwe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function Nwe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function IZ(e, t, n, r) {
  return n !== void 0 ? Bwe(e, t, Iwe(n, google.maps.LatLngBounds, Twe)) : Nwe(e, t, Awe(r, google.maps.LatLng, jwe));
}
function Rwe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function QN(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fwe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QN(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QN(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function zwe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Fwe({}, this.container ? AZ(this.container, o) : {
        x: 0,
        y: 0
      }), u = IZ(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function eR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Uwe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function tR(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function nR(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Wwe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(It), c = On(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = On(() => zwe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
ve(Wwe);
class Oc extends pe {
  constructor(t) {
    super(t), xe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), xe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      bo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), xe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), xe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = Uwe({
        x: 0,
        y: 0
      }, this.containerRef.current ? AZ(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = IZ(r, o, this.props.bounds, this.props.position);
      if (!Rwe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), xe(this, "draw", () => {
      this.onPositionElement();
    }), xe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = ir();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = tR(t.position), r = tR(this.props.position), o = nR(t.bounds), i = nR(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(ai.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
xe(Oc, "FLOAT_PANE", "floatPane");
xe(Oc, "MAP_PANE", "mapPane");
xe(Oc, "MARKER_LAYER", "markerLayer");
xe(Oc, "OVERLAY_LAYER", "overlayLayer");
xe(Oc, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
xe(Oc, "contextType", It);
function $we() {
}
function rR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iR = {
  onDblClick: "dblclick",
  onClick: "click"
}, sR = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Hwe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(It), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = On(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(Hwe);
class BZ extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      groundOverlay: null
    }), xe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    bo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, oR(oR({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: sR,
      eventMap: iR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: sR,
      eventMap: iR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
xe(BZ, "defaultProps", {
  onLoad: $we
});
xe(BZ, "contextType", It);
function aR(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Lv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aR(Object(n), !0).forEach(function(r) {
      xe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aR(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var lR = {}, uR = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Vwe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(It), [a, s] = P(null);
  return h(() => {
    google.maps.visualization || bo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    bo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Lv(Lv({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(Vwe);
class Zwe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      heatmapLayer: null
    }), xe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    bo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), bo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Lv(Lv({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = cn({
      updaterMap: uR,
      eventMap: lR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: uR,
      eventMap: lR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), mn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Zwe, "contextType", It);
var cR = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, pR = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class qwe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      streetViewPanorama: null
    }), xe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = cn({
      updaterMap: pR,
      eventMap: cR,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: pR,
      eventMap: cR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), mn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
xe(qwe, "contextType", It);
class Kwe extends pe {
  constructor() {
    super(...arguments), xe(this, "state", {
      streetViewService: null
    }), xe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
xe(Kwe, "contextType", It);
var dR = {
  onDirectionsChanged: "directions_changed"
}, fR = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class Gwe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "state", {
      directionsRenderer: null
    }), xe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = cn({
      updaterMap: fR,
      eventMap: dR,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: fR,
      eventMap: dR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), mn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
xe(Gwe, "contextType", It);
var hR = {
  onPlacesChanged: "places_changed"
}, gR = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class Ywe extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", ir()), xe(this, "state", {
      searchBox: null
    }), xe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (bo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = cn({
          updaterMap: gR,
          eventMap: hR,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: gR,
      eventMap: hR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), mn(this.registeredEvents));
  }
  render() {
    return ai.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
xe(Ywe, "contextType", It);
var mR = {
  onPlaceChanged: "place_changed"
}, vR = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class NZ extends pe {
  constructor() {
    super(...arguments), xe(this, "registeredEvents", []), xe(this, "containerElement", ir()), xe(this, "state", {
      autocomplete: null
    }), xe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    bo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = cn({
        updaterMap: vR,
        eventMap: mR,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    mn(this.registeredEvents), this.registeredEvents = cn({
      updaterMap: vR,
      eventMap: mR,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && mn(this.registeredEvents);
  }
  render() {
    return ai.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
xe(NZ, "defaultProps", {
  className: ""
});
xe(NZ, "contextType", It);
let Xwe = { data: "" }, Jwe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || Xwe, Qwe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, e1e = /\/\*[^]*?\*\/|  +/g, yR = /\n+/g, tl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? tl(a, i) : i + "{" + tl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += tl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += tl.p ? tl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ks = {}, RZ = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + RZ(e[n]);
    return t;
  }
  return e;
}, t1e = (e, t, n, r, o) => {
  let i = RZ(e), a = Ks[i] || (Ks[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ks[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = Qwe.exec(u.replace(e1e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(yR, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(yR, " ").trim();
      return d[0];
    })(e);
    Ks[a] = tl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ks.g ? Ks.g : null;
  return n && (Ks.g = Ks[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ks[a], t, r, s), a;
}, n1e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : tl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function x0(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return t1e(n.unshift ? n.raw ? n1e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Jwe(t.target), t.g, t.o, t.k);
}
let FZ, hE, gE;
x0.bind({ g: 1 });
let ua = x0.bind({ k: 1 });
function r1e(e, t, n, r) {
  tl.p = t, FZ = e, hE = n, gE = r;
}
function kl(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: hE && hE() }, s), n.o = / *go\d+/.test(l), s.className = x0.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), gE && u[0] && gE(s), FZ(u, s);
    }
    return o;
  };
}
var o1e = (e) => typeof e == "function", i1e = (e, t) => o1e(e) ? e(t) : e, s1e = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), a1e = ua`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, l1e = ua`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, u1e = ua`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, c1e = kl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${a1e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${l1e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${u1e} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, p1e = ua`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, d1e = kl("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${p1e} 1s linear infinite;
`, f1e = ua`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, h1e = ua`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, g1e = kl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${f1e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${h1e} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, m1e = kl("div")`
  position: absolute;
`, v1e = kl("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, y1e = ua`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, b1e = kl("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${y1e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, w1e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Re.createElement(b1e, null, t) : t : n === "blank" ? null : Re.createElement(v1e, null, Re.createElement(d1e, { ...r }), n !== "loading" && Re.createElement(m1e, null, n === "error" ? Re.createElement(c1e, { ...r }) : Re.createElement(g1e, { ...r })));
}, C1e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, O1e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, x1e = "0%{opacity:0;} 100%{opacity:1;}", E1e = "0%{opacity:1;} 100%{opacity:0;}", L1e = kl("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, P1e = kl("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, k1e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = s1e() ? [x1e, E1e] : [C1e(n), O1e(n)];
  return { animation: t ? `${ua(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ua(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Re.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? k1e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Re.createElement(w1e, { toast: e }), a = Re.createElement(P1e, { ...e.ariaProps }, i1e(e.message, e));
  return Re.createElement(L1e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Re.createElement(Re.Fragment, null, i, a));
});
r1e(Re.createElement);
x0`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ye({});
function S1e(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const M1e = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
S1e(M1e.CNPJ).length;
ga((e, t) => /* @__PURE__ */ si.jsx("input", { ref: t, ...e }));
Ye({});
var ya = {};
Object.defineProperty(ya, "__esModule", {
  value: !0
});
var D1e = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), A1 = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, zZ = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: D1e ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, qk = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var ng = 1; ng < 20; ng++)
  qk["f" + ng] = 111 + ng;
function E0(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return UZ(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return WZ(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function _1e(e, t) {
  return E0(e, t);
}
function j1e(e, t) {
  return E0(e, { byKey: !0 }, t);
}
function UZ(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in A1)
    r[A1[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = Kk(d), v = A1[f];
      if (d.length > 1 && !v && !zZ[d] && !qk[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = $Z(d)), v && (r[v] = y ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function WZ(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function $Z(e) {
  e = Kk(e);
  var t = qk[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function Kk(e) {
  return e = e.toLowerCase(), e = zZ[e] || e, e;
}
ya.default = E0;
var I1 = ya.isHotkey = E0;
ya.isCodeHotkey = _1e;
ya.isKeyHotkey = j1e;
ya.parseHotkey = UZ;
ya.compareHotkey = WZ;
ya.toKeyCode = $Z;
ya.toKeyName = Kk;
var T1e = typeof nr == "object" && nr && nr.Object === Object && nr, A1e = T1e, I1e = A1e, B1e = typeof self == "object" && self && self.Object === Object && self, N1e = I1e || B1e || Function("return this")(), R1e = N1e, F1e = R1e, z1e = F1e.Symbol, HZ = z1e, bR = HZ;
bR && bR.toStringTag;
var wR = HZ;
wR && wR.toStringTag;
var CR;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(CR || (CR = {}));
var Gk = function(e) {
  return Object.freeze(e);
}, U1e = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Gk(this);
  }
  return e;
}(), W1e = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Gk(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), OR = typeof window < "u" ? window : {};
/msie|trident/i.test(OR.navigator && OR.navigator.userAgent);
var B1 = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new U1e((n ? t : e) || 0, (n ? e : t) || 0);
};
Gk({
  devicePixelContentBoxSize: B1(),
  borderBoxSize: B1(),
  contentBoxSize: B1(),
  contentRect: new W1e(0, 0, 0, 0)
});
function Fd(e) {
  "@babel/helpers - typeof";
  return Fd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Fd(e);
}
function $1e(e, t) {
  if (Fd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Fd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function H1e(e) {
  var t = $1e(e, "string");
  return Fd(t) === "symbol" ? t : String(t);
}
function Gp(e, t, n) {
  return t = H1e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var V1e = /* @__PURE__ */ Ye(null), N1, R1;
parseInt(Ce.version.split(".")[0], 10);
var xR = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), F1 = typeof navigator < "u" && /Android/.test(navigator.userAgent), rg = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Z1e = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (N1 = navigator.userAgent.match(/Version\/(\d+)/)) !== null && N1 !== void 0 && N1[1] && parseInt((R1 = navigator.userAgent.match(/Version\/(\d+)/)) === null || R1 === void 0 ? void 0 : R1[1], 10) < 17;
var q1e = /* @__PURE__ */ new WeakMap(), K1e = /* @__PURE__ */ new WeakMap(), G1e = /* @__PURE__ */ new WeakMap(), Y1e = /* @__PURE__ */ new WeakMap(), X1e = /* @__PURE__ */ new WeakMap(), ER = /* @__PURE__ */ new WeakMap(), J1e = /* @__PURE__ */ new WeakMap(), LR = /* @__PURE__ */ new WeakMap(), og = /* @__PURE__ */ new WeakMap(), Q1e = /* @__PURE__ */ new WeakMap(), eCe = /* @__PURE__ */ new WeakMap(), tCe = /* @__PURE__ */ new WeakMap(), VZ = globalThis.Node, nCe = globalThis.Text, ZZ = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, rCe = (e) => Pv(e) && e.nodeType === 8, Ss = (e) => Pv(e) && e.nodeType === 1, Pv = (e) => {
  var t = ZZ(e);
  return !!t && e instanceof t.Node;
}, PR = (e) => {
  var t = e && e.anchorNode && ZZ(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, oCe = (e) => {
  var [t, n] = e;
  if (Ss(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = qZ(t, o, r ? "backward" : "forward"), r = o < n; Ss(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = sCe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, iCe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, qZ = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (rCe(o) || Ss(o) && o.childNodes.length === 0 || Ss(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, sCe = (e, t, n) => {
  var [r] = qZ(e, t, n);
  return r;
}, kR = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), KZ = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ss(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = on.getWindow(e);
  if (o.contains(r))
    return on.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : KZ(e, i, n);
}, SR = (e, t) => !!(e.compareDocumentPosition(t) & VZ.DOCUMENT_POSITION_PRECEDING), aCe = (e, t) => !!(e.compareDocumentPosition(t) & VZ.DOCUMENT_POSITION_FOLLOWING), lCe = 0;
class uCe {
  constructor() {
    Gp(this, "id", void 0), this.id = "".concat(lCe++);
  }
}
var on = {
  androidPendingDiffs: (e) => tCe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = eCe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = on.toDOMNode(e, e), n = on.findDocumentOrShadowRoot(e);
    og.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = on.findDocumentOrShadowRoot(e), r = kR(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Zm.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = on.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = on.toSlateNode(e, t.target), a = on.findPath(e, i);
    if (ra.isElement(i) && Gn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Gn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Gn.before(e, u) : Gn.after(e, u);
      if (c) {
        var p = Gn.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = on.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = on.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = ER.get(t);
    return n || (n = new uCe(), ER.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = K1e.get(r);
      if (o == null) {
        if (Gn.isEditor(r))
          return n;
        break;
      }
      var i = q1e.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Mi.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!og.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          on.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = on.toDOMNode(e, e), r = on.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = kR(r), i = on.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Zm.select(e, Gn.start(e, [])), og.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = G1e.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = on.toDOMNode(e, e), i;
    try {
      i = Ss(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Pv(t) && on.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Gn.hasPath(e, n.path) && Gn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => on.hasEditableTarget(e, t) || on.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Pv(t) && on.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!Q1e.get(e),
  isFocused: (e) => !!og.get(e),
  isReadOnly: (e) => !!LR.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (LR.get(e)) return !1;
    var n = on.hasTarget(e, t) && on.toSlateNode(e, t);
    return ra.isElement(n) && Gn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = J1e.get(e), r = Gn.isEditor(t) ? Y1e.get(e) : n == null ? void 0 : n.get(on.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Mi.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Gn.node(e, t.path), r = on.toDOMNode(e, n), o;
    Gn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof nCe ? E : v,
            (g = v.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Mi.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Ht.isBackward(t), i = on.toDOMPoint(e, n), a = Ht.isCollapsed(t) ? i : on.toDOMPoint(e, r), s = on.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = Ss(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = Ss(p) ? p : p.parentElement, g = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ss(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? X1e.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : oCe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = on.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && y.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = on.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (F1 && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var z = v.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var R = z[L];
          if (on.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (E) {
        var B = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, W = [...B(H), ...B(H == null ? void 0 : H.nextElementSibling)];
          w = (V = W.find((M) => aCe(E, M))) !== null && V !== void 0 ? V : null;
        } else {
          var q, Y = [...B(H == null ? void 0 : H.previousElementSibling), ...B(H)];
          w = (q = Y.findLast((M) => SR(E, M))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      F1 && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      rg && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (F1 && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && on.hasDOMNode(e, X, {
        editable: !0
      })) {
        var ee = on.toSlateNode(e, X), {
          path: J,
          offset: k
        } = Gn.start(e, on.findPath(e, ee));
        return X.querySelector("[data-slate-leaf]") || (k = s), {
          path: J,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = on.toSlateNode(e, u), U = on.findPath(e, _);
    return {
      path: U,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = PR(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (PR(t)) {
        if (rg && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, g = C(f.children[d.startOffset]), E = C(v.children[y.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        Z1e && iCe(s) || rg ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    rg && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = on.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = SR(s, u) || s === u && c < l, x = p ? w : on.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Ht.isExpanded(m) && Ht.isForward(m) && Ss(u) && Gn.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = Gn.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, cCe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, pCe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, dCe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, _r = (e) => {
  var t = cCe[e], n = pCe[e], r = dCe[e], o = t && I1(t), i = n && I1(n), a = r && I1(r);
  return (s) => !!(o && o(s) || xR && i && i(s) || !xR && a && a(s));
};
_r("bold"), _r("compose"), _r("moveBackward"), _r("moveForward"), _r("deleteBackward"), _r("deleteForward"), _r("deleteLineBackward"), _r("deleteLineForward"), _r("deleteWordBackward"), _r("deleteWordForward"), _r("extendBackward"), _r("extendForward"), _r("extendLineBackward"), _r("extendLineForward"), _r("italic"), _r("moveLineBackward"), _r("moveLineForward"), _r("moveWordBackward"), _r("moveWordForward"), _r("redo"), _r("insertSoftBreak"), _r("splitBlock"), _r("transposeCharacter"), _r("undo");
var fCe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => KZ(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, hCe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class gCe extends $u {
  constructor() {
    super(...arguments), Gp(this, "context", null), Gp(this, "manager", null), Gp(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, hCe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = fCe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Gp(gCe, "contextType", V1e);
Ye({});
Ye({});
Ye({});
var co = {}, Yk = {}, ff = {}, hf = {}, GZ = "Expected a function", MR = NaN, mCe = "[object Symbol]", vCe = /^\s+|\s+$/g, yCe = /^[-+]0x[0-9a-f]+$/i, bCe = /^0b[01]+$/i, wCe = /^0o[0-7]+$/i, CCe = parseInt, OCe = typeof nr == "object" && nr && nr.Object === Object && nr, xCe = typeof self == "object" && self && self.Object === Object && self, ECe = OCe || xCe || Function("return this")(), LCe = Object.prototype, PCe = LCe.toString, kCe = Math.max, SCe = Math.min, z1 = function() {
  return ECe.Date.now();
};
function MCe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(GZ);
  t = DR(t) || 0, kv(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? kCe(DR(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, z = o;
    return r = o = void 0, u = C, a = e.apply(z, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, z = C - u, L = t - S;
    return p ? SCe(L, i - z) : L;
  }
  function g(C) {
    var S = C - l, z = C - u;
    return l === void 0 || S >= t || S < 0 || p && z >= i;
  }
  function E() {
    var C = z1();
    if (g(C))
      return w(C);
    s = setTimeout(E, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(z1());
  }
  function m() {
    var C = z1(), S = g(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), y(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function DCe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(GZ);
  return kv(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), MCe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function kv(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function _Ce(e) {
  return !!e && typeof e == "object";
}
function jCe(e) {
  return typeof e == "symbol" || _Ce(e) && PCe.call(e) == mCe;
}
function DR(e) {
  if (typeof e == "number")
    return e;
  if (jCe(e))
    return MR;
  if (kv(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = kv(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(vCe, "");
  var n = bCe.test(e);
  return n || wCe.test(e) ? CCe(e.slice(2), n ? 2 : 8) : yCe.test(e) ? MR : +e;
}
var TCe = DCe, gf = {};
Object.defineProperty(gf, "__esModule", {
  value: !0
});
gf.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), um.has(t) || um.set(t, /* @__PURE__ */ new Set());
  var o = um.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
gf.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), um.get(t).delete(n.name || t);
};
var um = /* @__PURE__ */ new Map();
Object.defineProperty(hf, "__esModule", {
  value: !0
});
var ACe = TCe, ICe = NCe(ACe), BCe = gf;
function NCe(e) {
  return e && e.__esModule ? e : { default: e };
}
var RCe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, ICe.default)(e, t);
}, Hr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = RCe(function(r) {
        Hr.scrollHandler(e);
      }, t);
      Hr.scrollSpyContainers.push(e), (0, BCe.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Hr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Hr.scrollSpyContainers[Hr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Hr.currentPositionX(e), Hr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Hr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Hr.scrollSpyContainers[Hr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Hr.currentPositionX(t), Hr.currentPositionY(t));
  },
  updateStates: function() {
    Hr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Hr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Hr.spySetState && Hr.spySetState.length && Hr.spySetState.indexOf(e) > -1 && Hr.spySetState.splice(Hr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Hr.scrollHandler);
  },
  update: function() {
    return Hr.scrollSpyContainers.forEach(function(e) {
      return Hr.scrollHandler(e);
    });
  }
};
hf.default = Hr;
var xc = {}, mf = {};
Object.defineProperty(mf, "__esModule", {
  value: !0
});
var FCe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, zCe = function() {
  return window.location.hash.replace(/^#/, "");
}, UCe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, WCe = function(e) {
  return getComputedStyle(e).position !== "static";
}, U1 = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, $Ce = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (WCe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = U1(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return U1(t, s).offsetTop - U1(e, s).offsetTop;
};
mf.default = {
  updateHash: FCe,
  getHash: zCe,
  filterElementInContainer: UCe,
  scrollOffset: $Ce
};
var L0 = {}, Xk = {};
Object.defineProperty(Xk, "__esModule", {
  value: !0
});
Xk.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Jk = {};
Object.defineProperty(Jk, "__esModule", {
  value: !0
});
var HCe = gf, VCe = ["mousedown", "mousewheel", "touchmove", "keydown"];
Jk.default = {
  subscribe: function(e) {
    return typeof document < "u" && VCe.forEach(function(t) {
      return (0, HCe.addPassiveEventListener)(document, t, e);
    });
  }
};
var vf = {};
Object.defineProperty(vf, "__esModule", {
  value: !0
});
var mE = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      mE.registered[e] = t;
    },
    remove: function(e) {
      mE.registered[e] = null;
    }
  }
};
vf.default = mE;
Object.defineProperty(L0, "__esModule", {
  value: !0
});
var ZCe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, qCe = mf;
P0(qCe);
var KCe = Xk, _R = P0(KCe), GCe = Jk, YCe = P0(GCe), XCe = vf, Cs = P0(XCe);
function P0(e) {
  return e && e.__esModule ? e : { default: e };
}
var YZ = function(e) {
  return _R.default[e.smooth] || _R.default.defaultEasing;
}, JCe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, QCe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, vE = function() {
  return QCe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), XZ = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, JZ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, QZ = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, eOe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, tOe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, nOe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Cs.default.registered.end && Cs.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    vE.call(window, i);
    return;
  }
  Cs.default.registered.end && Cs.default.registered.end(o.to, o.target, o.currentPosition);
}, Qk = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, yf = function(e, t, n, r) {
  t.data = t.data || XZ(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (YCe.default.subscribe(o), Qk(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? JZ(t) : QZ(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Cs.default.registered.end && Cs.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = JCe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = YZ(t), a = nOe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Cs.default.registered.begin && Cs.default.registered.begin(t.data.to, t.data.target), vE.call(window, a);
    }, t.delay);
    return;
  }
  Cs.default.registered.begin && Cs.default.registered.begin(t.data.to, t.data.target), vE.call(window, a);
}, k0 = function(e) {
  return e = ZCe({}, e), e.data = e.data || XZ(), e.absolute = !0, e;
}, rOe = function(e) {
  yf(0, k0(e));
}, oOe = function(e, t) {
  yf(e, k0(t));
}, iOe = function(e) {
  e = k0(e), Qk(e), yf(e.horizontal ? eOe(e) : tOe(e), e);
}, sOe = function(e, t) {
  t = k0(t), Qk(t);
  var n = t.horizontal ? JZ(t) : QZ(t);
  yf(e + n, t);
};
L0.default = {
  animateTopScroll: yf,
  getAnimationType: YZ,
  scrollToTop: rOe,
  scrollToBottom: iOe,
  scrollTo: oOe,
  scrollMore: sOe
};
Object.defineProperty(xc, "__esModule", {
  value: !0
});
var aOe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, lOe = mf, uOe = eS(lOe), cOe = L0, pOe = eS(cOe), dOe = vf, ig = eS(dOe);
function eS(e) {
  return e && e.__esModule ? e : { default: e };
}
var sg = {}, jR = void 0;
xc.default = {
  unmount: function() {
    sg = {};
  },
  register: function(e, t) {
    sg[e] = t;
  },
  unregister: function(e) {
    delete sg[e];
  },
  get: function(e) {
    return sg[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return jR = e;
  },
  getActiveLink: function() {
    return jR;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = aOe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = uOe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      ig.default.registered.begin && ig.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, ig.default.registered.end && ig.default.registered.end(e, n);
      return;
    }
    pOe.default.animateTopScroll(s, t, e, n);
  }
};
var yE = { exports: {} }, W1 = { exports: {} }, jn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var TR;
function fOe() {
  if (TR) return jn;
  TR = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return jn.AsyncMode = l, jn.ConcurrentMode = u, jn.ContextConsumer = s, jn.ContextProvider = a, jn.Element = t, jn.ForwardRef = c, jn.Fragment = r, jn.Lazy = f, jn.Memo = y, jn.Portal = n, jn.Profiler = i, jn.StrictMode = o, jn.Suspense = p, jn.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, jn.isConcurrentMode = x, jn.isContextConsumer = function(m) {
    return D(m) === s;
  }, jn.isContextProvider = function(m) {
    return D(m) === a;
  }, jn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, jn.isForwardRef = function(m) {
    return D(m) === c;
  }, jn.isFragment = function(m) {
    return D(m) === r;
  }, jn.isLazy = function(m) {
    return D(m) === f;
  }, jn.isMemo = function(m) {
    return D(m) === y;
  }, jn.isPortal = function(m) {
    return D(m) === n;
  }, jn.isProfiler = function(m) {
    return D(m) === i;
  }, jn.isStrictMode = function(m) {
    return D(m) === o;
  }, jn.isSuspense = function(m) {
    return D(m) === p;
  }, jn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === g || m.$$typeof === E || m.$$typeof === w || m.$$typeof === v);
  }, jn.typeOf = D, jn;
}
var Un = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var AR;
function hOe() {
  return AR || (AR = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === y || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === g || N.$$typeof === E || N.$$typeof === w || N.$$typeof === v);
    }
    function x(N) {
      if (typeof N == "object" && N !== null) {
        var ue = N.$$typeof;
        switch (ue) {
          case t:
            var fe = N.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var m = l, C = u, S = s, z = a, L = t, R = c, B = r, H = f, V = y, W = n, q = i, Y = o, X = p, ee = !1;
    function J(N) {
      return ee || (ee = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || x(N) === l;
    }
    function k(N) {
      return x(N) === u;
    }
    function _(N) {
      return x(N) === s;
    }
    function U(N) {
      return x(N) === a;
    }
    function M(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function $(N) {
      return x(N) === c;
    }
    function O(N) {
      return x(N) === r;
    }
    function j(N) {
      return x(N) === f;
    }
    function F(N) {
      return x(N) === y;
    }
    function T(N) {
      return x(N) === n;
    }
    function Z(N) {
      return x(N) === i;
    }
    function A(N) {
      return x(N) === o;
    }
    function G(N) {
      return x(N) === p;
    }
    Un.AsyncMode = m, Un.ConcurrentMode = C, Un.ContextConsumer = S, Un.ContextProvider = z, Un.Element = L, Un.ForwardRef = R, Un.Fragment = B, Un.Lazy = H, Un.Memo = V, Un.Portal = W, Un.Profiler = q, Un.StrictMode = Y, Un.Suspense = X, Un.isAsyncMode = J, Un.isConcurrentMode = k, Un.isContextConsumer = _, Un.isContextProvider = U, Un.isElement = M, Un.isForwardRef = $, Un.isFragment = O, Un.isLazy = j, Un.isMemo = F, Un.isPortal = T, Un.isProfiler = Z, Un.isStrictMode = A, Un.isSuspense = G, Un.isValidElementType = D, Un.typeOf = x;
  }()), Un;
}
var IR;
function eq() {
  return IR || (IR = 1, process.env.NODE_ENV === "production" ? W1.exports = fOe() : W1.exports = hOe()), W1.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var $1, BR;
function gOe() {
  if (BR) return $1;
  BR = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return $1 = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, $1;
}
var H1, NR;
function tS() {
  if (NR) return H1;
  NR = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return H1 = e, H1;
}
var RR, FR;
function tq() {
  return FR || (FR = 1, RR = Function.call.bind(Object.prototype.hasOwnProperty)), RR;
}
var V1, zR;
function mOe() {
  if (zR) return V1;
  zR = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = tS(), n = {}, r = tq();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, V1 = o, V1;
}
var Z1, UR;
function vOe() {
  if (UR) return Z1;
  UR = 1;
  var e = eq(), t = gOe(), n = tS(), r = tq(), o = mOe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Z1 = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var _ = k && (u && k[u] || k[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: z,
      oneOf: S,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(k, _) {
      return k === _ ? k !== 0 || 1 / k === 1 / _ : k !== k && _ !== _;
    }
    function v(k, _) {
      this.message = k, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function g(k) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, U = 0;
      function M(O, j, F, T, Z, A, G) {
        if (T = T || d, A = A || F, G !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + F;
            !_[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            U < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[ue] = !0, U++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + Z + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + Z + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : k(j, F, T, Z, A);
      }
      var $ = M.bind(null, !1);
      return $.isRequired = M.bind(null, !0), $;
    }
    function E(k) {
      function _(U, M, $, O, j, F) {
        var T = U[M], Z = Y(T);
        if (Z !== k) {
          var A = X(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return g(_);
    }
    function w() {
      return g(a);
    }
    function D(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var F = U[M];
        if (!Array.isArray(F)) {
          var T = Y(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var Z = 0; Z < F.length; Z++) {
          var A = k(F, Z, $, O, j + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(_);
    }
    function x() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!s(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(k);
    }
    function m() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!e.isValidElementType(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(k);
    }
    function C(k) {
      function _(U, M, $, O, j) {
        if (!(U[M] instanceof k)) {
          var F = k.name || d, T = J(U[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return g(_);
    }
    function S(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(U, M, $, O, j) {
        for (var F = U[M], T = 0; T < k.length; T++)
          if (f(F, k[T]))
            return null;
        var Z = JSON.stringify(k, function(A, G) {
          var N = X(G);
          return N === "symbol" ? String(G) : G;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + $ + "`, expected one of " + Z + "."));
      }
      return g(_);
    }
    function z(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var Z in F)
          if (r(F, Z)) {
            var A = k(F, Z, $, O, j + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(_);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < k.length; _++) {
        var U = k[_];
        if (typeof U != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ee(U) + " at index " + _ + "."
          ), a;
      }
      function M($, O, j, F, T) {
        for (var Z = [], A = 0; A < k.length; A++) {
          var G = k[A], N = G($, O, j, F, T, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && Z.push(N.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return g(M);
    }
    function R() {
      function k(_, U, M, $, O) {
        return W(_[U]) ? null : new v("Invalid " + $ + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return g(k);
    }
    function B(k, _, U, M, $) {
      return new v(
        (k || "React class") + ": " + _ + " type `" + U + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function H(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var Z in k) {
          var A = k[Z];
          if (typeof A != "function")
            return B($, O, j, Z, X(A));
          var G = A(F, Z, $, O, j + "." + Z, n);
          if (G)
            return G;
        }
        return null;
      }
      return g(_);
    }
    function V(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var Z = t({}, U[M], k);
        for (var A in Z) {
          var G = k[A];
          if (r(k, A) && typeof G != "function")
            return B($, O, j, A, X(G));
          if (!G)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(U[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = G(F, A, $, O, j + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return g(_);
    }
    function W(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(W);
          if (k === null || s(k))
            return !0;
          var _ = p(k);
          if (_) {
            var U = _.call(k), M;
            if (_ !== k.entries) {
              for (; !(M = U.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = U.next()).done; ) {
                var $ = M.value;
                if ($ && !W($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(k, _) {
      return k === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function Y(k) {
      var _ = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : q(_, k) ? "symbol" : _;
    }
    function X(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var _ = Y(k);
      if (_ === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function ee(k) {
      var _ = X(k);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, Z1;
}
var q1, WR;
function yOe() {
  if (WR) return q1;
  WR = 1;
  var e = tS();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, q1 = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, q1;
}
if (process.env.NODE_ENV !== "production") {
  var bOe = eq(), wOe = !0;
  yE.exports = vOe()(bOe.isElement, wOe);
} else
  yE.exports = yOe()();
var S0 = yE.exports, M0 = {};
Object.defineProperty(M0, "__esModule", {
  value: !0
});
var COe = mf, K1 = OOe(COe);
function OOe(e) {
  return e && e.__esModule ? e : { default: e };
}
var xOe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return K1.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && K1.default.getHash() !== e && K1.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
M0.default = xOe;
Object.defineProperty(ff, "__esModule", {
  value: !0
});
var ag = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, EOe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), LOe = Ce, $R = bf(LOe), POe = hf, lg = bf(POe), kOe = xc, SOe = bf(kOe), MOe = S0, jr = bf(MOe), DOe = M0, ka = bf(DOe);
function bf(e) {
  return e && e.__esModule ? e : { default: e };
}
function _Oe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function jOe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function TOe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var HR = {
  to: jr.default.string.isRequired,
  containerId: jr.default.string,
  container: jr.default.object,
  activeClass: jr.default.string,
  activeStyle: jr.default.object,
  spy: jr.default.bool,
  horizontal: jr.default.bool,
  smooth: jr.default.oneOfType([jr.default.bool, jr.default.string]),
  offset: jr.default.number,
  delay: jr.default.number,
  isDynamic: jr.default.bool,
  onClick: jr.default.func,
  duration: jr.default.oneOfType([jr.default.number, jr.default.func]),
  absolute: jr.default.bool,
  onSetActive: jr.default.func,
  onSetInactive: jr.default.func,
  ignoreCancelEvents: jr.default.bool,
  hashSpy: jr.default.bool,
  saveHashHistory: jr.default.bool,
  spyThrottle: jr.default.number
};
ff.default = function(e, t) {
  var n = t || SOe.default, r = function(i) {
    TOe(a, i);
    function a(s) {
      _Oe(this, a);
      var l = jOe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return EOe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          lg.default.isMounted(s) || lg.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (ka.default.isMounted() || ka.default.mount(n), ka.default.mapContainer(this.props.to, s)), lg.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        lg.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = ag({}, this.props.style, this.props.activeStyle) : l = ag({}, this.props.style);
        var u = ag({}, this.props);
        for (var c in HR)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, $R.default.createElement(e, u);
      }
    }]), a;
  }($R.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, ag({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(ka.default.isMounted() && !ka.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, g = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            g = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - g + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            x = z.top - C + s, m = x + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(m), y = L < Math.floor(x) || L >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && ka.default.getHash() === c) {
            var B = i.props.saveHashHistory, H = B === void 0 ? !1 : B;
            ka.default.changeHash("", H);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, W = V === void 0 ? !1 : V;
          i.props.hashSpy && ka.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = HR, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Yk, "__esModule", {
  value: !0
});
var AOe = Ce, VR = nq(AOe), IOe = ff, BOe = nq(IOe);
function nq(e) {
  return e && e.__esModule ? e : { default: e };
}
function NOe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ZR(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ROe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var FOe = function(e) {
  ROe(t, e);
  function t() {
    var n, r, o, i;
    NOe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = ZR(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return VR.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), ZR(o, i);
  }
  return t;
}(VR.default.Component);
Yk.default = (0, BOe.default)(FOe);
var nS = {};
Object.defineProperty(nS, "__esModule", {
  value: !0
});
var zOe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), UOe = Ce, qR = rq(UOe), WOe = ff, $Oe = rq(WOe);
function rq(e) {
  return e && e.__esModule ? e : { default: e };
}
function HOe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function VOe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ZOe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var qOe = function(e) {
  ZOe(t, e);
  function t() {
    return HOe(this, t), VOe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return zOe(t, [{
    key: "render",
    value: function() {
      return qR.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(qR.default.Component);
nS.default = (0, $Oe.default)(qOe);
var rS = {}, D0 = {};
Object.defineProperty(D0, "__esModule", {
  value: !0
});
var KOe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, GOe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), YOe = Ce, KR = _0(YOe), XOe = pl;
_0(XOe);
var JOe = xc, GR = _0(JOe), QOe = S0, YR = _0(QOe);
function _0(e) {
  return e && e.__esModule ? e : { default: e };
}
function exe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function txe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function nxe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
D0.default = function(e) {
  var t = function(n) {
    nxe(r, n);
    function r(o) {
      exe(this, r);
      var i = txe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return GOe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        GR.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        GR.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return KR.default.createElement(e, KOe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(KR.default.Component);
  return t.propTypes = {
    name: YR.default.string,
    id: YR.default.string
  }, t;
};
Object.defineProperty(rS, "__esModule", {
  value: !0
});
var XR = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, rxe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), oxe = Ce, JR = oS(oxe), ixe = D0, sxe = oS(ixe), axe = S0, QR = oS(axe);
function oS(e) {
  return e && e.__esModule ? e : { default: e };
}
function lxe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function uxe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function cxe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var oq = function(e) {
  cxe(t, e);
  function t() {
    return lxe(this, t), uxe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return rxe(t, [{
    key: "render",
    value: function() {
      var n = this, r = XR({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, JR.default.createElement(
        "div",
        XR({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(JR.default.Component);
oq.propTypes = {
  name: QR.default.string,
  id: QR.default.string
};
rS.default = (0, sxe.default)(oq);
var G1 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, eF = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function tF(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function nF(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function rF(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ug = Ce, Rl = hf, Y1 = xc, Xr = S0, Sa = M0, oF = {
  to: Xr.string.isRequired,
  containerId: Xr.string,
  container: Xr.object,
  activeClass: Xr.string,
  spy: Xr.bool,
  smooth: Xr.oneOfType([Xr.bool, Xr.string]),
  offset: Xr.number,
  delay: Xr.number,
  isDynamic: Xr.bool,
  onClick: Xr.func,
  duration: Xr.oneOfType([Xr.number, Xr.func]),
  absolute: Xr.bool,
  onSetActive: Xr.func,
  onSetInactive: Xr.func,
  ignoreCancelEvents: Xr.bool,
  hashSpy: Xr.bool,
  spyThrottle: Xr.number
}, pxe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Y1, r = function(i) {
      rF(a, i);
      function a(s) {
        tF(this, a);
        var l = nF(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return eF(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Rl.isMounted(s) || Rl.mount(s, this.props.spyThrottle), this.props.hashSpy && (Sa.isMounted() || Sa.mount(n), Sa.mapContainer(this.props.to, s)), this.props.spy && Rl.addStateHandler(this.stateHandler), Rl.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Rl.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = G1({}, this.props);
          for (var u in oF)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, ug.createElement(e, l);
        }
      }]), a;
    }(ug.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, G1({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Sa.isMounted() && !Sa.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, g = v >= Math.floor(c) && v < Math.floor(p), E = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Sa.getHash() === l && Sa.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Rl.updateStates();
          if (g && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Sa.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Rl.updateStates();
        }
      };
    };
    return r.propTypes = oF, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      rF(r, n);
      function r(o) {
        tF(this, r);
        var i = nF(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return eF(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Y1.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Y1.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return ug.createElement(e, G1({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(ug.Component);
    return t.propTypes = {
      name: Xr.string,
      id: Xr.string
    }, t;
  }
}, dxe = pxe;
Object.defineProperty(co, "__esModule", {
  value: !0
});
co.Helpers = co.ScrollElement = co.ScrollLink = co.animateScroll = co.scrollSpy = co.Events = co.scroller = co.Element = co.Button = co.Link = void 0;
var fxe = Yk, iq = Is(fxe), hxe = nS, sq = Is(hxe), gxe = rS, aq = Is(gxe), mxe = xc, lq = Is(mxe), vxe = vf, uq = Is(vxe), yxe = hf, cq = Is(yxe), bxe = L0, pq = Is(bxe), wxe = ff, dq = Is(wxe), Cxe = D0, fq = Is(Cxe), Oxe = dxe, hq = Is(Oxe);
function Is(e) {
  return e && e.__esModule ? e : { default: e };
}
co.Link = iq.default;
co.Button = sq.default;
co.Element = aq.default;
co.scroller = lq.default;
co.Events = uq.default;
co.scrollSpy = cq.default;
co.animateScroll = pq.default;
co.ScrollLink = dq.default;
co.ScrollElement = fq.default;
co.Helpers = hq.default;
co.default = { Link: iq.default, Button: sq.default, Element: aq.default, scroller: lq.default, Events: uq.default, scrollSpy: cq.default, animateScroll: pq.default, ScrollLink: dq.default, ScrollElement: fq.default, Helpers: hq.default };
Ye({});
Ye({});
Ye({});
function zd(e) {
  "@babel/helpers - typeof";
  return zd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, zd(e);
}
function xxe(e, t) {
  if (zd(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (zd(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function Exe(e) {
  var t = xxe(e, "string");
  return zd(t) == "symbol" ? t : t + "";
}
function Ee(e, t, n) {
  return (t = Exe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function gq(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var X1, iF;
function Lxe() {
  if (iF) return X1;
  iF = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return X1 = t, X1;
}
var Pxe = Lxe(), wo = /* @__PURE__ */ gq(Pxe), Bt = Ye(null);
function kxe() {
  wo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Bt);
  return wo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Sxe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Mxe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function Dxe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return Mxe(e, i), o;
}
function _xe(e, t, n) {
  var r = Sxe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function jxe(e) {
  google.maps.event.removeListener(e);
}
function vn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(jxe);
}
function pn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = _xe(o, i, n);
  return Dxe(t, r, o, i), a;
}
function Txe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = P(null), S = dt(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null), [A, G] = P(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && g && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(m, "mouseup", g)));
  }, [g]), h(() => {
    m && E && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", E)));
  }, [E]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), G(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var N = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(N), N !== null && D && D(N), () => {
      N !== null && x && x(N);
    };
  }, []), si.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: si.jsx(Bt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
ve(Txe);
function sF(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function mq(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        sF(i, r, o, a, s, "next", l);
      }
      function s(l) {
        sF(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function vq(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return wo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var du = typeof document < "u";
function yq(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return du ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function aF(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function bq() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return aF(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return aF(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var ep = !1;
function wq() {
  return si.jsx("div", {
    children: "Loading..."
  });
}
var bE = {
  id: "script-loader",
  version: "weekly"
};
class Axe extends pe {
  constructor() {
    super(...arguments), Ee(this, "check", ir()), Ee(this, "state", {
      loaded: !1
    }), Ee(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Ee(this, "isCleaningUp", /* @__PURE__ */ mq(function* () {
      function t(n) {
        if (!ep)
          n();
        else if (du)
          var r = window.setInterval(function() {
            ep || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Ee(this, "cleanup", () => {
      ep = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Ee(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && bq(), wo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: vq(this.props)
      };
      yq(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (du) {
      if (window.google && window.google.maps && !ep) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), du && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (du) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, ep = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return si.jsxs(si.Fragment, {
      children: [si.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || si.jsx(wq, {})]
    });
  }
}
Ee(Axe, "defaultProps", bE);
function Ixe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function iS(e, t) {
  if (e == null) return {};
  var n, r, o = Ixe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var lF;
function Bxe(e) {
  var {
    id: t = bE.id,
    version: n = bE.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = dt(!1), [f, v] = P(!1), [g, E] = P(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    du && u && bq();
  }, [u]), h(function() {
    f && wo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = vq({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!du)
      return;
    function x() {
      y.current && (v(!0), lF = w);
    }
    if (window.google && window.google.maps && lF === w) {
      x();
      return;
    }
    yq({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && E(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = dt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var Nxe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], Rxe = si.jsx(wq, {});
function Fxe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = iS(e, Nxe), {
    isLoaded: s,
    loadError: l
  } = Bxe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || Rxe;
}
ve(Fxe);
var uF;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(uF || (uF = {}));
function cF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? cF(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : cF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var pF = {}, dF = {
  options(e, t) {
    e.setOptions(t);
  }
};
function zxe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Bt), [i, a] = P(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Sv(Sv({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(zxe);
class Uxe extends pe {
  constructor() {
    super(...arguments), Ee(this, "state", {
      trafficLayer: null
    }), Ee(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Ee(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Sv(Sv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: dF,
      eventMap: pF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: dF,
      eventMap: pF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), vn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(Uxe, "contextType", Bt);
function Wxe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Bt), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(Wxe);
class $xe extends pe {
  constructor() {
    super(...arguments), Ee(this, "state", {
      bicyclingLayer: null
    }), Ee(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ee($xe, "contextType", Bt);
function Hxe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Bt), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(Hxe);
class Vxe extends pe {
  constructor() {
    super(...arguments), Ee(this, "state", {
      transitLayer: null
    }), Ee(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(Vxe, "contextType", Bt);
function fF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fF(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var hF = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, gF = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Zxe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Bt), [d, y] = P(null), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    wo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(Mv(Mv({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && E(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && L(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(Zxe);
class qxe extends pe {
  constructor(t) {
    super(t), Ee(this, "registeredEvents", []), Ee(this, "state", {
      drawingManager: null
    }), Ee(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), wo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Mv(Mv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: gF,
      eventMap: hF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: gF,
      eventMap: hF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), vn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(qxe, "contextType", Bt);
function mF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mF(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vF = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, yF = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Dv = {};
function Kxe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: R,
    onClickableChanged: B,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: W,
    onFlatChanged: q,
    onIconChanged: Y,
    onPositionChanged: X,
    onShapeChanged: ee,
    onTitleChanged: J,
    onVisibleChanged: k,
    onZindexChanged: _,
    onLoad: U,
    onUnmount: M
  } = e, $ = ge(Bt), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null), [oe, Ie] = P(null), [qe, Ge] = P(null), [Be, et] = P(null), [Xe, Me] = P(null), [Je, at] = P(null), [Se, _e] = P(null), [Ae, Ve] = P(null), [Ne, nt] = P(null), [we, mt] = P(null), [ot, st] = P(null), [ut, vt] = P(null), [ct, yt] = P(null), [Qe, ft] = P(null), [tt, bt] = P(null), [pt, Dt] = P(null), [wt, _t] = P(null), [Ct, jt] = P(null);
  h(() => {
    O !== null && O.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ie(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (qe !== null && google.maps.event.removeListener(qe), Ge(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && z && (Be !== null && google.maps.event.removeListener(Be), et(google.maps.event.addListener(O, "mouseup", z)));
  }, [z]), h(() => {
    O && R && (Xe !== null && google.maps.event.removeListener(Xe), Me(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && E && (Je !== null && google.maps.event.removeListener(Je), at(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && D && (Se !== null && google.maps.event.removeListener(Se), _e(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && B && (Ae !== null && google.maps.event.removeListener(Ae), Ve(google.maps.event.addListener(O, "clickable_changed", B)));
  }, [B]), h(() => {
    O && H && (Ne !== null && google.maps.event.removeListener(Ne), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), h(() => {
    O && V && (we !== null && google.maps.event.removeListener(we), mt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && W && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && q && (ut !== null && google.maps.event.removeListener(ut), vt(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), h(() => {
    O && Y && (ct !== null && google.maps.event.removeListener(ct), yt(google.maps.event.addListener(O, "icon_changed", Y)));
  }, [Y]), h(() => {
    O && X && (Qe !== null && google.maps.event.removeListener(Qe), ft(google.maps.event.addListener(O, "position_changed", X)));
  }, [X]), h(() => {
    O && ee && (tt !== null && google.maps.event.removeListener(tt), bt(google.maps.event.addListener(O, "shape_changed", ee)));
  }, [ee]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Dt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && k && (wt !== null && google.maps.event.removeListener(wt), _t(google.maps.event.addListener(O, "visible_changed", k)));
  }, [k]), h(() => {
    O && _ && (Ct !== null && google.maps.event.removeListener(Ct), jt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var ht = Yu(Yu(Yu({}, n || Dv), r ? Dv : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof y < "u" && re.setOpacity(y), f && re.setShape(f), typeof v == "string" && re.setTitle(v), typeof g == "number" && re.setZIndex(g), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), m && N(google.maps.event.addListener(re, "dragstart", m)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ie(google.maps.event.addListener(re, "mouseout", C)), S && Ge(google.maps.event.addListener(re, "mouseover", S)), z && et(google.maps.event.addListener(re, "mouseup", z)), R && Me(google.maps.event.addListener(re, "rightclick", R)), E && at(google.maps.event.addListener(re, "click", E)), D && _e(google.maps.event.addListener(re, "drag", D)), B && Ve(google.maps.event.addListener(re, "clickable_changed", B)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && mt(google.maps.event.addListener(re, "animation_changed", V)), W && st(google.maps.event.addListener(re, "draggable_changed", W)), q && vt(google.maps.event.addListener(re, "flat_changed", q)), Y && yt(google.maps.event.addListener(re, "icon_changed", Y)), X && ft(google.maps.event.addListener(re, "position_changed", X)), ee && bt(google.maps.event.addListener(re, "shape_changed", ee)), J && Dt(google.maps.event.addListener(re, "title_changed", J)), k && _t(google.maps.event.addListener(re, "visible_changed", k)), _ && jt(google.maps.event.addListener(re, "zindex_changed", _)), j(re), U && U(re), () => {
      F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), qe !== null && google.maps.event.removeListener(qe), Be !== null && google.maps.event.removeListener(Be), Xe !== null && google.maps.event.removeListener(Xe), Je !== null && google.maps.event.removeListener(Je), Ae !== null && google.maps.event.removeListener(Ae), Ne !== null && google.maps.event.removeListener(Ne), we !== null && google.maps.event.removeListener(we), ot !== null && google.maps.event.removeListener(ot), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), Qe !== null && google.maps.event.removeListener(Qe), pt !== null && google.maps.event.removeListener(pt), wt !== null && google.maps.event.removeListener(wt), Ct !== null && google.maps.event.removeListener(Ct), M && M(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Cn = On(() => i ? lt.map(i, (ht) => {
    if (!mi(ht))
      return ht;
    var re = ht;
    return vi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return si.jsx(si.Fragment, {
    children: Cn
  }) || null;
}
ve(Kxe);
class Gxe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return mq(function* () {
      var n = Yu(Yu(Yu({}, t.props.options || Dv), t.props.clusterer ? Dv : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = pn({
        updaterMap: yF,
        eventMap: vF,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: yF,
      eventMap: vF,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), vn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Ee(Gxe, "contextType", Bt);
var Yxe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), Xxe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Yxe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Jxe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var Qxe = 2e3, eEe = 500, tEe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", nEe = "png", rEe = [53, 56, 66, 78, 90], oEe = "cluster", Cq = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || tEe, this.imageExtension = r.imageExtension || nEe, this.imageSizes = r.imageSizes || rEe, this.calculator = r.calculator || Jxe, this.batchSize = r.batchSize || Qxe, this.batchSizeIE = r.batchSizeIE || eEe, this.clusterClass = r.clusterClass || oEe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new Xxe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function bF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function iEe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bF(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ns = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Ln = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, sEe = {};
function aEe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: z
  } = e, [L, R] = P(null), B = ge(Bt), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null);
  return h(() => {
    L && C && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(L, ns.onMouseOut, C)));
  }, [C]), h(() => {
    L && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(L, ns.onMouseOver, m)));
  }, [m]), h(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, ns.onClick, w)));
  }, [w]), h(() => {
    L && D && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(L, ns.onClusteringBegin, D)));
  }, [D]), h(() => {
    L && x && (Y !== null && google.maps.event.removeListener(Y), q(google.maps.event.addListener(L, ns.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && Ln.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Ln.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Ln.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Ln.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Ln.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Ln.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Ln.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Ln.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Ln.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Ln.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof y < "u" && L !== null && Ln.maxZoom(L, y);
  }, [L, y]), h(() => {
    typeof f < "u" && L !== null && Ln.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof v < "u" && L !== null && Ln.styles(L, v);
  }, [L, v]), h(() => {
    typeof g < "u" && L !== null && Ln.title(L, g);
  }, [L, g]), h(() => {
    typeof E < "u" && L !== null && Ln.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (B) {
      var U = iEe({}, n || sEe), M = new Cq(B, [], U);
      return r && Ln.averageCenter(M, r), o && Ln.batchSizeIE(M, o), i && Ln.calculator(M, i), a && Ln.clusterClass(M, a), s && Ln.enableRetinaIcons(M, s), l && Ln.gridSize(M, l), u && Ln.ignoreHidden(M, u), c && Ln.imageExtension(M, c), p && Ln.imagePath(M, p), d && Ln.imageSizes(M, d), y && Ln.maxZoom(M, y), f && Ln.minimumClusterSize(M, f), v && Ln.styles(M, v), g && Ln.title(M, g), E && Ln.zoomOnClick(M, E), C && J(google.maps.event.addListener(M, ns.onMouseOut, C)), m && _(google.maps.event.addListener(M, ns.onMouseOver, m)), w && V(google.maps.event.addListener(M, ns.onClick, w)), D && q(google.maps.event.addListener(M, ns.onClusteringBegin, D)), x && X(google.maps.event.addListener(M, ns.onClusteringEnd, x)), R(M), S && S(M), () => {
        ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), z && z(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(aEe);
class lEe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      markerClusterer: null
    }), Ee(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new Cq(this.context, [], this.props.options);
      this.registeredEvents = pn({
        updaterMap: Ln,
        eventMap: ns,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: Ln,
      eventMap: ns,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), vn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Ee(lEe, "contextType", Bt);
function wF(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var Oq = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || wF(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, wF));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), g = v.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + y ? r = g.x + u - y : g.x + p + u + y > s && (r = g.x + p + u + y - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), uEe = ["position"], cEe = ["position"];
function CF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _v(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? CF(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : CF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var OF = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, xF = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, pEe = {};
function dEe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Bt), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var B = r || pEe, {
        position: H
      } = B, V = iS(B, uEe), W;
      H && !(H instanceof google.maps.LatLng) && (W = new google.maps.LatLng(H.lat, H.lng));
      var q = new Oq(_v(_v({}, V), W ? {
        position: W
      } : {}));
      R.current = document.createElement("div"), v(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && D(google.maps.event.addListener(q, "domready", s)), l && m(google.maps.event.addListener(q, "content_changed", l)), u && S(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(R.current), n ? q.open(y, n) : q.getPosition() ? q.open(y) : wo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(dEe);
class fEe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "containerElement", null), Ee(this, "state", {
      infoBox: null
    }), Ee(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : wo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Ee(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = iS(t, cEe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Oq(_v(_v({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = pn({
      updaterMap: xF,
      eventMap: OF,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: xF,
      eventMap: OF,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), vn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
Ee(fEe, "contextType", Bt);
var EF, LF;
function hEe() {
  return LF || (LF = 1, EF = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), EF;
}
var gEe = hEe(), PF = /* @__PURE__ */ gq(gEe), kF = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], J1 = 1, tp = 8;
class sS {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== J1)
      throw new Error("Got v".concat(o, " data when expected v").concat(J1, "."));
    var i = kF[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new sS(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = kF.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, tp, t), this.coords = new this.ArrayType(this.data, tp + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(tp + a + s + l), this.ids = new this.IndexArrayType(this.data, tp, t), this.coords = new this.ArrayType(this.data, tp + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (J1 << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return wE(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          SF(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], g = i[2 * f + 1];
      SF(v, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function wE(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    xq(e, t, a, r, o, i), wE(e, t, n, r, a - 1, 1 - i), wE(e, t, n, a + 1, o, 1 - i);
  }
}
function xq(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      xq(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (np(e, t, r, n), t[2 * o + i] > y && np(e, t, r, o); f < v; ) {
      for (np(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? np(e, t, r, v) : (v++, np(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function np(e, t, n, r) {
  Q1(e, n, r), Q1(t, 2 * n, 2 * r), Q1(t, 2 * n + 1, 2 * r + 1);
}
function Q1(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function SF(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var mEe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, MF = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Fl = 2, qa = 3, eC = 4, za = 5, Eq = 6;
class vEe {
  constructor(t) {
    this.options = Object.assign(Object.create(mEe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = MF(cg(u)), d = MF(pg(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(cg(r), pg(a), cg(i), pg(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + za] > 1 ? DF(p, f, this.clusterProps) : this.points[p[f + qa]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + eC] === t && p.push(a[y + za] > 1 ? DF(a, y, this.clusterProps) : this.points[a[y + qa]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new sS(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + za] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = Lq(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + qa]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = cg(f), d = pg(v);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + qa] : E = this.points[n[l + qa]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Fl] <= n)) {
        l[p + Fl] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + za], g = v;
        for (var E of f) {
          var w = E * c;
          l[w + Fl] > n && (g += l[w + za]);
        }
        if (g > v && g >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Fl] <= n)) {
              l[L + Fl] = n;
              var R = l[L + za];
              D += l[L] * R, x += l[L + 1] * R, l[L + eC] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, L)));
            }
          }
          l[p + eC] = S, u.push(D / g, x / g, 1 / 0, S, -1, g), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + Fl] <= n)) {
                l[V + Fl] = n;
                for (var W = 0; W < c; W++) u.push(l[V + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + za] > 1) {
      var o = this.clusterProps[t[n + Eq]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + qa]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function DF(e, t, n) {
  return {
    type: "Feature",
    id: e[t + qa],
    properties: Lq(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [yEe(e[t]), bEe(e[t + 1])]
    }
  };
}
function Lq(e, t, n) {
  var r = e[t + za], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + Eq], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + qa],
    point_count: r,
    point_count_abbreviated: o
  });
}
function cg(e) {
  return e / 360 + 0.5;
}
function pg(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function yEe(e) {
  return (e - 0.5) * 360;
}
function bEe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function wEe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ai {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class CE {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ai.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ai.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ai.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class CEe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return OEe(n);
  }
}
var OEe = (e) => {
  var t = e.map((n) => new CE({
    position: Ai.getPosition(n),
    markers: [n]
  }));
  return t;
};
class xEe extends CEe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = wEe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new vEe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!PF(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ai.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !PF(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new CE({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new CE({
      markers: [i],
      position: Ai.getPosition(i)
    });
  }
}
class EEe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class LEe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ai.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function PEe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class aS {
  constructor() {
    PEe(aS, google.maps.OverlayView);
  }
}
var Yp;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Yp || (Yp = {}));
var kEe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class SEe extends aS {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new xEe(o),
      renderer: a = new LEe(),
      onClusterClick: s = kEe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ai.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Yp.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ai.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ai.setMap(l, null)));
      }
      google.maps.event.trigger(this, Yp.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ai.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new EEe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ai.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Yp.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ai.setMap(r.marker, n);
    });
  }
}
function _F(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _F(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _F(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function MEe(e) {
  var t = kxe(), [n, r] = P(null);
  return h(() => {
    if (t && n === null) {
      var o = new SEe(jF(jF({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function DEe(e) {
  var {
    children: t,
    options: n
  } = e, r = MEe(n);
  return r !== null ? t(r) : null;
}
ve(DEe);
var TF = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, AF = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function _Ee(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Bt), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var B = new google.maps.InfoWindow(r);
    return v(B), R.current = document.createElement("div"), a && E(google.maps.event.addListener(B, "closeclick", a)), s && D(google.maps.event.addListener(B, "domready", s)), l && m(google.maps.event.addListener(B, "content_changed", l)), u && S(google.maps.event.addListener(B, "position_changed", u)), c && L(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(R.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(y, n) : B.getPosition() ? B.open(y) : wo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(B), B.close();
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(_Ee);
class jEe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "containerElement", null), Ee(this, "state", {
      infoWindow: null
    }), Ee(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : wo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Ee(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = pn({
      updaterMap: AF,
      eventMap: TF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: AF,
      eventMap: TF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (vn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
Ee(jEe, "contextType", Bt);
function IF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IF(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var BF = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, NF = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, TEe = {};
function AEe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, D = ge(Bt), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && g && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", g)));
  }, [g]), h(() => {
    var T = new google.maps.Polyline(jv(jv({}, t || TEe), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && B(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && q(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), g && F(google.maps.event.addListener(T, "drag", g)), m(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(AEe);
class IEe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      polyline: null
    }), Ee(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(jv(jv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: NF,
      eventMap: BF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: NF,
      eventMap: BF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), vn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(IEe, "contextType", Bt);
function RF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function FF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RF(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zF = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, UF = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function BEe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Bt), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof g == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", g)));
  }, [g]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(FF(FF({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), g && F(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), S(A), w && w(A), () => {
      z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), D && D(A), A.setMap(null);
    };
  }, []), null;
}
ve(BEe);
class NEe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = pn({
      updaterMap: UF,
      eventMap: zF,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: UF,
      eventMap: zF,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), vn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(NEe, "contextType", Bt);
function WF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Tv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WF(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $F = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, HF = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function REe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Bt), [m, C] = P(null), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), z(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", g)));
  }, [g]), h(() => {
    m && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(m, "bounds_changed", E)));
  }, [E]), h(() => {
    var G = new google.maps.Rectangle(Tv(Tv({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && G.setVisible(i), typeof o < "u" && G.setEditable(o), typeof r < "u" && G.setDraggable(r), typeof n < "u" && G.setBounds(n), a && z(google.maps.event.addListener(G, "dblclick", a)), s && R(google.maps.event.addListener(G, "dragend", s)), l && H(google.maps.event.addListener(G, "dragstart", l)), u && W(google.maps.event.addListener(G, "mousedown", u)), c && Y(google.maps.event.addListener(G, "mousemove", c)), p && ee(google.maps.event.addListener(G, "mouseout", p)), d && k(google.maps.event.addListener(G, "mouseover", d)), y && U(google.maps.event.addListener(G, "mouseup", y)), f && $(google.maps.event.addListener(G, "rightclick", f)), v && j(google.maps.event.addListener(G, "click", v)), g && T(google.maps.event.addListener(G, "drag", g)), E && A(google.maps.event.addListener(G, "bounds_changed", E)), C(G), w && w(G), () => {
      S !== null && google.maps.event.removeListener(S), L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), D && D(G), G.setMap(null);
    };
  }, []), null;
}
ve(REe);
class FEe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      rectangle: null
    }), Ee(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Tv(Tv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: HF,
      eventMap: $F,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: HF,
      eventMap: $F,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), vn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(FEe, "contextType", Bt);
function VF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Av(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? VF(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : VF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ZF = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, qF = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, zEe = {};
function UEe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Bt), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", g)));
  }, [g]), h(() => {
    S && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(S, "drag", E)));
  }, [E]), h(() => {
    S && w && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(S, "center_changed", w)));
  }, [g]), h(() => {
    S && D && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(Av(Av({}, t || zEe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && R(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && Y(google.maps.event.addListener(oe, "mousedown", c)), p && ee(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), y && U(google.maps.event.addListener(oe, "mouseover", y)), f && $(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), g && T(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && N(google.maps.event.addListener(oe, "center_changed", w)), D && fe(google.maps.event.addListener(oe, "radius_changed", D)), z(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(UEe);
class WEe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      circle: null
    }), Ee(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Av(Av({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: qF,
      eventMap: ZF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: qF,
      eventMap: ZF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), vn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Ee(WEe, "contextType", Bt);
function KF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Iv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KF(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GF = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, YF = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function $Ee(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: g
  } = e, E = ge(Bt), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Iv(Iv({}, t), {}, {
        map: E
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && B(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && Z(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), g && g(w), w.setMap(null));
    };
  }, []), null;
}
ve($Ee);
class HEe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      data: null
    }), Ee(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Iv(Iv({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = pn({
        updaterMap: YF,
        eventMap: GF,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: YF,
      eventMap: GF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), vn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(HEe, "contextType", Bt);
function XF(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function JF(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XF(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XF(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var QF = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, ez = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class VEe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      kmlLayer: null
    }), Ee(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(JF(JF({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: ez,
      eventMap: QF,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: ez,
      eventMap: QF,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), vn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(VEe, "contextType", Bt);
function Pq(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function ZEe(e, t) {
  return new t(e.lat, e.lng);
}
function qEe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function KEe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function GEe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function YEe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function XEe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function kq(e, t, n, r) {
  return n !== void 0 ? YEe(e, t, GEe(n, google.maps.LatLngBounds, qEe)) : XEe(e, t, KEe(r, google.maps.LatLng, ZEe));
}
function JEe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function tz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function QEe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tz(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function eLe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = QEe({}, this.container ? Pq(this.container, o) : {
        x: 0,
        y: 0
      }), u = kq(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function nz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tLe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nz(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function rz(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function oz(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function nLe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Bt), c = On(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = On(() => eLe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
ve(nLe);
class Ec extends pe {
  constructor(t) {
    super(t), Ee(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Ee(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      wo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Ee(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Ee(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = tLe({
        x: 0,
        y: 0
      }, this.containerRef.current ? Pq(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = kq(r, o, this.props.bounds, this.props.position);
      if (!JEe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Ee(this, "draw", () => {
      this.onPositionElement();
    }), Ee(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = ir();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = rz(t.position), r = rz(this.props.position), o = oz(t.bounds), i = oz(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(si.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
Ee(Ec, "FLOAT_PANE", "floatPane");
Ee(Ec, "MAP_PANE", "mapPane");
Ee(Ec, "MARKER_LAYER", "markerLayer");
Ee(Ec, "OVERLAY_LAYER", "overlayLayer");
Ee(Ec, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Ee(Ec, "contextType", Bt);
function rLe() {
}
function iz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function sz(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? iz(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : iz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var az = {
  onDblClick: "dblclick",
  onClick: "click"
}, lz = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function oLe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Bt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = On(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(oLe);
class Sq extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      groundOverlay: null
    }), Ee(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    wo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, sz(sz({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: lz,
      eventMap: az,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: lz,
      eventMap: az,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(Sq, "defaultProps", {
  onLoad: rLe
});
Ee(Sq, "contextType", Bt);
function uz(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? uz(Object(n), !0).forEach(function(r) {
      Ee(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : uz(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var cz = {}, pz = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function iLe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Bt), [a, s] = P(null);
  return h(() => {
    google.maps.visualization || wo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    wo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(Bv(Bv({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(iLe);
class sLe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      heatmapLayer: null
    }), Ee(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    wo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), wo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(Bv(Bv({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = pn({
      updaterMap: pz,
      eventMap: cz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: pz,
      eventMap: cz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), vn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(sLe, "contextType", Bt);
var dz = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, fz = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class aLe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      streetViewPanorama: null
    }), Ee(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = pn({
      updaterMap: fz,
      eventMap: dz,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: fz,
      eventMap: dz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), vn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Ee(aLe, "contextType", Bt);
class lLe extends pe {
  constructor() {
    super(...arguments), Ee(this, "state", {
      streetViewService: null
    }), Ee(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Ee(lLe, "contextType", Bt);
var hz = {
  onDirectionsChanged: "directions_changed"
}, gz = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class uLe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "state", {
      directionsRenderer: null
    }), Ee(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = pn({
      updaterMap: gz,
      eventMap: hz,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: gz,
      eventMap: hz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), vn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Ee(uLe, "contextType", Bt);
var mz = {
  onPlacesChanged: "places_changed"
}, vz = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class cLe extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "containerElement", ir()), Ee(this, "state", {
      searchBox: null
    }), Ee(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (wo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = pn({
          updaterMap: vz,
          eventMap: mz,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: vz,
      eventMap: mz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), vn(this.registeredEvents));
  }
  render() {
    return si.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
Ee(cLe, "contextType", Bt);
var yz = {
  onPlaceChanged: "place_changed"
}, bz = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class Mq extends pe {
  constructor() {
    super(...arguments), Ee(this, "registeredEvents", []), Ee(this, "containerElement", ir()), Ee(this, "state", {
      autocomplete: null
    }), Ee(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    wo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = pn({
        updaterMap: bz,
        eventMap: yz,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    vn(this.registeredEvents), this.registeredEvents = pn({
      updaterMap: bz,
      eventMap: yz,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && vn(this.registeredEvents);
  }
  render() {
    return si.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
Ee(Mq, "defaultProps", {
  className: ""
});
Ee(Mq, "contextType", Bt);
let pLe = { data: "" }, dLe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || pLe, fLe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, hLe = /\/\*[^]*?\*\/|  +/g, wz = /\n+/g, nl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? nl(a, i) : i + "{" + nl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += nl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += nl.p ? nl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Gs = {}, Dq = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + Dq(e[n]);
    return t;
  }
  return e;
}, gLe = (e, t, n, r, o) => {
  let i = Dq(e), a = Gs[i] || (Gs[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Gs[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = fLe.exec(u.replace(hLe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(wz, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(wz, " ").trim();
      return d[0];
    })(e);
    Gs[a] = nl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Gs.g ? Gs.g : null;
  return n && (Gs.g = Gs[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Gs[a], t, r, s), a;
}, mLe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : nl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function j0(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return gLe(n.unshift ? n.raw ? mLe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, dLe(t.target), t.g, t.o, t.k);
}
let _q, OE, xE;
j0.bind({ g: 1 });
let ca = j0.bind({ k: 1 });
function vLe(e, t, n, r) {
  nl.p = t, _q = e, OE = n, xE = r;
}
function Sl(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: OE && OE() }, s), n.o = / *go\d+/.test(l), s.className = j0.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), xE && u[0] && xE(s), _q(u, s);
    }
    return o;
  };
}
var yLe = (e) => typeof e == "function", bLe = (e, t) => yLe(e) ? e(t) : e, wLe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), CLe = ca`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, OLe = ca`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, xLe = ca`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, ELe = Sl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${CLe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${OLe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${xLe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, LLe = ca`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, PLe = Sl("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${LLe} 1s linear infinite;
`, kLe = ca`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, SLe = ca`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, MLe = Sl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${kLe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${SLe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, DLe = Sl("div")`
  position: absolute;
`, _Le = Sl("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, jLe = ca`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, TLe = Sl("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${jLe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, ALe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Re.createElement(TLe, null, t) : t : n === "blank" ? null : Re.createElement(_Le, null, Re.createElement(PLe, { ...r }), n !== "loading" && Re.createElement(DLe, null, n === "error" ? Re.createElement(ELe, { ...r }) : Re.createElement(MLe, { ...r })));
}, ILe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, BLe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, NLe = "0%{opacity:0;} 100%{opacity:1;}", RLe = "0%{opacity:1;} 100%{opacity:0;}", FLe = Sl("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, zLe = Sl("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, ULe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = wLe() ? [NLe, RLe] : [ILe(n), BLe(n)];
  return { animation: t ? `${ca(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ca(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Re.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? ULe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Re.createElement(ALe, { toast: e }), a = Re.createElement(zLe, { ...e.ariaProps }, bLe(e.message, e));
  return Re.createElement(FLe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Re.createElement(Re.Fragment, null, i, a));
});
vLe(Re.createElement);
j0`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ye({});
function WLe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const $Le = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
WLe($Le.CNPJ).length;
ga((e, t) => /* @__PURE__ */ ii.jsx("input", { ref: t, ...e }));
Ye({});
var ba = {};
Object.defineProperty(ba, "__esModule", {
  value: !0
});
var HLe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), tC = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, jq = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: HLe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, lS = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var dg = 1; dg < 20; dg++)
  lS["f" + dg] = 111 + dg;
function T0(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return Tq(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return Aq(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function VLe(e, t) {
  return T0(e, t);
}
function ZLe(e, t) {
  return T0(e, { byKey: !0 }, t);
}
function Tq(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in tC)
    r[tC[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = uS(d), v = tC[f];
      if (d.length > 1 && !v && !jq[d] && !lS[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = Iq(d)), v && (r[v] = y ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function Aq(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function Iq(e) {
  e = uS(e);
  var t = lS[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function uS(e) {
  return e = e.toLowerCase(), e = jq[e] || e, e;
}
ba.default = T0;
var nC = ba.isHotkey = T0;
ba.isCodeHotkey = VLe;
ba.isKeyHotkey = ZLe;
ba.parseHotkey = Tq;
ba.compareHotkey = Aq;
ba.toKeyCode = Iq;
ba.toKeyName = uS;
var qLe = typeof tr == "object" && tr && tr.Object === Object && tr, KLe = qLe, GLe = KLe, YLe = typeof self == "object" && self && self.Object === Object && self, XLe = GLe || YLe || Function("return this")(), JLe = XLe, QLe = JLe, ePe = QLe.Symbol, Bq = ePe, Cz = Bq;
Cz && Cz.toStringTag;
var Oz = Bq;
Oz && Oz.toStringTag;
var xz;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(xz || (xz = {}));
var cS = function(e) {
  return Object.freeze(e);
}, tPe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, cS(this);
  }
  return e;
}(), nPe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, cS(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), Ez = typeof window < "u" ? window : {};
/msie|trident/i.test(Ez.navigator && Ez.navigator.userAgent);
var rC = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new tPe((n ? t : e) || 0, (n ? e : t) || 0);
};
cS({
  devicePixelContentBoxSize: rC(),
  borderBoxSize: rC(),
  contentBoxSize: rC(),
  contentRect: new nPe(0, 0, 0, 0)
});
function Ud(e) {
  "@babel/helpers - typeof";
  return Ud = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ud(e);
}
function rPe(e, t) {
  if (Ud(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ud(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function oPe(e) {
  var t = rPe(e, "string");
  return Ud(t) === "symbol" ? t : String(t);
}
function Xp(e, t, n) {
  return t = oPe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var iPe = /* @__PURE__ */ Ye(null), oC, iC;
parseInt(Ce.version.split(".")[0], 10);
var Lz = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), sC = typeof navigator < "u" && /Android/.test(navigator.userAgent), fg = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), sPe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (oC = navigator.userAgent.match(/Version\/(\d+)/)) !== null && oC !== void 0 && oC[1] && parseInt((iC = navigator.userAgent.match(/Version\/(\d+)/)) === null || iC === void 0 ? void 0 : iC[1], 10) < 17;
var aPe = /* @__PURE__ */ new WeakMap(), lPe = /* @__PURE__ */ new WeakMap(), uPe = /* @__PURE__ */ new WeakMap(), cPe = /* @__PURE__ */ new WeakMap(), pPe = /* @__PURE__ */ new WeakMap(), Pz = /* @__PURE__ */ new WeakMap(), dPe = /* @__PURE__ */ new WeakMap(), kz = /* @__PURE__ */ new WeakMap(), hg = /* @__PURE__ */ new WeakMap(), fPe = /* @__PURE__ */ new WeakMap(), hPe = /* @__PURE__ */ new WeakMap(), gPe = /* @__PURE__ */ new WeakMap(), Nq = globalThis.Node, mPe = globalThis.Text, Rq = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, vPe = (e) => Nv(e) && e.nodeType === 8, Ms = (e) => Nv(e) && e.nodeType === 1, Nv = (e) => {
  var t = Rq(e);
  return !!t && e instanceof t.Node;
}, Sz = (e) => {
  var t = e && e.anchorNode && Rq(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, yPe = (e) => {
  var [t, n] = e;
  if (Ms(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = Fq(t, o, r ? "backward" : "forward"), r = o < n; Ms(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = wPe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, bPe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, Fq = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (vPe(o) || Ms(o) && o.childNodes.length === 0 || Ms(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, wPe = (e, t, n) => {
  var [r] = Fq(e, t, n);
  return r;
}, Mz = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), zq = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ms(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = sn.getWindow(e);
  if (o.contains(r))
    return sn.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : zq(e, i, n);
}, Dz = (e, t) => !!(e.compareDocumentPosition(t) & Nq.DOCUMENT_POSITION_PRECEDING), CPe = (e, t) => !!(e.compareDocumentPosition(t) & Nq.DOCUMENT_POSITION_FOLLOWING), OPe = 0;
class xPe {
  constructor() {
    Xp(this, "id", void 0), this.id = "".concat(OPe++);
  }
}
var sn = {
  androidPendingDiffs: (e) => gPe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = hPe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = sn.toDOMNode(e, e), n = sn.findDocumentOrShadowRoot(e);
    hg.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = sn.findDocumentOrShadowRoot(e), r = Mz(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Um.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = sn.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = sn.toSlateNode(e, t.target), a = sn.findPath(e, i);
    if (na.isElement(i) && Kn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Kn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Kn.before(e, u) : Kn.after(e, u);
      if (c) {
        var p = Kn.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = sn.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = sn.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = Pz.get(t);
    return n || (n = new xPe(), Pz.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = lPe.get(r);
      if (o == null) {
        if (Kn.isEditor(r))
          return n;
        break;
      }
      var i = aPe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Si.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!hg.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          sn.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = sn.toDOMNode(e, e), r = sn.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = Mz(r), i = sn.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Um.select(e, Kn.start(e, [])), hg.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = uPe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = sn.toDOMNode(e, e), i;
    try {
      i = Ms(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Nv(t) && sn.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Kn.hasPath(e, n.path) && Kn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => sn.hasEditableTarget(e, t) || sn.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Nv(t) && sn.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!fPe.get(e),
  isFocused: (e) => !!hg.get(e),
  isReadOnly: (e) => !!kz.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (kz.get(e)) return !1;
    var n = sn.hasTarget(e, t) && sn.toSlateNode(e, t);
    return na.isElement(n) && Kn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = dPe.get(e), r = Kn.isEditor(t) ? cPe.get(e) : n == null ? void 0 : n.get(sn.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Si.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Kn.node(e, t.path), r = sn.toDOMNode(e, n), o;
    Kn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof mPe ? E : v,
            (g = v.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Si.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = $t.isBackward(t), i = sn.toDOMPoint(e, n), a = $t.isCollapsed(t) ? i : sn.toDOMPoint(e, r), s = sn.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = Ms(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = Ms(p) ? p : p.parentElement, g = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ms(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? pPe.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : yPe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = sn.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && y.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = sn.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (sC && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var z = v.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var R = z[L];
          if (sn.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (E) {
        var B = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, W = [...B(H), ...B(H == null ? void 0 : H.nextElementSibling)];
          w = (V = W.find((M) => CPe(E, M))) !== null && V !== void 0 ? V : null;
        } else {
          var q, Y = [...B(H == null ? void 0 : H.previousElementSibling), ...B(H)];
          w = (q = Y.findLast((M) => Dz(E, M))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      sC && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      fg && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (sC && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && sn.hasDOMNode(e, X, {
        editable: !0
      })) {
        var ee = sn.toSlateNode(e, X), {
          path: J,
          offset: k
        } = Kn.start(e, sn.findPath(e, ee));
        return X.querySelector("[data-slate-leaf]") || (k = s), {
          path: J,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = sn.toSlateNode(e, u), U = sn.findPath(e, _);
    return {
      path: U,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = Sz(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (Sz(t)) {
        if (fg && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, g = C(f.children[d.startOffset]), E = C(v.children[y.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        sPe && bPe(s) || fg ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    fg && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = sn.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = Dz(s, u) || s === u && c < l, x = p ? w : sn.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return $t.isExpanded(m) && $t.isForward(m) && Ms(u) && Kn.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = Kn.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, EPe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, LPe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, PPe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Tr = (e) => {
  var t = EPe[e], n = LPe[e], r = PPe[e], o = t && nC(t), i = n && nC(n), a = r && nC(r);
  return (s) => !!(o && o(s) || Lz && i && i(s) || !Lz && a && a(s));
};
Tr("bold"), Tr("compose"), Tr("moveBackward"), Tr("moveForward"), Tr("deleteBackward"), Tr("deleteForward"), Tr("deleteLineBackward"), Tr("deleteLineForward"), Tr("deleteWordBackward"), Tr("deleteWordForward"), Tr("extendBackward"), Tr("extendForward"), Tr("extendLineBackward"), Tr("extendLineForward"), Tr("italic"), Tr("moveLineBackward"), Tr("moveLineForward"), Tr("moveWordBackward"), Tr("moveWordForward"), Tr("redo"), Tr("insertSoftBreak"), Tr("splitBlock"), Tr("transposeCharacter"), Tr("undo");
var kPe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => zq(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, SPe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class MPe extends $u {
  constructor() {
    super(...arguments), Xp(this, "context", null), Xp(this, "manager", null), Xp(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, SPe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = kPe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Xp(MPe, "contextType", iPe);
Ye({});
Ye({});
Ye({});
var po = {}, pS = {}, wf = {}, Cf = {}, Uq = "Expected a function", _z = NaN, DPe = "[object Symbol]", _Pe = /^\s+|\s+$/g, jPe = /^[-+]0x[0-9a-f]+$/i, TPe = /^0b[01]+$/i, APe = /^0o[0-7]+$/i, IPe = parseInt, BPe = typeof tr == "object" && tr && tr.Object === Object && tr, NPe = typeof self == "object" && self && self.Object === Object && self, RPe = BPe || NPe || Function("return this")(), FPe = Object.prototype, zPe = FPe.toString, UPe = Math.max, WPe = Math.min, aC = function() {
  return RPe.Date.now();
};
function $Pe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(Uq);
  t = jz(t) || 0, Rv(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? UPe(jz(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, z = o;
    return r = o = void 0, u = C, a = e.apply(z, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, z = C - u, L = t - S;
    return p ? WPe(L, i - z) : L;
  }
  function g(C) {
    var S = C - l, z = C - u;
    return l === void 0 || S >= t || S < 0 || p && z >= i;
  }
  function E() {
    var C = aC();
    if (g(C))
      return w(C);
    s = setTimeout(E, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(aC());
  }
  function m() {
    var C = aC(), S = g(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), y(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function HPe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(Uq);
  return Rv(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), $Pe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Rv(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function VPe(e) {
  return !!e && typeof e == "object";
}
function ZPe(e) {
  return typeof e == "symbol" || VPe(e) && zPe.call(e) == DPe;
}
function jz(e) {
  if (typeof e == "number")
    return e;
  if (ZPe(e))
    return _z;
  if (Rv(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Rv(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(_Pe, "");
  var n = TPe.test(e);
  return n || APe.test(e) ? IPe(e.slice(2), n ? 2 : 8) : jPe.test(e) ? _z : +e;
}
var qPe = HPe, Of = {};
Object.defineProperty(Of, "__esModule", {
  value: !0
});
Of.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), cm.has(t) || cm.set(t, /* @__PURE__ */ new Set());
  var o = cm.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Of.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), cm.get(t).delete(n.name || t);
};
var cm = /* @__PURE__ */ new Map();
Object.defineProperty(Cf, "__esModule", {
  value: !0
});
var KPe = qPe, GPe = XPe(KPe), YPe = Of;
function XPe(e) {
  return e && e.__esModule ? e : { default: e };
}
var JPe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, GPe.default)(e, t);
}, Vr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = JPe(function(r) {
        Vr.scrollHandler(e);
      }, t);
      Vr.scrollSpyContainers.push(e), (0, YPe.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Vr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Vr.scrollSpyContainers[Vr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Vr.currentPositionX(e), Vr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Vr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Vr.scrollSpyContainers[Vr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Vr.currentPositionX(t), Vr.currentPositionY(t));
  },
  updateStates: function() {
    Vr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Vr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Vr.spySetState && Vr.spySetState.length && Vr.spySetState.indexOf(e) > -1 && Vr.spySetState.splice(Vr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Vr.scrollHandler);
  },
  update: function() {
    return Vr.scrollSpyContainers.forEach(function(e) {
      return Vr.scrollHandler(e);
    });
  }
};
Cf.default = Vr;
var Lc = {}, xf = {};
Object.defineProperty(xf, "__esModule", {
  value: !0
});
var QPe = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, eke = function() {
  return window.location.hash.replace(/^#/, "");
}, tke = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, nke = function(e) {
  return getComputedStyle(e).position !== "static";
}, lC = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, rke = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (nke(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = lC(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return lC(t, s).offsetTop - lC(e, s).offsetTop;
};
xf.default = {
  updateHash: QPe,
  getHash: eke,
  filterElementInContainer: tke,
  scrollOffset: rke
};
var A0 = {}, dS = {};
Object.defineProperty(dS, "__esModule", {
  value: !0
});
dS.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var fS = {};
Object.defineProperty(fS, "__esModule", {
  value: !0
});
var oke = Of, ike = ["mousedown", "mousewheel", "touchmove", "keydown"];
fS.default = {
  subscribe: function(e) {
    return typeof document < "u" && ike.forEach(function(t) {
      return (0, oke.addPassiveEventListener)(document, t, e);
    });
  }
};
var Ef = {};
Object.defineProperty(Ef, "__esModule", {
  value: !0
});
var EE = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      EE.registered[e] = t;
    },
    remove: function(e) {
      EE.registered[e] = null;
    }
  }
};
Ef.default = EE;
Object.defineProperty(A0, "__esModule", {
  value: !0
});
var ske = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ake = xf;
I0(ake);
var lke = dS, Tz = I0(lke), uke = fS, cke = I0(uke), pke = Ef, Os = I0(pke);
function I0(e) {
  return e && e.__esModule ? e : { default: e };
}
var Wq = function(e) {
  return Tz.default[e.smooth] || Tz.default.defaultEasing;
}, dke = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, fke = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, LE = function() {
  return fke() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), $q = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, Hq = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Vq = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, hke = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, gke = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, mke = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Os.default.registered.end && Os.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    LE.call(window, i);
    return;
  }
  Os.default.registered.end && Os.default.registered.end(o.to, o.target, o.currentPosition);
}, hS = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Lf = function(e, t, n, r) {
  t.data = t.data || $q(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (cke.default.subscribe(o), hS(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? Hq(t) : Vq(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Os.default.registered.end && Os.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = dke(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = Wq(t), a = mke.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Os.default.registered.begin && Os.default.registered.begin(t.data.to, t.data.target), LE.call(window, a);
    }, t.delay);
    return;
  }
  Os.default.registered.begin && Os.default.registered.begin(t.data.to, t.data.target), LE.call(window, a);
}, B0 = function(e) {
  return e = ske({}, e), e.data = e.data || $q(), e.absolute = !0, e;
}, vke = function(e) {
  Lf(0, B0(e));
}, yke = function(e, t) {
  Lf(e, B0(t));
}, bke = function(e) {
  e = B0(e), hS(e), Lf(e.horizontal ? hke(e) : gke(e), e);
}, wke = function(e, t) {
  t = B0(t), hS(t);
  var n = t.horizontal ? Hq(t) : Vq(t);
  Lf(e + n, t);
};
A0.default = {
  animateTopScroll: Lf,
  getAnimationType: Wq,
  scrollToTop: vke,
  scrollToBottom: bke,
  scrollTo: yke,
  scrollMore: wke
};
Object.defineProperty(Lc, "__esModule", {
  value: !0
});
var Cke = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Oke = xf, xke = gS(Oke), Eke = A0, Lke = gS(Eke), Pke = Ef, gg = gS(Pke);
function gS(e) {
  return e && e.__esModule ? e : { default: e };
}
var mg = {}, Az = void 0;
Lc.default = {
  unmount: function() {
    mg = {};
  },
  register: function(e, t) {
    mg[e] = t;
  },
  unregister: function(e) {
    delete mg[e];
  },
  get: function(e) {
    return mg[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return Az = e;
  },
  getActiveLink: function() {
    return Az;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Cke({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = xke.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      gg.default.registered.begin && gg.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, gg.default.registered.end && gg.default.registered.end(e, n);
      return;
    }
    Lke.default.animateTopScroll(s, t, e, n);
  }
};
var PE = { exports: {} }, uC = { exports: {} }, Tn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Iz;
function kke() {
  if (Iz) return Tn;
  Iz = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return Tn.AsyncMode = l, Tn.ConcurrentMode = u, Tn.ContextConsumer = s, Tn.ContextProvider = a, Tn.Element = t, Tn.ForwardRef = c, Tn.Fragment = r, Tn.Lazy = f, Tn.Memo = y, Tn.Portal = n, Tn.Profiler = i, Tn.StrictMode = o, Tn.Suspense = p, Tn.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, Tn.isConcurrentMode = x, Tn.isContextConsumer = function(m) {
    return D(m) === s;
  }, Tn.isContextProvider = function(m) {
    return D(m) === a;
  }, Tn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, Tn.isForwardRef = function(m) {
    return D(m) === c;
  }, Tn.isFragment = function(m) {
    return D(m) === r;
  }, Tn.isLazy = function(m) {
    return D(m) === f;
  }, Tn.isMemo = function(m) {
    return D(m) === y;
  }, Tn.isPortal = function(m) {
    return D(m) === n;
  }, Tn.isProfiler = function(m) {
    return D(m) === i;
  }, Tn.isStrictMode = function(m) {
    return D(m) === o;
  }, Tn.isSuspense = function(m) {
    return D(m) === p;
  }, Tn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === g || m.$$typeof === E || m.$$typeof === w || m.$$typeof === v);
  }, Tn.typeOf = D, Tn;
}
var Wn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Bz;
function Ske() {
  return Bz || (Bz = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === y || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === g || N.$$typeof === E || N.$$typeof === w || N.$$typeof === v);
    }
    function x(N) {
      if (typeof N == "object" && N !== null) {
        var ue = N.$$typeof;
        switch (ue) {
          case t:
            var fe = N.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var m = l, C = u, S = s, z = a, L = t, R = c, B = r, H = f, V = y, W = n, q = i, Y = o, X = p, ee = !1;
    function J(N) {
      return ee || (ee = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || x(N) === l;
    }
    function k(N) {
      return x(N) === u;
    }
    function _(N) {
      return x(N) === s;
    }
    function U(N) {
      return x(N) === a;
    }
    function M(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function $(N) {
      return x(N) === c;
    }
    function O(N) {
      return x(N) === r;
    }
    function j(N) {
      return x(N) === f;
    }
    function F(N) {
      return x(N) === y;
    }
    function T(N) {
      return x(N) === n;
    }
    function Z(N) {
      return x(N) === i;
    }
    function A(N) {
      return x(N) === o;
    }
    function G(N) {
      return x(N) === p;
    }
    Wn.AsyncMode = m, Wn.ConcurrentMode = C, Wn.ContextConsumer = S, Wn.ContextProvider = z, Wn.Element = L, Wn.ForwardRef = R, Wn.Fragment = B, Wn.Lazy = H, Wn.Memo = V, Wn.Portal = W, Wn.Profiler = q, Wn.StrictMode = Y, Wn.Suspense = X, Wn.isAsyncMode = J, Wn.isConcurrentMode = k, Wn.isContextConsumer = _, Wn.isContextProvider = U, Wn.isElement = M, Wn.isForwardRef = $, Wn.isFragment = O, Wn.isLazy = j, Wn.isMemo = F, Wn.isPortal = T, Wn.isProfiler = Z, Wn.isStrictMode = A, Wn.isSuspense = G, Wn.isValidElementType = D, Wn.typeOf = x;
  }()), Wn;
}
var Nz;
function Zq() {
  return Nz || (Nz = 1, process.env.NODE_ENV === "production" ? uC.exports = kke() : uC.exports = Ske()), uC.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var cC, Rz;
function Mke() {
  if (Rz) return cC;
  Rz = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return cC = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, cC;
}
var pC, Fz;
function mS() {
  if (Fz) return pC;
  Fz = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return pC = e, pC;
}
var zz, Uz;
function qq() {
  return Uz || (Uz = 1, zz = Function.call.bind(Object.prototype.hasOwnProperty)), zz;
}
var dC, Wz;
function Dke() {
  if (Wz) return dC;
  Wz = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = mS(), n = {}, r = qq();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, dC = o, dC;
}
var fC, $z;
function _ke() {
  if ($z) return fC;
  $z = 1;
  var e = Zq(), t = Mke(), n = mS(), r = qq(), o = Dke(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return fC = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var _ = k && (u && k[u] || k[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: z,
      oneOf: S,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(k, _) {
      return k === _ ? k !== 0 || 1 / k === 1 / _ : k !== k && _ !== _;
    }
    function v(k, _) {
      this.message = k, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function g(k) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, U = 0;
      function M(O, j, F, T, Z, A, G) {
        if (T = T || d, A = A || F, G !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + F;
            !_[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            U < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[ue] = !0, U++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + Z + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + Z + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : k(j, F, T, Z, A);
      }
      var $ = M.bind(null, !1);
      return $.isRequired = M.bind(null, !0), $;
    }
    function E(k) {
      function _(U, M, $, O, j, F) {
        var T = U[M], Z = Y(T);
        if (Z !== k) {
          var A = X(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return g(_);
    }
    function w() {
      return g(a);
    }
    function D(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var F = U[M];
        if (!Array.isArray(F)) {
          var T = Y(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var Z = 0; Z < F.length; Z++) {
          var A = k(F, Z, $, O, j + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(_);
    }
    function x() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!s(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(k);
    }
    function m() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!e.isValidElementType(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(k);
    }
    function C(k) {
      function _(U, M, $, O, j) {
        if (!(U[M] instanceof k)) {
          var F = k.name || d, T = J(U[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return g(_);
    }
    function S(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(U, M, $, O, j) {
        for (var F = U[M], T = 0; T < k.length; T++)
          if (f(F, k[T]))
            return null;
        var Z = JSON.stringify(k, function(A, G) {
          var N = X(G);
          return N === "symbol" ? String(G) : G;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + $ + "`, expected one of " + Z + "."));
      }
      return g(_);
    }
    function z(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var Z in F)
          if (r(F, Z)) {
            var A = k(F, Z, $, O, j + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(_);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < k.length; _++) {
        var U = k[_];
        if (typeof U != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ee(U) + " at index " + _ + "."
          ), a;
      }
      function M($, O, j, F, T) {
        for (var Z = [], A = 0; A < k.length; A++) {
          var G = k[A], N = G($, O, j, F, T, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && Z.push(N.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return g(M);
    }
    function R() {
      function k(_, U, M, $, O) {
        return W(_[U]) ? null : new v("Invalid " + $ + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return g(k);
    }
    function B(k, _, U, M, $) {
      return new v(
        (k || "React class") + ": " + _ + " type `" + U + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function H(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var Z in k) {
          var A = k[Z];
          if (typeof A != "function")
            return B($, O, j, Z, X(A));
          var G = A(F, Z, $, O, j + "." + Z, n);
          if (G)
            return G;
        }
        return null;
      }
      return g(_);
    }
    function V(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var Z = t({}, U[M], k);
        for (var A in Z) {
          var G = k[A];
          if (r(k, A) && typeof G != "function")
            return B($, O, j, A, X(G));
          if (!G)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(U[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = G(F, A, $, O, j + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return g(_);
    }
    function W(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(W);
          if (k === null || s(k))
            return !0;
          var _ = p(k);
          if (_) {
            var U = _.call(k), M;
            if (_ !== k.entries) {
              for (; !(M = U.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = U.next()).done; ) {
                var $ = M.value;
                if ($ && !W($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(k, _) {
      return k === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function Y(k) {
      var _ = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : q(_, k) ? "symbol" : _;
    }
    function X(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var _ = Y(k);
      if (_ === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function ee(k) {
      var _ = X(k);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, fC;
}
var hC, Hz;
function jke() {
  if (Hz) return hC;
  Hz = 1;
  var e = mS();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, hC = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, hC;
}
if (process.env.NODE_ENV !== "production") {
  var Tke = Zq(), Ake = !0;
  PE.exports = _ke()(Tke.isElement, Ake);
} else
  PE.exports = jke()();
var N0 = PE.exports, R0 = {};
Object.defineProperty(R0, "__esModule", {
  value: !0
});
var Ike = xf, gC = Bke(Ike);
function Bke(e) {
  return e && e.__esModule ? e : { default: e };
}
var Nke = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return gC.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && gC.default.getHash() !== e && gC.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
R0.default = Nke;
Object.defineProperty(wf, "__esModule", {
  value: !0
});
var vg = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Rke = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Fke = Ce, Vz = Pf(Fke), zke = Cf, yg = Pf(zke), Uke = Lc, Wke = Pf(Uke), $ke = N0, Ar = Pf($ke), Hke = R0, Ma = Pf(Hke);
function Pf(e) {
  return e && e.__esModule ? e : { default: e };
}
function Vke(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Zke(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function qke(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Zz = {
  to: Ar.default.string.isRequired,
  containerId: Ar.default.string,
  container: Ar.default.object,
  activeClass: Ar.default.string,
  activeStyle: Ar.default.object,
  spy: Ar.default.bool,
  horizontal: Ar.default.bool,
  smooth: Ar.default.oneOfType([Ar.default.bool, Ar.default.string]),
  offset: Ar.default.number,
  delay: Ar.default.number,
  isDynamic: Ar.default.bool,
  onClick: Ar.default.func,
  duration: Ar.default.oneOfType([Ar.default.number, Ar.default.func]),
  absolute: Ar.default.bool,
  onSetActive: Ar.default.func,
  onSetInactive: Ar.default.func,
  ignoreCancelEvents: Ar.default.bool,
  hashSpy: Ar.default.bool,
  saveHashHistory: Ar.default.bool,
  spyThrottle: Ar.default.number
};
wf.default = function(e, t) {
  var n = t || Wke.default, r = function(i) {
    qke(a, i);
    function a(s) {
      Vke(this, a);
      var l = Zke(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return Rke(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          yg.default.isMounted(s) || yg.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (Ma.default.isMounted() || Ma.default.mount(n), Ma.default.mapContainer(this.props.to, s)), yg.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        yg.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = vg({}, this.props.style, this.props.activeStyle) : l = vg({}, this.props.style);
        var u = vg({}, this.props);
        for (var c in Zz)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, Vz.default.createElement(e, u);
      }
    }]), a;
  }(Vz.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, vg({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Ma.default.isMounted() && !Ma.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, g = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            g = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - g + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            x = z.top - C + s, m = x + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(m), y = L < Math.floor(x) || L >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && Ma.default.getHash() === c) {
            var B = i.props.saveHashHistory, H = B === void 0 ? !1 : B;
            Ma.default.changeHash("", H);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, W = V === void 0 ? !1 : V;
          i.props.hashSpy && Ma.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = Zz, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(pS, "__esModule", {
  value: !0
});
var Kke = Ce, qz = Kq(Kke), Gke = wf, Yke = Kq(Gke);
function Kq(e) {
  return e && e.__esModule ? e : { default: e };
}
function Xke(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Kz(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Jke(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Qke = function(e) {
  Jke(t, e);
  function t() {
    var n, r, o, i;
    Xke(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = Kz(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return qz.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), Kz(o, i);
  }
  return t;
}(qz.default.Component);
pS.default = (0, Yke.default)(Qke);
var vS = {};
Object.defineProperty(vS, "__esModule", {
  value: !0
});
var eSe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), tSe = Ce, Gz = Gq(tSe), nSe = wf, rSe = Gq(nSe);
function Gq(e) {
  return e && e.__esModule ? e : { default: e };
}
function oSe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function iSe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function sSe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var aSe = function(e) {
  sSe(t, e);
  function t() {
    return oSe(this, t), iSe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return eSe(t, [{
    key: "render",
    value: function() {
      return Gz.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(Gz.default.Component);
vS.default = (0, rSe.default)(aSe);
var yS = {}, F0 = {};
Object.defineProperty(F0, "__esModule", {
  value: !0
});
var lSe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, uSe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), cSe = Ce, Yz = z0(cSe), pSe = pl;
z0(pSe);
var dSe = Lc, Xz = z0(dSe), fSe = N0, Jz = z0(fSe);
function z0(e) {
  return e && e.__esModule ? e : { default: e };
}
function hSe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gSe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function mSe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
F0.default = function(e) {
  var t = function(n) {
    mSe(r, n);
    function r(o) {
      hSe(this, r);
      var i = gSe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return uSe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        Xz.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        Xz.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return Yz.default.createElement(e, lSe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(Yz.default.Component);
  return t.propTypes = {
    name: Jz.default.string,
    id: Jz.default.string
  }, t;
};
Object.defineProperty(yS, "__esModule", {
  value: !0
});
var Qz = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, vSe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), ySe = Ce, e2 = bS(ySe), bSe = F0, wSe = bS(bSe), CSe = N0, t2 = bS(CSe);
function bS(e) {
  return e && e.__esModule ? e : { default: e };
}
function OSe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function xSe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ESe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Yq = function(e) {
  ESe(t, e);
  function t() {
    return OSe(this, t), xSe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return vSe(t, [{
    key: "render",
    value: function() {
      var n = this, r = Qz({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, e2.default.createElement(
        "div",
        Qz({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(e2.default.Component);
Yq.propTypes = {
  name: t2.default.string,
  id: t2.default.string
};
yS.default = (0, wSe.default)(Yq);
var mC = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, n2 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function r2(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function o2(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function i2(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var bg = Ce, zl = Cf, vC = Lc, Jr = N0, Da = R0, s2 = {
  to: Jr.string.isRequired,
  containerId: Jr.string,
  container: Jr.object,
  activeClass: Jr.string,
  spy: Jr.bool,
  smooth: Jr.oneOfType([Jr.bool, Jr.string]),
  offset: Jr.number,
  delay: Jr.number,
  isDynamic: Jr.bool,
  onClick: Jr.func,
  duration: Jr.oneOfType([Jr.number, Jr.func]),
  absolute: Jr.bool,
  onSetActive: Jr.func,
  onSetInactive: Jr.func,
  ignoreCancelEvents: Jr.bool,
  hashSpy: Jr.bool,
  spyThrottle: Jr.number
}, LSe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || vC, r = function(i) {
      i2(a, i);
      function a(s) {
        r2(this, a);
        var l = o2(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return n2(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            zl.isMounted(s) || zl.mount(s, this.props.spyThrottle), this.props.hashSpy && (Da.isMounted() || Da.mount(n), Da.mapContainer(this.props.to, s)), this.props.spy && zl.addStateHandler(this.stateHandler), zl.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          zl.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = mC({}, this.props);
          for (var u in s2)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, bg.createElement(e, l);
        }
      }]), a;
    }(bg.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, mC({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Da.isMounted() && !Da.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, g = v >= Math.floor(c) && v < Math.floor(p), E = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Da.getHash() === l && Da.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), zl.updateStates();
          if (g && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Da.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), zl.updateStates();
        }
      };
    };
    return r.propTypes = s2, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      i2(r, n);
      function r(o) {
        r2(this, r);
        var i = o2(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return n2(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          vC.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          vC.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return bg.createElement(e, mC({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(bg.Component);
    return t.propTypes = {
      name: Jr.string,
      id: Jr.string
    }, t;
  }
}, PSe = LSe;
Object.defineProperty(po, "__esModule", {
  value: !0
});
po.Helpers = po.ScrollElement = po.ScrollLink = po.animateScroll = po.scrollSpy = po.Events = po.scroller = po.Element = po.Button = po.Link = void 0;
var kSe = pS, Xq = Bs(kSe), SSe = vS, Jq = Bs(SSe), MSe = yS, Qq = Bs(MSe), DSe = Lc, eK = Bs(DSe), _Se = Ef, tK = Bs(_Se), jSe = Cf, nK = Bs(jSe), TSe = A0, rK = Bs(TSe), ASe = wf, oK = Bs(ASe), ISe = F0, iK = Bs(ISe), BSe = PSe, sK = Bs(BSe);
function Bs(e) {
  return e && e.__esModule ? e : { default: e };
}
po.Link = Xq.default;
po.Button = Jq.default;
po.Element = Qq.default;
po.scroller = eK.default;
po.Events = tK.default;
po.scrollSpy = nK.default;
po.animateScroll = rK.default;
po.ScrollLink = oK.default;
po.ScrollElement = iK.default;
po.Helpers = sK.default;
po.default = { Link: Xq.default, Button: Jq.default, Element: Qq.default, scroller: eK.default, Events: tK.default, scrollSpy: nK.default, animateScroll: rK.default, ScrollLink: oK.default, ScrollElement: iK.default, Helpers: sK.default };
Ye({});
Ye({});
Ye({});
function Wd(e) {
  "@babel/helpers - typeof";
  return Wd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Wd(e);
}
function NSe(e, t) {
  if (Wd(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Wd(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function RSe(e) {
  var t = NSe(e, "string");
  return Wd(t) == "symbol" ? t : t + "";
}
function Le(e, t, n) {
  return (t = RSe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function aK(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var yC, a2;
function FSe() {
  if (a2) return yC;
  a2 = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return yC = t, yC;
}
var zSe = FSe(), Co = /* @__PURE__ */ aK(zSe), Nt = Ye(null);
function USe() {
  Co(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Nt);
  return Co(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function WSe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function $Se(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function HSe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return $Se(e, i), o;
}
function VSe(e, t, n) {
  var r = WSe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function ZSe(e) {
  google.maps.event.removeListener(e);
}
function yn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(ZSe);
}
function dn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = VSe(o, i, n);
  return HSe(t, r, o, i), a;
}
function qSe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = P(null), S = dt(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null), [A, G] = P(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && g && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(m, "mouseup", g)));
  }, [g]), h(() => {
    m && E && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", E)));
  }, [E]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), G(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var N = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(N), N !== null && D && D(N), () => {
      N !== null && x && x(N);
    };
  }, []), ii.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: ii.jsx(Nt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
ve(qSe);
function l2(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function lK(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        l2(i, r, o, a, s, "next", l);
      }
      function s(l) {
        l2(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function uK(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Co(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var fu = typeof document < "u";
function cK(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return fu ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function u2(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function pK() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return u2(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return u2(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var rp = !1;
function dK() {
  return ii.jsx("div", {
    children: "Loading..."
  });
}
var kE = {
  id: "script-loader",
  version: "weekly"
};
class KSe extends pe {
  constructor() {
    super(...arguments), Le(this, "check", ir()), Le(this, "state", {
      loaded: !1
    }), Le(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Le(this, "isCleaningUp", /* @__PURE__ */ lK(function* () {
      function t(n) {
        if (!rp)
          n();
        else if (fu)
          var r = window.setInterval(function() {
            rp || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Le(this, "cleanup", () => {
      rp = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Le(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && pK(), Co(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: uK(this.props)
      };
      cK(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (fu) {
      if (window.google && window.google.maps && !rp) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), fu && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (fu) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, rp = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ii.jsxs(ii.Fragment, {
      children: [ii.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ii.jsx(dK, {})]
    });
  }
}
Le(KSe, "defaultProps", kE);
function GSe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function wS(e, t) {
  if (e == null) return {};
  var n, r, o = GSe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var c2;
function YSe(e) {
  var {
    id: t = kE.id,
    version: n = kE.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = dt(!1), [f, v] = P(!1), [g, E] = P(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    fu && u && pK();
  }, [u]), h(function() {
    f && Co(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = uK({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!fu)
      return;
    function x() {
      y.current && (v(!0), c2 = w);
    }
    if (window.google && window.google.maps && c2 === w) {
      x();
      return;
    }
    cK({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && E(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = dt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var XSe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], JSe = ii.jsx(dK, {});
function QSe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = wS(e, XSe), {
    isLoaded: s,
    loadError: l
  } = YSe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || JSe;
}
ve(QSe);
var p2;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(p2 || (p2 = {}));
function d2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? d2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : d2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var f2 = {}, h2 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function eMe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Nt), [i, a] = P(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Fv(Fv({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(eMe);
class tMe extends pe {
  constructor() {
    super(...arguments), Le(this, "state", {
      trafficLayer: null
    }), Le(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Le(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Fv(Fv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: h2,
      eventMap: f2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: h2,
      eventMap: f2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), yn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(tMe, "contextType", Nt);
function nMe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Nt), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(nMe);
class rMe extends pe {
  constructor() {
    super(...arguments), Le(this, "state", {
      bicyclingLayer: null
    }), Le(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(rMe, "contextType", Nt);
function oMe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Nt), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(oMe);
class iMe extends pe {
  constructor() {
    super(...arguments), Le(this, "state", {
      transitLayer: null
    }), Le(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(iMe, "contextType", Nt);
function g2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? g2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : g2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var m2 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, v2 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function sMe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Nt), [d, y] = P(null), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Co(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(zv(zv({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && E(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && L(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(sMe);
class aMe extends pe {
  constructor(t) {
    super(t), Le(this, "registeredEvents", []), Le(this, "state", {
      drawingManager: null
    }), Le(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Co(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(zv(zv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: v2,
      eventMap: m2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: v2,
      eventMap: m2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), yn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Le(aMe, "contextType", Nt);
function y2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? y2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : y2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var b2 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, w2 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Uv = {};
function lMe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: R,
    onClickableChanged: B,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: W,
    onFlatChanged: q,
    onIconChanged: Y,
    onPositionChanged: X,
    onShapeChanged: ee,
    onTitleChanged: J,
    onVisibleChanged: k,
    onZindexChanged: _,
    onLoad: U,
    onUnmount: M
  } = e, $ = ge(Nt), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null), [oe, Ie] = P(null), [qe, Ge] = P(null), [Be, et] = P(null), [Xe, Me] = P(null), [Je, at] = P(null), [Se, _e] = P(null), [Ae, Ve] = P(null), [Ne, nt] = P(null), [we, mt] = P(null), [ot, st] = P(null), [ut, vt] = P(null), [ct, yt] = P(null), [Qe, ft] = P(null), [tt, bt] = P(null), [pt, Dt] = P(null), [wt, _t] = P(null), [Ct, jt] = P(null);
  h(() => {
    O !== null && O.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ie(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (qe !== null && google.maps.event.removeListener(qe), Ge(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && z && (Be !== null && google.maps.event.removeListener(Be), et(google.maps.event.addListener(O, "mouseup", z)));
  }, [z]), h(() => {
    O && R && (Xe !== null && google.maps.event.removeListener(Xe), Me(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && E && (Je !== null && google.maps.event.removeListener(Je), at(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && D && (Se !== null && google.maps.event.removeListener(Se), _e(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && B && (Ae !== null && google.maps.event.removeListener(Ae), Ve(google.maps.event.addListener(O, "clickable_changed", B)));
  }, [B]), h(() => {
    O && H && (Ne !== null && google.maps.event.removeListener(Ne), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), h(() => {
    O && V && (we !== null && google.maps.event.removeListener(we), mt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && W && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && q && (ut !== null && google.maps.event.removeListener(ut), vt(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), h(() => {
    O && Y && (ct !== null && google.maps.event.removeListener(ct), yt(google.maps.event.addListener(O, "icon_changed", Y)));
  }, [Y]), h(() => {
    O && X && (Qe !== null && google.maps.event.removeListener(Qe), ft(google.maps.event.addListener(O, "position_changed", X)));
  }, [X]), h(() => {
    O && ee && (tt !== null && google.maps.event.removeListener(tt), bt(google.maps.event.addListener(O, "shape_changed", ee)));
  }, [ee]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Dt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && k && (wt !== null && google.maps.event.removeListener(wt), _t(google.maps.event.addListener(O, "visible_changed", k)));
  }, [k]), h(() => {
    O && _ && (Ct !== null && google.maps.event.removeListener(Ct), jt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var ht = Xu(Xu(Xu({}, n || Uv), r ? Uv : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof y < "u" && re.setOpacity(y), f && re.setShape(f), typeof v == "string" && re.setTitle(v), typeof g == "number" && re.setZIndex(g), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), m && N(google.maps.event.addListener(re, "dragstart", m)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ie(google.maps.event.addListener(re, "mouseout", C)), S && Ge(google.maps.event.addListener(re, "mouseover", S)), z && et(google.maps.event.addListener(re, "mouseup", z)), R && Me(google.maps.event.addListener(re, "rightclick", R)), E && at(google.maps.event.addListener(re, "click", E)), D && _e(google.maps.event.addListener(re, "drag", D)), B && Ve(google.maps.event.addListener(re, "clickable_changed", B)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && mt(google.maps.event.addListener(re, "animation_changed", V)), W && st(google.maps.event.addListener(re, "draggable_changed", W)), q && vt(google.maps.event.addListener(re, "flat_changed", q)), Y && yt(google.maps.event.addListener(re, "icon_changed", Y)), X && ft(google.maps.event.addListener(re, "position_changed", X)), ee && bt(google.maps.event.addListener(re, "shape_changed", ee)), J && Dt(google.maps.event.addListener(re, "title_changed", J)), k && _t(google.maps.event.addListener(re, "visible_changed", k)), _ && jt(google.maps.event.addListener(re, "zindex_changed", _)), j(re), U && U(re), () => {
      F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), qe !== null && google.maps.event.removeListener(qe), Be !== null && google.maps.event.removeListener(Be), Xe !== null && google.maps.event.removeListener(Xe), Je !== null && google.maps.event.removeListener(Je), Ae !== null && google.maps.event.removeListener(Ae), Ne !== null && google.maps.event.removeListener(Ne), we !== null && google.maps.event.removeListener(we), ot !== null && google.maps.event.removeListener(ot), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), Qe !== null && google.maps.event.removeListener(Qe), pt !== null && google.maps.event.removeListener(pt), wt !== null && google.maps.event.removeListener(wt), Ct !== null && google.maps.event.removeListener(Ct), M && M(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Cn = On(() => i ? lt.map(i, (ht) => {
    if (!mi(ht))
      return ht;
    var re = ht;
    return vi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return ii.jsx(ii.Fragment, {
    children: Cn
  }) || null;
}
ve(lMe);
class uMe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return lK(function* () {
      var n = Xu(Xu(Xu({}, t.props.options || Uv), t.props.clusterer ? Uv : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = dn({
        updaterMap: w2,
        eventMap: b2,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: w2,
      eventMap: b2,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), yn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Le(uMe, "contextType", Nt);
var cMe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), pMe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new cMe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function dMe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var fMe = 2e3, hMe = 500, gMe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", mMe = "png", vMe = [53, 56, 66, 78, 90], yMe = "cluster", fK = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || gMe, this.imageExtension = r.imageExtension || mMe, this.imageSizes = r.imageSizes || vMe, this.calculator = r.calculator || dMe, this.batchSize = r.batchSize || fMe, this.batchSizeIE = r.batchSizeIE || hMe, this.clusterClass = r.clusterClass || yMe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new pMe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function C2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function bMe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? C2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var rs = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Pn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, wMe = {};
function CMe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: z
  } = e, [L, R] = P(null), B = ge(Nt), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null);
  return h(() => {
    L && C && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(L, rs.onMouseOut, C)));
  }, [C]), h(() => {
    L && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(L, rs.onMouseOver, m)));
  }, [m]), h(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, rs.onClick, w)));
  }, [w]), h(() => {
    L && D && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(L, rs.onClusteringBegin, D)));
  }, [D]), h(() => {
    L && x && (Y !== null && google.maps.event.removeListener(Y), q(google.maps.event.addListener(L, rs.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && Pn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Pn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Pn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Pn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Pn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Pn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Pn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Pn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Pn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Pn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof y < "u" && L !== null && Pn.maxZoom(L, y);
  }, [L, y]), h(() => {
    typeof f < "u" && L !== null && Pn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof v < "u" && L !== null && Pn.styles(L, v);
  }, [L, v]), h(() => {
    typeof g < "u" && L !== null && Pn.title(L, g);
  }, [L, g]), h(() => {
    typeof E < "u" && L !== null && Pn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (B) {
      var U = bMe({}, n || wMe), M = new fK(B, [], U);
      return r && Pn.averageCenter(M, r), o && Pn.batchSizeIE(M, o), i && Pn.calculator(M, i), a && Pn.clusterClass(M, a), s && Pn.enableRetinaIcons(M, s), l && Pn.gridSize(M, l), u && Pn.ignoreHidden(M, u), c && Pn.imageExtension(M, c), p && Pn.imagePath(M, p), d && Pn.imageSizes(M, d), y && Pn.maxZoom(M, y), f && Pn.minimumClusterSize(M, f), v && Pn.styles(M, v), g && Pn.title(M, g), E && Pn.zoomOnClick(M, E), C && J(google.maps.event.addListener(M, rs.onMouseOut, C)), m && _(google.maps.event.addListener(M, rs.onMouseOver, m)), w && V(google.maps.event.addListener(M, rs.onClick, w)), D && q(google.maps.event.addListener(M, rs.onClusteringBegin, D)), x && X(google.maps.event.addListener(M, rs.onClusteringEnd, x)), R(M), S && S(M), () => {
        ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), z && z(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(CMe);
class OMe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      markerClusterer: null
    }), Le(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new fK(this.context, [], this.props.options);
      this.registeredEvents = dn({
        updaterMap: Pn,
        eventMap: rs,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: Pn,
      eventMap: rs,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), yn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Le(OMe, "contextType", Nt);
function O2(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var hK = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || O2(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, O2));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), g = v.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + y ? r = g.x + u - y : g.x + p + u + y > s && (r = g.x + p + u + y - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), xMe = ["position"], EMe = ["position"];
function x2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var E2 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, L2 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, LMe = {};
function PMe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Nt), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var B = r || LMe, {
        position: H
      } = B, V = wS(B, xMe), W;
      H && !(H instanceof google.maps.LatLng) && (W = new google.maps.LatLng(H.lat, H.lng));
      var q = new hK(Wv(Wv({}, V), W ? {
        position: W
      } : {}));
      R.current = document.createElement("div"), v(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && D(google.maps.event.addListener(q, "domready", s)), l && m(google.maps.event.addListener(q, "content_changed", l)), u && S(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(R.current), n ? q.open(y, n) : q.getPosition() ? q.open(y) : Co(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(PMe);
class kMe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "containerElement", null), Le(this, "state", {
      infoBox: null
    }), Le(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Co(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Le(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = wS(t, EMe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new hK(Wv(Wv({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = dn({
      updaterMap: L2,
      eventMap: E2,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: L2,
      eventMap: E2,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), yn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
Le(kMe, "contextType", Nt);
var P2, k2;
function SMe() {
  return k2 || (k2 = 1, P2 = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), P2;
}
var MMe = SMe(), S2 = /* @__PURE__ */ aK(MMe), M2 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], bC = 1, op = 8;
let DMe = class gK {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== bC)
      throw new Error("Got v".concat(o, " data when expected v").concat(bC, "."));
    var i = M2[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new gK(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = M2.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, op, t), this.coords = new this.ArrayType(this.data, op + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(op + a + s + l), this.ids = new this.IndexArrayType(this.data, op, t), this.coords = new this.ArrayType(this.data, op + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (bC << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return SE(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          D2(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], g = i[2 * f + 1];
      D2(v, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
};
function SE(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    mK(e, t, a, r, o, i), SE(e, t, n, r, a - 1, 1 - i), SE(e, t, n, a + 1, o, 1 - i);
  }
}
function mK(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      mK(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (ip(e, t, r, n), t[2 * o + i] > y && ip(e, t, r, o); f < v; ) {
      for (ip(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? ip(e, t, r, v) : (v++, ip(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function ip(e, t, n, r) {
  wC(e, n, r), wC(t, 2 * n, 2 * r), wC(t, 2 * n + 1, 2 * r + 1);
}
function wC(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function D2(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var _Me = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, _2 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Ul = 2, Ka = 3, CC = 4, Ua = 5, vK = 6;
class jMe {
  constructor(t) {
    this.options = Object.assign(Object.create(_Me), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = _2(wg(u)), d = _2(Cg(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(wg(r), Cg(a), wg(i), Cg(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Ua] > 1 ? j2(p, f, this.clusterProps) : this.points[p[f + Ka]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + CC] === t && p.push(a[y + Ua] > 1 ? j2(a, y, this.clusterProps) : this.points[a[y + Ka]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new DMe(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Ua] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = yK(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Ka]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = wg(f), d = Cg(v);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Ka] : E = this.points[n[l + Ka]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Ul] <= n)) {
        l[p + Ul] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Ua], g = v;
        for (var E of f) {
          var w = E * c;
          l[w + Ul] > n && (g += l[w + Ua]);
        }
        if (g > v && g >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Ul] <= n)) {
              l[L + Ul] = n;
              var R = l[L + Ua];
              D += l[L] * R, x += l[L + 1] * R, l[L + CC] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, L)));
            }
          }
          l[p + CC] = S, u.push(D / g, x / g, 1 / 0, S, -1, g), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + Ul] <= n)) {
                l[V + Ul] = n;
                for (var W = 0; W < c; W++) u.push(l[V + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Ua] > 1) {
      var o = this.clusterProps[t[n + vK]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Ka]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function j2(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Ka],
    properties: yK(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [TMe(e[t]), AMe(e[t + 1])]
    }
  };
}
function yK(e, t, n) {
  var r = e[t + Ua], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + vK], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Ka],
    point_count: r,
    point_count_abbreviated: o
  });
}
function wg(e) {
  return e / 360 + 0.5;
}
function Cg(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function TMe(e) {
  return (e - 0.5) * 360;
}
function AMe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function IMe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ii {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class ME {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ii.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ii.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ii.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class BMe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return NMe(n);
  }
}
var NMe = (e) => {
  var t = e.map((n) => new ME({
    position: Ii.getPosition(n),
    markers: [n]
  }));
  return t;
};
class RMe extends BMe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = IMe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new jMe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!S2(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ii.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !S2(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new ME({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new ME({
      markers: [i],
      position: Ii.getPosition(i)
    });
  }
}
class FMe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class zMe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ii.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function UMe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class CS {
  constructor() {
    UMe(CS, google.maps.OverlayView);
  }
}
var Jp;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Jp || (Jp = {}));
var WMe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class $Me extends CS {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new RMe(o),
      renderer: a = new zMe(),
      onClusterClick: s = WMe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ii.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Jp.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ii.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ii.setMap(l, null)));
      }
      google.maps.event.trigger(this, Jp.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ii.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new FMe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ii.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Jp.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ii.setMap(r.marker, n);
    });
  }
}
function T2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function A2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? T2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : T2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function HMe(e) {
  var t = USe(), [n, r] = P(null);
  return h(() => {
    if (t && n === null) {
      var o = new $Me(A2(A2({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function VMe(e) {
  var {
    children: t,
    options: n
  } = e, r = HMe(n);
  return r !== null ? t(r) : null;
}
ve(VMe);
var I2 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, B2 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function ZMe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Nt), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var B = new google.maps.InfoWindow(r);
    return v(B), R.current = document.createElement("div"), a && E(google.maps.event.addListener(B, "closeclick", a)), s && D(google.maps.event.addListener(B, "domready", s)), l && m(google.maps.event.addListener(B, "content_changed", l)), u && S(google.maps.event.addListener(B, "position_changed", u)), c && L(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(R.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(y, n) : B.getPosition() ? B.open(y) : Co(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(B), B.close();
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(ZMe);
class qMe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "containerElement", null), Le(this, "state", {
      infoWindow: null
    }), Le(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Co(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Le(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = dn({
      updaterMap: B2,
      eventMap: I2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: B2,
      eventMap: I2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (yn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
Le(qMe, "contextType", Nt);
function N2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $v(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? N2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : N2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var R2 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, F2 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, KMe = {};
function GMe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, D = ge(Nt), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && g && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", g)));
  }, [g]), h(() => {
    var T = new google.maps.Polyline($v($v({}, t || KMe), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && B(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && q(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), g && F(google.maps.event.addListener(T, "drag", g)), m(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(GMe);
class YMe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      polyline: null
    }), Le(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline($v($v({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: F2,
      eventMap: R2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: F2,
      eventMap: R2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), yn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Le(YMe, "contextType", Nt);
function z2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function U2(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? z2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : z2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var W2 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, $2 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function XMe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Nt), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof g == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", g)));
  }, [g]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(U2(U2({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), g && F(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), S(A), w && w(A), () => {
      z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), D && D(A), A.setMap(null);
    };
  }, []), null;
}
ve(XMe);
class JMe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = dn({
      updaterMap: $2,
      eventMap: W2,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: $2,
      eventMap: W2,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), yn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Le(JMe, "contextType", Nt);
function H2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? H2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : H2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var V2 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Z2 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function QMe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Nt), [m, C] = P(null), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), z(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", g)));
  }, [g]), h(() => {
    m && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(m, "bounds_changed", E)));
  }, [E]), h(() => {
    var G = new google.maps.Rectangle(Hv(Hv({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && G.setVisible(i), typeof o < "u" && G.setEditable(o), typeof r < "u" && G.setDraggable(r), typeof n < "u" && G.setBounds(n), a && z(google.maps.event.addListener(G, "dblclick", a)), s && R(google.maps.event.addListener(G, "dragend", s)), l && H(google.maps.event.addListener(G, "dragstart", l)), u && W(google.maps.event.addListener(G, "mousedown", u)), c && Y(google.maps.event.addListener(G, "mousemove", c)), p && ee(google.maps.event.addListener(G, "mouseout", p)), d && k(google.maps.event.addListener(G, "mouseover", d)), y && U(google.maps.event.addListener(G, "mouseup", y)), f && $(google.maps.event.addListener(G, "rightclick", f)), v && j(google.maps.event.addListener(G, "click", v)), g && T(google.maps.event.addListener(G, "drag", g)), E && A(google.maps.event.addListener(G, "bounds_changed", E)), C(G), w && w(G), () => {
      S !== null && google.maps.event.removeListener(S), L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), D && D(G), G.setMap(null);
    };
  }, []), null;
}
ve(QMe);
class eDe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      rectangle: null
    }), Le(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Hv(Hv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: Z2,
      eventMap: V2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: Z2,
      eventMap: V2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), yn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Le(eDe, "contextType", Nt);
function q2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? q2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : q2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var K2 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, G2 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, tDe = {};
function nDe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Nt), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", g)));
  }, [g]), h(() => {
    S && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(S, "drag", E)));
  }, [E]), h(() => {
    S && w && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(S, "center_changed", w)));
  }, [g]), h(() => {
    S && D && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(Vv(Vv({}, t || tDe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && R(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && Y(google.maps.event.addListener(oe, "mousedown", c)), p && ee(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), y && U(google.maps.event.addListener(oe, "mouseover", y)), f && $(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), g && T(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && N(google.maps.event.addListener(oe, "center_changed", w)), D && fe(google.maps.event.addListener(oe, "radius_changed", D)), z(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(nDe);
class rDe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      circle: null
    }), Le(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Vv(Vv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: G2,
      eventMap: K2,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: G2,
      eventMap: K2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), yn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Le(rDe, "contextType", Nt);
function Y2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Y2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Y2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var X2 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, J2 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function oDe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: g
  } = e, E = ge(Nt), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Zv(Zv({}, t), {}, {
        map: E
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && B(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && Z(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), g && g(w), w.setMap(null));
    };
  }, []), null;
}
ve(oDe);
class iDe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      data: null
    }), Le(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Zv(Zv({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = dn({
        updaterMap: J2,
        eventMap: X2,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: J2,
      eventMap: X2,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), yn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Le(iDe, "contextType", Nt);
function Q2(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Q2(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q2(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var tU = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, nU = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class sDe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      kmlLayer: null
    }), Le(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(eU(eU({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: nU,
      eventMap: tU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: nU,
      eventMap: tU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), yn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(sDe, "contextType", Nt);
function bK(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function aDe(e, t) {
  return new t(e.lat, e.lng);
}
function lDe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function uDe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function cDe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function pDe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function dDe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function wK(e, t, n, r) {
  return n !== void 0 ? pDe(e, t, cDe(n, google.maps.LatLngBounds, lDe)) : dDe(e, t, uDe(r, google.maps.LatLng, aDe));
}
function fDe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function rU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hDe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? rU(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : rU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function gDe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = hDe({}, this.container ? bK(this.container, o) : {
        x: 0,
        y: 0
      }), u = wK(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function oU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function mDe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oU(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function iU(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function sU(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function vDe(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Nt), c = On(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = On(() => gDe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
ve(vDe);
class Pc extends pe {
  constructor(t) {
    super(t), Le(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Le(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Co(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Le(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Le(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = mDe({
        x: 0,
        y: 0
      }, this.containerRef.current ? bK(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = wK(r, o, this.props.bounds, this.props.position);
      if (!fDe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Le(this, "draw", () => {
      this.onPositionElement();
    }), Le(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = ir();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = iU(t.position), r = iU(this.props.position), o = sU(t.bounds), i = sU(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(ii.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
Le(Pc, "FLOAT_PANE", "floatPane");
Le(Pc, "MAP_PANE", "mapPane");
Le(Pc, "MARKER_LAYER", "markerLayer");
Le(Pc, "OVERLAY_LAYER", "overlayLayer");
Le(Pc, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Le(Pc, "contextType", Nt);
function yDe() {
}
function aU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lU(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aU(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var uU = {
  onDblClick: "dblclick",
  onClick: "click"
}, cU = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function bDe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Nt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = On(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(bDe);
class CK extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      groundOverlay: null
    }), Le(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Co(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, lU(lU({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: cU,
      eventMap: uU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: cU,
      eventMap: uU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Le(CK, "defaultProps", {
  onLoad: yDe
});
Le(CK, "contextType", Nt);
function pU(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pU(Object(n), !0).forEach(function(r) {
      Le(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pU(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dU = {}, fU = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function wDe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Nt), [a, s] = P(null);
  return h(() => {
    google.maps.visualization || Co(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Co(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(qv(qv({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(wDe);
class CDe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      heatmapLayer: null
    }), Le(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Co(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Co(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(qv(qv({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = dn({
      updaterMap: fU,
      eventMap: dU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: fU,
      eventMap: dU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), yn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(CDe, "contextType", Nt);
var hU = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, gU = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class ODe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      streetViewPanorama: null
    }), Le(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = dn({
      updaterMap: gU,
      eventMap: hU,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: gU,
      eventMap: hU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), yn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Le(ODe, "contextType", Nt);
class xDe extends pe {
  constructor() {
    super(...arguments), Le(this, "state", {
      streetViewService: null
    }), Le(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Le(xDe, "contextType", Nt);
var mU = {
  onDirectionsChanged: "directions_changed"
}, vU = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class EDe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "state", {
      directionsRenderer: null
    }), Le(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = dn({
      updaterMap: vU,
      eventMap: mU,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: vU,
      eventMap: mU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), yn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Le(EDe, "contextType", Nt);
var yU = {
  onPlacesChanged: "places_changed"
}, bU = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class LDe extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "containerElement", ir()), Le(this, "state", {
      searchBox: null
    }), Le(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Co(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = dn({
          updaterMap: bU,
          eventMap: yU,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: bU,
      eventMap: yU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), yn(this.registeredEvents));
  }
  render() {
    return ii.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
Le(LDe, "contextType", Nt);
var wU = {
  onPlaceChanged: "place_changed"
}, CU = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class OK extends pe {
  constructor() {
    super(...arguments), Le(this, "registeredEvents", []), Le(this, "containerElement", ir()), Le(this, "state", {
      autocomplete: null
    }), Le(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Co(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = dn({
        updaterMap: CU,
        eventMap: wU,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    yn(this.registeredEvents), this.registeredEvents = dn({
      updaterMap: CU,
      eventMap: wU,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && yn(this.registeredEvents);
  }
  render() {
    return ii.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
Le(OK, "defaultProps", {
  className: ""
});
Le(OK, "contextType", Nt);
let PDe = { data: "" }, kDe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || PDe, SDe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, MDe = /\/\*[^]*?\*\/|  +/g, OU = /\n+/g, rl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? rl(a, i) : i + "{" + rl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += rl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += rl.p ? rl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ys = {}, xK = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + xK(e[n]);
    return t;
  }
  return e;
}, DDe = (e, t, n, r, o) => {
  let i = xK(e), a = Ys[i] || (Ys[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ys[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = SDe.exec(u.replace(MDe, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(OU, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(OU, " ").trim();
      return d[0];
    })(e);
    Ys[a] = rl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Ys.g ? Ys.g : null;
  return n && (Ys.g = Ys[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ys[a], t, r, s), a;
}, _De = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : rl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function U0(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return DDe(n.unshift ? n.raw ? _De(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, kDe(t.target), t.g, t.o, t.k);
}
let EK, DE, _E;
U0.bind({ g: 1 });
let pa = U0.bind({ k: 1 });
function jDe(e, t, n, r) {
  rl.p = t, EK = e, DE = n, _E = r;
}
function Ml(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: DE && DE() }, s), n.o = / *go\d+/.test(l), s.className = U0.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), _E && u[0] && _E(s), EK(u, s);
    }
    return o;
  };
}
var TDe = (e) => typeof e == "function", ADe = (e, t) => TDe(e) ? e(t) : e, IDe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), BDe = pa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, NDe = pa`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, RDe = pa`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, FDe = Ml("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${BDe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${NDe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${RDe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, zDe = pa`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, UDe = Ml("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${zDe} 1s linear infinite;
`, WDe = pa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, $De = pa`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, HDe = Ml("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${WDe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${$De} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, VDe = Ml("div")`
  position: absolute;
`, ZDe = Ml("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, qDe = pa`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, KDe = Ml("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${qDe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, GDe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Re.createElement(KDe, null, t) : t : n === "blank" ? null : Re.createElement(ZDe, null, Re.createElement(UDe, { ...r }), n !== "loading" && Re.createElement(VDe, null, n === "error" ? Re.createElement(FDe, { ...r }) : Re.createElement(HDe, { ...r })));
}, YDe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, XDe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, JDe = "0%{opacity:0;} 100%{opacity:1;}", QDe = "0%{opacity:1;} 100%{opacity:0;}", e_e = Ml("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, t_e = Ml("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, n_e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = IDe() ? [JDe, QDe] : [YDe(n), XDe(n)];
  return { animation: t ? `${pa(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${pa(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Re.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? n_e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Re.createElement(GDe, { toast: e }), a = Re.createElement(t_e, { ...e.ariaProps }, ADe(e.message, e));
  return Re.createElement(e_e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Re.createElement(Re.Fragment, null, i, a));
});
jDe(Re.createElement);
U0`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ye({});
function r_e(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const o_e = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
r_e(o_e.CNPJ).length;
ga((e, t) => /* @__PURE__ */ oi.jsx("input", { ref: t, ...e }));
Ye({});
var wa = {};
Object.defineProperty(wa, "__esModule", {
  value: !0
});
var i_e = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), OC = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, LK = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: i_e ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, OS = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Og = 1; Og < 20; Og++)
  OS["f" + Og] = 111 + Og;
function W0(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return PK(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return kK(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function s_e(e, t) {
  return W0(e, t);
}
function a_e(e, t) {
  return W0(e, { byKey: !0 }, t);
}
function PK(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in OC)
    r[OC[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = xS(d), v = OC[f];
      if (d.length > 1 && !v && !LK[d] && !OS[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = SK(d)), v && (r[v] = y ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function kK(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function SK(e) {
  e = xS(e);
  var t = OS[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function xS(e) {
  return e = e.toLowerCase(), e = LK[e] || e, e;
}
wa.default = W0;
var xC = wa.isHotkey = W0;
wa.isCodeHotkey = s_e;
wa.isKeyHotkey = a_e;
wa.parseHotkey = PK;
wa.compareHotkey = kK;
wa.toKeyCode = SK;
wa.toKeyName = xS;
var l_e = typeof er == "object" && er && er.Object === Object && er, u_e = l_e, c_e = u_e, p_e = typeof self == "object" && self && self.Object === Object && self, d_e = c_e || p_e || Function("return this")(), f_e = d_e, h_e = f_e, g_e = h_e.Symbol, MK = g_e, xU = MK;
xU && xU.toStringTag;
var EU = MK;
EU && EU.toStringTag;
var LU;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(LU || (LU = {}));
var ES = function(e) {
  return Object.freeze(e);
}, m_e = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, ES(this);
  }
  return e;
}(), v_e = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, ES(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), PU = typeof window < "u" ? window : {};
/msie|trident/i.test(PU.navigator && PU.navigator.userAgent);
var EC = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new m_e((n ? t : e) || 0, (n ? e : t) || 0);
};
ES({
  devicePixelContentBoxSize: EC(),
  borderBoxSize: EC(),
  contentBoxSize: EC(),
  contentRect: new v_e(0, 0, 0, 0)
});
function $d(e) {
  "@babel/helpers - typeof";
  return $d = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, $d(e);
}
function y_e(e, t) {
  if ($d(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if ($d(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function b_e(e) {
  var t = y_e(e, "string");
  return $d(t) === "symbol" ? t : String(t);
}
function Qp(e, t, n) {
  return t = b_e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var w_e = /* @__PURE__ */ Ye(null), LC, PC;
parseInt(Ce.version.split(".")[0], 10);
var kU = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), kC = typeof navigator < "u" && /Android/.test(navigator.userAgent), xg = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), C_e = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (LC = navigator.userAgent.match(/Version\/(\d+)/)) !== null && LC !== void 0 && LC[1] && parseInt((PC = navigator.userAgent.match(/Version\/(\d+)/)) === null || PC === void 0 ? void 0 : PC[1], 10) < 17;
var O_e = /* @__PURE__ */ new WeakMap(), x_e = /* @__PURE__ */ new WeakMap(), E_e = /* @__PURE__ */ new WeakMap(), L_e = /* @__PURE__ */ new WeakMap(), P_e = /* @__PURE__ */ new WeakMap(), SU = /* @__PURE__ */ new WeakMap(), k_e = /* @__PURE__ */ new WeakMap(), MU = /* @__PURE__ */ new WeakMap(), Eg = /* @__PURE__ */ new WeakMap(), S_e = /* @__PURE__ */ new WeakMap(), M_e = /* @__PURE__ */ new WeakMap(), D_e = /* @__PURE__ */ new WeakMap(), DK = globalThis.Node, __e = globalThis.Text, _K = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, j_e = (e) => Kv(e) && e.nodeType === 8, Ds = (e) => Kv(e) && e.nodeType === 1, Kv = (e) => {
  var t = _K(e);
  return !!t && e instanceof t.Node;
}, DU = (e) => {
  var t = e && e.anchorNode && _K(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, T_e = (e) => {
  var [t, n] = e;
  if (Ds(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = jK(t, o, r ? "backward" : "forward"), r = o < n; Ds(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = I_e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, A_e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, jK = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (j_e(o) || Ds(o) && o.childNodes.length === 0 || Ds(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, I_e = (e, t, n) => {
  var [r] = jK(e, t, n);
  return r;
}, _U = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), TK = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Ds(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = an.getWindow(e);
  if (o.contains(r))
    return an.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : TK(e, i, n);
}, jU = (e, t) => !!(e.compareDocumentPosition(t) & DK.DOCUMENT_POSITION_PRECEDING), B_e = (e, t) => !!(e.compareDocumentPosition(t) & DK.DOCUMENT_POSITION_FOLLOWING), N_e = 0;
class R_e {
  constructor() {
    Qp(this, "id", void 0), this.id = "".concat(N_e++);
  }
}
var an = {
  androidPendingDiffs: (e) => D_e.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = M_e.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = an.toDOMNode(e, e), n = an.findDocumentOrShadowRoot(e);
    Eg.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = an.findDocumentOrShadowRoot(e), r = _U(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Bm.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = an.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = an.toSlateNode(e, t.target), a = an.findPath(e, i);
    if (ta.isElement(i) && qn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = qn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? qn.before(e, u) : qn.after(e, u);
      if (c) {
        var p = qn.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = an.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = an.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = SU.get(t);
    return n || (n = new R_e(), SU.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = x_e.get(r);
      if (o == null) {
        if (qn.isEditor(r))
          return n;
        break;
      }
      var i = O_e.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(ki.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Eg.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          an.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = an.toDOMNode(e, e), r = an.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = _U(r), i = an.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Bm.select(e, qn.start(e, [])), Eg.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = E_e.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = an.toDOMNode(e, e), i;
    try {
      i = Ds(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Kv(t) && an.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return qn.hasPath(e, n.path) && qn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => an.hasEditableTarget(e, t) || an.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Kv(t) && an.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!S_e.get(e),
  isFocused: (e) => !!Eg.get(e),
  isReadOnly: (e) => !!MU.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (MU.get(e)) return !1;
    var n = an.hasTarget(e, t) && an.toSlateNode(e, t);
    return ta.isElement(n) && qn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = k_e.get(e), r = qn.isEditor(t) ? L_e.get(e) : n == null ? void 0 : n.get(an.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(ki.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = qn.node(e, t.path), r = an.toDOMNode(e, n), o;
    qn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof __e ? E : v,
            (g = v.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(ki.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Wt.isBackward(t), i = an.toDOMPoint(e, n), a = Wt.isCollapsed(t) ? i : an.toDOMPoint(e, r), s = an.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = Ds(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = Ds(p) ? p : p.parentElement, g = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Ds(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? P_e.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : T_e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = an.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && y.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = an.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (kC && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var z = v.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var R = z[L];
          if (an.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (E) {
        var B = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, W = [...B(H), ...B(H == null ? void 0 : H.nextElementSibling)];
          w = (V = W.find((M) => B_e(E, M))) !== null && V !== void 0 ? V : null;
        } else {
          var q, Y = [...B(H == null ? void 0 : H.previousElementSibling), ...B(H)];
          w = (q = Y.findLast((M) => jU(E, M))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      kC && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      xg && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (kC && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && an.hasDOMNode(e, X, {
        editable: !0
      })) {
        var ee = an.toSlateNode(e, X), {
          path: J,
          offset: k
        } = qn.start(e, an.findPath(e, ee));
        return X.querySelector("[data-slate-leaf]") || (k = s), {
          path: J,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = an.toSlateNode(e, u), U = an.findPath(e, _);
    return {
      path: U,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = DU(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (DU(t)) {
        if (xg && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, g = C(f.children[d.startOffset]), E = C(v.children[y.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        C_e && A_e(s) || xg ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    xg && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = an.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = jU(s, u) || s === u && c < l, x = p ? w : an.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Wt.isExpanded(m) && Wt.isForward(m) && Ds(u) && qn.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = qn.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, F_e = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, z_e = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, U_e = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Ir = (e) => {
  var t = F_e[e], n = z_e[e], r = U_e[e], o = t && xC(t), i = n && xC(n), a = r && xC(r);
  return (s) => !!(o && o(s) || kU && i && i(s) || !kU && a && a(s));
};
Ir("bold"), Ir("compose"), Ir("moveBackward"), Ir("moveForward"), Ir("deleteBackward"), Ir("deleteForward"), Ir("deleteLineBackward"), Ir("deleteLineForward"), Ir("deleteWordBackward"), Ir("deleteWordForward"), Ir("extendBackward"), Ir("extendForward"), Ir("extendLineBackward"), Ir("extendLineForward"), Ir("italic"), Ir("moveLineBackward"), Ir("moveLineForward"), Ir("moveWordBackward"), Ir("moveWordForward"), Ir("redo"), Ir("insertSoftBreak"), Ir("splitBlock"), Ir("transposeCharacter"), Ir("undo");
var W_e = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => TK(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, $_e = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class H_e extends $u {
  constructor() {
    super(...arguments), Qp(this, "context", null), Qp(this, "manager", null), Qp(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, $_e);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = W_e(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Qp(H_e, "contextType", w_e);
Ye({});
Ye({});
Ye({});
var fo = {}, LS = {}, kf = {}, Sf = {}, AK = "Expected a function", TU = NaN, V_e = "[object Symbol]", Z_e = /^\s+|\s+$/g, q_e = /^[-+]0x[0-9a-f]+$/i, K_e = /^0b[01]+$/i, G_e = /^0o[0-7]+$/i, Y_e = parseInt, X_e = typeof er == "object" && er && er.Object === Object && er, J_e = typeof self == "object" && self && self.Object === Object && self, Q_e = X_e || J_e || Function("return this")(), eje = Object.prototype, tje = eje.toString, nje = Math.max, rje = Math.min, SC = function() {
  return Q_e.Date.now();
};
function oje(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(AK);
  t = AU(t) || 0, Gv(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? nje(AU(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, z = o;
    return r = o = void 0, u = C, a = e.apply(z, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, z = C - u, L = t - S;
    return p ? rje(L, i - z) : L;
  }
  function g(C) {
    var S = C - l, z = C - u;
    return l === void 0 || S >= t || S < 0 || p && z >= i;
  }
  function E() {
    var C = SC();
    if (g(C))
      return w(C);
    s = setTimeout(E, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(SC());
  }
  function m() {
    var C = SC(), S = g(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), y(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function ije(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(AK);
  return Gv(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), oje(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Gv(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function sje(e) {
  return !!e && typeof e == "object";
}
function aje(e) {
  return typeof e == "symbol" || sje(e) && tje.call(e) == V_e;
}
function AU(e) {
  if (typeof e == "number")
    return e;
  if (aje(e))
    return TU;
  if (Gv(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Gv(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Z_e, "");
  var n = K_e.test(e);
  return n || G_e.test(e) ? Y_e(e.slice(2), n ? 2 : 8) : q_e.test(e) ? TU : +e;
}
var lje = ije, Mf = {};
Object.defineProperty(Mf, "__esModule", {
  value: !0
});
Mf.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), pm.has(t) || pm.set(t, /* @__PURE__ */ new Set());
  var o = pm.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Mf.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), pm.get(t).delete(n.name || t);
};
var pm = /* @__PURE__ */ new Map();
Object.defineProperty(Sf, "__esModule", {
  value: !0
});
var uje = lje, cje = dje(uje), pje = Mf;
function dje(e) {
  return e && e.__esModule ? e : { default: e };
}
var fje = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, cje.default)(e, t);
}, Zr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = fje(function(r) {
        Zr.scrollHandler(e);
      }, t);
      Zr.scrollSpyContainers.push(e), (0, pje.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Zr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Zr.scrollSpyContainers[Zr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Zr.currentPositionX(e), Zr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Zr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Zr.scrollSpyContainers[Zr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Zr.currentPositionX(t), Zr.currentPositionY(t));
  },
  updateStates: function() {
    Zr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Zr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Zr.spySetState && Zr.spySetState.length && Zr.spySetState.indexOf(e) > -1 && Zr.spySetState.splice(Zr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Zr.scrollHandler);
  },
  update: function() {
    return Zr.scrollSpyContainers.forEach(function(e) {
      return Zr.scrollHandler(e);
    });
  }
};
Sf.default = Zr;
var kc = {}, Df = {};
Object.defineProperty(Df, "__esModule", {
  value: !0
});
var hje = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, gje = function() {
  return window.location.hash.replace(/^#/, "");
}, mje = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, vje = function(e) {
  return getComputedStyle(e).position !== "static";
}, MC = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, yje = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (vje(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = MC(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return MC(t, s).offsetTop - MC(e, s).offsetTop;
};
Df.default = {
  updateHash: hje,
  getHash: gje,
  filterElementInContainer: mje,
  scrollOffset: yje
};
var $0 = {}, PS = {};
Object.defineProperty(PS, "__esModule", {
  value: !0
});
PS.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var kS = {};
Object.defineProperty(kS, "__esModule", {
  value: !0
});
var bje = Mf, wje = ["mousedown", "mousewheel", "touchmove", "keydown"];
kS.default = {
  subscribe: function(e) {
    return typeof document < "u" && wje.forEach(function(t) {
      return (0, bje.addPassiveEventListener)(document, t, e);
    });
  }
};
var _f = {};
Object.defineProperty(_f, "__esModule", {
  value: !0
});
var jE = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      jE.registered[e] = t;
    },
    remove: function(e) {
      jE.registered[e] = null;
    }
  }
};
_f.default = jE;
Object.defineProperty($0, "__esModule", {
  value: !0
});
var Cje = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Oje = Df;
H0(Oje);
var xje = PS, IU = H0(xje), Eje = kS, Lje = H0(Eje), Pje = _f, xs = H0(Pje);
function H0(e) {
  return e && e.__esModule ? e : { default: e };
}
var IK = function(e) {
  return IU.default[e.smooth] || IU.default.defaultEasing;
}, kje = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, Sje = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, TE = function() {
  return Sje() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), BK = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, NK = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, RK = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, Mje = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, Dje = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, _je = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    xs.default.registered.end && xs.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    TE.call(window, i);
    return;
  }
  xs.default.registered.end && xs.default.registered.end(o.to, o.target, o.currentPosition);
}, SS = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, jf = function(e, t, n, r) {
  t.data = t.data || BK(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (Lje.default.subscribe(o), SS(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? NK(t) : RK(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    xs.default.registered.end && xs.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = kje(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = IK(t), a = _je.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      xs.default.registered.begin && xs.default.registered.begin(t.data.to, t.data.target), TE.call(window, a);
    }, t.delay);
    return;
  }
  xs.default.registered.begin && xs.default.registered.begin(t.data.to, t.data.target), TE.call(window, a);
}, V0 = function(e) {
  return e = Cje({}, e), e.data = e.data || BK(), e.absolute = !0, e;
}, jje = function(e) {
  jf(0, V0(e));
}, Tje = function(e, t) {
  jf(e, V0(t));
}, Aje = function(e) {
  e = V0(e), SS(e), jf(e.horizontal ? Mje(e) : Dje(e), e);
}, Ije = function(e, t) {
  t = V0(t), SS(t);
  var n = t.horizontal ? NK(t) : RK(t);
  jf(e + n, t);
};
$0.default = {
  animateTopScroll: jf,
  getAnimationType: IK,
  scrollToTop: jje,
  scrollToBottom: Aje,
  scrollTo: Tje,
  scrollMore: Ije
};
Object.defineProperty(kc, "__esModule", {
  value: !0
});
var Bje = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Nje = Df, Rje = MS(Nje), Fje = $0, zje = MS(Fje), Uje = _f, Lg = MS(Uje);
function MS(e) {
  return e && e.__esModule ? e : { default: e };
}
var Pg = {}, BU = void 0;
kc.default = {
  unmount: function() {
    Pg = {};
  },
  register: function(e, t) {
    Pg[e] = t;
  },
  unregister: function(e) {
    delete Pg[e];
  },
  get: function(e) {
    return Pg[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return BU = e;
  },
  getActiveLink: function() {
    return BU;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = Bje({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = Rje.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Lg.default.registered.begin && Lg.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Lg.default.registered.end && Lg.default.registered.end(e, n);
      return;
    }
    zje.default.animateTopScroll(s, t, e, n);
  }
};
var AE = { exports: {} }, DC = { exports: {} }, An = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var NU;
function Wje() {
  if (NU) return An;
  NU = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return An.AsyncMode = l, An.ConcurrentMode = u, An.ContextConsumer = s, An.ContextProvider = a, An.Element = t, An.ForwardRef = c, An.Fragment = r, An.Lazy = f, An.Memo = y, An.Portal = n, An.Profiler = i, An.StrictMode = o, An.Suspense = p, An.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, An.isConcurrentMode = x, An.isContextConsumer = function(m) {
    return D(m) === s;
  }, An.isContextProvider = function(m) {
    return D(m) === a;
  }, An.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, An.isForwardRef = function(m) {
    return D(m) === c;
  }, An.isFragment = function(m) {
    return D(m) === r;
  }, An.isLazy = function(m) {
    return D(m) === f;
  }, An.isMemo = function(m) {
    return D(m) === y;
  }, An.isPortal = function(m) {
    return D(m) === n;
  }, An.isProfiler = function(m) {
    return D(m) === i;
  }, An.isStrictMode = function(m) {
    return D(m) === o;
  }, An.isSuspense = function(m) {
    return D(m) === p;
  }, An.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === g || m.$$typeof === E || m.$$typeof === w || m.$$typeof === v);
  }, An.typeOf = D, An;
}
var $n = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var RU;
function $je() {
  return RU || (RU = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === y || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === g || N.$$typeof === E || N.$$typeof === w || N.$$typeof === v);
    }
    function x(N) {
      if (typeof N == "object" && N !== null) {
        var ue = N.$$typeof;
        switch (ue) {
          case t:
            var fe = N.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var m = l, C = u, S = s, z = a, L = t, R = c, B = r, H = f, V = y, W = n, q = i, Y = o, X = p, ee = !1;
    function J(N) {
      return ee || (ee = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || x(N) === l;
    }
    function k(N) {
      return x(N) === u;
    }
    function _(N) {
      return x(N) === s;
    }
    function U(N) {
      return x(N) === a;
    }
    function M(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function $(N) {
      return x(N) === c;
    }
    function O(N) {
      return x(N) === r;
    }
    function j(N) {
      return x(N) === f;
    }
    function F(N) {
      return x(N) === y;
    }
    function T(N) {
      return x(N) === n;
    }
    function Z(N) {
      return x(N) === i;
    }
    function A(N) {
      return x(N) === o;
    }
    function G(N) {
      return x(N) === p;
    }
    $n.AsyncMode = m, $n.ConcurrentMode = C, $n.ContextConsumer = S, $n.ContextProvider = z, $n.Element = L, $n.ForwardRef = R, $n.Fragment = B, $n.Lazy = H, $n.Memo = V, $n.Portal = W, $n.Profiler = q, $n.StrictMode = Y, $n.Suspense = X, $n.isAsyncMode = J, $n.isConcurrentMode = k, $n.isContextConsumer = _, $n.isContextProvider = U, $n.isElement = M, $n.isForwardRef = $, $n.isFragment = O, $n.isLazy = j, $n.isMemo = F, $n.isPortal = T, $n.isProfiler = Z, $n.isStrictMode = A, $n.isSuspense = G, $n.isValidElementType = D, $n.typeOf = x;
  }()), $n;
}
var FU;
function FK() {
  return FU || (FU = 1, process.env.NODE_ENV === "production" ? DC.exports = Wje() : DC.exports = $je()), DC.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var _C, zU;
function Hje() {
  if (zU) return _C;
  zU = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return _C = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, _C;
}
var jC, UU;
function DS() {
  if (UU) return jC;
  UU = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return jC = e, jC;
}
var WU, $U;
function zK() {
  return $U || ($U = 1, WU = Function.call.bind(Object.prototype.hasOwnProperty)), WU;
}
var TC, HU;
function Vje() {
  if (HU) return TC;
  HU = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = DS(), n = {}, r = zK();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, TC = o, TC;
}
var AC, VU;
function Zje() {
  if (VU) return AC;
  VU = 1;
  var e = FK(), t = Hje(), n = DS(), r = zK(), o = Vje(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return AC = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var _ = k && (u && k[u] || k[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: z,
      oneOf: S,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(k, _) {
      return k === _ ? k !== 0 || 1 / k === 1 / _ : k !== k && _ !== _;
    }
    function v(k, _) {
      this.message = k, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function g(k) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, U = 0;
      function M(O, j, F, T, Z, A, G) {
        if (T = T || d, A = A || F, G !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + F;
            !_[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            U < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[ue] = !0, U++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + Z + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + Z + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : k(j, F, T, Z, A);
      }
      var $ = M.bind(null, !1);
      return $.isRequired = M.bind(null, !0), $;
    }
    function E(k) {
      function _(U, M, $, O, j, F) {
        var T = U[M], Z = Y(T);
        if (Z !== k) {
          var A = X(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return g(_);
    }
    function w() {
      return g(a);
    }
    function D(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var F = U[M];
        if (!Array.isArray(F)) {
          var T = Y(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var Z = 0; Z < F.length; Z++) {
          var A = k(F, Z, $, O, j + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(_);
    }
    function x() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!s(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(k);
    }
    function m() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!e.isValidElementType(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(k);
    }
    function C(k) {
      function _(U, M, $, O, j) {
        if (!(U[M] instanceof k)) {
          var F = k.name || d, T = J(U[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return g(_);
    }
    function S(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(U, M, $, O, j) {
        for (var F = U[M], T = 0; T < k.length; T++)
          if (f(F, k[T]))
            return null;
        var Z = JSON.stringify(k, function(A, G) {
          var N = X(G);
          return N === "symbol" ? String(G) : G;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + $ + "`, expected one of " + Z + "."));
      }
      return g(_);
    }
    function z(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var Z in F)
          if (r(F, Z)) {
            var A = k(F, Z, $, O, j + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(_);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < k.length; _++) {
        var U = k[_];
        if (typeof U != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ee(U) + " at index " + _ + "."
          ), a;
      }
      function M($, O, j, F, T) {
        for (var Z = [], A = 0; A < k.length; A++) {
          var G = k[A], N = G($, O, j, F, T, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && Z.push(N.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return g(M);
    }
    function R() {
      function k(_, U, M, $, O) {
        return W(_[U]) ? null : new v("Invalid " + $ + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return g(k);
    }
    function B(k, _, U, M, $) {
      return new v(
        (k || "React class") + ": " + _ + " type `" + U + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function H(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var Z in k) {
          var A = k[Z];
          if (typeof A != "function")
            return B($, O, j, Z, X(A));
          var G = A(F, Z, $, O, j + "." + Z, n);
          if (G)
            return G;
        }
        return null;
      }
      return g(_);
    }
    function V(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var Z = t({}, U[M], k);
        for (var A in Z) {
          var G = k[A];
          if (r(k, A) && typeof G != "function")
            return B($, O, j, A, X(G));
          if (!G)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(U[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = G(F, A, $, O, j + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return g(_);
    }
    function W(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(W);
          if (k === null || s(k))
            return !0;
          var _ = p(k);
          if (_) {
            var U = _.call(k), M;
            if (_ !== k.entries) {
              for (; !(M = U.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = U.next()).done; ) {
                var $ = M.value;
                if ($ && !W($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(k, _) {
      return k === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function Y(k) {
      var _ = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : q(_, k) ? "symbol" : _;
    }
    function X(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var _ = Y(k);
      if (_ === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function ee(k) {
      var _ = X(k);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, AC;
}
var IC, ZU;
function qje() {
  if (ZU) return IC;
  ZU = 1;
  var e = DS();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, IC = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, IC;
}
if (process.env.NODE_ENV !== "production") {
  var Kje = FK(), Gje = !0;
  AE.exports = Zje()(Kje.isElement, Gje);
} else
  AE.exports = qje()();
var Z0 = AE.exports, q0 = {};
Object.defineProperty(q0, "__esModule", {
  value: !0
});
var Yje = Df, BC = Xje(Yje);
function Xje(e) {
  return e && e.__esModule ? e : { default: e };
}
var Jje = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return BC.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && BC.default.getHash() !== e && BC.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
q0.default = Jje;
Object.defineProperty(kf, "__esModule", {
  value: !0
});
var kg = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Qje = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), eTe = Ce, qU = Tf(eTe), tTe = Sf, Sg = Tf(tTe), nTe = kc, rTe = Tf(nTe), oTe = Z0, Br = Tf(oTe), iTe = q0, _a = Tf(iTe);
function Tf(e) {
  return e && e.__esModule ? e : { default: e };
}
function sTe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function aTe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function lTe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var KU = {
  to: Br.default.string.isRequired,
  containerId: Br.default.string,
  container: Br.default.object,
  activeClass: Br.default.string,
  activeStyle: Br.default.object,
  spy: Br.default.bool,
  horizontal: Br.default.bool,
  smooth: Br.default.oneOfType([Br.default.bool, Br.default.string]),
  offset: Br.default.number,
  delay: Br.default.number,
  isDynamic: Br.default.bool,
  onClick: Br.default.func,
  duration: Br.default.oneOfType([Br.default.number, Br.default.func]),
  absolute: Br.default.bool,
  onSetActive: Br.default.func,
  onSetInactive: Br.default.func,
  ignoreCancelEvents: Br.default.bool,
  hashSpy: Br.default.bool,
  saveHashHistory: Br.default.bool,
  spyThrottle: Br.default.number
};
kf.default = function(e, t) {
  var n = t || rTe.default, r = function(i) {
    lTe(a, i);
    function a(s) {
      sTe(this, a);
      var l = aTe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return Qje(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Sg.default.isMounted(s) || Sg.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (_a.default.isMounted() || _a.default.mount(n), _a.default.mapContainer(this.props.to, s)), Sg.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Sg.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = kg({}, this.props.style, this.props.activeStyle) : l = kg({}, this.props.style);
        var u = kg({}, this.props);
        for (var c in KU)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, qU.default.createElement(e, u);
      }
    }]), a;
  }(qU.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, kg({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(_a.default.isMounted() && !_a.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, g = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            g = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - g + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            x = z.top - C + s, m = x + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(m), y = L < Math.floor(x) || L >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && _a.default.getHash() === c) {
            var B = i.props.saveHashHistory, H = B === void 0 ? !1 : B;
            _a.default.changeHash("", H);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, W = V === void 0 ? !1 : V;
          i.props.hashSpy && _a.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = KU, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(LS, "__esModule", {
  value: !0
});
var uTe = Ce, GU = UK(uTe), cTe = kf, pTe = UK(cTe);
function UK(e) {
  return e && e.__esModule ? e : { default: e };
}
function dTe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function YU(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function fTe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var hTe = function(e) {
  fTe(t, e);
  function t() {
    var n, r, o, i;
    dTe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = YU(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return GU.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), YU(o, i);
  }
  return t;
}(GU.default.Component);
LS.default = (0, pTe.default)(hTe);
var _S = {};
Object.defineProperty(_S, "__esModule", {
  value: !0
});
var gTe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), mTe = Ce, XU = WK(mTe), vTe = kf, yTe = WK(vTe);
function WK(e) {
  return e && e.__esModule ? e : { default: e };
}
function bTe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function wTe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function CTe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var OTe = function(e) {
  CTe(t, e);
  function t() {
    return bTe(this, t), wTe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return gTe(t, [{
    key: "render",
    value: function() {
      return XU.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(XU.default.Component);
_S.default = (0, yTe.default)(OTe);
var jS = {}, K0 = {};
Object.defineProperty(K0, "__esModule", {
  value: !0
});
var xTe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, ETe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), LTe = Ce, JU = G0(LTe), PTe = pl;
G0(PTe);
var kTe = kc, QU = G0(kTe), STe = Z0, eW = G0(STe);
function G0(e) {
  return e && e.__esModule ? e : { default: e };
}
function MTe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function DTe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function _Te(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
K0.default = function(e) {
  var t = function(n) {
    _Te(r, n);
    function r(o) {
      MTe(this, r);
      var i = DTe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return ETe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        QU.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        QU.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return JU.default.createElement(e, xTe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(JU.default.Component);
  return t.propTypes = {
    name: eW.default.string,
    id: eW.default.string
  }, t;
};
Object.defineProperty(jS, "__esModule", {
  value: !0
});
var tW = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, jTe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), TTe = Ce, nW = TS(TTe), ATe = K0, ITe = TS(ATe), BTe = Z0, rW = TS(BTe);
function TS(e) {
  return e && e.__esModule ? e : { default: e };
}
function NTe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function RTe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function FTe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var $K = function(e) {
  FTe(t, e);
  function t() {
    return NTe(this, t), RTe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return jTe(t, [{
    key: "render",
    value: function() {
      var n = this, r = tW({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, nW.default.createElement(
        "div",
        tW({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(nW.default.Component);
$K.propTypes = {
  name: rW.default.string,
  id: rW.default.string
};
jS.default = (0, ITe.default)($K);
var NC = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, oW = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function iW(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function sW(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function aW(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Mg = Ce, Wl = Sf, RC = kc, Qr = Z0, ja = q0, lW = {
  to: Qr.string.isRequired,
  containerId: Qr.string,
  container: Qr.object,
  activeClass: Qr.string,
  spy: Qr.bool,
  smooth: Qr.oneOfType([Qr.bool, Qr.string]),
  offset: Qr.number,
  delay: Qr.number,
  isDynamic: Qr.bool,
  onClick: Qr.func,
  duration: Qr.oneOfType([Qr.number, Qr.func]),
  absolute: Qr.bool,
  onSetActive: Qr.func,
  onSetInactive: Qr.func,
  ignoreCancelEvents: Qr.bool,
  hashSpy: Qr.bool,
  spyThrottle: Qr.number
}, zTe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || RC, r = function(i) {
      aW(a, i);
      function a(s) {
        iW(this, a);
        var l = sW(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return oW(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Wl.isMounted(s) || Wl.mount(s, this.props.spyThrottle), this.props.hashSpy && (ja.isMounted() || ja.mount(n), ja.mapContainer(this.props.to, s)), this.props.spy && Wl.addStateHandler(this.stateHandler), Wl.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Wl.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = NC({}, this.props);
          for (var u in lW)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Mg.createElement(e, l);
        }
      }]), a;
    }(Mg.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, NC({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(ja.isMounted() && !ja.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, g = v >= Math.floor(c) && v < Math.floor(p), E = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && ja.getHash() === l && ja.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Wl.updateStates();
          if (g && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && ja.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Wl.updateStates();
        }
      };
    };
    return r.propTypes = lW, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      aW(r, n);
      function r(o) {
        iW(this, r);
        var i = sW(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return oW(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          RC.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          RC.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Mg.createElement(e, NC({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Mg.Component);
    return t.propTypes = {
      name: Qr.string,
      id: Qr.string
    }, t;
  }
}, UTe = zTe;
Object.defineProperty(fo, "__esModule", {
  value: !0
});
fo.Helpers = fo.ScrollElement = fo.ScrollLink = fo.animateScroll = fo.scrollSpy = fo.Events = fo.scroller = fo.Element = fo.Button = fo.Link = void 0;
var WTe = LS, HK = Ns(WTe), $Te = _S, VK = Ns($Te), HTe = jS, ZK = Ns(HTe), VTe = kc, qK = Ns(VTe), ZTe = _f, KK = Ns(ZTe), qTe = Sf, GK = Ns(qTe), KTe = $0, YK = Ns(KTe), GTe = kf, XK = Ns(GTe), YTe = K0, JK = Ns(YTe), XTe = UTe, QK = Ns(XTe);
function Ns(e) {
  return e && e.__esModule ? e : { default: e };
}
fo.Link = HK.default;
fo.Button = VK.default;
fo.Element = ZK.default;
fo.scroller = qK.default;
fo.Events = KK.default;
fo.scrollSpy = GK.default;
fo.animateScroll = YK.default;
fo.ScrollLink = XK.default;
fo.ScrollElement = JK.default;
fo.Helpers = QK.default;
fo.default = { Link: HK.default, Button: VK.default, Element: ZK.default, scroller: qK.default, Events: KK.default, scrollSpy: GK.default, animateScroll: YK.default, ScrollLink: XK.default, ScrollElement: JK.default, Helpers: QK.default };
Ye({});
Ye({});
Ye({});
function Hd(e) {
  "@babel/helpers - typeof";
  return Hd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Hd(e);
}
function JTe(e, t) {
  if (Hd(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Hd(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function QTe(e) {
  var t = JTe(e, "string");
  return Hd(t) == "symbol" ? t : t + "";
}
function Pe(e, t, n) {
  return (t = QTe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function eG(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var FC, uW;
function eAe() {
  if (uW) return FC;
  uW = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return FC = t, FC;
}
var tAe = eAe(), Oo = /* @__PURE__ */ eG(tAe), Rt = Ye(null);
function nAe() {
  Oo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Rt);
  return Oo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function rAe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function oAe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function iAe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return oAe(e, i), o;
}
function sAe(e, t, n) {
  var r = rAe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function aAe(e) {
  google.maps.event.removeListener(e);
}
function bn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(aAe);
}
function fn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = sAe(o, i, n);
  return iAe(t, r, o, i), a;
}
function lAe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = P(null), S = dt(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null), [A, G] = P(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && g && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(m, "mouseup", g)));
  }, [g]), h(() => {
    m && E && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", E)));
  }, [E]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), G(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var N = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(N), N !== null && D && D(N), () => {
      N !== null && x && x(N);
    };
  }, []), oi.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: oi.jsx(Rt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
ve(lAe);
function cW(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function tG(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        cW(i, r, o, a, s, "next", l);
      }
      function s(l) {
        cW(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function nG(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Oo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var hu = typeof document < "u";
function rG(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return hu ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function pW(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function oG() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return pW(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return pW(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var sp = !1;
function iG() {
  return oi.jsx("div", {
    children: "Loading..."
  });
}
var IE = {
  id: "script-loader",
  version: "weekly"
};
class uAe extends pe {
  constructor() {
    super(...arguments), Pe(this, "check", ir()), Pe(this, "state", {
      loaded: !1
    }), Pe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), Pe(this, "isCleaningUp", /* @__PURE__ */ tG(function* () {
      function t(n) {
        if (!sp)
          n();
        else if (hu)
          var r = window.setInterval(function() {
            sp || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), Pe(this, "cleanup", () => {
      sp = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), Pe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && oG(), Oo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: nG(this.props)
      };
      rG(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (hu) {
      if (window.google && window.google.maps && !sp) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), hu && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (hu) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, sp = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return oi.jsxs(oi.Fragment, {
      children: [oi.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || oi.jsx(iG, {})]
    });
  }
}
Pe(uAe, "defaultProps", IE);
function cAe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function AS(e, t) {
  if (e == null) return {};
  var n, r, o = cAe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var dW;
function pAe(e) {
  var {
    id: t = IE.id,
    version: n = IE.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = dt(!1), [f, v] = P(!1), [g, E] = P(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    hu && u && oG();
  }, [u]), h(function() {
    f && Oo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = nG({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!hu)
      return;
    function x() {
      y.current && (v(!0), dW = w);
    }
    if (window.google && window.google.maps && dW === w) {
      x();
      return;
    }
    rG({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && E(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = dt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var dAe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], fAe = oi.jsx(iG, {});
function hAe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = AS(e, dAe), {
    isLoaded: s,
    loadError: l
  } = pAe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || fAe;
}
ve(hAe);
var fW;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(fW || (fW = {}));
function hW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? hW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : hW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gW = {}, mW = {
  options(e, t) {
    e.setOptions(t);
  }
};
function gAe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Rt), [i, a] = P(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(Yv(Yv({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(gAe);
class mAe extends pe {
  constructor() {
    super(...arguments), Pe(this, "state", {
      trafficLayer: null
    }), Pe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), Pe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(Yv(Yv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = fn({
      updaterMap: mW,
      eventMap: gW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: mW,
      eventMap: gW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), bn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(mAe, "contextType", Rt);
function vAe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Rt), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(vAe);
class yAe extends pe {
  constructor() {
    super(...arguments), Pe(this, "state", {
      bicyclingLayer: null
    }), Pe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(yAe, "contextType", Rt);
function bAe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Rt), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(bAe);
class wAe extends pe {
  constructor() {
    super(...arguments), Pe(this, "state", {
      transitLayer: null
    }), Pe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(wAe, "contextType", Rt);
function vW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yW = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, bW = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function CAe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Rt), [d, y] = P(null), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Oo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(Xv(Xv({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && E(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && L(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(CAe);
class OAe extends pe {
  constructor(t) {
    super(t), Pe(this, "registeredEvents", []), Pe(this, "state", {
      drawingManager: null
    }), Pe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Oo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(Xv(Xv({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = fn({
      updaterMap: bW,
      eventMap: yW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: bW,
      eventMap: yW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), bn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(OAe, "contextType", Rt);
function wW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ju(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? wW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : wW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var CW = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, OW = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Jv = {};
function xAe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: R,
    onClickableChanged: B,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: W,
    onFlatChanged: q,
    onIconChanged: Y,
    onPositionChanged: X,
    onShapeChanged: ee,
    onTitleChanged: J,
    onVisibleChanged: k,
    onZindexChanged: _,
    onLoad: U,
    onUnmount: M
  } = e, $ = ge(Rt), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null), [oe, Ie] = P(null), [qe, Ge] = P(null), [Be, et] = P(null), [Xe, Me] = P(null), [Je, at] = P(null), [Se, _e] = P(null), [Ae, Ve] = P(null), [Ne, nt] = P(null), [we, mt] = P(null), [ot, st] = P(null), [ut, vt] = P(null), [ct, yt] = P(null), [Qe, ft] = P(null), [tt, bt] = P(null), [pt, Dt] = P(null), [wt, _t] = P(null), [Ct, jt] = P(null);
  h(() => {
    O !== null && O.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ie(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (qe !== null && google.maps.event.removeListener(qe), Ge(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && z && (Be !== null && google.maps.event.removeListener(Be), et(google.maps.event.addListener(O, "mouseup", z)));
  }, [z]), h(() => {
    O && R && (Xe !== null && google.maps.event.removeListener(Xe), Me(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && E && (Je !== null && google.maps.event.removeListener(Je), at(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && D && (Se !== null && google.maps.event.removeListener(Se), _e(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && B && (Ae !== null && google.maps.event.removeListener(Ae), Ve(google.maps.event.addListener(O, "clickable_changed", B)));
  }, [B]), h(() => {
    O && H && (Ne !== null && google.maps.event.removeListener(Ne), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), h(() => {
    O && V && (we !== null && google.maps.event.removeListener(we), mt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && W && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && q && (ut !== null && google.maps.event.removeListener(ut), vt(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), h(() => {
    O && Y && (ct !== null && google.maps.event.removeListener(ct), yt(google.maps.event.addListener(O, "icon_changed", Y)));
  }, [Y]), h(() => {
    O && X && (Qe !== null && google.maps.event.removeListener(Qe), ft(google.maps.event.addListener(O, "position_changed", X)));
  }, [X]), h(() => {
    O && ee && (tt !== null && google.maps.event.removeListener(tt), bt(google.maps.event.addListener(O, "shape_changed", ee)));
  }, [ee]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Dt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && k && (wt !== null && google.maps.event.removeListener(wt), _t(google.maps.event.addListener(O, "visible_changed", k)));
  }, [k]), h(() => {
    O && _ && (Ct !== null && google.maps.event.removeListener(Ct), jt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var ht = Ju(Ju(Ju({}, n || Jv), r ? Jv : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof y < "u" && re.setOpacity(y), f && re.setShape(f), typeof v == "string" && re.setTitle(v), typeof g == "number" && re.setZIndex(g), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), m && N(google.maps.event.addListener(re, "dragstart", m)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ie(google.maps.event.addListener(re, "mouseout", C)), S && Ge(google.maps.event.addListener(re, "mouseover", S)), z && et(google.maps.event.addListener(re, "mouseup", z)), R && Me(google.maps.event.addListener(re, "rightclick", R)), E && at(google.maps.event.addListener(re, "click", E)), D && _e(google.maps.event.addListener(re, "drag", D)), B && Ve(google.maps.event.addListener(re, "clickable_changed", B)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && mt(google.maps.event.addListener(re, "animation_changed", V)), W && st(google.maps.event.addListener(re, "draggable_changed", W)), q && vt(google.maps.event.addListener(re, "flat_changed", q)), Y && yt(google.maps.event.addListener(re, "icon_changed", Y)), X && ft(google.maps.event.addListener(re, "position_changed", X)), ee && bt(google.maps.event.addListener(re, "shape_changed", ee)), J && Dt(google.maps.event.addListener(re, "title_changed", J)), k && _t(google.maps.event.addListener(re, "visible_changed", k)), _ && jt(google.maps.event.addListener(re, "zindex_changed", _)), j(re), U && U(re), () => {
      F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), qe !== null && google.maps.event.removeListener(qe), Be !== null && google.maps.event.removeListener(Be), Xe !== null && google.maps.event.removeListener(Xe), Je !== null && google.maps.event.removeListener(Je), Ae !== null && google.maps.event.removeListener(Ae), Ne !== null && google.maps.event.removeListener(Ne), we !== null && google.maps.event.removeListener(we), ot !== null && google.maps.event.removeListener(ot), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), Qe !== null && google.maps.event.removeListener(Qe), pt !== null && google.maps.event.removeListener(pt), wt !== null && google.maps.event.removeListener(wt), Ct !== null && google.maps.event.removeListener(Ct), M && M(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Cn = On(() => i ? lt.map(i, (ht) => {
    if (!mi(ht))
      return ht;
    var re = ht;
    return vi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return oi.jsx(oi.Fragment, {
    children: Cn
  }) || null;
}
ve(xAe);
class EAe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return tG(function* () {
      var n = Ju(Ju(Ju({}, t.props.options || Jv), t.props.clusterer ? Jv : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = fn({
        updaterMap: OW,
        eventMap: CW,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: OW,
      eventMap: CW,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), bn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
Pe(EAe, "contextType", Rt);
var LAe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), PAe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new LAe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function kAe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var SAe = 2e3, MAe = 500, DAe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", _Ae = "png", jAe = [53, 56, 66, 78, 90], TAe = "cluster", sG = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || DAe, this.imageExtension = r.imageExtension || _Ae, this.imageSizes = r.imageSizes || jAe, this.calculator = r.calculator || kAe, this.batchSize = r.batchSize || SAe, this.batchSizeIE = r.batchSizeIE || MAe, this.clusterClass = r.clusterClass || TAe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new PAe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function xW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function AAe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? xW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : xW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var os = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, kn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, IAe = {};
function BAe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: z
  } = e, [L, R] = P(null), B = ge(Rt), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null);
  return h(() => {
    L && C && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(L, os.onMouseOut, C)));
  }, [C]), h(() => {
    L && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(L, os.onMouseOver, m)));
  }, [m]), h(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, os.onClick, w)));
  }, [w]), h(() => {
    L && D && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(L, os.onClusteringBegin, D)));
  }, [D]), h(() => {
    L && x && (Y !== null && google.maps.event.removeListener(Y), q(google.maps.event.addListener(L, os.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && kn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && kn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && kn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && kn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && kn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && kn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && kn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && kn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && kn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && kn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof y < "u" && L !== null && kn.maxZoom(L, y);
  }, [L, y]), h(() => {
    typeof f < "u" && L !== null && kn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof v < "u" && L !== null && kn.styles(L, v);
  }, [L, v]), h(() => {
    typeof g < "u" && L !== null && kn.title(L, g);
  }, [L, g]), h(() => {
    typeof E < "u" && L !== null && kn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (B) {
      var U = AAe({}, n || IAe), M = new sG(B, [], U);
      return r && kn.averageCenter(M, r), o && kn.batchSizeIE(M, o), i && kn.calculator(M, i), a && kn.clusterClass(M, a), s && kn.enableRetinaIcons(M, s), l && kn.gridSize(M, l), u && kn.ignoreHidden(M, u), c && kn.imageExtension(M, c), p && kn.imagePath(M, p), d && kn.imageSizes(M, d), y && kn.maxZoom(M, y), f && kn.minimumClusterSize(M, f), v && kn.styles(M, v), g && kn.title(M, g), E && kn.zoomOnClick(M, E), C && J(google.maps.event.addListener(M, os.onMouseOut, C)), m && _(google.maps.event.addListener(M, os.onMouseOver, m)), w && V(google.maps.event.addListener(M, os.onClick, w)), D && q(google.maps.event.addListener(M, os.onClusteringBegin, D)), x && X(google.maps.event.addListener(M, os.onClusteringEnd, x)), R(M), S && S(M), () => {
        ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), z && z(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(BAe);
class NAe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      markerClusterer: null
    }), Pe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new sG(this.context, [], this.props.options);
      this.registeredEvents = fn({
        updaterMap: kn,
        eventMap: os,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: kn,
      eventMap: os,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), bn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
Pe(NAe, "contextType", Rt);
function EW(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var aG = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || EW(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, EW));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), g = v.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + y ? r = g.x + u - y : g.x + p + u + y > s && (r = g.x + p + u + y - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), RAe = ["position"], FAe = ["position"];
function LW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qv(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PW = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, kW = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, zAe = {};
function UAe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Rt), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var B = r || zAe, {
        position: H
      } = B, V = AS(B, RAe), W;
      H && !(H instanceof google.maps.LatLng) && (W = new google.maps.LatLng(H.lat, H.lng));
      var q = new aG(Qv(Qv({}, V), W ? {
        position: W
      } : {}));
      R.current = document.createElement("div"), v(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && D(google.maps.event.addListener(q, "domready", s)), l && m(google.maps.event.addListener(q, "content_changed", l)), u && S(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(R.current), n ? q.open(y, n) : q.getPosition() ? q.open(y) : Oo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(UAe);
class WAe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "containerElement", null), Pe(this, "state", {
      infoBox: null
    }), Pe(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Oo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), Pe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = AS(t, FAe), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new aG(Qv(Qv({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = fn({
      updaterMap: kW,
      eventMap: PW,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: kW,
      eventMap: PW,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), bn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
Pe(WAe, "contextType", Rt);
var SW, MW;
function $Ae() {
  return MW || (MW = 1, SW = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), SW;
}
var HAe = $Ae(), DW = /* @__PURE__ */ eG(HAe), _W = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], zC = 1, ap = 8;
class IS {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== zC)
      throw new Error("Got v".concat(o, " data when expected v").concat(zC, "."));
    var i = _W[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new IS(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = _W.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, ap, t), this.coords = new this.ArrayType(this.data, ap + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(ap + a + s + l), this.ids = new this.IndexArrayType(this.data, ap, t), this.coords = new this.ArrayType(this.data, ap + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (zC << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return BE(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          jW(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], g = i[2 * f + 1];
      jW(v, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function BE(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    lG(e, t, a, r, o, i), BE(e, t, n, r, a - 1, 1 - i), BE(e, t, n, a + 1, o, 1 - i);
  }
}
function lG(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      lG(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (lp(e, t, r, n), t[2 * o + i] > y && lp(e, t, r, o); f < v; ) {
      for (lp(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? lp(e, t, r, v) : (v++, lp(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function lp(e, t, n, r) {
  UC(e, n, r), UC(t, 2 * n, 2 * r), UC(t, 2 * n + 1, 2 * r + 1);
}
function UC(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function jW(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var VAe = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, TW = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), $l = 2, Ga = 3, WC = 4, Wa = 5, uG = 6;
class ZAe {
  constructor(t) {
    this.options = Object.assign(Object.create(VAe), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = TW(Dg(u)), d = TW(_g(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Dg(r), _g(a), Dg(i), _g(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Wa] > 1 ? AW(p, f, this.clusterProps) : this.points[p[f + Ga]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + WC] === t && p.push(a[y + Wa] > 1 ? AW(a, y, this.clusterProps) : this.points[a[y + Ga]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new IS(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Wa] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = cG(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Ga]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = Dg(f), d = _g(v);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Ga] : E = this.points[n[l + Ga]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + $l] <= n)) {
        l[p + $l] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Wa], g = v;
        for (var E of f) {
          var w = E * c;
          l[w + $l] > n && (g += l[w + Wa]);
        }
        if (g > v && g >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + $l] <= n)) {
              l[L + $l] = n;
              var R = l[L + Wa];
              D += l[L] * R, x += l[L + 1] * R, l[L + WC] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, L)));
            }
          }
          l[p + WC] = S, u.push(D / g, x / g, 1 / 0, S, -1, g), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + $l] <= n)) {
                l[V + $l] = n;
                for (var W = 0; W < c; W++) u.push(l[V + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Wa] > 1) {
      var o = this.clusterProps[t[n + uG]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Ga]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function AW(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Ga],
    properties: cG(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [qAe(e[t]), KAe(e[t + 1])]
    }
  };
}
function cG(e, t, n) {
  var r = e[t + Wa], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + uG], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Ga],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Dg(e) {
  return e / 360 + 0.5;
}
function _g(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function qAe(e) {
  return (e - 0.5) * 360;
}
function KAe(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function GAe(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Bi {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class NE {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Bi.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Bi.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Bi.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class YAe {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return XAe(n);
  }
}
var XAe = (e) => {
  var t = e.map((n) => new NE({
    position: Bi.getPosition(n),
    markers: [n]
  }));
  return t;
};
class JAe extends YAe {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = GAe(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new ZAe(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!DW(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Bi.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !DW(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new NE({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new NE({
      markers: [i],
      position: Bi.getPosition(i)
    });
  }
}
class QAe {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class eIe {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Bi.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function tIe(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class BS {
  constructor() {
    tIe(BS, google.maps.OverlayView);
  }
}
var ed;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(ed || (ed = {}));
var nIe = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class rIe extends BS {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new JAe(o),
      renderer: a = new eIe(),
      onClusterClick: s = nIe
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Bi.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, ed.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Bi.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Bi.setMap(l, null)));
      }
      google.maps.event.trigger(this, ed.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Bi.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new QAe(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Bi.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, ed.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Bi.setMap(r.marker, n);
    });
  }
}
function IW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function BW(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? IW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : IW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function oIe(e) {
  var t = nAe(), [n, r] = P(null);
  return h(() => {
    if (t && n === null) {
      var o = new rIe(BW(BW({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function iIe(e) {
  var {
    children: t,
    options: n
  } = e, r = oIe(n);
  return r !== null ? t(r) : null;
}
ve(iIe);
var NW = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, RW = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function sIe(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Rt), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var B = new google.maps.InfoWindow(r);
    return v(B), R.current = document.createElement("div"), a && E(google.maps.event.addListener(B, "closeclick", a)), s && D(google.maps.event.addListener(B, "domready", s)), l && m(google.maps.event.addListener(B, "content_changed", l)), u && S(google.maps.event.addListener(B, "position_changed", u)), c && L(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(R.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(y, n) : B.getPosition() ? B.open(y) : Oo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(B), B.close();
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(sIe);
class aIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "containerElement", null), Pe(this, "state", {
      infoWindow: null
    }), Pe(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Oo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), Pe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = fn({
      updaterMap: RW,
      eventMap: NW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: RW,
      eventMap: NW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (bn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
Pe(aIe, "contextType", Rt);
function FW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ey(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? FW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : FW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var zW = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, UW = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, lIe = {};
function uIe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, D = ge(Rt), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && g && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", g)));
  }, [g]), h(() => {
    var T = new google.maps.Polyline(ey(ey({}, t || lIe), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && B(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && q(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), g && F(google.maps.event.addListener(T, "drag", g)), m(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(uIe);
class cIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      polyline: null
    }), Pe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(ey(ey({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = fn({
      updaterMap: UW,
      eventMap: zW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: UW,
      eventMap: zW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), bn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(cIe, "contextType", Rt);
function WW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $W(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var HW = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, VW = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function pIe(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Rt), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof g == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", g)));
  }, [g]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon($W($W({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), g && F(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), S(A), w && w(A), () => {
      z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), D && D(A), A.setMap(null);
    };
  }, []), null;
}
ve(pIe);
class dIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = fn({
      updaterMap: VW,
      eventMap: HW,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: VW,
      eventMap: HW,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), bn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(dIe, "contextType", Rt);
function ZW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ty(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qW = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, KW = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function fIe(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Rt), [m, C] = P(null), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), z(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", g)));
  }, [g]), h(() => {
    m && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(m, "bounds_changed", E)));
  }, [E]), h(() => {
    var G = new google.maps.Rectangle(ty(ty({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && G.setVisible(i), typeof o < "u" && G.setEditable(o), typeof r < "u" && G.setDraggable(r), typeof n < "u" && G.setBounds(n), a && z(google.maps.event.addListener(G, "dblclick", a)), s && R(google.maps.event.addListener(G, "dragend", s)), l && H(google.maps.event.addListener(G, "dragstart", l)), u && W(google.maps.event.addListener(G, "mousedown", u)), c && Y(google.maps.event.addListener(G, "mousemove", c)), p && ee(google.maps.event.addListener(G, "mouseout", p)), d && k(google.maps.event.addListener(G, "mouseover", d)), y && U(google.maps.event.addListener(G, "mouseup", y)), f && $(google.maps.event.addListener(G, "rightclick", f)), v && j(google.maps.event.addListener(G, "click", v)), g && T(google.maps.event.addListener(G, "drag", g)), E && A(google.maps.event.addListener(G, "bounds_changed", E)), C(G), w && w(G), () => {
      S !== null && google.maps.event.removeListener(S), L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), D && D(G), G.setMap(null);
    };
  }, []), null;
}
ve(fIe);
class hIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      rectangle: null
    }), Pe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(ty(ty({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = fn({
      updaterMap: KW,
      eventMap: qW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: KW,
      eventMap: qW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), bn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(hIe, "contextType", Rt);
function GW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ny(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var YW = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, XW = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, gIe = {};
function mIe(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Rt), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", g)));
  }, [g]), h(() => {
    S && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(S, "drag", E)));
  }, [E]), h(() => {
    S && w && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(S, "center_changed", w)));
  }, [g]), h(() => {
    S && D && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(ny(ny({}, t || gIe), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && R(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && Y(google.maps.event.addListener(oe, "mousedown", c)), p && ee(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), y && U(google.maps.event.addListener(oe, "mouseover", y)), f && $(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), g && T(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && N(google.maps.event.addListener(oe, "center_changed", w)), D && fe(google.maps.event.addListener(oe, "radius_changed", D)), z(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(mIe);
class vIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      circle: null
    }), Pe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(ny(ny({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = fn({
      updaterMap: XW,
      eventMap: YW,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: XW,
      eventMap: YW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), bn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
Pe(vIe, "contextType", Rt);
function JW(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ry(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JW(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JW(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var QW = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, e$ = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function yIe(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: g
  } = e, E = ge(Rt), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(ry(ry({}, t), {}, {
        map: E
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && B(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && Z(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), g && g(w), w.setMap(null));
    };
  }, []), null;
}
ve(yIe);
class bIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      data: null
    }), Pe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(ry(ry({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = fn({
        updaterMap: e$,
        eventMap: QW,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: e$,
      eventMap: QW,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), bn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(bIe, "contextType", Rt);
function t$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function n$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? t$(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : t$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var r$ = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, o$ = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class wIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      kmlLayer: null
    }), Pe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(n$(n$({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = fn({
      updaterMap: o$,
      eventMap: r$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: o$,
      eventMap: r$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), bn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(wIe, "contextType", Rt);
function pG(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function CIe(e, t) {
  return new t(e.lat, e.lng);
}
function OIe(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function xIe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function EIe(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function LIe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function PIe(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function dG(e, t, n, r) {
  return n !== void 0 ? LIe(e, t, EIe(n, google.maps.LatLngBounds, OIe)) : PIe(e, t, xIe(r, google.maps.LatLng, CIe));
}
function kIe(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function i$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function SIe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? i$(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : i$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function MIe(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = SIe({}, this.container ? pG(this.container, o) : {
        x: 0,
        y: 0
      }), u = dG(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function s$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function DIe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? s$(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : s$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function a$(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function l$(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function _Ie(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Rt), c = On(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = On(() => MIe(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
ve(_Ie);
class Sc extends pe {
  constructor(t) {
    super(t), Pe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), Pe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Oo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), Pe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), Pe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = DIe({
        x: 0,
        y: 0
      }, this.containerRef.current ? pG(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = dG(r, o, this.props.bounds, this.props.position);
      if (!kIe(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), Pe(this, "draw", () => {
      this.onPositionElement();
    }), Pe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = ir();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = a$(t.position), r = a$(this.props.position), o = l$(t.bounds), i = l$(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(oi.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
Pe(Sc, "FLOAT_PANE", "floatPane");
Pe(Sc, "MAP_PANE", "mapPane");
Pe(Sc, "MARKER_LAYER", "markerLayer");
Pe(Sc, "OVERLAY_LAYER", "overlayLayer");
Pe(Sc, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
Pe(Sc, "contextType", Rt);
function jIe() {
}
function u$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function c$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? u$(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : u$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var p$ = {
  onDblClick: "dblclick",
  onClick: "click"
}, d$ = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function TIe(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Rt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = On(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(TIe);
class fG extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      groundOverlay: null
    }), Pe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Oo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, c$(c$({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = fn({
      updaterMap: d$,
      eventMap: p$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: d$,
      eventMap: p$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(fG, "defaultProps", {
  onLoad: jIe
});
Pe(fG, "contextType", Rt);
function f$(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function oy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? f$(Object(n), !0).forEach(function(r) {
      Pe(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : f$(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var h$ = {}, g$ = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function AIe(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Rt), [a, s] = P(null);
  return h(() => {
    google.maps.visualization || Oo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Oo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(oy(oy({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(AIe);
class IIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      heatmapLayer: null
    }), Pe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Oo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Oo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(oy(oy({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = fn({
      updaterMap: g$,
      eventMap: h$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: g$,
      eventMap: h$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), bn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(IIe, "contextType", Rt);
var m$ = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, v$ = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class BIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      streetViewPanorama: null
    }), Pe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = fn({
      updaterMap: v$,
      eventMap: m$,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: v$,
      eventMap: m$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), bn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
Pe(BIe, "contextType", Rt);
class NIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "state", {
      streetViewService: null
    }), Pe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
Pe(NIe, "contextType", Rt);
var y$ = {
  onDirectionsChanged: "directions_changed"
}, b$ = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class RIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "state", {
      directionsRenderer: null
    }), Pe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = fn({
      updaterMap: b$,
      eventMap: y$,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: b$,
      eventMap: y$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), bn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
Pe(RIe, "contextType", Rt);
var w$ = {
  onPlacesChanged: "places_changed"
}, C$ = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class FIe extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "containerElement", ir()), Pe(this, "state", {
      searchBox: null
    }), Pe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Oo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = fn({
          updaterMap: C$,
          eventMap: w$,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: C$,
      eventMap: w$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), bn(this.registeredEvents));
  }
  render() {
    return oi.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
Pe(FIe, "contextType", Rt);
var O$ = {
  onPlaceChanged: "place_changed"
}, x$ = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class hG extends pe {
  constructor() {
    super(...arguments), Pe(this, "registeredEvents", []), Pe(this, "containerElement", ir()), Pe(this, "state", {
      autocomplete: null
    }), Pe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Oo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = fn({
        updaterMap: x$,
        eventMap: O$,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    bn(this.registeredEvents), this.registeredEvents = fn({
      updaterMap: x$,
      eventMap: O$,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && bn(this.registeredEvents);
  }
  render() {
    return oi.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
Pe(hG, "defaultProps", {
  className: ""
});
Pe(hG, "contextType", Rt);
let zIe = { data: "" }, UIe = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || zIe, WIe = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, $Ie = /\/\*[^]*?\*\/|  +/g, E$ = /\n+/g, ol = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? ol(a, i) : i + "{" + ol(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += ol(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += ol.p ? ol.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Xs = {}, gG = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + gG(e[n]);
    return t;
  }
  return e;
}, HIe = (e, t, n, r, o) => {
  let i = gG(e), a = Xs[i] || (Xs[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Xs[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = WIe.exec(u.replace($Ie, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(E$, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(E$, " ").trim();
      return d[0];
    })(e);
    Xs[a] = ol(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Xs.g ? Xs.g : null;
  return n && (Xs.g = Xs[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Xs[a], t, r, s), a;
}, VIe = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : ol(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Y0(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return HIe(n.unshift ? n.raw ? VIe(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, UIe(t.target), t.g, t.o, t.k);
}
let mG, RE, FE;
Y0.bind({ g: 1 });
let da = Y0.bind({ k: 1 });
function ZIe(e, t, n, r) {
  ol.p = t, mG = e, RE = n, FE = r;
}
function Dl(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: RE && RE() }, s), n.o = / *go\d+/.test(l), s.className = Y0.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), FE && u[0] && FE(s), mG(u, s);
    }
    return o;
  };
}
var qIe = (e) => typeof e == "function", KIe = (e, t) => qIe(e) ? e(t) : e, GIe = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), YIe = da`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, XIe = da`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, JIe = da`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, QIe = Dl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${YIe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${XIe} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${JIe} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, eBe = da`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, tBe = Dl("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${eBe} 1s linear infinite;
`, nBe = da`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, rBe = da`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, oBe = Dl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${nBe} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${rBe} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, iBe = Dl("div")`
  position: absolute;
`, sBe = Dl("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, aBe = da`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, lBe = Dl("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${aBe} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, uBe = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Re.createElement(lBe, null, t) : t : n === "blank" ? null : Re.createElement(sBe, null, Re.createElement(tBe, { ...r }), n !== "loading" && Re.createElement(iBe, null, n === "error" ? Re.createElement(QIe, { ...r }) : Re.createElement(oBe, { ...r })));
}, cBe = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, pBe = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, dBe = "0%{opacity:0;} 100%{opacity:1;}", fBe = "0%{opacity:1;} 100%{opacity:0;}", hBe = Dl("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, gBe = Dl("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, mBe = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = GIe() ? [dBe, fBe] : [cBe(n), pBe(n)];
  return { animation: t ? `${da(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${da(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Re.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? mBe(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Re.createElement(uBe, { toast: e }), a = Re.createElement(gBe, { ...e.ariaProps }, KIe(e.message, e));
  return Re.createElement(hBe, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Re.createElement(Re.Fragment, null, i, a));
});
ZIe(Re.createElement);
Y0`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function vG(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, d = { xs: 12, sm: 16, md: 20, lg: 24 }[i], y = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ Vn.jsxs("button", { className: y, disabled: l || t, ...p, children: [
    /* @__PURE__ */ Vn.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ Vn.jsx(js, { size: d, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ Vn.jsxs("div", { className: "arkynButtonContent", children: [
      kD(d, a),
      c,
      kD(d, s)
    ] })
  ] });
}
function vBe() {
  const e = gL(), t = b9(), n = w9(), [r, o] = P(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  h(() => {
    var u, c;
    let p = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, p) || Object.entries(p).length !== 0 && o(p);
  }, [n, e]), h(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
Ye({});
function yBe(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ Vn.jsxs(
    "button",
    {
      disabled: a || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ Vn.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ Vn.jsx(js, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ Vn.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ Vn.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function bBe(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ Vn.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ Vn.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function wBe(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const CBe = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
wBe(CBe.CNPJ).length;
ga((e, t) => /* @__PURE__ */ Vn.jsx("input", { ref: t, ...e }));
Ye({});
var Ca = {};
Object.defineProperty(Ca, "__esModule", {
  value: !0
});
var OBe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), $C = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, yG = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: OBe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, NS = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var jg = 1; jg < 20; jg++)
  NS["f" + jg] = 111 + jg;
function X0(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return bG(a, t);
  }), o = function(a) {
    return r.some(function(s) {
      return wG(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function xBe(e, t) {
  return X0(e, t);
}
function EBe(e, t) {
  return X0(e, { byKey: !0 }, t);
}
function bG(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in $C)
    r[$C[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = RS(d), v = $C[f];
      if (d.length > 1 && !v && !yG[d] && !NS[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = CG(d)), v && (r[v] = y ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function wG(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function CG(e) {
  e = RS(e);
  var t = NS[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function RS(e) {
  return e = e.toLowerCase(), e = yG[e] || e, e;
}
Ca.default = X0;
var HC = Ca.isHotkey = X0;
Ca.isCodeHotkey = xBe;
Ca.isKeyHotkey = EBe;
Ca.parseHotkey = bG;
Ca.compareHotkey = wG;
Ca.toKeyCode = CG;
Ca.toKeyName = RS;
var LBe = typeof Qn == "object" && Qn && Qn.Object === Object && Qn, PBe = LBe, kBe = PBe, SBe = typeof self == "object" && self && self.Object === Object && self, MBe = kBe || SBe || Function("return this")(), DBe = MBe, _Be = DBe, jBe = _Be.Symbol, OG = jBe, L$ = OG;
L$ && L$.toStringTag;
var P$ = OG;
P$ && P$.toStringTag;
var k$;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(k$ || (k$ = {}));
var FS = function(e) {
  return Object.freeze(e);
}, TBe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, FS(this);
  }
  return e;
}(), ABe = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, FS(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), S$ = typeof window < "u" ? window : {};
/msie|trident/i.test(S$.navigator && S$.navigator.userAgent);
var VC = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new TBe((n ? t : e) || 0, (n ? e : t) || 0);
};
FS({
  devicePixelContentBoxSize: VC(),
  borderBoxSize: VC(),
  contentBoxSize: VC(),
  contentRect: new ABe(0, 0, 0, 0)
});
function Vd(e) {
  "@babel/helpers - typeof";
  return Vd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Vd(e);
}
function IBe(e, t) {
  if (Vd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Vd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function BBe(e) {
  var t = IBe(e, "string");
  return Vd(t) === "symbol" ? t : String(t);
}
function td(e, t, n) {
  return t = BBe(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var NBe = /* @__PURE__ */ Ye(null), ZC, qC;
parseInt(Ce.version.split(".")[0], 10);
var M$ = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), KC = typeof navigator < "u" && /Android/.test(navigator.userAgent), Tg = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), RBe = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (ZC = navigator.userAgent.match(/Version\/(\d+)/)) !== null && ZC !== void 0 && ZC[1] && parseInt((qC = navigator.userAgent.match(/Version\/(\d+)/)) === null || qC === void 0 ? void 0 : qC[1], 10) < 17;
var FBe = /* @__PURE__ */ new WeakMap(), zBe = /* @__PURE__ */ new WeakMap(), UBe = /* @__PURE__ */ new WeakMap(), WBe = /* @__PURE__ */ new WeakMap(), $Be = /* @__PURE__ */ new WeakMap(), D$ = /* @__PURE__ */ new WeakMap(), HBe = /* @__PURE__ */ new WeakMap(), _$ = /* @__PURE__ */ new WeakMap(), Ag = /* @__PURE__ */ new WeakMap(), VBe = /* @__PURE__ */ new WeakMap(), ZBe = /* @__PURE__ */ new WeakMap(), qBe = /* @__PURE__ */ new WeakMap(), xG = globalThis.Node, KBe = globalThis.Text, EG = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, GBe = (e) => iy(e) && e.nodeType === 8, _s = (e) => iy(e) && e.nodeType === 1, iy = (e) => {
  var t = EG(e);
  return !!t && e instanceof t.Node;
}, j$ = (e) => {
  var t = e && e.anchorNode && EG(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, YBe = (e) => {
  var [t, n] = e;
  if (_s(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = LG(t, o, r ? "backward" : "forward"), r = o < n; _s(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = JBe(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, XBe = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, LG = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (GBe(o) || _s(o) && o.childNodes.length === 0 || _s(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, JBe = (e, t, n) => {
  var [r] = LG(e, t, n);
  return r;
}, T$ = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), PG = (e, t, n) => {
  var {
    target: r
  } = t;
  if (_s(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = ln.getWindow(e);
  if (o.contains(r))
    return ln.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : PG(e, i, n);
}, A$ = (e, t) => !!(e.compareDocumentPosition(t) & xG.DOCUMENT_POSITION_PRECEDING), QBe = (e, t) => !!(e.compareDocumentPosition(t) & xG.DOCUMENT_POSITION_FOLLOWING), eNe = 0;
class tNe {
  constructor() {
    td(this, "id", void 0), this.id = "".concat(eNe++);
  }
}
var ln = {
  androidPendingDiffs: (e) => qBe.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = ZBe.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = ln.toDOMNode(e, e), n = ln.findDocumentOrShadowRoot(e);
    Ag.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = ln.findDocumentOrShadowRoot(e), r = T$(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && _m.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = ln.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = ln.toSlateNode(e, t.target), a = ln.findPath(e, i);
    if (ea.isElement(i) && Zn.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Zn.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Zn.before(e, u) : Zn.after(e, u);
      if (c) {
        var p = Zn.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = ln.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = ln.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = D$.get(t);
    return n || (n = new tNe(), D$.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = zBe.get(r);
      if (o == null) {
        if (Zn.isEditor(r))
          return n;
        break;
      }
      var i = FBe.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Pi.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Ag.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          ln.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = ln.toDOMNode(e, e), r = ln.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = T$(r), i = ln.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || _m.select(e, Zn.start(e, [])), Ag.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = UBe.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = ln.toDOMNode(e, e), i;
    try {
      i = _s(t) ? t : t.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => iy(t) && ln.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Zn.hasPath(e, n.path) && Zn.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => ln.hasEditableTarget(e, t) || ln.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => iy(t) && ln.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!VBe.get(e),
  isFocused: (e) => !!Ag.get(e),
  isReadOnly: (e) => !!_$.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (_$.get(e)) return !1;
    var n = ln.hasTarget(e, t) && ln.toSlateNode(e, t);
    return ea.isElement(n) && Zn.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = HBe.get(e), r = Zn.isEditor(t) ? WBe.get(e) : n == null ? void 0 : n.get(ln.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Pi.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Zn.node(e, t.path), r = ln.toDOMNode(e, n), o;
    Zn.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof KBe ? E : v,
            (g = v.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Pi.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = Ut.isBackward(t), i = ln.toDOMPoint(e, n), a = Ut.isCollapsed(t) ? i : ln.toDOMPoint(e, r), s = ln.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = _s(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = _s(p) ? p : p.parentElement, g = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = _s(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? $Be.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : YBe(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = ln.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && y.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = ln.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (KC && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var z = v.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var R = z[L];
          if (ln.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (E) {
        var B = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, W = [...B(H), ...B(H == null ? void 0 : H.nextElementSibling)];
          w = (V = W.find((M) => QBe(E, M))) !== null && V !== void 0 ? V : null;
        } else {
          var q, Y = [...B(H == null ? void 0 : H.previousElementSibling), ...B(H)];
          w = (q = Y.findLast((M) => A$(E, M))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      KC && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Tg && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (KC && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && ln.hasDOMNode(e, X, {
        editable: !0
      })) {
        var ee = ln.toSlateNode(e, X), {
          path: J,
          offset: k
        } = Zn.start(e, ln.findPath(e, ee));
        return X.querySelector("[data-slate-leaf]") || (k = s), {
          path: J,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = ln.toSlateNode(e, u), U = ln.findPath(e, _);
    return {
      path: U,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = j$(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (j$(t)) {
        if (Tg && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, g = C(f.children[d.startOffset]), E = C(v.children[y.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        RBe && XBe(s) || Tg ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Tg && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = ln.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = A$(s, u) || s === u && c < l, x = p ? w : ln.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return Ut.isExpanded(m) && Ut.isForward(m) && _s(u) && Zn.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = Zn.unhangRange(e, m, {
      voids: !0
    })), m;
  }
}, nNe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, rNe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, oNe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Nr = (e) => {
  var t = nNe[e], n = rNe[e], r = oNe[e], o = t && HC(t), i = n && HC(n), a = r && HC(r);
  return (s) => !!(o && o(s) || M$ && i && i(s) || !M$ && a && a(s));
};
Nr("bold"), Nr("compose"), Nr("moveBackward"), Nr("moveForward"), Nr("deleteBackward"), Nr("deleteForward"), Nr("deleteLineBackward"), Nr("deleteLineForward"), Nr("deleteWordBackward"), Nr("deleteWordForward"), Nr("extendBackward"), Nr("extendForward"), Nr("extendLineBackward"), Nr("extendLineForward"), Nr("italic"), Nr("moveLineBackward"), Nr("moveLineForward"), Nr("moveWordBackward"), Nr("moveWordForward"), Nr("redo"), Nr("insertSoftBreak"), Nr("splitBlock"), Nr("transposeCharacter"), Nr("undo");
var iNe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => PG(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, sNe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class aNe extends $u {
  constructor() {
    super(...arguments), td(this, "context", null), td(this, "manager", null), td(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, sNe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = iNe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
td(aNe, "contextType", NBe);
Ye({});
Ye({});
Ye({});
var ho = {}, zS = {}, Af = {}, If = {}, kG = "Expected a function", I$ = NaN, lNe = "[object Symbol]", uNe = /^\s+|\s+$/g, cNe = /^[-+]0x[0-9a-f]+$/i, pNe = /^0b[01]+$/i, dNe = /^0o[0-7]+$/i, fNe = parseInt, hNe = typeof Qn == "object" && Qn && Qn.Object === Object && Qn, gNe = typeof self == "object" && self && self.Object === Object && self, mNe = hNe || gNe || Function("return this")(), vNe = Object.prototype, yNe = vNe.toString, bNe = Math.max, wNe = Math.min, GC = function() {
  return mNe.Date.now();
};
function CNe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(kG);
  t = B$(t) || 0, sy(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? bNe(B$(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, z = o;
    return r = o = void 0, u = C, a = e.apply(z, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, z = C - u, L = t - S;
    return p ? wNe(L, i - z) : L;
  }
  function g(C) {
    var S = C - l, z = C - u;
    return l === void 0 || S >= t || S < 0 || p && z >= i;
  }
  function E() {
    var C = GC();
    if (g(C))
      return w(C);
    s = setTimeout(E, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(GC());
  }
  function m() {
    var C = GC(), S = g(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), y(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function ONe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(kG);
  return sy(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), CNe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function sy(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function xNe(e) {
  return !!e && typeof e == "object";
}
function ENe(e) {
  return typeof e == "symbol" || xNe(e) && yNe.call(e) == lNe;
}
function B$(e) {
  if (typeof e == "number")
    return e;
  if (ENe(e))
    return I$;
  if (sy(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = sy(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(uNe, "");
  var n = pNe.test(e);
  return n || dNe.test(e) ? fNe(e.slice(2), n ? 2 : 8) : cNe.test(e) ? I$ : +e;
}
var LNe = ONe, Bf = {};
Object.defineProperty(Bf, "__esModule", {
  value: !0
});
Bf.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), dm.has(t) || dm.set(t, /* @__PURE__ */ new Set());
  var o = dm.get(t);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Bf.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), dm.get(t).delete(n.name || t);
};
var dm = /* @__PURE__ */ new Map();
Object.defineProperty(If, "__esModule", {
  value: !0
});
var PNe = LNe, kNe = MNe(PNe), SNe = Bf;
function MNe(e) {
  return e && e.__esModule ? e : { default: e };
}
var DNe = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, kNe.default)(e, t);
}, qr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = DNe(function(r) {
        qr.scrollHandler(e);
      }, t);
      qr.scrollSpyContainers.push(e), (0, SNe.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return qr.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = qr.scrollSpyContainers[qr.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(qr.currentPositionX(e), qr.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    qr.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = qr.scrollSpyContainers[qr.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(qr.currentPositionX(t), qr.currentPositionY(t));
  },
  updateStates: function() {
    qr.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    qr.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), qr.spySetState && qr.spySetState.length && qr.spySetState.indexOf(e) > -1 && qr.spySetState.splice(qr.spySetState.indexOf(e), 1), document.removeEventListener("scroll", qr.scrollHandler);
  },
  update: function() {
    return qr.scrollSpyContainers.forEach(function(e) {
      return qr.scrollHandler(e);
    });
  }
};
If.default = qr;
var Mc = {}, Nf = {};
Object.defineProperty(Nf, "__esModule", {
  value: !0
});
var _Ne = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, jNe = function() {
  return window.location.hash.replace(/^#/, "");
}, TNe = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, ANe = function(e) {
  return getComputedStyle(e).position !== "static";
}, YC = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, INe = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (ANe(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = YC(t, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return YC(t, s).offsetTop - YC(e, s).offsetTop;
};
Nf.default = {
  updateHash: _Ne,
  getHash: jNe,
  filterElementInContainer: TNe,
  scrollOffset: INe
};
var J0 = {}, US = {};
Object.defineProperty(US, "__esModule", {
  value: !0
});
US.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var WS = {};
Object.defineProperty(WS, "__esModule", {
  value: !0
});
var BNe = Bf, NNe = ["mousedown", "mousewheel", "touchmove", "keydown"];
WS.default = {
  subscribe: function(e) {
    return typeof document < "u" && NNe.forEach(function(t) {
      return (0, BNe.addPassiveEventListener)(document, t, e);
    });
  }
};
var Rf = {};
Object.defineProperty(Rf, "__esModule", {
  value: !0
});
var zE = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      zE.registered[e] = t;
    },
    remove: function(e) {
      zE.registered[e] = null;
    }
  }
};
Rf.default = zE;
Object.defineProperty(J0, "__esModule", {
  value: !0
});
var RNe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, FNe = Nf;
Q0(FNe);
var zNe = US, N$ = Q0(zNe), UNe = WS, WNe = Q0(UNe), $Ne = Rf, Es = Q0($Ne);
function Q0(e) {
  return e && e.__esModule ? e : { default: e };
}
var SG = function(e) {
  return N$.default[e.smooth] || N$.default.defaultEasing;
}, HNe = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, VNe = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, UE = function() {
  return VNe() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), MG = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, DG = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, _G = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, ZNe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, qNe = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, KNe = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Es.default.registered.end && Es.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    UE.call(window, i);
    return;
  }
  Es.default.registered.end && Es.default.registered.end(o.to, o.target, o.currentPosition);
}, $S = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Ff = function(e, t, n, r) {
  t.data = t.data || MG(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (WNe.default.subscribe(o), $S(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? DG(t) : _G(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    Es.default.registered.end && Es.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = HNe(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = SG(t), a = KNe.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      Es.default.registered.begin && Es.default.registered.begin(t.data.to, t.data.target), UE.call(window, a);
    }, t.delay);
    return;
  }
  Es.default.registered.begin && Es.default.registered.begin(t.data.to, t.data.target), UE.call(window, a);
}, ew = function(e) {
  return e = RNe({}, e), e.data = e.data || MG(), e.absolute = !0, e;
}, GNe = function(e) {
  Ff(0, ew(e));
}, YNe = function(e, t) {
  Ff(e, ew(t));
}, XNe = function(e) {
  e = ew(e), $S(e), Ff(e.horizontal ? ZNe(e) : qNe(e), e);
}, JNe = function(e, t) {
  t = ew(t), $S(t);
  var n = t.horizontal ? DG(t) : _G(t);
  Ff(e + n, t);
};
J0.default = {
  animateTopScroll: Ff,
  getAnimationType: SG,
  scrollToTop: GNe,
  scrollToBottom: XNe,
  scrollTo: YNe,
  scrollMore: JNe
};
Object.defineProperty(Mc, "__esModule", {
  value: !0
});
var QNe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, eRe = Nf, tRe = HS(eRe), nRe = J0, rRe = HS(nRe), oRe = Rf, Ig = HS(oRe);
function HS(e) {
  return e && e.__esModule ? e : { default: e };
}
var Bg = {}, R$ = void 0;
Mc.default = {
  unmount: function() {
    Bg = {};
  },
  register: function(e, t) {
    Bg[e] = t;
  },
  unregister: function(e) {
    delete Bg[e];
  },
  get: function(e) {
    return Bg[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return R$ = e;
  },
  getActiveLink: function() {
    return R$;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = QNe({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var a = t.horizontal, s = tRe.default.scrollOffset(i, n, a) + (t.offset || 0);
    if (!t.smooth) {
      Ig.default.registered.begin && Ig.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Ig.default.registered.end && Ig.default.registered.end(e, n);
      return;
    }
    rRe.default.animateTopScroll(s, t, e, n);
  }
};
var WE = { exports: {} }, XC = { exports: {} }, In = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var F$;
function iRe() {
  if (F$) return In;
  F$ = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return In.AsyncMode = l, In.ConcurrentMode = u, In.ContextConsumer = s, In.ContextProvider = a, In.Element = t, In.ForwardRef = c, In.Fragment = r, In.Lazy = f, In.Memo = y, In.Portal = n, In.Profiler = i, In.StrictMode = o, In.Suspense = p, In.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, In.isConcurrentMode = x, In.isContextConsumer = function(m) {
    return D(m) === s;
  }, In.isContextProvider = function(m) {
    return D(m) === a;
  }, In.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, In.isForwardRef = function(m) {
    return D(m) === c;
  }, In.isFragment = function(m) {
    return D(m) === r;
  }, In.isLazy = function(m) {
    return D(m) === f;
  }, In.isMemo = function(m) {
    return D(m) === y;
  }, In.isPortal = function(m) {
    return D(m) === n;
  }, In.isProfiler = function(m) {
    return D(m) === i;
  }, In.isStrictMode = function(m) {
    return D(m) === o;
  }, In.isSuspense = function(m) {
    return D(m) === p;
  }, In.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === g || m.$$typeof === E || m.$$typeof === w || m.$$typeof === v);
  }, In.typeOf = D, In;
}
var Hn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var z$;
function sRe() {
  return z$ || (z$ = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === y || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === g || N.$$typeof === E || N.$$typeof === w || N.$$typeof === v);
    }
    function x(N) {
      if (typeof N == "object" && N !== null) {
        var ue = N.$$typeof;
        switch (ue) {
          case t:
            var fe = N.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var m = l, C = u, S = s, z = a, L = t, R = c, B = r, H = f, V = y, W = n, q = i, Y = o, X = p, ee = !1;
    function J(N) {
      return ee || (ee = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || x(N) === l;
    }
    function k(N) {
      return x(N) === u;
    }
    function _(N) {
      return x(N) === s;
    }
    function U(N) {
      return x(N) === a;
    }
    function M(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function $(N) {
      return x(N) === c;
    }
    function O(N) {
      return x(N) === r;
    }
    function j(N) {
      return x(N) === f;
    }
    function F(N) {
      return x(N) === y;
    }
    function T(N) {
      return x(N) === n;
    }
    function Z(N) {
      return x(N) === i;
    }
    function A(N) {
      return x(N) === o;
    }
    function G(N) {
      return x(N) === p;
    }
    Hn.AsyncMode = m, Hn.ConcurrentMode = C, Hn.ContextConsumer = S, Hn.ContextProvider = z, Hn.Element = L, Hn.ForwardRef = R, Hn.Fragment = B, Hn.Lazy = H, Hn.Memo = V, Hn.Portal = W, Hn.Profiler = q, Hn.StrictMode = Y, Hn.Suspense = X, Hn.isAsyncMode = J, Hn.isConcurrentMode = k, Hn.isContextConsumer = _, Hn.isContextProvider = U, Hn.isElement = M, Hn.isForwardRef = $, Hn.isFragment = O, Hn.isLazy = j, Hn.isMemo = F, Hn.isPortal = T, Hn.isProfiler = Z, Hn.isStrictMode = A, Hn.isSuspense = G, Hn.isValidElementType = D, Hn.typeOf = x;
  }()), Hn;
}
var U$;
function jG() {
  return U$ || (U$ = 1, process.env.NODE_ENV === "production" ? XC.exports = iRe() : XC.exports = sRe()), XC.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var JC, W$;
function aRe() {
  if (W$) return JC;
  W$ = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return JC = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, JC;
}
var QC, $$;
function VS() {
  if ($$) return QC;
  $$ = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return QC = e, QC;
}
var H$, V$;
function TG() {
  return V$ || (V$ = 1, H$ = Function.call.bind(Object.prototype.hasOwnProperty)), H$;
}
var eO, Z$;
function lRe() {
  if (Z$) return eO;
  Z$ = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = VS(), n = {}, r = TG();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, eO = o, eO;
}
var tO, q$;
function uRe() {
  if (q$) return tO;
  q$ = 1;
  var e = jG(), t = aRe(), n = VS(), r = TG(), o = lRe(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return tO = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var _ = k && (u && k[u] || k[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: z,
      oneOf: S,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(k, _) {
      return k === _ ? k !== 0 || 1 / k === 1 / _ : k !== k && _ !== _;
    }
    function v(k, _) {
      this.message = k, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function g(k) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, U = 0;
      function M(O, j, F, T, Z, A, G) {
        if (T = T || d, A = A || F, G !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + F;
            !_[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            U < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[ue] = !0, U++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + Z + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + Z + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : k(j, F, T, Z, A);
      }
      var $ = M.bind(null, !1);
      return $.isRequired = M.bind(null, !0), $;
    }
    function E(k) {
      function _(U, M, $, O, j, F) {
        var T = U[M], Z = Y(T);
        if (Z !== k) {
          var A = X(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return g(_);
    }
    function w() {
      return g(a);
    }
    function D(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var F = U[M];
        if (!Array.isArray(F)) {
          var T = Y(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var Z = 0; Z < F.length; Z++) {
          var A = k(F, Z, $, O, j + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(_);
    }
    function x() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!s(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(k);
    }
    function m() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!e.isValidElementType(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(k);
    }
    function C(k) {
      function _(U, M, $, O, j) {
        if (!(U[M] instanceof k)) {
          var F = k.name || d, T = J(U[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return g(_);
    }
    function S(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(U, M, $, O, j) {
        for (var F = U[M], T = 0; T < k.length; T++)
          if (f(F, k[T]))
            return null;
        var Z = JSON.stringify(k, function(A, G) {
          var N = X(G);
          return N === "symbol" ? String(G) : G;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + $ + "`, expected one of " + Z + "."));
      }
      return g(_);
    }
    function z(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var Z in F)
          if (r(F, Z)) {
            var A = k(F, Z, $, O, j + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(_);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < k.length; _++) {
        var U = k[_];
        if (typeof U != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ee(U) + " at index " + _ + "."
          ), a;
      }
      function M($, O, j, F, T) {
        for (var Z = [], A = 0; A < k.length; A++) {
          var G = k[A], N = G($, O, j, F, T, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && Z.push(N.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return g(M);
    }
    function R() {
      function k(_, U, M, $, O) {
        return W(_[U]) ? null : new v("Invalid " + $ + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return g(k);
    }
    function B(k, _, U, M, $) {
      return new v(
        (k || "React class") + ": " + _ + " type `" + U + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function H(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var Z in k) {
          var A = k[Z];
          if (typeof A != "function")
            return B($, O, j, Z, X(A));
          var G = A(F, Z, $, O, j + "." + Z, n);
          if (G)
            return G;
        }
        return null;
      }
      return g(_);
    }
    function V(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var Z = t({}, U[M], k);
        for (var A in Z) {
          var G = k[A];
          if (r(k, A) && typeof G != "function")
            return B($, O, j, A, X(G));
          if (!G)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(U[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = G(F, A, $, O, j + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return g(_);
    }
    function W(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(W);
          if (k === null || s(k))
            return !0;
          var _ = p(k);
          if (_) {
            var U = _.call(k), M;
            if (_ !== k.entries) {
              for (; !(M = U.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = U.next()).done; ) {
                var $ = M.value;
                if ($ && !W($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(k, _) {
      return k === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function Y(k) {
      var _ = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : q(_, k) ? "symbol" : _;
    }
    function X(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var _ = Y(k);
      if (_ === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function ee(k) {
      var _ = X(k);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, tO;
}
var nO, K$;
function cRe() {
  if (K$) return nO;
  K$ = 1;
  var e = VS();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, nO = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, nO;
}
if (process.env.NODE_ENV !== "production") {
  var pRe = jG(), dRe = !0;
  WE.exports = uRe()(pRe.isElement, dRe);
} else
  WE.exports = cRe()();
var tw = WE.exports, nw = {};
Object.defineProperty(nw, "__esModule", {
  value: !0
});
var fRe = Nf, rO = hRe(fRe);
function hRe(e) {
  return e && e.__esModule ? e : { default: e };
}
var gRe = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return rO.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && rO.default.getHash() !== e && rO.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
nw.default = gRe;
Object.defineProperty(Af, "__esModule", {
  value: !0
});
var Ng = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, mRe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), vRe = Ce, G$ = zf(vRe), yRe = If, Rg = zf(yRe), bRe = Mc, wRe = zf(bRe), CRe = tw, Rr = zf(CRe), ORe = nw, Ta = zf(ORe);
function zf(e) {
  return e && e.__esModule ? e : { default: e };
}
function xRe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ERe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function LRe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Y$ = {
  to: Rr.default.string.isRequired,
  containerId: Rr.default.string,
  container: Rr.default.object,
  activeClass: Rr.default.string,
  activeStyle: Rr.default.object,
  spy: Rr.default.bool,
  horizontal: Rr.default.bool,
  smooth: Rr.default.oneOfType([Rr.default.bool, Rr.default.string]),
  offset: Rr.default.number,
  delay: Rr.default.number,
  isDynamic: Rr.default.bool,
  onClick: Rr.default.func,
  duration: Rr.default.oneOfType([Rr.default.number, Rr.default.func]),
  absolute: Rr.default.bool,
  onSetActive: Rr.default.func,
  onSetInactive: Rr.default.func,
  ignoreCancelEvents: Rr.default.bool,
  hashSpy: Rr.default.bool,
  saveHashHistory: Rr.default.bool,
  spyThrottle: Rr.default.number
};
Af.default = function(e, t) {
  var n = t || wRe.default, r = function(i) {
    LRe(a, i);
    function a(s) {
      xRe(this, a);
      var l = ERe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return mRe(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          Rg.default.isMounted(s) || Rg.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (Ta.default.isMounted() || Ta.default.mount(n), Ta.default.mapContainer(this.props.to, s)), Rg.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        Rg.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Ng({}, this.props.style, this.props.activeStyle) : l = Ng({}, this.props.style);
        var u = Ng({}, this.props);
        for (var c in Y$)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, G$.default.createElement(e, u);
      }
    }]), a;
  }(G$.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Ng({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(Ta.default.isMounted() && !Ta.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, y = void 0;
        if (u) {
          var f = 0, v = 0, g = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            g = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var w = p.getBoundingClientRect();
            f = w.left - g + a, v = f + w.width;
          }
          var D = a - i.props.offset;
          d = D >= Math.floor(f) && D < Math.floor(v), y = D < Math.floor(f) || D >= Math.floor(v);
        } else {
          var x = 0, m = 0, C = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            C = S.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var z = p.getBoundingClientRect();
            x = z.top - C + s, m = x + z.height;
          }
          var L = s - i.props.offset;
          d = L >= Math.floor(x) && L < Math.floor(m), y = L < Math.floor(x) || L >= Math.floor(m);
        }
        var R = n.getActiveLink();
        if (y) {
          if (c === R && n.setActiveLink(void 0), i.props.hashSpy && Ta.default.getHash() === c) {
            var B = i.props.saveHashHistory, H = B === void 0 ? !1 : B;
            Ta.default.changeHash("", H);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (R !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var V = i.props.saveHashHistory, W = V === void 0 ? !1 : V;
          i.props.hashSpy && Ta.default.changeHash(c, W), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = Y$, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(zS, "__esModule", {
  value: !0
});
var PRe = Ce, X$ = AG(PRe), kRe = Af, SRe = AG(kRe);
function AG(e) {
  return e && e.__esModule ? e : { default: e };
}
function MRe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function J$(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function DRe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var _Re = function(e) {
  DRe(t, e);
  function t() {
    var n, r, o, i;
    MRe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = J$(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return X$.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), J$(o, i);
  }
  return t;
}(X$.default.Component);
zS.default = (0, SRe.default)(_Re);
var ZS = {};
Object.defineProperty(ZS, "__esModule", {
  value: !0
});
var jRe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), TRe = Ce, Q$ = IG(TRe), ARe = Af, IRe = IG(ARe);
function IG(e) {
  return e && e.__esModule ? e : { default: e };
}
function BRe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function NRe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function RRe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var FRe = function(e) {
  RRe(t, e);
  function t() {
    return BRe(this, t), NRe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return jRe(t, [{
    key: "render",
    value: function() {
      return Q$.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(Q$.default.Component);
ZS.default = (0, IRe.default)(FRe);
var qS = {}, rw = {};
Object.defineProperty(rw, "__esModule", {
  value: !0
});
var zRe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, URe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), WRe = Ce, eH = ow(WRe), $Re = pl;
ow($Re);
var HRe = Mc, tH = ow(HRe), VRe = tw, nH = ow(VRe);
function ow(e) {
  return e && e.__esModule ? e : { default: e };
}
function ZRe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function qRe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function KRe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
rw.default = function(e) {
  var t = function(n) {
    KRe(r, n);
    function r(o) {
      ZRe(this, r);
      var i = qRe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return URe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        tH.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        tH.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return eH.default.createElement(e, zRe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(eH.default.Component);
  return t.propTypes = {
    name: nH.default.string,
    id: nH.default.string
  }, t;
};
Object.defineProperty(qS, "__esModule", {
  value: !0
});
var rH = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, GRe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), YRe = Ce, oH = KS(YRe), XRe = rw, JRe = KS(XRe), QRe = tw, iH = KS(QRe);
function KS(e) {
  return e && e.__esModule ? e : { default: e };
}
function eFe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function tFe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function nFe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var BG = function(e) {
  nFe(t, e);
  function t() {
    return eFe(this, t), tFe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return GRe(t, [{
    key: "render",
    value: function() {
      var n = this, r = rH({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, oH.default.createElement(
        "div",
        rH({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(oH.default.Component);
BG.propTypes = {
  name: iH.default.string,
  id: iH.default.string
};
qS.default = (0, JRe.default)(BG);
var oO = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, sH = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function aH(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function lH(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function uH(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Fg = Ce, Hl = If, iO = Mc, eo = tw, Aa = nw, cH = {
  to: eo.string.isRequired,
  containerId: eo.string,
  container: eo.object,
  activeClass: eo.string,
  spy: eo.bool,
  smooth: eo.oneOfType([eo.bool, eo.string]),
  offset: eo.number,
  delay: eo.number,
  isDynamic: eo.bool,
  onClick: eo.func,
  duration: eo.oneOfType([eo.number, eo.func]),
  absolute: eo.bool,
  onSetActive: eo.func,
  onSetInactive: eo.func,
  ignoreCancelEvents: eo.bool,
  hashSpy: eo.bool,
  spyThrottle: eo.number
}, rFe = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || iO, r = function(i) {
      uH(a, i);
      function a(s) {
        aH(this, a);
        var l = lH(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return sH(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Hl.isMounted(s) || Hl.mount(s, this.props.spyThrottle), this.props.hashSpy && (Aa.isMounted() || Aa.mount(n), Aa.mapContainer(this.props.to, s)), this.props.spy && Hl.addStateHandler(this.stateHandler), Hl.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Hl.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = oO({}, this.props);
          for (var u in cH)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, Fg.createElement(e, l);
        }
      }]), a;
    }(Fg.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, oO({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(Aa.isMounted() && !Aa.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (s.getBoundingClientRect) {
            var y = s.getBoundingClientRect();
            d = y.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var f = u.getBoundingClientRect();
            c = f.top - d + a, p = c + f.height;
          }
          var v = a - i.props.offset, g = v >= Math.floor(c) && v < Math.floor(p), E = v < Math.floor(c) || v >= Math.floor(p), w = n.getActiveLink();
          if (E)
            return l === w && n.setActiveLink(void 0), i.props.hashSpy && Aa.getHash() === l && Aa.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Hl.updateStates();
          if (g && w !== l)
            return n.setActiveLink(l), i.props.hashSpy && Aa.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Hl.updateStates();
        }
      };
    };
    return r.propTypes = cH, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      uH(r, n);
      function r(o) {
        aH(this, r);
        var i = lH(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return sH(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          iO.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          iO.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Fg.createElement(e, oO({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Fg.Component);
    return t.propTypes = {
      name: eo.string,
      id: eo.string
    }, t;
  }
}, oFe = rFe;
Object.defineProperty(ho, "__esModule", {
  value: !0
});
ho.Helpers = ho.ScrollElement = ho.ScrollLink = ho.animateScroll = ho.scrollSpy = ho.Events = ho.scroller = ho.Element = ho.Button = ho.Link = void 0;
var iFe = zS, NG = Rs(iFe), sFe = ZS, RG = Rs(sFe), aFe = qS, FG = Rs(aFe), lFe = Mc, zG = Rs(lFe), uFe = Rf, UG = Rs(uFe), cFe = If, WG = Rs(cFe), pFe = J0, $G = Rs(pFe), dFe = Af, HG = Rs(dFe), fFe = rw, VG = Rs(fFe), hFe = oFe, ZG = Rs(hFe);
function Rs(e) {
  return e && e.__esModule ? e : { default: e };
}
ho.Link = NG.default;
ho.Button = RG.default;
ho.Element = FG.default;
ho.scroller = zG.default;
ho.Events = UG.default;
ho.scrollSpy = WG.default;
ho.animateScroll = $G.default;
ho.ScrollLink = HG.default;
ho.ScrollElement = VG.default;
ho.Helpers = ZG.default;
ho.default = { Link: NG.default, Button: RG.default, Element: FG.default, scroller: zG.default, Events: UG.default, scrollSpy: WG.default, animateScroll: $G.default, ScrollLink: HG.default, ScrollElement: VG.default, Helpers: ZG.default };
Ye({});
Ye({});
Ye({});
function Zd(e) {
  "@babel/helpers - typeof";
  return Zd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Zd(e);
}
function gFe(e, t) {
  if (Zd(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Zd(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function mFe(e) {
  var t = gFe(e, "string");
  return Zd(t) == "symbol" ? t : t + "";
}
function ke(e, t, n) {
  return (t = mFe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function qG(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var sO, pH;
function vFe() {
  if (pH) return sO;
  pH = 1;
  var e = process.env.NODE_ENV, t = function(n, r, o, i, a, s, l, u) {
    if (e !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var p = [o, i, a, s, l, u], d = 0;
        c = new Error(r.replace(/%s/g, function() {
          return p[d++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return sO = t, sO;
}
var yFe = vFe(), xo = /* @__PURE__ */ qG(yFe), Ft = Ye(null);
function bFe() {
  xo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Ft);
  return xo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function wFe(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function CFe(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function OFe(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return CFe(e, i), o;
}
function xFe(e, t, n) {
  var r = wFe(n, function(o, i, a) {
    return typeof e[a] == "function" && o.push(google.maps.event.addListener(t, i, e[a])), o;
  }, []);
  return r;
}
function EFe(e) {
  google.maps.event.removeListener(e);
}
function wn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(EFe);
}
function hn(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = xFe(o, i, n);
  return OFe(t, r, o, i), a;
}
function LFe(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = P(null), S = dt(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null), [A, G] = P(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && g && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(m, "mouseup", g)));
  }, [g]), h(() => {
    m && E && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", E)));
  }, [E]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), G(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var N = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(N), N !== null && D && D(N), () => {
      N !== null && x && x(N);
    };
  }, []), Vn.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: Vn.jsx(Ft.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
ve(LFe);
function dH(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function KG(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        dH(i, r, o, a, s, "next", l);
      }
      function s(l) {
        dH(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function GG(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return xo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var gu = typeof document < "u";
function YG(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return gu ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        a.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, s.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function fH(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function XG() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return fH(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return fH(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
var up = !1;
function JG() {
  return Vn.jsx("div", {
    children: "Loading..."
  });
}
var $E = {
  id: "script-loader",
  version: "weekly"
};
class PFe extends pe {
  constructor() {
    super(...arguments), ke(this, "check", ir()), ke(this, "state", {
      loaded: !1
    }), ke(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ke(this, "isCleaningUp", /* @__PURE__ */ KG(function* () {
      function t(n) {
        if (!up)
          n();
        else if (gu)
          var r = window.setInterval(function() {
            up || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ke(this, "cleanup", () => {
      up = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), ke(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && XG(), xo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: GG(this.props)
      };
      YG(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (gu) {
      if (window.google && window.google.maps && !up) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(t) {
        console.error("Error at injecting script after cleaning up: ", t);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), gu && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (gu) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, up = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return Vn.jsxs(Vn.Fragment, {
      children: [Vn.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || Vn.jsx(JG, {})]
    });
  }
}
ke(PFe, "defaultProps", $E);
function kFe(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function GS(e, t) {
  if (e == null) return {};
  var n, r, o = kFe(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var hH;
function SFe(e) {
  var {
    id: t = $E.id,
    version: n = $E.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = dt(!1), [f, v] = P(!1), [g, E] = P(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    gu && u && XG();
  }, [u]), h(function() {
    f && xo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = GG({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!gu)
      return;
    function x() {
      y.current && (v(!0), hH = w);
    }
    if (window.google && window.google.maps && hH === w) {
      x();
      return;
    }
    YG({
      id: t,
      url: w,
      nonce: r
    }).then(x).catch(function(m) {
      y.current && E(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [t, w, r]);
  var D = dt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var MFe = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], DFe = Vn.jsx(JG, {});
function _Fe(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = GS(e, MFe), {
    isLoaded: s,
    loadError: l
  } = SFe(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || DFe;
}
ve(_Fe);
var gH;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(gH || (gH = {}));
function mH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ay(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var vH = {}, yH = {
  options(e, t) {
    e.setOptions(t);
  }
};
function jFe(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Ft), [i, a] = P(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(ay(ay({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(jFe);
class TFe extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      trafficLayer: null
    }), ke(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(ay(ay({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = hn({
      updaterMap: yH,
      eventMap: vH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: yH,
      eventMap: vH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), wn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(TFe, "contextType", Ft);
function AFe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ft), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(AFe);
class IFe extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      bicyclingLayer: null
    }), ke(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(IFe, "contextType", Ft);
function BFe(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Ft), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(BFe);
class NFe extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      transitLayer: null
    }), ke(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(NFe, "contextType", Ft);
function bH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ly(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? bH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : bH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wH = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, CH = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function RFe(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Ft), [d, y] = P(null), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    xo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(ly(ly({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && E(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && L(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(RFe);
class FFe extends pe {
  constructor(t) {
    super(t), ke(this, "registeredEvents", []), ke(this, "state", {
      drawingManager: null
    }), ke(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), xo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(ly(ly({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = hn({
      updaterMap: CH,
      eventMap: wH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: CH,
      eventMap: wH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), wn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ke(FFe, "contextType", Ft);
function OH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? OH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : OH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xH = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, EH = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, uy = {};
function zFe(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: R,
    onClickableChanged: B,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: W,
    onFlatChanged: q,
    onIconChanged: Y,
    onPositionChanged: X,
    onShapeChanged: ee,
    onTitleChanged: J,
    onVisibleChanged: k,
    onZindexChanged: _,
    onLoad: U,
    onUnmount: M
  } = e, $ = ge(Ft), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null), [oe, Ie] = P(null), [qe, Ge] = P(null), [Be, et] = P(null), [Xe, Me] = P(null), [Je, at] = P(null), [Se, _e] = P(null), [Ae, Ve] = P(null), [Ne, nt] = P(null), [we, mt] = P(null), [ot, st] = P(null), [ut, vt] = P(null), [ct, yt] = P(null), [Qe, ft] = P(null), [tt, bt] = P(null), [pt, Dt] = P(null), [wt, _t] = P(null), [Ct, jt] = P(null);
  h(() => {
    O !== null && O.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ie(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (qe !== null && google.maps.event.removeListener(qe), Ge(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && z && (Be !== null && google.maps.event.removeListener(Be), et(google.maps.event.addListener(O, "mouseup", z)));
  }, [z]), h(() => {
    O && R && (Xe !== null && google.maps.event.removeListener(Xe), Me(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && E && (Je !== null && google.maps.event.removeListener(Je), at(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && D && (Se !== null && google.maps.event.removeListener(Se), _e(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && B && (Ae !== null && google.maps.event.removeListener(Ae), Ve(google.maps.event.addListener(O, "clickable_changed", B)));
  }, [B]), h(() => {
    O && H && (Ne !== null && google.maps.event.removeListener(Ne), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), h(() => {
    O && V && (we !== null && google.maps.event.removeListener(we), mt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && W && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && q && (ut !== null && google.maps.event.removeListener(ut), vt(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), h(() => {
    O && Y && (ct !== null && google.maps.event.removeListener(ct), yt(google.maps.event.addListener(O, "icon_changed", Y)));
  }, [Y]), h(() => {
    O && X && (Qe !== null && google.maps.event.removeListener(Qe), ft(google.maps.event.addListener(O, "position_changed", X)));
  }, [X]), h(() => {
    O && ee && (tt !== null && google.maps.event.removeListener(tt), bt(google.maps.event.addListener(O, "shape_changed", ee)));
  }, [ee]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Dt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && k && (wt !== null && google.maps.event.removeListener(wt), _t(google.maps.event.addListener(O, "visible_changed", k)));
  }, [k]), h(() => {
    O && _ && (Ct !== null && google.maps.event.removeListener(Ct), jt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var ht = Qu(Qu(Qu({}, n || uy), r ? uy : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof y < "u" && re.setOpacity(y), f && re.setShape(f), typeof v == "string" && re.setTitle(v), typeof g == "number" && re.setZIndex(g), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), m && N(google.maps.event.addListener(re, "dragstart", m)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ie(google.maps.event.addListener(re, "mouseout", C)), S && Ge(google.maps.event.addListener(re, "mouseover", S)), z && et(google.maps.event.addListener(re, "mouseup", z)), R && Me(google.maps.event.addListener(re, "rightclick", R)), E && at(google.maps.event.addListener(re, "click", E)), D && _e(google.maps.event.addListener(re, "drag", D)), B && Ve(google.maps.event.addListener(re, "clickable_changed", B)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && mt(google.maps.event.addListener(re, "animation_changed", V)), W && st(google.maps.event.addListener(re, "draggable_changed", W)), q && vt(google.maps.event.addListener(re, "flat_changed", q)), Y && yt(google.maps.event.addListener(re, "icon_changed", Y)), X && ft(google.maps.event.addListener(re, "position_changed", X)), ee && bt(google.maps.event.addListener(re, "shape_changed", ee)), J && Dt(google.maps.event.addListener(re, "title_changed", J)), k && _t(google.maps.event.addListener(re, "visible_changed", k)), _ && jt(google.maps.event.addListener(re, "zindex_changed", _)), j(re), U && U(re), () => {
      F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), qe !== null && google.maps.event.removeListener(qe), Be !== null && google.maps.event.removeListener(Be), Xe !== null && google.maps.event.removeListener(Xe), Je !== null && google.maps.event.removeListener(Je), Ae !== null && google.maps.event.removeListener(Ae), Ne !== null && google.maps.event.removeListener(Ne), we !== null && google.maps.event.removeListener(we), ot !== null && google.maps.event.removeListener(ot), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), Qe !== null && google.maps.event.removeListener(Qe), pt !== null && google.maps.event.removeListener(pt), wt !== null && google.maps.event.removeListener(wt), Ct !== null && google.maps.event.removeListener(Ct), M && M(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Cn = On(() => i ? lt.map(i, (ht) => {
    if (!mi(ht))
      return ht;
    var re = ht;
    return vi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return Vn.jsx(Vn.Fragment, {
    children: Cn
  }) || null;
}
ve(zFe);
class UFe extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return KG(function* () {
      var n = Qu(Qu(Qu({}, t.props.options || uy), t.props.clusterer ? uy : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = hn({
        updaterMap: EH,
        eventMap: xH,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: EH,
      eventMap: xH,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), wn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ke(UFe, "contextType", Ft);
var WFe = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), $Fe = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new WFe(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function HFe(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var VFe = 2e3, ZFe = 500, qFe = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", KFe = "png", GFe = [53, 56, 66, 78, 90], YFe = "cluster", QG = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || qFe, this.imageExtension = r.imageExtension || KFe, this.imageSizes = r.imageSizes || GFe, this.calculator = r.calculator || HFe, this.batchSize = r.batchSize || VFe, this.batchSizeIE = r.batchSizeIE || ZFe, this.clusterClass = r.clusterClass || YFe, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new $Fe(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function LH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function XFe(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? LH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : LH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var is = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Sn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, JFe = {};
function QFe(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: z
  } = e, [L, R] = P(null), B = ge(Ft), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null);
  return h(() => {
    L && C && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(L, is.onMouseOut, C)));
  }, [C]), h(() => {
    L && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(L, is.onMouseOver, m)));
  }, [m]), h(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, is.onClick, w)));
  }, [w]), h(() => {
    L && D && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(L, is.onClusteringBegin, D)));
  }, [D]), h(() => {
    L && x && (Y !== null && google.maps.event.removeListener(Y), q(google.maps.event.addListener(L, is.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && Sn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Sn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Sn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Sn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Sn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Sn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Sn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Sn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Sn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Sn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof y < "u" && L !== null && Sn.maxZoom(L, y);
  }, [L, y]), h(() => {
    typeof f < "u" && L !== null && Sn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof v < "u" && L !== null && Sn.styles(L, v);
  }, [L, v]), h(() => {
    typeof g < "u" && L !== null && Sn.title(L, g);
  }, [L, g]), h(() => {
    typeof E < "u" && L !== null && Sn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (B) {
      var U = XFe({}, n || JFe), M = new QG(B, [], U);
      return r && Sn.averageCenter(M, r), o && Sn.batchSizeIE(M, o), i && Sn.calculator(M, i), a && Sn.clusterClass(M, a), s && Sn.enableRetinaIcons(M, s), l && Sn.gridSize(M, l), u && Sn.ignoreHidden(M, u), c && Sn.imageExtension(M, c), p && Sn.imagePath(M, p), d && Sn.imageSizes(M, d), y && Sn.maxZoom(M, y), f && Sn.minimumClusterSize(M, f), v && Sn.styles(M, v), g && Sn.title(M, g), E && Sn.zoomOnClick(M, E), C && J(google.maps.event.addListener(M, is.onMouseOut, C)), m && _(google.maps.event.addListener(M, is.onMouseOver, m)), w && V(google.maps.event.addListener(M, is.onClick, w)), D && q(google.maps.event.addListener(M, is.onClusteringBegin, D)), x && X(google.maps.event.addListener(M, is.onClusteringEnd, x)), R(M), S && S(M), () => {
        ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), z && z(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(QFe);
class eze extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      markerClusterer: null
    }), ke(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new QG(this.context, [], this.props.options);
      this.registeredEvents = hn({
        updaterMap: Sn,
        eventMap: is,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: Sn,
      eventMap: is,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), wn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ke(eze, "contextType", Ft);
function PH(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var eY = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || PH(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, PH));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), g = v.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + y ? r = g.x + u - y : g.x + p + u + y > s && (r = g.x + p + u + y - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), tze = ["position"], nze = ["position"];
function kH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? kH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : kH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SH = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, MH = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, rze = {};
function oze(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Ft), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var B = r || rze, {
        position: H
      } = B, V = GS(B, tze), W;
      H && !(H instanceof google.maps.LatLng) && (W = new google.maps.LatLng(H.lat, H.lng));
      var q = new eY(cy(cy({}, V), W ? {
        position: W
      } : {}));
      R.current = document.createElement("div"), v(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && D(google.maps.event.addListener(q, "domready", s)), l && m(google.maps.event.addListener(q, "content_changed", l)), u && S(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(R.current), n ? q.open(y, n) : q.getPosition() ? q.open(y) : xo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(oze);
class ize extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", null), ke(this, "state", {
      infoBox: null
    }), ke(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : xo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ke(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = GS(t, nze), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new eY(cy(cy({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = hn({
      updaterMap: MH,
      eventMap: SH,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: MH,
      eventMap: SH,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), wn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
ke(ize, "contextType", Ft);
var DH, _H;
function sze() {
  return _H || (_H = 1, DH = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), DH;
}
var aze = sze(), jH = /* @__PURE__ */ qG(aze), TH = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], aO = 1, cp = 8;
class YS {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== aO)
      throw new Error("Got v".concat(o, " data when expected v").concat(aO, "."));
    var i = TH[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new YS(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = TH.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, cp, t), this.coords = new this.ArrayType(this.data, cp + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(cp + a + s + l), this.ids = new this.IndexArrayType(this.data, cp, t), this.coords = new this.ArrayType(this.data, cp + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (aO << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return HE(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          AH(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], g = i[2 * f + 1];
      AH(v, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function HE(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    tY(e, t, a, r, o, i), HE(e, t, n, r, a - 1, 1 - i), HE(e, t, n, a + 1, o, 1 - i);
  }
}
function tY(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      tY(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (pp(e, t, r, n), t[2 * o + i] > y && pp(e, t, r, o); f < v; ) {
      for (pp(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? pp(e, t, r, v) : (v++, pp(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function pp(e, t, n, r) {
  lO(e, n, r), lO(t, 2 * n, 2 * r), lO(t, 2 * n + 1, 2 * r + 1);
}
function lO(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function AH(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var lze = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, IH = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Vl = 2, Ya = 3, uO = 4, $a = 5, nY = 6;
class uze {
  constructor(t) {
    this.options = Object.assign(Object.create(lze), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = IH(zg(u)), d = IH(Ug(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(zg(r), Ug(a), zg(i), Ug(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + $a] > 1 ? BH(p, f, this.clusterProps) : this.points[p[f + Ya]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + uO] === t && p.push(a[y + $a] > 1 ? BH(a, y, this.clusterProps) : this.points[a[y + Ya]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new YS(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + $a] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = rY(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Ya]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = zg(f), d = Ug(v);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Ya] : E = this.points[n[l + Ya]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Vl] <= n)) {
        l[p + Vl] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + $a], g = v;
        for (var E of f) {
          var w = E * c;
          l[w + Vl] > n && (g += l[w + $a]);
        }
        if (g > v && g >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Vl] <= n)) {
              l[L + Vl] = n;
              var R = l[L + $a];
              D += l[L] * R, x += l[L + 1] * R, l[L + uO] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, L)));
            }
          }
          l[p + uO] = S, u.push(D / g, x / g, 1 / 0, S, -1, g), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + Vl] <= n)) {
                l[V + Vl] = n;
                for (var W = 0; W < c; W++) u.push(l[V + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + $a] > 1) {
      var o = this.clusterProps[t[n + nY]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Ya]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function BH(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Ya],
    properties: rY(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [cze(e[t]), pze(e[t + 1])]
    }
  };
}
function rY(e, t, n) {
  var r = e[t + $a], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + nY], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Ya],
    point_count: r,
    point_count_abbreviated: o
  });
}
function zg(e) {
  return e / 360 + 0.5;
}
function Ug(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function cze(e) {
  return (e - 0.5) * 360;
}
function pze(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function dze(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ni {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class VE {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ni.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ni.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ni.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class fze {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return hze(n);
  }
}
var hze = (e) => {
  var t = e.map((n) => new VE({
    position: Ni.getPosition(n),
    markers: [n]
  }));
  return t;
};
class gze extends fze {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = dze(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new uze(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!jH(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ni.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !jH(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new VE({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new VE({
      markers: [i],
      position: Ni.getPosition(i)
    });
  }
}
class mze {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class vze {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ni.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function yze(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class XS {
  constructor() {
    yze(XS, google.maps.OverlayView);
  }
}
var nd;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(nd || (nd = {}));
var bze = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class wze extends XS {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new gze(o),
      renderer: a = new vze(),
      onClusterClick: s = bze
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ni.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, nd.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ni.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ni.setMap(l, null)));
      }
      google.maps.event.trigger(this, nd.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ni.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new mze(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ni.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, nd.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ni.setMap(r.marker, n);
    });
  }
}
function NH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function RH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? NH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : NH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Cze(e) {
  var t = bFe(), [n, r] = P(null);
  return h(() => {
    if (t && n === null) {
      var o = new wze(RH(RH({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function Oze(e) {
  var {
    children: t,
    options: n
  } = e, r = Cze(n);
  return r !== null ? t(r) : null;
}
ve(Oze);
var FH = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, zH = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function xze(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Ft), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var B = new google.maps.InfoWindow(r);
    return v(B), R.current = document.createElement("div"), a && E(google.maps.event.addListener(B, "closeclick", a)), s && D(google.maps.event.addListener(B, "domready", s)), l && m(google.maps.event.addListener(B, "content_changed", l)), u && S(google.maps.event.addListener(B, "position_changed", u)), c && L(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(R.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(y, n) : B.getPosition() ? B.open(y) : xo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(B), B.close();
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(xze);
class Eze extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", null), ke(this, "state", {
      infoWindow: null
    }), ke(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : xo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ke(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = hn({
      updaterMap: zH,
      eventMap: FH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: zH,
      eventMap: FH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (wn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
ke(Eze, "contextType", Ft);
function UH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function py(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WH = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, $H = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, Lze = {};
function Pze(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, D = ge(Ft), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && g && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", g)));
  }, [g]), h(() => {
    var T = new google.maps.Polyline(py(py({}, t || Lze), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && B(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && q(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), g && F(google.maps.event.addListener(T, "drag", g)), m(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(Pze);
class kze extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      polyline: null
    }), ke(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(py(py({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = hn({
      updaterMap: $H,
      eventMap: WH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: $H,
      eventMap: WH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), wn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ke(kze, "contextType", Ft);
function HH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function VH(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ZH = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, qH = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Sze(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Ft), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof g == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", g)));
  }, [g]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(VH(VH({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), g && F(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), S(A), w && w(A), () => {
      z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), D && D(A), A.setMap(null);
    };
  }, []), null;
}
ve(Sze);
class Mze extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = hn({
      updaterMap: qH,
      eventMap: ZH,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: qH,
      eventMap: ZH,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), wn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Mze, "contextType", Ft);
function KH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? KH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : KH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var GH = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, YH = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function Dze(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Ft), [m, C] = P(null), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), z(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", g)));
  }, [g]), h(() => {
    m && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(m, "bounds_changed", E)));
  }, [E]), h(() => {
    var G = new google.maps.Rectangle(dy(dy({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && G.setVisible(i), typeof o < "u" && G.setEditable(o), typeof r < "u" && G.setDraggable(r), typeof n < "u" && G.setBounds(n), a && z(google.maps.event.addListener(G, "dblclick", a)), s && R(google.maps.event.addListener(G, "dragend", s)), l && H(google.maps.event.addListener(G, "dragstart", l)), u && W(google.maps.event.addListener(G, "mousedown", u)), c && Y(google.maps.event.addListener(G, "mousemove", c)), p && ee(google.maps.event.addListener(G, "mouseout", p)), d && k(google.maps.event.addListener(G, "mouseover", d)), y && U(google.maps.event.addListener(G, "mouseup", y)), f && $(google.maps.event.addListener(G, "rightclick", f)), v && j(google.maps.event.addListener(G, "click", v)), g && T(google.maps.event.addListener(G, "drag", g)), E && A(google.maps.event.addListener(G, "bounds_changed", E)), C(G), w && w(G), () => {
      S !== null && google.maps.event.removeListener(S), L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), D && D(G), G.setMap(null);
    };
  }, []), null;
}
ve(Dze);
class _ze extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      rectangle: null
    }), ke(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(dy(dy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = hn({
      updaterMap: YH,
      eventMap: GH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: YH,
      eventMap: GH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), wn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ke(_ze, "contextType", Ft);
function XH(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XH(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XH(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var JH = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, QH = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, jze = {};
function Tze(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Ft), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", g)));
  }, [g]), h(() => {
    S && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(S, "drag", E)));
  }, [E]), h(() => {
    S && w && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(S, "center_changed", w)));
  }, [g]), h(() => {
    S && D && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(fy(fy({}, t || jze), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && R(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && Y(google.maps.event.addListener(oe, "mousedown", c)), p && ee(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), y && U(google.maps.event.addListener(oe, "mouseover", y)), f && $(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), g && T(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && N(google.maps.event.addListener(oe, "center_changed", w)), D && fe(google.maps.event.addListener(oe, "radius_changed", D)), z(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(Tze);
class Aze extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      circle: null
    }), ke(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(fy(fy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = hn({
      updaterMap: QH,
      eventMap: JH,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: QH,
      eventMap: JH,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), wn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ke(Aze, "contextType", Ft);
function e3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? e3(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : e3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var t3 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, n3 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function Ize(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: g
  } = e, E = ge(Ft), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(hy(hy({}, t), {}, {
        map: E
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && B(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && Z(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), g && g(w), w.setMap(null));
    };
  }, []), null;
}
ve(Ize);
class Bze extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      data: null
    }), ke(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(hy(hy({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = hn({
        updaterMap: n3,
        eventMap: t3,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: n3,
      eventMap: t3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), wn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Bze, "contextType", Ft);
function r3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function o3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? r3(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : r3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var i3 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, s3 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class Nze extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      kmlLayer: null
    }), ke(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(o3(o3({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = hn({
      updaterMap: s3,
      eventMap: i3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: s3,
      eventMap: i3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), wn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Nze, "contextType", Ft);
function oY(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function Rze(e, t) {
  return new t(e.lat, e.lng);
}
function Fze(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function zze(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Uze(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function Wze(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function $ze(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function iY(e, t, n, r) {
  return n !== void 0 ? Wze(e, t, Uze(n, google.maps.LatLngBounds, Fze)) : $ze(e, t, zze(r, google.maps.LatLng, Rze));
}
function Hze(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function a3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vze(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a3(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function Zze(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = Vze({}, this.container ? oY(this.container, o) : {
        x: 0,
        y: 0
      }), u = iY(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function l3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qze(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? l3(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : l3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function u3(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function c3(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function Kze(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Ft), c = On(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = On(() => Zze(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
ve(Kze);
class Dc extends pe {
  constructor(t) {
    super(t), ke(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ke(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      xo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ke(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ke(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = qze({
        x: 0,
        y: 0
      }, this.containerRef.current ? oY(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = iY(r, o, this.props.bounds, this.props.position);
      if (!Hze(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ke(this, "draw", () => {
      this.onPositionElement();
    }), ke(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = ir();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = u3(t.position), r = u3(this.props.position), o = c3(t.bounds), i = c3(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(Vn.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
ke(Dc, "FLOAT_PANE", "floatPane");
ke(Dc, "MAP_PANE", "mapPane");
ke(Dc, "MARKER_LAYER", "markerLayer");
ke(Dc, "OVERLAY_LAYER", "overlayLayer");
ke(Dc, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ke(Dc, "contextType", Ft);
function Gze() {
}
function p3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function d3(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? p3(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : p3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var f3 = {
  onDblClick: "dblclick",
  onClick: "click"
}, h3 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function Yze(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Ft), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = On(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(Yze);
class sY extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      groundOverlay: null
    }), ke(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    xo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, d3(d3({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = hn({
      updaterMap: h3,
      eventMap: f3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: h3,
      eventMap: f3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ke(sY, "defaultProps", {
  onLoad: Gze
});
ke(sY, "contextType", Ft);
function g3(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function gy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? g3(Object(n), !0).forEach(function(r) {
      ke(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : g3(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var m3 = {}, v3 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function Xze(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Ft), [a, s] = P(null);
  return h(() => {
    google.maps.visualization || xo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    xo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(gy(gy({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(Xze);
class Jze extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      heatmapLayer: null
    }), ke(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    xo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), xo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(gy(gy({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = hn({
      updaterMap: v3,
      eventMap: m3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: v3,
      eventMap: m3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), wn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(Jze, "contextType", Ft);
var y3 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, b3 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class Qze extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      streetViewPanorama: null
    }), ke(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = hn({
      updaterMap: b3,
      eventMap: y3,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: b3,
      eventMap: y3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), wn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ke(Qze, "contextType", Ft);
class e2e extends pe {
  constructor() {
    super(...arguments), ke(this, "state", {
      streetViewService: null
    }), ke(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ke(e2e, "contextType", Ft);
var w3 = {
  onDirectionsChanged: "directions_changed"
}, C3 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class t2e extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "state", {
      directionsRenderer: null
    }), ke(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = hn({
      updaterMap: C3,
      eventMap: w3,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: C3,
      eventMap: w3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), wn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ke(t2e, "contextType", Ft);
var O3 = {
  onPlacesChanged: "places_changed"
}, x3 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class n2e extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", ir()), ke(this, "state", {
      searchBox: null
    }), ke(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (xo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = hn({
          updaterMap: x3,
          eventMap: O3,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: x3,
      eventMap: O3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), wn(this.registeredEvents));
  }
  render() {
    return Vn.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
ke(n2e, "contextType", Ft);
var E3 = {
  onPlaceChanged: "place_changed"
}, L3 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class aY extends pe {
  constructor() {
    super(...arguments), ke(this, "registeredEvents", []), ke(this, "containerElement", ir()), ke(this, "state", {
      autocomplete: null
    }), ke(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    xo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = hn({
        updaterMap: L3,
        eventMap: E3,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    wn(this.registeredEvents), this.registeredEvents = hn({
      updaterMap: L3,
      eventMap: E3,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && wn(this.registeredEvents);
  }
  render() {
    return Vn.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
ke(aY, "defaultProps", {
  className: ""
});
ke(aY, "contextType", Ft);
let r2e = { data: "" }, o2e = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || r2e, i2e = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, s2e = /\/\*[^]*?\*\/|  +/g, P3 = /\n+/g, il = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? il(a, i) : i + "{" + il(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += il(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += il.p ? il.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Js = {}, lY = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + lY(e[n]);
    return t;
  }
  return e;
}, a2e = (e, t, n, r, o) => {
  let i = lY(e), a = Js[i] || (Js[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Js[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = i2e.exec(u.replace(s2e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(P3, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(P3, " ").trim();
      return d[0];
    })(e);
    Js[a] = il(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Js.g ? Js.g : null;
  return n && (Js.g = Js[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Js[a], t, r, s), a;
}, l2e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : il(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function iw(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return a2e(n.unshift ? n.raw ? l2e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, o2e(t.target), t.g, t.o, t.k);
}
let uY, ZE, qE;
iw.bind({ g: 1 });
let fa = iw.bind({ k: 1 });
function u2e(e, t, n, r) {
  il.p = t, uY = e, ZE = n, qE = r;
}
function _l(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: ZE && ZE() }, s), n.o = / *go\d+/.test(l), s.className = iw.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), qE && u[0] && qE(s), uY(u, s);
    }
    return o;
  };
}
var c2e = (e) => typeof e == "function", p2e = (e, t) => c2e(e) ? e(t) : e, d2e = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), f2e = fa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, h2e = fa`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, g2e = fa`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, m2e = _l("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${f2e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${h2e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${g2e} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, v2e = fa`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, y2e = _l("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${v2e} 1s linear infinite;
`, b2e = fa`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, w2e = fa`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, C2e = _l("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${b2e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${w2e} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, O2e = _l("div")`
  position: absolute;
`, x2e = _l("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, E2e = fa`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, L2e = _l("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${E2e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, P2e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Re.createElement(L2e, null, t) : t : n === "blank" ? null : Re.createElement(x2e, null, Re.createElement(y2e, { ...r }), n !== "loading" && Re.createElement(O2e, null, n === "error" ? Re.createElement(m2e, { ...r }) : Re.createElement(C2e, { ...r })));
}, k2e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, S2e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, M2e = "0%{opacity:0;} 100%{opacity:1;}", D2e = "0%{opacity:1;} 100%{opacity:0;}", _2e = _l("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, j2e = _l("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, T2e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = d2e() ? [M2e, D2e] : [k2e(n), S2e(n)];
  return { animation: t ? `${fa(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${fa(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Re.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? T2e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Re.createElement(P2e, { toast: e }), a = Re.createElement(j2e, { ...e.ariaProps }, p2e(e.message, e));
  return Re.createElement(_2e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Re.createElement(Re.Fragment, null, i, a));
});
u2e(Re.createElement);
iw`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function A2e(e) {
  const { error: t } = e, n = "arkynAudioUploadError";
  return t ? /* @__PURE__ */ te.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ te.jsx(te.Fragment, {});
}
function I2e(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ te.jsx("strong", { className: o.trim(), children: t });
}
function B2e(e) {
  const { onChange: t, value: n, disableDrag: r = !1, onDragging: o } = e, [i, a] = P(!1), s = dt(null), l = () => {
    a(!0);
  }, u = () => {
    a(!1);
  }, c = (f) => {
    if (r || !i || !s.current) return;
    const v = s.current.getBoundingClientRect(), g = f.clientX - v.left, E = Math.min(Math.max(g / v.width * 100, 0), 100);
    t(E);
  }, p = (f) => {
    if (!s.current) return;
    const v = s.current.getBoundingClientRect(), g = f.clientX - v.left, E = Math.min(Math.max(g / v.width * 100, 0), 100);
    t(E);
  };
  h(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const y = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ te.jsxs(
    "div",
    {
      className: y,
      ref: s,
      onMouseDown: l,
      onClick: p,
      children: [
        /* @__PURE__ */ te.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ te.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function N2e(e) {
  var S, z, L, R;
  const {
    filePath: t,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: a,
    changeAudioButtonText: s
  } = e, [l, u] = P(0), c = dt(null), [p, d] = P(!1), [y, f] = P(!1);
  h(() => {
    const B = c.current;
    if (!B) return;
    const H = () => {
      const V = B.duration, q = B.currentTime / V * 100;
      u(q);
    };
    return B.addEventListener("timeupdate", H), () => {
      B.removeEventListener("timeupdate", H);
    };
  }, []);
  function v(B) {
    const H = c.current;
    if (!H) return;
    const V = H.duration, W = B / 100 * V;
    H.currentTime = W;
  }
  function g() {
    var B;
    (B = c.current) == null || B.play(), f(!0);
  }
  function E() {
    var B;
    (B = c.current) == null || B.pause(), f(!1);
  }
  function w() {
    y ? E() : g();
  }
  const D = (S = c.current) == null ? void 0 : S.currentTime, x = (z = c.current) == null ? void 0 : z.duration;
  function m(B) {
    if (!B) return "00:00";
    const H = Math.floor(B / 60), V = Math.floor(B % 60), W = String(H).padStart(2, "0"), q = String(V).padStart(2, "0");
    return `${W}:${q}`;
  }
  p || !y ? (L = c.current) == null || L.pause() : y && ((R = c.current) == null || R.play());
  function C() {
    if (n) return;
    const B = document.createElement("input");
    B.type = "file", B.accept = r, B.onchange = (H) => {
      var W;
      const V = (W = H.target.files) == null ? void 0 : W[0];
      V && o(V);
    }, B.click();
  }
  return /* @__PURE__ */ te.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ te.jsx("audio", { ref: c, src: t, onEnded: E }),
    /* @__PURE__ */ te.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ te.jsxs("button", { type: "button", onClick: w, children: [
        y && /* @__PURE__ */ te.jsx(tJ, {}),
        !y && /* @__PURE__ */ te.jsx(nJ, {})
      ] }),
      /* @__PURE__ */ te.jsx("p", { children: m(D) }),
      /* @__PURE__ */ te.jsx(
        B2e,
        {
          value: l,
          onChange: v,
          onDragging: d
        }
      ),
      /* @__PURE__ */ te.jsx("p", { children: m(x) })
    ] }),
    /* @__PURE__ */ te.jsx(zre, {}),
    /* @__PURE__ */ te.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!a && /* @__PURE__ */ te.jsx(bBe, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ te.jsx(
        yBe,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: a,
          icon: m9,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ te.jsx(
        vG,
        {
          isLoading: i,
          onClick: C,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: s
        }
      )
    ] })
  ] });
}
function R2e(e) {
  const {
    dropAudioText: t,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ te.jsxs("div", { onDrop: s, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ te.jsx(
      vG,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ te.jsx("p", { children: t })
  ] });
}
function X8e(e) {
  const {
    name: t,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: a = "url",
    selectAudioButtonText: s = "Selecionar arquivo de áudio",
    dropAudioText: l = "Ou arraste e solte um arquivo de áudio aqui",
    changeAudioButtonText: u = "Trocar arquivo de áudio",
    acceptAudio: c = "audio/*",
    action: p,
    defaultValue: d = "",
    showAsterisk: y = !1,
    disabled: f = !1
  } = e, g = vBe()[t], [E, w] = P(d), [D, x] = P(""), [m, C] = P(null), [S, z] = P(d), [L, R] = P(!1);
  async function B(X) {
    if (f) return;
    R(!0), C(X), x("");
    const ee = new FormData();
    ee.append(r, X), await fetch(p, { method: o, body: ee }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? x(J.error) : w(J == null ? void 0 : J[a]), i && i(J == null ? void 0 : J[a]);
    }).catch((J) => {
      console.error(J), x("Erro ao enviar audio");
    }).finally(() => R(!1));
  }
  function H(X) {
    if (!f) {
      if (console.log(X.type), X.type.indexOf("audio") === -1) {
        x("O arquivo selecionado não é um arquivo de áudio");
        return;
      }
      z(URL.createObjectURL(X)), B(X);
    }
  }
  const V = g || D, Y = `arkynAudioUpload ${V ? "hasError" : "noHasError"} ${S ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ te.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ te.jsx(I2e, { label: n, showAsterisk: y }),
    /* @__PURE__ */ te.jsxs("div", { className: Y, children: [
      /* @__PURE__ */ te.jsx("input", { type: "hidden", name: t, value: E || "" }),
      !S && /* @__PURE__ */ te.jsx(
        R2e,
        {
          disabled: f,
          isLoading: L,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: H,
          selectAudioButtonText: s
        }
      ),
      S && /* @__PURE__ */ te.jsx(
        N2e,
        {
          filePath: S,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: f,
          handleSelectFile: H,
          isLoading: L,
          reSendAudio: V && m ? () => B(m) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ te.jsx(A2e, { error: V })
  ] });
}
function my(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, y = { xs: 12, sm: 16, md: 20, lg: 24 }[i], g = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ te.jsxs("button", { className: g, disabled: l || t, ...p, children: [
    /* @__PURE__ */ te.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ te.jsx(js, { size: y, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ te.jsxs("div", { className: "arkynButtonContent", children: [
      Cm(y, a),
      c,
      Cm(y, s)
    ] })
  ] });
}
function cY() {
  const e = gL(), t = b9(), n = w9(), [r, o] = P(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  h(() => {
    var c, p;
    let u = ((p = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : p.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), h(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, t]);
  const s = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const pY = Ye({});
function k3(e) {
  var p;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = cY(), a = dt(null), s = ((p = a.current) == null ? void 0 : p.name) || "", l = (i == null ? void 0 : i[s]) || null, u = YX(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ te.jsx(pY.Provider, { value: { error: l, id: u, inputRef: a }, children: /* @__PURE__ */ te.jsx(
    "section",
    {
      id: r || s || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function bi() {
  return ge(pY);
}
function J8e(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: a = null,
    onCheck: s,
    value: l,
    ...u
  } = e, { id: c, inputRef: p, error: d } = bi(), y = o || !!d, [f, v] = P(i || !1), g = typeof a == "boolean" ? a : f, D = `arkynCheckbox ${r} ${y ? "errorTrue" : "errorFalse"} ${g ? "checkedTrue" : "checkedFalse"} ${n}`;
  function x() {
    const m = f;
    v(!m), s && s(m ? "" : l || "checked");
  }
  return /* @__PURE__ */ te.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: D,
      onClick: x,
      ...u,
      children: [
        /* @__PURE__ */ te.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: p,
            value: g ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ te.jsx(fL, {})
      ]
    }
  );
}
function Q8e(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = bi();
  return t ? /* @__PURE__ */ te.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ te.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ te.jsx(te.Fragment, {});
}
function S3(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = bi(), a = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ te.jsx("label", { className: a.trim(), htmlFor: o, ...r });
}
function F2e(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, p = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ te.jsxs(
    "button",
    {
      disabled: a || t,
      className: p.trim(),
      ...l,
      children: [
        /* @__PURE__ */ te.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ te.jsx(js, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ te.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ te.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function z2e(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = e, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ te.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ te.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
function U2e(e) {
  const {
    disabled: t,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: a,
    reSendImage: s
  } = e;
  function l() {
    if (t) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && a(p);
    }, u.click();
  }
  return /* @__PURE__ */ te.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        s && /* @__PURE__ */ te.jsx(z2e, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ te.jsx(
          F2e,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: s,
            icon: m9,
            disabled: t
          }
        ) }),
        /* @__PURE__ */ te.jsx(
          my,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: t,
            children: i
          }
        )
      ]
    }
  );
}
function W2e(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ te.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ te.jsx(te.Fragment, {});
}
function $2e(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ te.jsx("strong", { className: o.trim(), children: t });
}
function H2e(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: a
  } = e;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var d;
      const p = (d = c.target.files) == null ? void 0 : d[0];
      p && o(p);
    }, u.click();
  }
  return /* @__PURE__ */ te.jsxs("div", { onDrop: s, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ te.jsx(
      my,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ te.jsx("p", { children: t })
  ] });
}
function V2e(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: a = "file",
    method: s = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: p = "Selecionar imagem",
    dropImageText: d = "Ou arraste e solte a imagem aqui",
    onUpload: y,
    disabled: f = !1
  } = e, g = cY()[t], [E, w] = P(n), [D, x] = P(""), [m, C] = P(null), [S, z] = P(n), [L, R] = P(!1);
  async function B(X) {
    if (f) return;
    R(!0), C(X), x("");
    const ee = new FormData();
    ee.append(a, X), await fetch(i, { method: s, body: ee }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? x(J.error) : w(J == null ? void 0 : J[u]), y && y(J == null ? void 0 : J[u]);
    }).catch((J) => {
      console.error(J), x("Erro ao enviar imagem");
    }).finally(() => R(!1));
  }
  function H(X) {
    f || (z(URL.createObjectURL(X)), B(X));
  }
  const V = g || D, Y = `arkynImageUpload ${V ? "hasError" : "noHasError"} ${S ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ te.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ te.jsx($2e, { label: r, showAsterisk: o }),
    /* @__PURE__ */ te.jsxs("div", { className: Y, children: [
      /* @__PURE__ */ te.jsx("input", { type: "hidden", name: t, value: E || "" }),
      !S && /* @__PURE__ */ te.jsx(
        H2e,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          dropImageText: d,
          handleSelectFile: H,
          selectImageButtonText: p
        }
      ),
      S && /* @__PURE__ */ te.jsx(
        U2e,
        {
          disabled: f,
          isLoading: L,
          acceptImage: l,
          filePath: S,
          handleSelectFile: H,
          changeImageButtonText: c,
          reSendImage: V && m ? () => B(m) : void 0
        }
      )
    ] }),
    V && /* @__PURE__ */ te.jsx(W2e, { error: V })
  ] });
}
function ul(e, t, n) {
  if (!e) return /* @__PURE__ */ te.jsx(te.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ te.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ te.jsx("p", { className: n, children: /* @__PURE__ */ te.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function JS(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function dY(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function fY(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const QS = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, hY = JS(QS.CNPJ).length;
function Z2e(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    defaultValue: d,
    readOnly: y,
    onFocus: f,
    onBlur: v,
    title: g,
    style: E,
    onChange: w,
    ...D
  } = e;
  function x(W) {
    let q = JS(W);
    const Y = fY(q);
    if (!(q.length > hY))
      return q = dY(q, QS[Y]), q;
  }
  const m = c ? "right" : "left", B = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || y || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: B,
    prefix: ul(s, V, "prefix"),
    sufix: ul(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: x(d || ""),
    disabled: p,
    readOnly: y,
    onFocus: f,
    onBlur: v,
    title: g,
    style: E,
    onChange: w,
    loadingPosition: m,
    iconSize: V,
    Spinner: /* @__PURE__ */ te.jsx(js, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...D
  };
}
function q2e(e) {
  const [t, n] = P(!1), r = dt(null), { inputRef: o, id: i, error: a } = bi(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: y,
    sufix: f,
    iconSize: v,
    loadingPosition: g,
    isLoading: E,
    LeftIcon: w,
    readOnly: D,
    onFocus: x,
    onBlur: m,
    RightIcon: C,
    Spinner: S,
    onChange: z,
    value: L,
    defaultValue: R,
    ...B
  } = Z2e({ ...e, id: i, isError: l }, t), [H, V] = P(R), W = w && !E, q = C && !E, Y = g === "left" && E, X = g === "right" && E;
  function ee() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function J(U) {
    let M = JS(U.target.value);
    const $ = fY(M);
    M.length > hY || (M = dY(M, QS[$]), U.target.value = M, V(M), z && z(U));
  }
  function k(U) {
    n(!0), x && x(U);
  }
  function _(U) {
    n(!1), m && m(U);
  }
  return /* @__PURE__ */ te.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: ee,
      className: d,
      children: [
        y,
        Y && S,
        W && /* @__PURE__ */ te.jsx(w, { size: v, strokeWidth: 2.5 }),
        /* @__PURE__ */ te.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: D,
            ref: s,
            value: L || H,
            onFocus: k,
            onChange: J,
            onBlur: _,
            ...B
          }
        ),
        q && /* @__PURE__ */ te.jsx(C, { size: v, strokeWidth: 2.5 }),
        X && S,
        f
      ]
    }
  );
}
const K2e = 3, G2e = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? K2e : 0), Wg = 2, M3 = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), KE = (e) => {
  let t = e;
  return typeof e == "string" ? (t = M3(e), t % 1 !== 0 && (t = t.toFixed(Wg))) : t = Number.isInteger(e) ? Number(e) * 10 ** Wg : e.toFixed(Wg), M3(t) / 10 ** Wg;
}, D3 = (e, t, n) => {
  if (!t) return [0, ""];
  const r = KE(t), o = G2e(e, r, n);
  return [r, o];
};
function Y2e(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: g,
    // showCents = false,
    max: E = 1e9,
    locale: w = "pt-BR",
    currency: D = "BRL",
    ...x
  } = e, m = c ? "right" : "left", B = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: B,
    prefix: ul(s, V, "prefix"),
    sufix: ul(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    locale: w,
    currency: D,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: g,
    max: E,
    // showCents,
    loadingPosition: m,
    iconSize: V,
    Spinner: /* @__PURE__ */ te.jsx(js, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...x
  };
}
function X2e(e) {
  const [t, n] = P(!1), [r, o] = P("0"), i = dt(null), { inputRef: a, id: s, error: l } = bi(), u = a || i, c = e.isError || !!l, {
    disabled: p,
    title: d,
    style: y,
    className: f,
    prefix: v,
    sufix: g,
    iconSize: E,
    loadingPosition: w,
    isLoading: D,
    LeftIcon: x,
    readOnly: m,
    onFocus: C,
    onBlur: S,
    RightIcon: z,
    Spinner: L,
    value: R,
    max: B,
    onChangeValue: H,
    onKeyPress: V,
    currency: W,
    locale: q,
    name: Y,
    defaultValue: X,
    ...ee
  } = Y2e({ ...e, id: s, isError: c }, t), J = x && !D, k = z && !D, _ = w === "left" && D, U = w === "right" && D;
  function M() {
    p || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function $(Z) {
    n(!0), C && C(Z);
  }
  function O(Z) {
    n(!1), S && S(Z);
  }
  const j = (Z) => {
    const [A, G] = D3(
      q,
      Z,
      W
    );
    return !B || A <= B ? (o(G), [A, G]) : [KE(r), r];
  }, F = (Z) => {
    Z.preventDefault();
    const [A, G] = j(Z.target.value);
    H && H(Z, String(A), String(G));
  }, T = (Z) => V && V(Z, Z.key, Z.key);
  return h(() => {
    const Z = R || +X || void 0, [, A] = D3(q, Z, W);
    o(A);
  }, [W, X, R]), /* @__PURE__ */ te.jsxs(
    "section",
    {
      title: d,
      style: y,
      onClick: M,
      className: f,
      children: [
        v,
        _ && L,
        J && /* @__PURE__ */ te.jsx(x, { size: E, strokeWidth: 2.5 }),
        /* @__PURE__ */ te.jsx(
          "input",
          {
            value: r,
            onChange: F,
            onBlur: O,
            onFocus: $,
            onKeyUp: T,
            disabled: p || D,
            readOnly: m,
            ...ee
          }
        ),
        /* @__PURE__ */ te.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: Y,
            value: KE(r)
          }
        ),
        U && L,
        k && /* @__PURE__ */ te.jsx(z, { size: E, strokeWidth: 2.5 }),
        g
      ]
    }
  );
}
function J2e(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: g,
    onChange: E,
    showMask: w = !1,
    type: D,
    ...x
  } = e, m = c ? "right" : "left", B = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: B,
    prefix: ul(s, V, "prefix"),
    sufix: ul(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: g,
    onChange: E,
    loadingPosition: m,
    iconSize: V,
    showMask: w,
    Spinner: /* @__PURE__ */ te.jsx(js, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...x
  };
}
const Q2e = ga((e, t) => /* @__PURE__ */ te.jsx("input", { ref: t, ...e }));
function eUe(e) {
  const [t, n] = P(!1), r = dt(null), { inputRef: o, id: i, error: a } = bi(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: y,
    sufix: f,
    iconSize: v,
    loadingPosition: g,
    isLoading: E,
    LeftIcon: w,
    readOnly: D,
    onFocus: x,
    onBlur: m,
    RightIcon: C,
    Spinner: S,
    ...z
  } = J2e({ ...e, id: i, isError: l }, t), L = w && !E, R = C && !E, B = g === "left" && E, H = g === "right" && E;
  function V() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function W(Y) {
    n(!0), x && x(Y);
  }
  function q(Y) {
    n(!1), m && m(Y);
  }
  return /* @__PURE__ */ te.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: V,
      className: d,
      children: [
        y,
        B && S,
        L && /* @__PURE__ */ te.jsx(w, { size: v, strokeWidth: 2.5 }),
        /* @__PURE__ */ te.jsx(
          yJ,
          {
            component: Q2e,
            ref: s,
            onFocus: W,
            onBlur: q,
            disabled: u,
            ...z
          }
        ),
        R && /* @__PURE__ */ te.jsx(C, { size: v, strokeWidth: 2.5 }),
        H && S,
        f
      ]
    }
  );
}
function tUe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: g,
    onChange: E,
    ...w
  } = e, D = c ? "right" : "left", L = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, B = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: L,
    prefix: ul(s, B, "prefix"),
    sufix: ul(l, B, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: y,
    onBlur: f,
    title: v,
    style: g,
    onChange: E,
    loadingPosition: D,
    iconSize: B,
    Spinner: /* @__PURE__ */ te.jsx(js, { className: "spinner", size: B, strokeWidth: 2.5 }),
    ...w
  };
}
function nUe(e) {
  const [t, n] = P(!1), r = dt(null), { inputRef: o, id: i, error: a } = bi(), s = o || r, l = e.isError || !!a, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: y,
    sufix: f,
    iconSize: v,
    loadingPosition: g,
    isLoading: E,
    LeftIcon: w,
    readOnly: D,
    onFocus: x,
    onBlur: m,
    RightIcon: C,
    type: S,
    Spinner: z,
    ...L
  } = tUe({ ...e, id: i, isError: l }, t), R = w && !E, B = C && !E, H = g === "left" && E, V = g === "right" && E;
  function W() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function q(X) {
    n(!0), x && x(X);
  }
  function Y(X) {
    n(!1), m && m(X);
  }
  return S === "hidden" ? /* @__PURE__ */ te.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: s,
      ...L
    }
  ) : /* @__PURE__ */ te.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: W,
      className: d,
      children: [
        y,
        H && z,
        R && /* @__PURE__ */ te.jsx(w, { size: v, strokeWidth: 2.5 }),
        /* @__PURE__ */ te.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: D,
            ref: s,
            onFocus: q,
            onBlur: Y,
            type: S,
            ...L
          }
        ),
        B && /* @__PURE__ */ te.jsx(C, { size: v, strokeWidth: 2.5 }),
        V && z,
        f
      ]
    }
  );
}
function sw(e) {
  return e.type === "currency" ? /* @__PURE__ */ te.jsx(X2e, { ...e }) : e.type === "masked" ? /* @__PURE__ */ te.jsx(eUe, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ te.jsx(q2e, { ...e }) : /* @__PURE__ */ te.jsx(nUe, { ...e });
}
function rUe(e) {
  const { iconSize: t, isLoading: n, disabled: r, readOnly: o, isFocused: i } = e, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ te.jsx(te.Fragment, {}) : /* @__PURE__ */ te.jsx(v9, { className: l, size: t, strokeWidth: 2.5 });
}
function oUe(e) {
  const {
    children: t,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s,
    readOnly: l,
    variant: u,
    size: c,
    id: p,
    prefixExists: d
  } = e, y = d ? "hasPrefix" : "", f = o ? "errored" : "", v = r || l || i ? "opacity" : "", g = a ? "focused" : "";
  return /* @__PURE__ */ te.jsx(
    "section",
    {
      onClick: n,
      id: p,
      className: `arkynMultiSelectContainer ${y} ${u} ${c} ${v} ${f} ${g} ${s}`,
      children: t
    }
  );
}
function iUe(e) {
  const { children: t, size: n } = e, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ te.jsx("div", { className: r, children: t });
}
function sUe(e) {
  const { label: t, value: n, handleChangeValue: r } = e;
  return /* @__PURE__ */ te.jsxs("div", { className: "arkynMultiSelectMark", children: [
    t,
    /* @__PURE__ */ te.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ te.jsx(hL, {})
      }
    )
  ] });
}
function aUe(e) {
  const { label: t, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = e, a = n(o) ? "active" : "", s = `arkynMultiSelectOption ${i} ${a}`;
  return /* @__PURE__ */ te.jsxs("div", { onClick: () => r(o), className: s, children: [
    t,
    " ",
    /* @__PURE__ */ te.jsx(fL, {})
  ] });
}
function lUe(e) {
  const { children: t, isFocused: n, isSearchable: r, onSearch: o } = e;
  function i(a) {
    r && o(a.target.value);
  }
  return n ? /* @__PURE__ */ te.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ te.jsx(
      sw,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: y9,
        onChange: i
      }
    ),
    t
  ] }) : /* @__PURE__ */ te.jsx(te.Fragment, {});
}
function uUe(e) {
  const { isFocused: t, handleBlur: n } = e;
  return t ? /* @__PURE__ */ te.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ te.jsx(te.Fragment, {});
}
function cUe(e) {
  const { iconSize: t, isLoading: n } = e;
  return n ? /* @__PURE__ */ te.jsx(
    js,
    {
      className: "arkynMultiSelectSpinner",
      size: t,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ te.jsx(te.Fragment, {});
}
function e5e(e) {
  const {
    name: t,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: a = [],
    isError: s,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: p,
    onSearch: d,
    onSelect: y,
    onBlur: f,
    notFoundText: v = "Sem opções disponíveis",
    onFocus: g,
    disabled: E = !1,
    prefix: w,
    size: D = "md",
    value: x,
    variant: m = "solid"
  } = e, C = bi(), S = dt(null), z = C.inputRef || S, L = C.id, R = s || !!C.error, H = { md: 20, lg: 20 }[D], V = t8(w, H, "prefix"), [W, q] = P(""), [Y, X] = P(!1), [ee, J] = P(a), k = x || ee;
  function _(T) {
    return k.includes(T);
  }
  function U(T) {
    const Z = n.find((A) => A.value === T);
    return (Z == null ? void 0 : Z.label) || "";
  }
  function M() {
    E || !(z != null && z.current) || Y || (X(!0), z.current.focus(), g && g());
  }
  function $() {
    X(!1), f && z.current && z.current.blur();
  }
  function O(T) {
    q(T), d && d(T);
  }
  function j(T) {
    _(T) ? J(ee.filter((Z) => Z !== T)) : J([...ee, T]), y && y(ee), i && $();
  }
  const F = n.filter((T) => !!(e.onSearch || !e.isSearchable || T.label.toLowerCase().includes(W.toLowerCase())));
  return /* @__PURE__ */ te.jsxs(
    oUe,
    {
      handleContainerFocus: M,
      disabled: E,
      isError: R,
      isFocused: Y,
      isLoading: l,
      readOnly: u,
      size: D,
      variant: m,
      className: r,
      prefixExists: !!w,
      id: L,
      children: [
        /* @__PURE__ */ te.jsx(
          "input",
          {
            ref: z,
            name: t,
            value: JSON.stringify(k),
            type: "hidden"
          }
        ),
        V,
        p && /* @__PURE__ */ te.jsx(p, { size: H, strokeWidth: 2.5 }),
        /* @__PURE__ */ te.jsxs(iUe, { size: D, children: [
          k.map((T) => /* @__PURE__ */ te.jsx(
            sUe,
            {
              label: U(T),
              value: T,
              handleChangeValue: j
            },
            T
          )),
          k.length <= 0 && /* @__PURE__ */ te.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ te.jsxs(
          lUe,
          {
            isFocused: Y,
            isSearchable: c,
            onSearch: O,
            children: [
              F.map(({ label: T, value: Z }) => /* @__PURE__ */ te.jsx(
                aUe,
                {
                  label: T,
                  value: Z,
                  size: D,
                  handleChangeValue: j,
                  optionHasSelected: _
                },
                Z
              )),
              F.length <= 0 && /* @__PURE__ */ te.jsx("p", { children: v })
            ]
          }
        ),
        /* @__PURE__ */ te.jsx(
          rUe,
          {
            disabled: E,
            isFocused: Y,
            readOnly: u,
            iconSize: H,
            isLoading: l
          }
        ),
        /* @__PURE__ */ te.jsx(cUe, { iconSize: H, isLoading: l }),
        /* @__PURE__ */ te.jsx(uUe, { handleBlur: $, isFocused: Y })
      ]
    }
  );
}
const gY = Ye({});
function pUe() {
  return ge(gY);
}
function t5e(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: a = "",
    ...s
  } = e, [l, u] = P(t || ""), { inputRef: c, id: p } = bi();
  function d(f) {
    u(f), o && o(f);
  }
  const y = `arkynRadioGroup ${i} ${a}`;
  return /* @__PURE__ */ te.jsxs(
    gY.Provider,
    {
      value: { onChange: d, value: r || l, size: i },
      children: [
        /* @__PURE__ */ te.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: p,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ te.jsx("div", { className: y.trim(), ...s })
      ]
    }
  );
}
function n5e(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...a
  } = e, { onChange: s, size: l, value: u } = pUe(), { error: c } = bi(), v = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ te.jsxs("label", { className: v.trim(), children: [
    /* @__PURE__ */ te.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => s(t),
        onFocus: () => s(t),
        ...a
      }
    ),
    o
  ] });
}
var Oa = {};
Object.defineProperty(Oa, "__esModule", {
  value: !0
});
var dUe = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), cO = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, mY = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: dUe ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, eM = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var $g = 1; $g < 20; $g++)
  eM["f" + $g] = 111 + $g;
function aw(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(a) {
    return vY(a, t);
  }), o = function(s) {
    return r.some(function(l) {
      return yY(l, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function fUe(e, t) {
  return aw(e, t);
}
function hUe(e, t) {
  return aw(e, { byKey: !0 }, t);
}
function vY(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var a in cO)
    r[cO[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(s = (p = c.next()).done); s = !0) {
      var d = p.value, y = d.endsWith("?") && d.length > 1;
      y && (d = d.slice(0, -1));
      var f = tM(d), v = cO[f];
      if (d.length > 1 && !v && !mY[d] && !eM[f])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !v) && (n ? r.key = f : r.which = bY(d)), v && (r[v] = y ? null : !0);
    }
  } catch (g) {
    l = !0, u = g;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function yY(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function bY(e) {
  e = tM(e);
  var t = eM[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function tM(e) {
  return e = e.toLowerCase(), e = mY[e] || e, e;
}
var gUe = Oa.default = aw, pO = Oa.isHotkey = aw;
Oa.isCodeHotkey = fUe;
Oa.isKeyHotkey = hUe;
Oa.parseHotkey = vY;
Oa.compareHotkey = yY;
Oa.toKeyCode = bY;
Oa.toKeyName = tM;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function _3(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function mUe(e) {
  var t, n;
  return _3(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(_3(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var vUe = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return mUe(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || al.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || al.isOperationList(e.undos[0].operations));
  }
}, dO = /* @__PURE__ */ new WeakMap(), dp = /* @__PURE__ */ new WeakMap(), mu = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return vUe.isHistory(e.history) && Q.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return dp.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return dO.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = mu.isMerging(e);
    dp.set(e, !0), t(), dp.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = mu.isMerging(e);
    dp.set(e, !1), t(), dp.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = mu.isSaving(e);
    dO.set(e, !1), t(), dO.set(e, n);
  }
}, yUe = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && je.setSelection(t, i.selectionBefore), mu.withoutSaving(t, () => {
        Q.withoutNormalizing(t, () => {
          for (var a of i.operations)
            t.apply(a);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      mu.withoutSaving(t, () => {
        Q.withoutNormalizing(t, () => {
          var a = i.operations.map(al.inverse).reverse();
          for (var s of a)
            t.apply(s);
          i.selectionBefore && je.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: a
    } = i, s = a[a.length - 1], l = s && s.operations[s.operations.length - 1], u = mu.isSaving(t), c = mu.isMerging(t);
    if (u == null && (u = wUe(r)), u) {
      if (c == null && (s == null ? c = !1 : o.length !== 0 ? c = !0 : c = bUe(r, l)), s && c)
        s.operations.push(r);
      else {
        var p = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", p);
      }
      for (; a.length > 100; )
        a.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, bUe = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && le.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && le.equals(e.path, t.path)), wUe = (e, t) => e.type !== "set_selection", CUe = EUe, wY = "֑-߿יִ-﷽ﹰ-ﻼ", CY = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", OUe = new RegExp("^[^" + CY + "]*[" + wY + "]"), xUe = new RegExp("^[^" + wY + "]*[" + CY + "]");
function EUe(e) {
  return e = String(e || ""), OUe.test(e) ? "rtl" : xUe.test(e) ? "ltr" : "neutral";
}
const OY = /* @__PURE__ */ My(CUe);
function LUe(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var nM = LUe, PUe = typeof Jn == "object" && Jn && Jn.Object === Object && Jn, kUe = PUe, SUe = kUe, MUe = typeof self == "object" && self && self.Object === Object && self, DUe = SUe || MUe || Function("return this")(), xY = DUe, _Ue = xY, jUe = function() {
  return _Ue.Date.now();
}, TUe = jUe, AUe = /\s/;
function IUe(e) {
  for (var t = e.length; t-- && AUe.test(e.charAt(t)); )
    ;
  return t;
}
var BUe = IUe, NUe = BUe, RUe = /^\s+/;
function FUe(e) {
  return e && e.slice(0, NUe(e) + 1).replace(RUe, "");
}
var zUe = FUe, UUe = xY, WUe = UUe.Symbol, EY = WUe, j3 = EY, LY = Object.prototype, $Ue = LY.hasOwnProperty, HUe = LY.toString, fp = j3 ? j3.toStringTag : void 0;
function VUe(e) {
  var t = $Ue.call(e, fp), n = e[fp];
  try {
    e[fp] = void 0;
    var r = !0;
  } catch {
  }
  var o = HUe.call(e);
  return r && (t ? e[fp] = n : delete e[fp]), o;
}
var ZUe = VUe, qUe = Object.prototype, KUe = qUe.toString;
function GUe(e) {
  return KUe.call(e);
}
var YUe = GUe, T3 = EY, XUe = ZUe, JUe = YUe, QUe = "[object Null]", eWe = "[object Undefined]", A3 = T3 ? T3.toStringTag : void 0;
function tWe(e) {
  return e == null ? e === void 0 ? eWe : QUe : A3 && A3 in Object(e) ? XUe(e) : JUe(e);
}
var nWe = tWe;
function rWe(e) {
  return e != null && typeof e == "object";
}
var oWe = rWe, iWe = nWe, sWe = oWe, aWe = "[object Symbol]";
function lWe(e) {
  return typeof e == "symbol" || sWe(e) && iWe(e) == aWe;
}
var uWe = lWe, cWe = zUe, I3 = nM, pWe = uWe, B3 = NaN, dWe = /^[-+]0x[0-9a-f]+$/i, fWe = /^0b[01]+$/i, hWe = /^0o[0-7]+$/i, gWe = parseInt;
function mWe(e) {
  if (typeof e == "number")
    return e;
  if (pWe(e))
    return B3;
  if (I3(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = I3(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = cWe(e);
  var n = fWe.test(e);
  return n || hWe.test(e) ? gWe(e.slice(2), n ? 2 : 8) : dWe.test(e) ? B3 : +e;
}
var vWe = mWe, yWe = nM, fO = TUe, N3 = vWe, bWe = "Expected a function", wWe = Math.max, CWe = Math.min;
function OWe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(bWe);
  t = N3(t) || 0, yWe(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? wWe(N3(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, z = o;
    return r = o = void 0, u = C, a = e.apply(z, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, z = C - u, L = t - S;
    return p ? CWe(L, i - z) : L;
  }
  function g(C) {
    var S = C - l, z = C - u;
    return l === void 0 || S >= t || S < 0 || p && z >= i;
  }
  function E() {
    var C = fO();
    if (g(C))
      return w(C);
    s = setTimeout(E, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(fO());
  }
  function m() {
    var C = fO(), S = g(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return clearTimeout(s), s = setTimeout(E, t), y(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
var PY = OWe;
const xWe = /* @__PURE__ */ My(PY);
var EWe = PY, LWe = nM, PWe = "Expected a function";
function kWe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(PWe);
  return LWe(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), EWe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var SWe = kWe;
const MWe = /* @__PURE__ */ My(SWe), R3 = (e) => typeof e == "object" && e != null && e.nodeType === 1, F3 = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", hO = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return F3(n.overflowY, t) || F3(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, Hg = (e, t, n, r, o, i, a, s) => i < e && a > t || i > e && a < t ? 0 : i <= e && s <= n || a >= t && s >= n ? i - e - r : a > t && s < n || i < e && s > n ? a - t + o : 0, DWe = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, z3 = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: a, block: s, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, p = typeof u == "function" ? u : (Y) => Y !== u;
  if (!R3(e)) throw new TypeError("Invalid target");
  const d = document.scrollingElement || document.documentElement, y = [];
  let f = e;
  for (; R3(f) && p(f); ) {
    if (f = DWe(f), f === d) {
      y.push(f);
      break;
    }
    f != null && f === document.body && hO(f) && !hO(document.documentElement) || f != null && hO(f, c) && y.push(f);
  }
  const v = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, g = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: E, scrollY: w } = window, { height: D, width: x, top: m, right: C, bottom: S, left: z } = e.getBoundingClientRect(), { top: L, right: R, bottom: B, left: H } = ((Y) => {
    const X = window.getComputedStyle(Y);
    return { top: parseFloat(X.scrollMarginTop) || 0, right: parseFloat(X.scrollMarginRight) || 0, bottom: parseFloat(X.scrollMarginBottom) || 0, left: parseFloat(X.scrollMarginLeft) || 0 };
  })(e);
  let V = s === "start" || s === "nearest" ? m - L : s === "end" ? S + B : m + D / 2 - L + B, W = l === "center" ? z + x / 2 - H + R : l === "end" ? C + R : z - H;
  const q = [];
  for (let Y = 0; Y < y.length; Y++) {
    const X = y[Y], { height: ee, width: J, top: k, right: _, bottom: U, left: M } = X.getBoundingClientRect();
    if (a === "if-needed" && m >= 0 && z >= 0 && S <= g && C <= v && m >= k && S <= U && z >= M && C <= _) return q;
    const $ = getComputedStyle(X), O = parseInt($.borderLeftWidth, 10), j = parseInt($.borderTopWidth, 10), F = parseInt($.borderRightWidth, 10), T = parseInt($.borderBottomWidth, 10);
    let Z = 0, A = 0;
    const G = "offsetWidth" in X ? X.offsetWidth - X.clientWidth - O - F : 0, N = "offsetHeight" in X ? X.offsetHeight - X.clientHeight - j - T : 0, ue = "offsetWidth" in X ? X.offsetWidth === 0 ? 0 : J / X.offsetWidth : 0, fe = "offsetHeight" in X ? X.offsetHeight === 0 ? 0 : ee / X.offsetHeight : 0;
    if (d === X) Z = s === "start" ? V : s === "end" ? V - g : s === "nearest" ? Hg(w, w + g, g, j, T, w + V, w + V + D, D) : V - g / 2, A = l === "start" ? W : l === "center" ? W - v / 2 : l === "end" ? W - v : Hg(E, E + v, v, O, F, E + W, E + W + x, x), Z = Math.max(0, Z + w), A = Math.max(0, A + E);
    else {
      Z = s === "start" ? V - k - j : s === "end" ? V - U + T + N : s === "nearest" ? Hg(k, U, ee, j, T + N, V, V + D, D) : V - (k + ee / 2) + N / 2, A = l === "start" ? W - M - O : l === "center" ? W - (M + J / 2) + G / 2 : l === "end" ? W - _ + F + G : Hg(M, _, J, O, F + G, W, W + x, x);
      const { scrollLeft: oe, scrollTop: Ie } = X;
      Z = fe === 0 ? 0 : Math.max(0, Math.min(Ie + Z / fe, X.scrollHeight - ee / fe + N)), A = ue === 0 ? 0 : Math.max(0, Math.min(oe + A / ue, X.scrollWidth - J / ue + G)), V += Ie - Z, W += oe - A;
    }
    q.push({ el: X, top: Z, left: A });
  }
  return q;
}, _We = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function jWe(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(z3(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: a } of z3(e, _We(t))) {
    const s = i - n.top + n.bottom, l = a - n.left + n.right;
    o.scroll({ top: s, left: l, behavior: r });
  }
}
var bu = [], TWe = function() {
  return bu.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, AWe = function() {
  return bu.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, U3 = "ResizeObserver loop completed with undelivered notifications.", IWe = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: U3
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = U3), window.dispatchEvent(e);
}, qd;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(qd || (qd = {}));
var wu = function(e) {
  return Object.freeze(e);
}, BWe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, wu(this);
  }
  return e;
}(), kY = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, wu(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, a = t.bottom, s = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), rM = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, SY = function(e) {
  if (rM(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, a = o.offsetHeight;
  return !(i || a || e.getClientRects().length);
}, W3 = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, NWe = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, rd = typeof window < "u" ? window : {}, Vg = /* @__PURE__ */ new WeakMap(), $3 = /auto|scroll/, RWe = /^tb|vertical/, FWe = /msie|trident/i.test(rd.navigator && rd.navigator.userAgent), vs = function(e) {
  return parseFloat(e || "0");
}, ec = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new BWe((n ? t : e) || 0, (n ? e : t) || 0);
}, H3 = wu({
  devicePixelContentBoxSize: ec(),
  borderBoxSize: ec(),
  contentBoxSize: ec(),
  contentRect: new kY(0, 0, 0, 0)
}), MY = function(e, t) {
  if (t === void 0 && (t = !1), Vg.has(e) && !t)
    return Vg.get(e);
  if (SY(e))
    return Vg.set(e, H3), H3;
  var n = getComputedStyle(e), r = rM(e) && e.ownerSVGElement && e.getBBox(), o = !FWe && n.boxSizing === "border-box", i = RWe.test(n.writingMode || ""), a = !r && $3.test(n.overflowY || ""), s = !r && $3.test(n.overflowX || ""), l = r ? 0 : vs(n.paddingTop), u = r ? 0 : vs(n.paddingRight), c = r ? 0 : vs(n.paddingBottom), p = r ? 0 : vs(n.paddingLeft), d = r ? 0 : vs(n.borderTopWidth), y = r ? 0 : vs(n.borderRightWidth), f = r ? 0 : vs(n.borderBottomWidth), v = r ? 0 : vs(n.borderLeftWidth), g = p + u, E = l + c, w = v + y, D = d + f, x = s ? e.offsetHeight - D - e.clientHeight : 0, m = a ? e.offsetWidth - w - e.clientWidth : 0, C = o ? g + w : 0, S = o ? E + D : 0, z = r ? r.width : vs(n.width) - C - m, L = r ? r.height : vs(n.height) - S - x, R = z + g + m + w, B = L + E + x + D, H = wu({
    devicePixelContentBoxSize: ec(Math.round(z * devicePixelRatio), Math.round(L * devicePixelRatio), i),
    borderBoxSize: ec(R, B, i),
    contentBoxSize: ec(z, L, i),
    contentRect: new kY(p, l, z, L)
  });
  return Vg.set(e, H), H;
}, DY = function(e, t, n) {
  var r = MY(e, n), o = r.borderBoxSize, i = r.contentBoxSize, a = r.devicePixelContentBoxSize;
  switch (t) {
    case qd.DEVICE_PIXEL_CONTENT_BOX:
      return a;
    case qd.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, zWe = /* @__PURE__ */ function() {
  function e(t) {
    var n = MY(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = wu([n.borderBoxSize]), this.contentBoxSize = wu([n.contentBoxSize]), this.devicePixelContentBoxSize = wu([n.devicePixelContentBoxSize]);
  }
  return e;
}(), _Y = function(e) {
  if (SY(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, UWe = function() {
  var e = 1 / 0, t = [];
  bu.forEach(function(a) {
    if (a.activeTargets.length !== 0) {
      var s = [];
      a.activeTargets.forEach(function(u) {
        var c = new zWe(u.target), p = _Y(u.target);
        s.push(c), u.lastReportedSize = DY(u.target, u.observedBox), p < e && (e = p);
      }), t.push(function() {
        a.callback.call(a.observer, s, a.observer);
      }), a.activeTargets.splice(0, a.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, V3 = function(e) {
  bu.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (_Y(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, WWe = function() {
  var e = 0;
  for (V3(e); TWe(); )
    e = UWe(), V3(e);
  return AWe() && IWe(), e > 0;
}, gO, jY = [], $We = function() {
  return jY.splice(0).forEach(function(e) {
    return e();
  });
}, HWe = function(e) {
  if (!gO) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return $We();
    }).observe(n, r), gO = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  jY.push(e), gO();
}, VWe = function(e) {
  HWe(function() {
    requestAnimationFrame(e);
  });
}, fm = 0, ZWe = function() {
  return !!fm;
}, qWe = 250, KWe = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, Z3 = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], q3 = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, mO = !1, GWe = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = qWe), !mO) {
      mO = !0;
      var r = q3(t);
      VWe(function() {
        var o = !1;
        try {
          o = WWe();
        } finally {
          if (mO = !1, t = r - q3(), !ZWe())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, KWe);
    };
    document.body ? n() : rd.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), Z3.forEach(function(n) {
      return rd.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), Z3.forEach(function(n) {
      return rd.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), GE = new GWe(), K3 = function(e) {
  !fm && e > 0 && GE.start(), fm += e, !fm && GE.stop();
}, YWe = function(e) {
  return !rM(e) && !NWe(e) && getComputedStyle(e).display === "inline";
}, XWe = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || qd.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = DY(this.target, this.observedBox, !0);
    return YWe(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), JWe = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), Zg = /* @__PURE__ */ new WeakMap(), G3 = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, qg = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new JWe(t, n);
    Zg.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = Zg.get(t), i = o.observationTargets.length === 0;
    G3(o.observationTargets, n) < 0 && (i && bu.push(o), o.observationTargets.push(new XWe(n, r && r.box)), K3(1), GE.schedule());
  }, e.unobserve = function(t, n) {
    var r = Zg.get(t), o = G3(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && bu.splice(bu.indexOf(r), 1), r.observationTargets.splice(o, 1), K3(-1));
  }, e.disconnect = function(t) {
    var n = this, r = Zg.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), QWe = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    qg.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!W3(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    qg.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!W3(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    qg.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    qg.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function e$e(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function cc(e, t) {
  if (e == null) return {};
  var n = e$e(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function Kd(e) {
  "@babel/helpers - typeof";
  return Kd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Kd(e);
}
function t$e(e, t) {
  if (Kd(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Kd(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function n$e(e) {
  var t = t$e(e, "string");
  return Kd(t) === "symbol" ? t : String(t);
}
function ls(e, t, n) {
  return t = n$e(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var oM = /* @__PURE__ */ Ye(null), jl = () => {
  var e = ge(oM);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, vO, yO, TY = parseInt(Ce.version.split(".")[0], 10), AY = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, Y3 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Uo = typeof navigator < "u" && /Android/.test(navigator.userAgent), qu = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), nu = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), r$e = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), IY = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), o$e = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), i$e = Uo && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), s$e = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), a$e = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), l$e = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), hm = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((vO = navigator.userAgent.match(/Version\/(\d+)/)) !== null && vO !== void 0 && vO[1] && parseInt((yO = navigator.userAgent.match(/Version\/(\d+)/)) === null || yO === void 0 ? void 0 : yO[1], 10) < 17);
var Ia = (!o$e || !i$e) && !r$e && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", tc = /* @__PURE__ */ new WeakMap(), iM = /* @__PURE__ */ new WeakMap(), sM = /* @__PURE__ */ new WeakMap(), BY = /* @__PURE__ */ new WeakMap(), gm = /* @__PURE__ */ new WeakMap(), YE = /* @__PURE__ */ new WeakMap(), Gd = /* @__PURE__ */ new WeakMap(), Cu = /* @__PURE__ */ new WeakMap(), vy = /* @__PURE__ */ new WeakMap(), lw = /* @__PURE__ */ new WeakMap(), XE = /* @__PURE__ */ new WeakMap(), ll = /* @__PURE__ */ new WeakMap(), vu = /* @__PURE__ */ new WeakMap(), od = /* @__PURE__ */ new WeakMap(), JE = /* @__PURE__ */ new WeakMap(), aM = /* @__PURE__ */ new WeakMap(), us = /* @__PURE__ */ new WeakMap(), sa = /* @__PURE__ */ new WeakMap(), Yo = /* @__PURE__ */ new WeakMap(), Xa = /* @__PURE__ */ new WeakMap(), Ja = /* @__PURE__ */ new WeakMap(), NY = /* @__PURE__ */ new WeakMap(), pc = Symbol("placeholder"), RY = Symbol("mark-placeholder"), FY = globalThis.Node, u$e = globalThis.Text, lM = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, c$e = (e) => cl(e) && e.nodeType === 8, as = (e) => cl(e) && e.nodeType === 1, cl = (e) => {
  var t = lM(e);
  return !!t && e instanceof t.Node;
}, QE = (e) => {
  var t = e && e.anchorNode && lM(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, zY = (e) => cl(e) && e.nodeType === 3, p$e = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, d$e = (e) => {
  var [t, n] = e;
  if (as(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = UY(t, o, r ? "backward" : "forward"), r = o < n; as(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = h$e(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, f$e = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, UY = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, a = !1, s = !1; (c$e(o) || as(o) && o.childNodes.length === 0 || as(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, h$e = (e, t, n) => {
  var [r] = UY(e, t, n);
  return r;
}, WY = (e) => {
  var t = "";
  if (zY(e) && e.nodeValue)
    return e.nodeValue;
  if (as(e)) {
    for (var n of Array.from(e.childNodes))
      t += WY(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, g$e = /data-slate-fragment="(.+?)"/m, m$e = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(g$e) || [];
  return n;
}, id = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), uM = (e, t, n) => {
  var {
    target: r
  } = t;
  if (as(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = be.getWindow(e);
  if (o.contains(r))
    return be.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : uM(e, i, n);
}, v$e = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, X3 = (e, t) => !!(e.compareDocumentPosition(t) & FY.DOCUMENT_POSITION_PRECEDING), y$e = (e, t) => !!(e.compareDocumentPosition(t) & FY.DOCUMENT_POSITION_FOLLOWING), b$e = 0;
class w$e {
  constructor() {
    ls(this, "id", void 0), this.id = "".concat(b$e++);
  }
}
var be = {
  androidPendingDiffs: (e) => Yo.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = aM.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = be.toDOMNode(e, e), n = be.findDocumentOrShadowRoot(e);
    ll.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = be.findDocumentOrShadowRoot(e), r = id(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && je.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = be.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = be.toSlateNode(e, t.target), a = be.findPath(e, i);
    if (rt.isElement(i) && Q.isVoid(e, i)) {
      var s = o.getBoundingClientRect(), l = e.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = Q.point(e, a, {
        edge: l ? "start" : "end"
      }), c = l ? Q.before(e, u) : Q.after(e, u);
      if (c) {
        var p = Q.range(e, c);
        return p;
      }
    }
    var d, {
      document: y
    } = be.getWindow(e);
    if (y.caretRangeFromPoint)
      d = y.caretRangeFromPoint(n, r);
    else {
      var f = y.caretPositionFromPoint(n, r);
      f && (d = y.createRange(), d.setStart(f.offsetNode, f.offset), d.setEnd(f.offsetNode, f.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var v = be.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return v;
  },
  findKey: (e, t) => {
    var n = vy.get(t);
    return n || (n = new w$e(), vy.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = sM.get(r);
      if (o == null) {
        if (Q.isEditor(r))
          return n;
        break;
      }
      var i = iM.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Lo.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!ll.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          be.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = be.toDOMNode(t, t), o = be.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = id(o), a = be.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(a);
        }
        t.selection || je.select(t, Q.start(t, [])), ll.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = BY.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = be.toDOMNode(t, t), a;
    try {
      a = as(n) ? n : n.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return a ? a.closest("[data-slate-editor]") === i && (!o || a.isContentEditable ? !0 : typeof a.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    a.closest('[contenteditable="false"]') === i || !!a.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => cl(t) && be.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Q.hasPath(e, n.path) && Q.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => be.hasEditableTarget(e, t) || be.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => cl(t) && be.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!vu.get(e),
  isFocused: (e) => !!ll.get(e),
  isReadOnly: (e) => !!XE.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (XE.get(e)) return !1;
    var n = be.hasTarget(e, t) && be.toSlateNode(e, t);
    return rt.isElement(n) && Q.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = lw.get(e), r = Q.isEditor(t) ? gm.get(e) : n == null ? void 0 : n.get(be.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Lo.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Q.node(e, t.path), r = be.toDOMNode(e, n), o;
    Q.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), y = d == null ? p : parseInt(d, 10), f = s + y, v = a[l + 1];
        if (t.offset === f && v !== null && v !== void 0 && v.hasAttribute("data-slate-mark-placeholder")) {
          var g, E = v.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof u$e ? E : v,
            (g = v.textContent) !== null && g !== void 0 && g.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= f) {
          var w = Math.min(p, Math.max(0, t.offset - s));
          o = [c, w];
          break;
        }
        s = f;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Lo.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = me.isBackward(t), i = be.toDOMPoint(e, n), a = me.isCollapsed(t) ? i : be.toDOMPoint(e, r), s = be.getWindow(e), l = s.document.createRange(), [u, c] = o ? a : i, [p, d] = o ? i : a, y = as(u) ? u : u.parentElement, f = !!y.getAttribute("data-slate-zero-width"), v = as(p) ? p : p.parentElement, g = !!v.getAttribute("data-slate-zero-width");
    return l.setStart(u, f ? 1 : c), l.setEnd(p, g ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = as(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? Gd.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? t : d$e(t), l = a.parentNode, u = null, c = 0;
    if (l) {
      var p, d, y = be.toDOMNode(e, e), f = l.closest('[data-slate-void="true"]'), v = f && y.contains(f) ? f : null, g = l.closest('[contenteditable="false"]'), E = g && y.contains(g) ? g : null, w = l.closest("[data-slate-leaf]"), D = null;
      if (w) {
        if (u = w.closest('[data-slate-node="text"]'), u) {
          var x = be.getWindow(e), m = x.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var C = m.cloneContents(), S = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          S.forEach((M) => {
            if (Uo && !r && M.hasAttribute("data-slate-zero-width") && M.textContent.length > 0 && M.textContext !== "\uFEFF") {
              M.textContent.startsWith("\uFEFF") && (M.textContent = M.textContent.slice(1));
              return;
            }
            M.parentNode.removeChild(M);
          }), c = C.textContent.length, D = u;
        }
      } else if (v) {
        for (var z = v.querySelectorAll("[data-slate-leaf]"), L = 0; L < z.length; L++) {
          var R = z[L];
          if (be.hasDOMNode(e, R)) {
            w = R;
            break;
          }
        }
        w ? (u = w.closest('[data-slate-node="text"]'), D = w, c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })) : c = 1;
      } else if (E) {
        var B = (M) => M ? M.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], H = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var V, W = [...B(H), ...B(H == null ? void 0 : H.nextElementSibling)];
          w = (V = W.find((M) => y$e(E, M))) !== null && V !== void 0 ? V : null;
        } else {
          var q, Y = [...B(H == null ? void 0 : H.previousElementSibling), ...B(H)];
          w = (q = Y.findLast((M) => X3(E, M))) !== null && q !== void 0 ? q : null;
        }
        w && (u = w.closest('[data-slate-node="text"]'), D = w, i === "forward" ? c = 0 : (c = D.textContent.length, D.querySelectorAll("[data-slate-zero-width]").forEach((M) => {
          c -= M.textContent.length;
        })));
      }
      D && c === D.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Uo && D.getAttribute("data-slate-zero-width") === "z" && (p = D.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      qu && (d = D.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Uo && !u && !r) {
      var X = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (X && be.hasDOMNode(e, X, {
        editable: !0
      })) {
        var ee = be.toSlateNode(e, X), {
          path: J,
          offset: k
        } = Q.start(e, be.findPath(e, ee));
        return X.querySelector("[data-slate-leaf]") || (k = s), {
          path: J,
          offset: k
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var _ = be.toSlateNode(e, u), U = be.findPath(e, _);
    return {
      path: U,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = QE(t) ? t.anchorNode : t.startContainer, s, l, u, c, p;
    if (a)
      if (QE(t)) {
        if (qu && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), y = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && y.startContainer instanceof HTMLTableRowElement) {
            let C = function(S) {
              return S.childElementCount > 0 ? C(S.children[0]) : S;
            };
            var f = d.startContainer, v = y.startContainer, g = C(f.children[d.startOffset]), E = C(v.children[y.startOffset]);
            c = 0, E.childNodes.length > 0 ? s = E.childNodes[0] : s = E, g.childNodes.length > 0 ? u = g.childNodes[0] : u = g, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (s = y.endContainer, l = y.endOffset, c = d.startOffset) : (s = d.startContainer, l = d.endOffset, c = y.startOffset);
        } else
          s = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        IY && f$e(s) || qu ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        s = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    qu && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var w = be.toSlatePoint(e, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!w)
      return null;
    var D = X3(s, u) || s === u && c < l, x = p ? w : be.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: D ? "forward" : "backward"
    });
    if (!x)
      return null;
    var m = {
      anchor: w,
      focus: x
    };
    return me.isExpanded(m) && me.isForward(m) && as(u) && Q.void(e, {
      at: m.focus,
      mode: "highest"
    }) && (m = Q.unhangRange(e, m, {
      voids: !0
    })), m;
  }
};
function C$e(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!Q.hasPath(e, n))
    return !1;
  var o = Ke.get(e, n);
  if (!it.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = le.next(n);
  if (!Q.hasPath(e, i))
    return !1;
  var a = Ke.get(e, i);
  return it.isText(a) && a.text.startsWith(r.text);
}
function $Y(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function O$e(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function x$e(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function HY(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), a = O$e(i, o), s = Math.min(i.length - a, o.length - a), l = x$e(i, o, s), u = {
    start: n + a,
    end: r - l,
    text: o.slice(a, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function E$e(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = $Y(e, t, n), a = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), s = i.slice(r, a), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return HY(e, {
    start: r,
    end: l,
    text: s
  });
}
function L$e(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function eL(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!Q.hasPath(e, n))
    return null;
  var o = Ke.get(e, n);
  if (!it.isText(o))
    return null;
  var i = Q.above(e, {
    match: (s) => rt.isElement(s) && Q.isBlock(e, s),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var a = Q.next(e, {
      at: n,
      match: it.isText
    });
    if (!a || !le.isDescendant(a[1], i[1]))
      return null;
    r -= o.text.length, o = a[0], n = a[1];
  }
  return {
    path: n,
    offset: r
  };
}
function J3(e, t) {
  var n = eL(e, t.anchor);
  if (!n)
    return null;
  if (me.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = eL(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function tL(e, t, n) {
  var r = Yo.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: p
    } = c;
    return le.equals(p, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return zt.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var a = {
      path: t.path,
      offset: i.start
    }, s = zt.transform(a, n, {
      affinity: "backward"
    });
    return s ? {
      path: s.path,
      offset: s.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = zt.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && le.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function Q3(e, t, n) {
  var r = tL(e, t.anchor, n);
  if (!r)
    return null;
  if (me.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = tL(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function P$e(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !le.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !le.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !le.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: le.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: le.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return le.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: le.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: le.transform(n, t)
      };
  }
  var i = le.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function eV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? eV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : eV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var k$e = 25, S$e = 200, M$e = function() {
}, D$e = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function _$e(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, a = null, s = null, l = 0, u = !1, c = () => {
    var H = Ja.get(t);
    if (Ja.delete(t), H) {
      var {
        selection: V
      } = t, W = J3(t, H);
      W && (!V || !me.equals(W, V)) && je.select(t, W);
    }
  }, p = () => {
    var H = Xa.get(t);
    if (Xa.delete(t), !!H) {
      if (H.at) {
        var V = zt.isPoint(H.at) ? eL(t, H.at) : J3(t, H.at);
        if (!V)
          return;
        var W = Q.range(t, V);
        (!t.selection || !me.equals(t.selection, W)) && je.select(t, V);
      }
      H.run();
    }
  }, d = () => {
    if (a && (clearTimeout(a), a = null), s && (clearTimeout(s), s = null), !x() && !D()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), D() && (o = "action");
    var H = t.selection && Q.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    sa.set(t, t.marks), M$e("flush", Xa.get(t), Yo.get(t));
    for (var V = x(), W; W = (q = Yo.get(t)) === null || q === void 0 ? void 0 : q[0]; ) {
      var q, Y, X = us.get(t);
      X !== void 0 && (us.delete(t), t.marks = X), X && u === !1 && (u = null);
      var ee = L$e(W);
      (!t.selection || !me.equals(t.selection, ee)) && je.select(t, ee), W.diff.text ? Q.insertText(t, W.diff.text) : Q.deleteFragment(t), Yo.set(t, (Y = Yo.get(t)) === null || Y === void 0 ? void 0 : Y.filter((_) => {
        var {
          id: U
        } = _;
        return U !== W.id;
      })), C$e(t, W) || (V = !1, Xa.delete(t), sa.delete(t), o = "action", Ja.delete(t), n.cancel(), r.cancel(), H == null || H.unref());
    }
    var J = H == null ? void 0 : H.unref();
    if (J && !Ja.get(t) && (!t.selection || !me.equals(J, t.selection)) && je.select(t, J), D()) {
      p();
      return;
    }
    V && n(), n.flush(), r.flush(), c();
    var k = sa.get(t);
    sa.delete(t), k !== void 0 && (t.marks = k, t.onChange());
  }, y = (H) => {
    i && clearTimeout(i), i = setTimeout(() => {
      vu.set(t, !1), d();
    }, k$e);
  }, f = (H) => {
    vu.set(t, !0), i && (clearTimeout(i), i = null);
  }, v = function() {
    var V = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, W = YE.get(t);
    if (W) {
      if (x() || V) {
        W.style.display = "none";
        return;
      }
      W.style.removeProperty("display");
    }
  }, g = (H, V) => {
    var W, q = (W = Yo.get(t)) !== null && W !== void 0 ? W : [];
    Yo.set(t, q);
    var Y = Ke.leaf(t, H), X = q.findIndex((k) => le.equals(k.path, H));
    if (X < 0) {
      var ee = HY(Y.text, V);
      ee && q.push({
        path: H,
        diff: V,
        id: l++
      }), v();
      return;
    }
    var J = E$e(Y.text, q[X].diff, V);
    if (!J) {
      q.splice(X, 1), v();
      return;
    }
    q[X] = Kg(Kg({}, q[X]), {}, {
      diff: J
    });
  }, E = function(V) {
    var {
      at: W
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, Ja.delete(t), n.cancel(), r.cancel(), D() && d(), Xa.set(t, {
      at: W,
      run: V
    }), s = setTimeout(d);
  }, w = (H) => {
    var V;
    if (a && (clearTimeout(a), a = null), !tc.get(t)) {
      var {
        inputType: W
      } = H, q = null, Y = H.dataTransfer || H.data || void 0;
      u !== !1 && W !== "insertText" && W !== "insertCompositionText" && (u = !1);
      var [X] = H.getTargetRanges();
      X && (q = be.toSlateRange(t, X, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var ee = be.getWindow(t), J = ee.getSelection();
      if (!q && J && (X = J, q = be.toSlateRange(t, J, {
        exactMatch: !1,
        suppressThrow: !0
      })), q = (V = q) !== null && V !== void 0 ? V : t.selection, !!q) {
        var k = !0;
        if (W.startsWith("delete")) {
          if (me.isExpanded(q)) {
            var [_, U] = me.edges(q), M = Ke.leaf(t, _.path);
            if (M.text.length === _.offset && U.offset === 0) {
              var $ = Q.next(t, {
                at: _.path,
                match: it.isText
              });
              $ && le.equals($[1], U.path) && (q = {
                anchor: U,
                focus: U
              });
            }
          }
          var O = W.endsWith("Backward") ? "backward" : "forward", [j, F] = me.edges(q), [T, Z] = Q.leaf(t, j.path), A = {
            text: "",
            start: j.offset,
            end: F.offset
          }, G = Yo.get(t), N = G == null ? void 0 : G.find((Ve) => le.equals(Ve.path, Z)), ue = N ? [N.diff, A] : [A], fe = $Y(T.text, ...ue);
          if (fe.length === 0 && (k = !1), me.isExpanded(q)) {
            if (k && le.equals(q.anchor.path, q.focus.path)) {
              var oe = {
                path: q.anchor.path,
                offset: j.offset
              }, Ie = Q.range(t, oe, oe);
              return S(Ie), g(q.anchor.path, {
                text: "",
                end: F.offset,
                start: j.offset
              });
            }
            return E(() => Q.deleteFragment(t, {
              direction: O
            }), {
              at: q
            });
          }
        }
        switch (W) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return E(() => Q.deleteFragment(t), {
              at: q
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: qe
            } = q;
            if (k && me.isCollapsed(q)) {
              var Ge = Ke.leaf(t, qe.path);
              if (qe.offset < Ge.text.length)
                return g(qe.path, {
                  text: "",
                  start: qe.offset,
                  end: qe.offset + 1
                });
            }
            return E(() => Q.deleteForward(t), {
              at: q
            });
          }
          case "deleteContentBackward": {
            var Be, {
              anchor: et
            } = q, Xe = QE(X) ? X.isCollapsed : !!((Be = X) !== null && Be !== void 0 && Be.collapsed);
            return k && Xe && me.isCollapsed(q) && et.offset > 0 ? g(et.path, {
              text: "",
              start: et.offset - 1,
              end: et.offset
            }) : E(() => Q.deleteBackward(t), {
              at: q
            });
          }
          case "deleteEntireSoftLine":
            return E(() => {
              Q.deleteBackward(t, {
                unit: "line"
              }), Q.deleteForward(t, {
                unit: "line"
              });
            }, {
              at: q
            });
          case "deleteHardLineBackward":
            return E(() => Q.deleteBackward(t, {
              unit: "block"
            }), {
              at: q
            });
          case "deleteSoftLineBackward":
            return E(() => Q.deleteBackward(t, {
              unit: "line"
            }), {
              at: q
            });
          case "deleteHardLineForward":
            return E(() => Q.deleteForward(t, {
              unit: "block"
            }), {
              at: q
            });
          case "deleteSoftLineForward":
            return E(() => Q.deleteForward(t, {
              unit: "line"
            }), {
              at: q
            });
          case "deleteWordBackward":
            return E(() => Q.deleteBackward(t, {
              unit: "word"
            }), {
              at: q
            });
          case "deleteWordForward":
            return E(() => Q.deleteForward(t, {
              unit: "word"
            }), {
              at: q
            });
          case "insertLineBreak":
            return E(() => Q.insertSoftBreak(t), {
              at: q
            });
          case "insertParagraph":
            return E(() => Q.insertBreak(t), {
              at: q
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if (D$e(Y))
              return E(() => be.insertData(t, Y), {
                at: q
              });
            var Me = Y ?? "";
            if (us.get(t) && (Me = Me.replace("\uFEFF", "")), W === "insertText" && /.*\n.*\n$/.test(Me) && (Me = Me.slice(0, -1)), Me.includes(`
`))
              return E(() => {
                var Ve = Me.split(`
`);
                Ve.forEach((Ne, nt) => {
                  Ne && Q.insertText(t, Ne), nt !== Ve.length - 1 && Q.insertSoftBreak(t);
                });
              }, {
                at: q
              });
            if (le.equals(q.anchor.path, q.focus.path)) {
              var [Je, at] = me.edges(q), Se = {
                start: Je.offset,
                end: at.offset,
                text: Me
              };
              if (Me && u && W === "insertCompositionText") {
                var _e = u.start + u.text.search(/\S|$/), Ae = Se.start + Se.text.search(/\S|$/);
                Ae === _e + 1 && Se.end === u.start + u.text.length ? (Se.start -= 1, u = null, R()) : u = !1;
              } else W === "insertText" ? u === null ? u = Se : u && me.isCollapsed(q) && u.end + u.text.length === Je.offset ? u = Kg(Kg({}, u), {}, {
                text: u.text + Me
              }) : u = !1 : u = !1;
              if (k) {
                g(Je.path, Se);
                return;
              }
            }
            return E(() => Q.insertText(t, Me), {
              at: q
            });
          }
        }
      }
    }
  }, D = () => !!Xa.get(t), x = () => {
    var H;
    return !!((H = Yo.get(t)) !== null && H !== void 0 && H.length);
  }, m = () => D() || x(), C = () => o, S = (H) => {
    Ja.set(t, H), a && (clearTimeout(a), a = null);
    var {
      selection: V
    } = t;
    if (H) {
      var W = !V || !le.equals(V.anchor.path, H.anchor.path), q = !V || !le.equals(V.anchor.path.slice(0, -1), H.anchor.path.slice(0, -1));
      (W && u || q) && (u = !1), (W || x()) && (a = setTimeout(d, S$e));
    }
  }, z = () => {
    (D() || !x()) && d();
  }, L = (H) => {
    x() || (v(!0), setTimeout(v));
  }, R = () => {
    D() || (s = setTimeout(d));
  }, B = (H) => {
    if (!(x() || D()) && H.some((W) => uM(t, W, H))) {
      var V;
      (V = NY.get(t)) === null || V === void 0 || V();
    }
  };
  return {
    flush: d,
    scheduleFlush: R,
    hasPendingDiffs: x,
    hasPendingAction: D,
    hasPendingChanges: m,
    isFlushing: C,
    handleUserSelect: S,
    handleCompositionEnd: y,
    handleCompositionStart: f,
    handleDOMBeforeInput: w,
    handleKeyDown: L,
    handleDomMutations: B,
    handleInput: z
  };
}
function j$e() {
  var e = dt(!1);
  return h(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var Yd = hm ? JX : h;
function T$e(e, t, n) {
  var [r] = P(() => new MutationObserver(t));
  Yd(() => {
    r.takeRecords();
  }), h(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var A$e = ["node"];
function tV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function I$e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? tV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : tV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var B$e = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, N$e = Uo ? (e) => {
  var {
    node: t
  } = e, n = cc(e, A$e);
  if (!Uo)
    return null;
  var r = jl(), o = j$e(), [i] = P(() => _$e(I$e({
    editor: r
  }, n)));
  return T$e(t, i.handleDomMutations, B$e), aM.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, R$e = ["anchor", "focus"], F$e = ["anchor", "focus"], z$e = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), VY = (e, t) => {
  var n = cc(e, R$e), r = cc(t, F$e);
  return e[pc] === t[pc] && z$e(n, r);
}, U$e = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!me.equals(r, o) || !VY(r, o))
      return !1;
  }
  return !0;
}, W$e = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !VY(r, o))
      return !1;
  }
  return !0;
};
function nV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $$e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var H$e = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = jl(), a = be.findPath(i, o), s = le.parent(a), l = !!n[RY];
  return i.isVoid(r) ? /* @__PURE__ */ Ce.createElement(bO, {
    length: Ke.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && Q.string(i, s) === "" ? /* @__PURE__ */ Ce.createElement(bO, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ Ce.createElement(bO, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ Ce.createElement(rV, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ Ce.createElement(rV, {
    text: n.text
  });
}, rV = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = dt(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = P(o);
  return Yd(() => {
    var a = o();
    r.current && r.current.textContent !== a && (r.current.textContent = a);
  }), /* @__PURE__ */ Ce.createElement(V$e, {
    ref: r
  }, i);
}, V$e = /* @__PURE__ */ ve(/* @__PURE__ */ ga((e, t) => /* @__PURE__ */ Ce.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), bO = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ Ce.createElement("span", $$e({}, o), !(Uo || AY) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ Ce.createElement("br", null) : null);
};
function oV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ZY(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? oV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : oV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Z$e = Uo ? 300 : 0;
function q$e(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function iV(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var K$e = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: a = (w) => /* @__PURE__ */ Ce.createElement(Y$e, ZY({}, w))
  } = e, s = jl(), l = dt(null), u = dt(null), [c, p] = P(!1), d = dt(null), y = Rn((w) => {
    if (q$e(l, w == null), w == null) {
      var D;
      YE.delete(s), (D = t.onPlaceholderResize) === null || D === void 0 || D.call(t, null);
    } else {
      if (YE.set(s, w), !l.current) {
        var x = window.ResizeObserver || QWe;
        l.current = new x(() => {
          var m;
          (m = t.onPlaceholderResize) === null || m === void 0 || m.call(t, w);
        });
      }
      l.current.observe(w), u.current = w;
    }
  }, [u, t, s]), f = /* @__PURE__ */ Ce.createElement(H$e, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), v = !!t[pc];
  if (h(() => (v ? d.current || (d.current = setTimeout(() => {
    p(!0), d.current = null;
  }, Z$e)) : (iV(d), p(!1)), () => iV(d)), [v, p]), v && c) {
    var g = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: nu ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: y
      }
    };
    f = /* @__PURE__ */ Ce.createElement(Ce.Fragment, null, i(g), f);
  }
  var E = {
    "data-slate-leaf": !0
  };
  return a({
    attributes: E,
    children: f,
    leaf: t,
    text: r
  });
}, G$e = /* @__PURE__ */ Ce.memo(K$e, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && it.equals(t.leaf, e.leaf) && t.leaf[pc] === e.leaf[pc]), Y$e = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ Ce.createElement("span", ZY({}, t), n);
}, X$e = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: a
  } = e, s = jl(), l = dt(null), u = it.decorations(a, t), c = be.findKey(s, a), p = [], d = 0; d < u.length; d++) {
    var y = u[d];
    p.push(/* @__PURE__ */ Ce.createElement(G$e, {
      isLast: n && d === u.length - 1,
      key: "".concat(c.id, "-").concat(d),
      renderPlaceholder: o,
      leaf: y,
      text: a,
      parent: r,
      renderLeaf: i
    }));
  }
  var f = Rn((v) => {
    var g = lw.get(s);
    v ? (g == null || g.set(c, v), Cu.set(a, v), Gd.set(v, a)) : (g == null || g.delete(c), Cu.delete(a), l.current && Gd.delete(l.current)), l.current = v;
  }, [l, s, c, a]);
  return /* @__PURE__ */ Ce.createElement("span", {
    "data-slate-node": "text",
    ref: f
  }, p);
}, qY = /* @__PURE__ */ Ce.memo(X$e, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && W$e(t.decorations, e.decorations));
function sV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? sV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : sV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var J$e = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (w) => /* @__PURE__ */ Ce.createElement(eHe, nL({}, w)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = jl(), l = rHe(), u = s.isInline(n), c = be.findKey(s, n), p = Rn((w) => {
    var D = lw.get(s);
    w ? (D == null || D.set(c, w), Cu.set(n, w), Gd.set(w, n)) : (D == null || D.delete(c), Cu.delete(n));
  }, [s, c, n]), d = GY({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  }), y = {
    "data-slate-node": "element",
    ref: p
  };
  if (u && (y["data-slate-inline"] = !0), !u && Q.hasInlines(s, n)) {
    var f = Ke.string(n), v = OY(f);
    v === "rtl" && (y.dir = v);
  }
  if (Q.isVoid(s, n)) {
    y["data-slate-void"] = !0, !l && u && (y.contentEditable = !1);
    var g = u ? "span" : "div", [[E]] = Ke.texts(n);
    d = /* @__PURE__ */ Ce.createElement(g, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ Ce.createElement(qY, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: E
    })), iM.set(E, 0), sM.set(E, n);
  }
  return r({
    attributes: y,
    children: d,
    element: n
  });
}, Q$e = /* @__PURE__ */ Ce.memo(J$e, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && U$e(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && me.equals(e.selection, t.selection))), eHe = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = jl(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ Ce.createElement(i, nL(nL({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, KY = /* @__PURE__ */ Ye(() => []), tHe = () => ge(KY), nHe = /* @__PURE__ */ Ye(!1), GY = (e) => {
  var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = e, s = tHe(), l = jl();
  tc.set(l, !1);
  for (var u = be.findPath(l, n), c = [], p = rt.isElement(n) && !l.isInline(n) && Q.hasInlines(l, n), d = 0; d < n.children.length; d++) {
    var y = u.concat(d), f = n.children[d], v = be.findKey(l, f), g = Q.range(l, y), E = a && me.intersection(g, a), w = s([f, y]);
    for (var D of t) {
      var x = me.intersection(D, g);
      x && w.push(x);
    }
    rt.isElement(f) ? c.push(/* @__PURE__ */ Ce.createElement(nHe.Provider, {
      key: "provider-".concat(v.id),
      value: !!E
    }, /* @__PURE__ */ Ce.createElement(Q$e, {
      decorations: w,
      element: f,
      key: v.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: E
    }))) : c.push(/* @__PURE__ */ Ce.createElement(qY, {
      decorations: w,
      key: v.id,
      isLast: p && d === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: f
    })), iM.set(f, d), sM.set(f, n);
  }
  return c;
}, YY = /* @__PURE__ */ Ye(!1), rHe = () => ge(YY), XY = /* @__PURE__ */ Ye(null), uw = () => {
  var e = ge(XY);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function oHe() {
  var e = jl(), t = dt(!1), n = dt(0), r = Rn(() => {
    if (!t.current) {
      t.current = !0;
      var o = be.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return h(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var iHe = 3, sHe = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, aHe = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, lHe = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Fr = (e) => {
  var t = sHe[e], n = aHe[e], r = lHe[e], o = t && pO(t), i = n && pO(n), a = r && pO(r);
  return (s) => !!(o && o(s) || Y3 && i && i(s) || !Y3 && a && a(s));
}, Ur = {
  isBold: Fr("bold"),
  isCompose: Fr("compose"),
  isMoveBackward: Fr("moveBackward"),
  isMoveForward: Fr("moveForward"),
  isDeleteBackward: Fr("deleteBackward"),
  isDeleteForward: Fr("deleteForward"),
  isDeleteLineBackward: Fr("deleteLineBackward"),
  isDeleteLineForward: Fr("deleteLineForward"),
  isDeleteWordBackward: Fr("deleteWordBackward"),
  isDeleteWordForward: Fr("deleteWordForward"),
  isExtendBackward: Fr("extendBackward"),
  isExtendForward: Fr("extendForward"),
  isExtendLineBackward: Fr("extendLineBackward"),
  isExtendLineForward: Fr("extendLineForward"),
  isItalic: Fr("italic"),
  isMoveLineBackward: Fr("moveLineBackward"),
  isMoveLineForward: Fr("moveLineForward"),
  isMoveWordBackward: Fr("moveWordBackward"),
  isMoveWordForward: Fr("moveWordForward"),
  isRedo: Fr("redo"),
  isSoftBreak: Fr("insertSoftBreak"),
  isSplitBlock: Fr("splitBlock"),
  isTransposeCharacter: Fr("transposeCharacter"),
  isUndo: Fr("undo")
}, uHe = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (t.current) {
      var s = a.filter((l) => uM(e, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, cHe = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class JY extends $u {
  constructor() {
    super(...arguments), ls(this, "context", null), ls(this, "manager", null), ls(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, cHe);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = uHe(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
ls(JY, "contextType", oM);
var pHe = Uo ? JY : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ Ce.createElement(Ce.Fragment, null, t);
}, dHe = /* @__PURE__ */ Ye(!1), fHe = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], hHe = ["text"];
function aV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ys(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? aV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : aV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gHe = (e) => /* @__PURE__ */ Ce.createElement(Ce.Fragment, null, GY(e)), mHe = /* @__PURE__ */ ga((e, t) => {
  var n = Rn((j) => /* @__PURE__ */ Ce.createElement(vHe, ys({}, j)), []), {
    autoFocus: r,
    decorate: o = yHe,
    onDOMBeforeInput: i,
    placeholder: a,
    readOnly: s = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: p = bHe,
    style: d = {},
    as: y = "div",
    disableDefaultStyles: f = !1
  } = e, v = cc(e, fHe), g = uw(), [E, w] = P(!1), D = dt(null), x = dt([]), [m, C] = P(), S = dt(!1), {
    onUserInput: z,
    receivedUserInput: L
  } = oHe(), [, R] = XX((j) => j + 1, 0);
  NY.set(g, R), XE.set(g, s);
  var B = On(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  h(() => {
    D.current && r && D.current.focus();
  }, [r]);
  var H = dt(), V = On(() => MWe(() => {
    if (tc.get(g)) {
      V();
      return;
    }
    var j = be.toDOMNode(g, g), F = j.getRootNode();
    if (!S.current && nu && F instanceof ShadowRoot) {
      S.current = !0;
      var T = v$e();
      T ? document.execCommand("indent") : je.deselect(g), S.current = !1;
      return;
    }
    var Z = H.current;
    if ((Uo || !be.isComposing(g)) && (!B.isUpdatingSelection || Z != null && Z.isFlushing()) && !B.isDraggingInternally) {
      var A = be.findDocumentOrShadowRoot(g), {
        activeElement: G
      } = A, N = be.toDOMNode(g, g), ue = id(A);
      if (G === N ? (B.latestElement = G, ll.set(g, !0)) : ll.delete(g), !ue)
        return je.deselect(g);
      var {
        anchorNode: fe,
        focusNode: oe
      } = ue, Ie = be.hasEditableTarget(g, fe) || be.isTargetInsideNonReadonlyVoid(g, fe), qe = be.hasTarget(g, oe);
      if (Ie && qe) {
        var Ge = be.toSlateRange(g, ue, {
          exactMatch: !1,
          suppressThrow: !0
        });
        Ge && (!be.isComposing(g) && !(Z != null && Z.hasPendingChanges()) && !(Z != null && Z.isFlushing()) ? je.select(g, Ge) : Z == null || Z.handleUserSelect(Ge));
      }
      s && (!Ie || !qe) && je.deselect(g);
    }
  }, 100), [g, s, B]), W = On(() => xWe(V, 0), [V]);
  H.current = N$e({
    node: D,
    onDOMSelectionChange: V,
    scheduleOnDOMSelectionChange: W
  }), Yd(() => {
    var j, F, T;
    D.current && (T = lM(D.current)) ? (BY.set(g, T), gm.set(g, D.current), Cu.set(g, D.current), Gd.set(D.current, g)) : Cu.delete(g);
    var {
      selection: Z
    } = g, A = be.findDocumentOrShadowRoot(g), G = id(A);
    if (!(!G || !be.isFocused(g) || (j = H.current) !== null && j !== void 0 && j.hasPendingAction())) {
      var N = (Ie) => {
        var qe = G.type !== "None";
        if (!(!Z && !qe)) {
          var Ge = G.focusNode, Be;
          if (qu && G.rangeCount > 1) {
            var et = G.getRangeAt(0), Xe = G.getRangeAt(G.rangeCount - 1);
            et.startContainer === Ge ? Be = Xe.endContainer : Be = et.startContainer;
          } else
            Be = G.anchorNode;
          var Me = gm.get(g), Je = !1;
          if (Me.contains(Be) && Me.contains(Ge) && (Je = !0), qe && Je && Z && !Ie) {
            var at = be.toSlateRange(g, G, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (at && me.equals(at, Z)) {
              var Se;
              if (!B.hasMarkPlaceholder || (Se = Be) !== null && Se !== void 0 && (Se = Se.parentElement) !== null && Se !== void 0 && Se.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (Z && !be.hasRange(g, Z)) {
            g.selection = be.toSlateRange(g, G, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          B.isUpdatingSelection = !0;
          var _e = Z && be.toDOMRange(g, Z);
          return _e ? (be.isComposing(g) && !Uo ? G.collapseToEnd() : me.isBackward(Z) ? G.setBaseAndExtent(_e.endContainer, _e.endOffset, _e.startContainer, _e.startOffset) : G.setBaseAndExtent(_e.startContainer, _e.startOffset, _e.endContainer, _e.endOffset), p(g, _e)) : G.removeAllRanges(), _e;
        }
      };
      G.rangeCount <= 1 && N();
      var ue = ((F = H.current) === null || F === void 0 ? void 0 : F.isFlushing()) === "action";
      if (!Uo || !ue) {
        setTimeout(() => {
          B.isUpdatingSelection = !1;
        });
        return;
      }
      var fe = null, oe = requestAnimationFrame(() => {
        if (ue) {
          var Ie = (qe) => {
            try {
              var Ge = be.toDOMNode(g, g);
              Ge.focus(), N(qe);
            } catch {
            }
          };
          Ie(), fe = setTimeout(() => {
            Ie(!0), B.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(oe), fe && clearTimeout(fe);
      };
    }
  });
  var q = Rn((j) => {
    var F = be.toDOMNode(g, g), T = F.getRootNode();
    if (S != null && S.current && nu && T instanceof ShadowRoot) {
      var Z = j.getTargetRanges(), A = Z[0], G = new window.Range();
      G.setStart(A.startContainer, A.startOffset), G.setEnd(A.endContainer, A.endOffset);
      var N = be.toSlateRange(g, G, {
        exactMatch: !1,
        suppressThrow: !1
      });
      je.select(g, N), j.preventDefault(), j.stopImmediatePropagation();
      return;
    }
    if (z(), !s && be.hasEditableTarget(g, j.target) && !wHe(j, i)) {
      var ue;
      if (H.current)
        return H.current.handleDOMBeforeInput(j);
      W.flush(), V.flush();
      var {
        selection: fe
      } = g, {
        inputType: oe
      } = j, Ie = j.dataTransfer || j.data || void 0, qe = oe === "insertCompositionText" || oe === "deleteCompositionText";
      if (qe && be.isComposing(g))
        return;
      var Ge = !1;
      if (oe === "insertText" && fe && me.isCollapsed(fe) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      j.data && j.data.length === 1 && /[a-z ]/i.test(j.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      fe.anchor.offset !== 0 && (Ge = !0, g.marks && (Ge = !1), !tc.get(g))) {
        var Be, et, {
          anchor: Xe
        } = fe, [Me, Je] = be.toDOMPoint(g, Xe), at = (Be = Me.parentElement) === null || Be === void 0 ? void 0 : Be.closest("a"), Se = be.getWindow(g);
        if (Ge && at && be.hasDOMNode(g, at)) {
          var _e, Ae = Se == null ? void 0 : Se.document.createTreeWalker(at, NodeFilter.SHOW_TEXT).lastChild();
          Ae === Me && ((_e = Ae.textContent) === null || _e === void 0 ? void 0 : _e.length) === Je && (Ge = !1);
        }
        if (Ge && Me.parentElement && (Se == null || (et = Se.getComputedStyle(Me.parentElement)) === null || et === void 0 ? void 0 : et.whiteSpace) === "pre") {
          var Ve = Q.above(g, {
            at: Xe.path,
            match: (st) => rt.isElement(st) && Q.isBlock(g, st)
          });
          Ve && Ke.string(Ve[0]).includes("	") && (Ge = !1);
        }
      }
      if ((!oe.startsWith("delete") || oe.startsWith("deleteBy")) && !tc.get(g)) {
        var [Ne] = j.getTargetRanges();
        if (Ne) {
          var nt = be.toSlateRange(g, Ne, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!fe || !me.equals(fe, nt)) {
            Ge = !1;
            var we = !qe && g.selection && Q.rangeRef(g, g.selection);
            je.select(g, nt), we && od.set(g, we);
          }
        }
      }
      if (qe)
        return;
      if (Ge || j.preventDefault(), fe && me.isExpanded(fe) && oe.startsWith("delete")) {
        var mt = oe.endsWith("Backward") ? "backward" : "forward";
        Q.deleteFragment(g, {
          direction: mt
        });
        return;
      }
      switch (oe) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          Q.deleteFragment(g);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          Q.deleteForward(g);
          break;
        }
        case "deleteContentBackward": {
          Q.deleteBackward(g);
          break;
        }
        case "deleteEntireSoftLine": {
          Q.deleteBackward(g, {
            unit: "line"
          }), Q.deleteForward(g, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          Q.deleteBackward(g, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          Q.deleteBackward(g, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          Q.deleteForward(g, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          Q.deleteForward(g, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          Q.deleteBackward(g, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          Q.deleteForward(g, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          Q.insertSoftBreak(g);
          break;
        case "insertParagraph": {
          Q.insertBreak(g);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          oe === "insertFromComposition" && be.isComposing(g) && (w(!1), vu.set(g, !1)), (Ie == null ? void 0 : Ie.constructor.name) === "DataTransfer" ? be.insertData(g, Ie) : typeof Ie == "string" && (Ge ? x.current.push(() => Q.insertText(g, Ie)) : Q.insertText(g, Ie));
          break;
        }
      }
      var ot = (ue = od.get(g)) === null || ue === void 0 ? void 0 : ue.unref();
      od.delete(g), ot && (!g.selection || !me.equals(g.selection, ot)) && je.select(g, ot);
    }
  }, [g, V, z, i, s, W]), Y = Rn((j) => {
    j == null ? (V.cancel(), W.cancel(), gm.delete(g), Cu.delete(g), D.current && Ia && D.current.removeEventListener("beforeinput", q)) : Ia && j.addEventListener("beforeinput", q), D.current = j, typeof t == "function" ? t(j) : t && (t.current = j);
  }, [V, W, g, q, t]);
  Yd(() => {
    var j = be.getWindow(g);
    j.document.addEventListener("selectionchange", W);
    var F = () => {
      B.isDraggingInternally = !1;
    };
    return j.document.addEventListener("dragend", F), j.document.addEventListener("drop", F), () => {
      j.document.removeEventListener("selectionchange", W), j.document.removeEventListener("dragend", F), j.document.removeEventListener("drop", F);
    };
  }, [W, B]);
  var X = o([g, []]), ee = a && g.children.length === 1 && Array.from(Ke.texts(g)).length === 1 && Ke.string(g) === "" && !E, J = Rn((j) => {
    if (j && ee) {
      var F;
      C((F = j.getBoundingClientRect()) === null || F === void 0 ? void 0 : F.height);
    } else
      C(void 0);
  }, [ee]);
  if (ee) {
    var k = Q.start(g, []);
    X.push({
      [pc]: !0,
      placeholder: a,
      onPlaceholderResize: J,
      anchor: k,
      focus: k
    });
  }
  var {
    marks: _
  } = g;
  if (B.hasMarkPlaceholder = !1, g.selection && me.isCollapsed(g.selection) && _) {
    var {
      anchor: U
    } = g.selection, M = Ke.leaf(g, U.path), $ = cc(M, hHe);
    if (!it.equals(M, _, {
      loose: !0
    })) {
      B.hasMarkPlaceholder = !0;
      var O = Object.fromEntries(Object.keys($).map((j) => [j, null]));
      X.push(ys(ys(ys({
        [RY]: !0
      }, O), _), {}, {
        anchor: U,
        focus: U
      }));
    }
  }
  return h(() => {
    setTimeout(() => {
      var {
        selection: j
      } = g;
      if (j) {
        var {
          anchor: F
        } = j, T = Ke.leaf(g, F.path);
        if (_ && !it.equals(T, _, {
          loose: !0
        })) {
          us.set(g, _);
          return;
        }
      }
      us.delete(g);
    });
  }), /* @__PURE__ */ Ce.createElement(YY.Provider, {
    value: s
  }, /* @__PURE__ */ Ce.createElement(dHe.Provider, {
    value: E
  }, /* @__PURE__ */ Ce.createElement(KY.Provider, {
    value: o
  }, /* @__PURE__ */ Ce.createElement(pHe, {
    node: D,
    receivedUserInput: L
  }, /* @__PURE__ */ Ce.createElement(y, ys(ys({
    role: s ? void 0 : "textbox",
    "aria-multiline": s ? void 0 : !0
  }, v), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: Ia || !hm ? v.spellCheck : !1,
    autoCorrect: Ia || !hm ? v.autoCorrect : "false",
    autoCapitalize: Ia || !hm ? v.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !s,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: Y,
    style: ys(ys({}, f ? {} : ys({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, m ? {
      minHeight: m
    } : {})), d),
    onBeforeInput: Rn((j) => {
      if (!Ia && !s && !zo(j, v.onBeforeInput) && be.hasSelectableTarget(g, j.target) && (j.preventDefault(), !be.isComposing(g))) {
        var F = j.data;
        Q.insertText(g, F);
      }
    }, [v.onBeforeInput, g, s]),
    onInput: Rn((j) => {
      if (!zo(j, v.onInput)) {
        if (H.current) {
          H.current.handleInput();
          return;
        }
        for (var F of x.current)
          F();
        if (x.current = [], !be.isFocused(g)) {
          var T = j.nativeEvent, Z = g;
          if (T.inputType === "historyUndo" && typeof Z.undo == "function") {
            Z.undo();
            return;
          }
          if (T.inputType === "historyRedo" && typeof Z.redo == "function") {
            Z.redo();
            return;
          }
        }
      }
    }, [v.onInput, g]),
    onBlur: Rn((j) => {
      if (!(s || B.isUpdatingSelection || !be.hasSelectableTarget(g, j.target) || zo(j, v.onBlur))) {
        var F = be.findDocumentOrShadowRoot(g);
        if (B.latestElement !== F.activeElement) {
          var {
            relatedTarget: T
          } = j, Z = be.toDOMNode(g, g);
          if (T !== Z && !(as(T) && T.hasAttribute("data-slate-spacer"))) {
            if (T != null && cl(T) && be.hasDOMNode(g, T)) {
              var A = be.toSlateNode(g, T);
              if (rt.isElement(A) && !g.isVoid(A))
                return;
            }
            if (nu) {
              var G = id(F);
              G == null || G.removeAllRanges();
            }
            ll.delete(g);
          }
        }
      }
    }, [s, B.isUpdatingSelection, B.latestElement, g, v.onBlur]),
    onClick: Rn((j) => {
      if (be.hasTarget(g, j.target) && !zo(j, v.onClick) && cl(j.target)) {
        var F = be.toSlateNode(g, j.target), T = be.findPath(g, F);
        if (!Q.hasPath(g, T) || Ke.get(g, T) !== F)
          return;
        if (j.detail === iHe && T.length >= 1) {
          var Z = T;
          if (!(rt.isElement(F) && Q.isBlock(g, F))) {
            var A, G = Q.above(g, {
              match: (Ge) => rt.isElement(Ge) && Q.isBlock(g, Ge),
              at: T
            });
            Z = (A = G == null ? void 0 : G[1]) !== null && A !== void 0 ? A : T.slice(0, 1);
          }
          var N = Q.range(g, Z);
          je.select(g, N);
          return;
        }
        if (s)
          return;
        var ue = Q.start(g, T), fe = Q.end(g, T), oe = Q.void(g, {
          at: ue
        }), Ie = Q.void(g, {
          at: fe
        });
        if (oe && Ie && le.equals(oe[1], Ie[1])) {
          var qe = Q.range(g, ue);
          je.select(g, qe);
        }
      }
    }, [g, v.onClick, s]),
    onCompositionEnd: Rn((j) => {
      if (be.hasSelectableTarget(g, j.target)) {
        var F;
        if (be.isComposing(g) && Promise.resolve().then(() => {
          w(!1), vu.set(g, !1);
        }), (F = H.current) === null || F === void 0 || F.handleCompositionEnd(j), zo(j, v.onCompositionEnd) || Uo)
          return;
        if (!nu && !s$e && !AY && !l$e && !a$e && j.data) {
          var T = us.get(g);
          us.delete(g), T !== void 0 && (sa.set(g, g.marks), g.marks = T), Q.insertText(g, j.data);
          var Z = sa.get(g);
          sa.delete(g), Z !== void 0 && (g.marks = Z);
        }
      }
    }, [v.onCompositionEnd, g]),
    onCompositionUpdate: Rn((j) => {
      be.hasSelectableTarget(g, j.target) && !zo(j, v.onCompositionUpdate) && (be.isComposing(g) || (w(!0), vu.set(g, !0)));
    }, [v.onCompositionUpdate, g]),
    onCompositionStart: Rn((j) => {
      if (be.hasSelectableTarget(g, j.target)) {
        var F;
        if ((F = H.current) === null || F === void 0 || F.handleCompositionStart(j), zo(j, v.onCompositionStart) || Uo)
          return;
        w(!0);
        var {
          selection: T
        } = g;
        if (T && me.isExpanded(T)) {
          Q.deleteFragment(g);
          return;
        }
      }
    }, [v.onCompositionStart, g]),
    onCopy: Rn((j) => {
      be.hasSelectableTarget(g, j.target) && !zo(j, v.onCopy) && !lV(j) && (j.preventDefault(), be.setFragmentData(g, j.clipboardData, "copy"));
    }, [v.onCopy, g]),
    onCut: Rn((j) => {
      if (!s && be.hasSelectableTarget(g, j.target) && !zo(j, v.onCut) && !lV(j)) {
        j.preventDefault(), be.setFragmentData(g, j.clipboardData, "cut");
        var {
          selection: F
        } = g;
        if (F)
          if (me.isExpanded(F))
            Q.deleteFragment(g);
          else {
            var T = Ke.parent(g, F.anchor.path);
            Q.isVoid(g, T) && je.delete(g);
          }
      }
    }, [s, g, v.onCut]),
    onDragOver: Rn((j) => {
      if (be.hasTarget(g, j.target) && !zo(j, v.onDragOver)) {
        var F = be.toSlateNode(g, j.target);
        rt.isElement(F) && Q.isVoid(g, F) && j.preventDefault();
      }
    }, [v.onDragOver, g]),
    onDragStart: Rn((j) => {
      if (!s && be.hasTarget(g, j.target) && !zo(j, v.onDragStart)) {
        var F = be.toSlateNode(g, j.target), T = be.findPath(g, F), Z = rt.isElement(F) && Q.isVoid(g, F) || Q.void(g, {
          at: T,
          voids: !0
        });
        if (Z) {
          var A = Q.range(g, T);
          je.select(g, A);
        }
        B.isDraggingInternally = !0, be.setFragmentData(g, j.dataTransfer, "drag");
      }
    }, [s, g, v.onDragStart, B]),
    onDrop: Rn((j) => {
      if (!s && be.hasTarget(g, j.target) && !zo(j, v.onDrop)) {
        j.preventDefault();
        var F = g.selection, T = be.findEventRange(g, j), Z = j.dataTransfer;
        je.select(g, T), B.isDraggingInternally && F && !me.equals(F, T) && !Q.void(g, {
          at: T,
          voids: !0
        }) && je.delete(g, {
          at: F
        }), be.insertData(g, Z), be.isFocused(g) || be.focus(g);
      }
    }, [s, g, v.onDrop, B]),
    onDragEnd: Rn((j) => {
      !s && B.isDraggingInternally && v.onDragEnd && be.hasTarget(g, j.target) && v.onDragEnd(j);
    }, [s, B, v, g]),
    onFocus: Rn((j) => {
      if (!s && !B.isUpdatingSelection && be.hasEditableTarget(g, j.target) && !zo(j, v.onFocus)) {
        var F = be.toDOMNode(g, g), T = be.findDocumentOrShadowRoot(g);
        if (B.latestElement = T.activeElement, qu && j.target !== F) {
          F.focus();
          return;
        }
        ll.set(g, !0);
      }
    }, [s, B, g, v.onFocus]),
    onKeyDown: Rn((j) => {
      if (!s && be.hasEditableTarget(g, j.target)) {
        var F;
        (F = H.current) === null || F === void 0 || F.handleKeyDown(j);
        var {
          nativeEvent: T
        } = j;
        if (be.isComposing(g) && T.isComposing === !1 && (vu.set(g, !1), w(!1)), zo(j, v.onKeyDown) || be.isComposing(g))
          return;
        var {
          selection: Z
        } = g, A = g.children[Z !== null ? Z.focus.path[0] : 0], G = OY(Ke.string(A)) === "rtl";
        if (Ur.isRedo(T)) {
          j.preventDefault();
          var N = g;
          typeof N.redo == "function" && N.redo();
          return;
        }
        if (Ur.isUndo(T)) {
          j.preventDefault();
          var ue = g;
          typeof ue.undo == "function" && ue.undo();
          return;
        }
        if (Ur.isMoveLineBackward(T)) {
          j.preventDefault(), je.move(g, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (Ur.isMoveLineForward(T)) {
          j.preventDefault(), je.move(g, {
            unit: "line"
          });
          return;
        }
        if (Ur.isExtendLineBackward(T)) {
          j.preventDefault(), je.move(g, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (Ur.isExtendLineForward(T)) {
          j.preventDefault(), je.move(g, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (Ur.isMoveBackward(T)) {
          j.preventDefault(), Z && me.isCollapsed(Z) ? je.move(g, {
            reverse: !G
          }) : je.collapse(g, {
            edge: G ? "end" : "start"
          });
          return;
        }
        if (Ur.isMoveForward(T)) {
          j.preventDefault(), Z && me.isCollapsed(Z) ? je.move(g, {
            reverse: G
          }) : je.collapse(g, {
            edge: G ? "start" : "end"
          });
          return;
        }
        if (Ur.isMoveWordBackward(T)) {
          j.preventDefault(), Z && me.isExpanded(Z) && je.collapse(g, {
            edge: "focus"
          }), je.move(g, {
            unit: "word",
            reverse: !G
          });
          return;
        }
        if (Ur.isMoveWordForward(T)) {
          j.preventDefault(), Z && me.isExpanded(Z) && je.collapse(g, {
            edge: "focus"
          }), je.move(g, {
            unit: "word",
            reverse: G
          });
          return;
        }
        if (Ia) {
          if ((IY || nu) && Z && (Ur.isDeleteBackward(T) || Ur.isDeleteForward(T)) && me.isCollapsed(Z)) {
            var fe = Ke.parent(g, Z.anchor.path);
            if (rt.isElement(fe) && Q.isVoid(g, fe) && (Q.isInline(g, fe) || Q.isBlock(g, fe))) {
              j.preventDefault(), Q.deleteBackward(g, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (Ur.isBold(T) || Ur.isItalic(T) || Ur.isTransposeCharacter(T)) {
            j.preventDefault();
            return;
          }
          if (Ur.isSoftBreak(T)) {
            j.preventDefault(), Q.insertSoftBreak(g);
            return;
          }
          if (Ur.isSplitBlock(T)) {
            j.preventDefault(), Q.insertBreak(g);
            return;
          }
          if (Ur.isDeleteBackward(T)) {
            j.preventDefault(), Z && me.isExpanded(Z) ? Q.deleteFragment(g, {
              direction: "backward"
            }) : Q.deleteBackward(g);
            return;
          }
          if (Ur.isDeleteForward(T)) {
            j.preventDefault(), Z && me.isExpanded(Z) ? Q.deleteFragment(g, {
              direction: "forward"
            }) : Q.deleteForward(g);
            return;
          }
          if (Ur.isDeleteLineBackward(T)) {
            j.preventDefault(), Z && me.isExpanded(Z) ? Q.deleteFragment(g, {
              direction: "backward"
            }) : Q.deleteBackward(g, {
              unit: "line"
            });
            return;
          }
          if (Ur.isDeleteLineForward(T)) {
            j.preventDefault(), Z && me.isExpanded(Z) ? Q.deleteFragment(g, {
              direction: "forward"
            }) : Q.deleteForward(g, {
              unit: "line"
            });
            return;
          }
          if (Ur.isDeleteWordBackward(T)) {
            j.preventDefault(), Z && me.isExpanded(Z) ? Q.deleteFragment(g, {
              direction: "backward"
            }) : Q.deleteBackward(g, {
              unit: "word"
            });
            return;
          }
          if (Ur.isDeleteWordForward(T)) {
            j.preventDefault(), Z && me.isExpanded(Z) ? Q.deleteFragment(g, {
              direction: "forward"
            }) : Q.deleteForward(g, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [s, g, v.onKeyDown]),
    onPaste: Rn((j) => {
      !s && be.hasEditableTarget(g, j.target) && !zo(j, v.onPaste) && (!Ia || p$e(j.nativeEvent) || nu) && (j.preventDefault(), be.insertData(g, j.clipboardData));
    }, [s, g, v.onPaste])
  }), /* @__PURE__ */ Ce.createElement(gHe, {
    decorations: X,
    node: g,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: g.selection
  }))))));
}), vHe = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ Ce.createElement("span", ys({}, t), n, Uo && /* @__PURE__ */ Ce.createElement("br", null))
  );
}, yHe = () => [], bHe = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && me.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), jWe(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, zo = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, lV = (e) => cl(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), wHe = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, CHe = /* @__PURE__ */ Ye(!1), OHe = /* @__PURE__ */ Ye({});
function xHe(e) {
  var t = dt([]).current, n = dt({
    editor: e
  }).current, r = Rn((i) => {
    n.editor = i, t.forEach((a) => a(i));
  }, [t, n]), o = On(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var EHe = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], LHe = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: a
  } = e, s = cc(e, EHe), [l, u] = Ce.useState(() => {
    if (!Ke.isNodeList(a))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(Lo.stringify(a)));
    if (!Q.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Lo.stringify(t)));
    return t.children = a, Object.assign(t, s), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: p
  } = xHe(t), d = Rn((v) => {
    var g;
    switch (r && r(t.children), v == null || (g = v.operation) === null || g === void 0 ? void 0 : g.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((E) => ({
      v: E.v + 1,
      editor: t
    })), p(t);
  }, [t, p, r, o, i]);
  h(() => (JE.set(t, d), () => {
    JE.set(t, () => {
    });
  }), [t, d]);
  var [y, f] = P(be.isFocused(t));
  return h(() => {
    f(be.isFocused(t));
  }, [t]), Yd(() => {
    var v = () => f(be.isFocused(t));
    return TY >= 17 ? (document.addEventListener("focusin", v), document.addEventListener("focusout", v), () => {
      document.removeEventListener("focusin", v), document.removeEventListener("focusout", v);
    }) : (document.addEventListener("focus", v, !0), document.addEventListener("blur", v, !0), () => {
      document.removeEventListener("focus", v, !0), document.removeEventListener("blur", v, !0);
    });
  }, []), /* @__PURE__ */ Ce.createElement(OHe.Provider, {
    value: c
  }, /* @__PURE__ */ Ce.createElement(XY.Provider, {
    value: l
  }, /* @__PURE__ */ Ce.createElement(oM.Provider, {
    value: l.editor
  }, /* @__PURE__ */ Ce.createElement(CHe.Provider, {
    value: y
  }, n))));
}, uV = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, cV = (e, t, n) => {
  var r = be.toDOMRange(e, t).getBoundingClientRect(), o = be.toDOMRange(e, n).getBoundingClientRect();
  return uV(r, o) && uV(o, r);
}, PHe = (e, t) => {
  var n = Q.range(e, me.end(t)), r = Array.from(Q.positions(e, {
    at: t
  })), o = 0, i = r.length, a = Math.floor(i / 2);
  if (cV(e, Q.range(e, r[o]), n))
    return Q.range(e, r[o], n);
  if (r.length < 2)
    return Q.range(e, r[r.length - 1], n);
  for (; a !== r.length && a !== o; )
    cV(e, Q.range(e, r[a]), n) ? i = a : o = a, a = Math.floor((o + i) / 2);
  return Q.range(e, r[i], n);
};
function pV(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? pV(Object(n), !0).forEach(function(r) {
      ls(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : pV(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var kHe = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: a,
    addMark: s,
    removeMark: l
  } = r;
  return lw.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var p, d;
    (p = aM.get(r)) === null || p === void 0 || p(), !us.get(r) && (d = Yo.get(r)) !== null && d !== void 0 && d.length && us.set(r, null), sa.delete(r), s(u, c);
  }, r.removeMark = (u) => {
    var c;
    !us.get(r) && (c = Yo.get(r)) !== null && c !== void 0 && c.length && us.set(r, null), sa.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return a(u);
    if (r.selection && me.isCollapsed(r.selection)) {
      var c = Q.above(r, {
        match: (f) => rt.isElement(f) && Q.isBlock(r, f),
        at: r.selection
      });
      if (c) {
        var [, p] = c, d = Q.range(r, p, r.selection.anchor), y = PHe(r, d);
        me.isCollapsed(y) || je.delete(r, {
          at: y
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], p = [], d = Yo.get(r);
    if (d != null && d.length) {
      var y = d.map((W) => P$e(W, u)).filter(Boolean);
      Yo.set(r, y);
    }
    var f = Ja.get(r);
    f && Ja.set(r, Q3(r, f, u));
    var v = Xa.get(r);
    if (v != null && v.at) {
      var g = zt.isPoint(v == null ? void 0 : v.at) ? tL(r, v.at, u) : Q3(r, v.at, u);
      Xa.set(r, g ? dV(dV({}, v), {}, {
        at: g
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...Vu(r, u.path));
        break;
      }
      case "set_selection": {
        var E;
        (E = od.get(r)) === null || E === void 0 || E.unref(), od.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...Vu(r, le.parent(u.path)));
        break;
      }
      case "merge_node": {
        var w = le.previous(u.path);
        c.push(...Vu(r, w));
        break;
      }
      case "move_node": {
        var D = le.common(le.parent(u.path), le.parent(u.newPath));
        c.push(...Vu(r, D));
        var x;
        le.isBefore(u.path, u.newPath) ? (c.push(...Vu(r, le.parent(u.path))), x = u.newPath) : (c.push(...Vu(r, le.parent(u.newPath))), x = u.path);
        var m = Ke.get(t, le.parent(x)), C = be.findKey(r, m), S = Q.pathRef(r, le.parent(x));
        p.push([S, C]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        tc.set(r, !0);
    }
    for (var [z, L] of c) {
      var [R] = Q.node(r, z);
      vy.set(R, L);
    }
    for (var [B, H] of p) {
      if (B.current) {
        var [V] = Q.node(r, B.current);
        vy.set(V, H);
      }
      B.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [p, d] = me.edges(c), y = Q.void(r, {
        at: p.path
      }), f = Q.void(r, {
        at: d.path
      });
      if (!(me.isCollapsed(c) && !y)) {
        var v = be.toDOMRange(r, c), g = v.cloneContents(), E = g.childNodes[0];
        if (g.childNodes.forEach((R) => {
          R.textContent && R.textContent.trim() !== "" && (E = R);
        }), f) {
          var [w] = f, D = v.cloneRange(), x = be.toDOMNode(r, w);
          D.setEndAfter(x), g = D.cloneContents();
        }
        if (y && (E = g.querySelector("[data-slate-spacer]")), Array.from(g.querySelectorAll("[data-slate-zero-width]")).forEach((R) => {
          var B = R.getAttribute("data-slate-zero-width") === "n";
          R.textContent = B ? `
` : "";
        }), zY(E)) {
          var m = E.ownerDocument.createElement("span");
          m.style.whiteSpace = "pre", m.appendChild(E), g.appendChild(m), E = m;
        }
        var C = r.getFragment(), S = JSON.stringify(C), z = window.btoa(encodeURIComponent(S));
        E.setAttribute("data-slate-fragment", z), u.setData("application/".concat(n), z);
        var L = g.ownerDocument.createElement("div");
        return L.appendChild(g), L.setAttribute("hidden", "true"), g.ownerDocument.body.appendChild(L), u.setData("text/html", L.innerHTML), u.setData("text/plain", WY(L)), g.ownerDocument.body.removeChild(L), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || m$e(u);
    if (c) {
      var p = decodeURIComponent(window.atob(c)), d = JSON.parse(p);
      return r.insertFragment(d), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var p = c.split(/\r\n|\r|\n/), d = !1;
      for (var y of p)
        d && je.splitNodes(r, {
          always: !0
        }), r.insertText(y), d = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = TY < 18 ? pl.unstable_batchedUpdates : (p) => p();
    c(() => {
      var p = JE.get(r);
      p && p(u), i(u);
    });
  }, r;
}, Vu = (e, t) => {
  var n = [];
  for (var [r, o] of Q.levels(e, {
    at: t
  })) {
    var i = be.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function QY(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    Q.nodes(e, {
      at: Q.unhangRange(e, r),
      match: (i) => !Q.isEditor(i) && rt.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const fV = ["listItem", "numberedList"], mm = ["left", "center", "right", "justify"];
function SHe(e, t) {
  const n = mm.includes(t) ? "align" : "type", r = QY(e, t, n), o = fV.includes(t);
  je.unwrapNodes(e, {
    match: (a) => !Q.isEditor(a) && rt.isElement(a) && fV.includes(a.type) && !mm.includes(t),
    split: !0
  });
  let i;
  if (mm.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, je.setNodes(e, i), !r && o) {
    const a = { type: t, children: [] };
    je.wrapNodes(e, a);
  }
}
function Zl({ format: e, icon: t }) {
  const n = uw(), r = mm.includes(e) ? "align" : "type", i = QY(n, e, r) ? "activeTrue" : "activeFalse";
  function a(s) {
    s.preventDefault(), SHe(n, e);
  }
  return /* @__PURE__ */ te.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: a,
      children: /* @__PURE__ */ te.jsx(t, {})
    }
  );
}
function MHe({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ te.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ te.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ te.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ te.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ te.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ te.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    case "image":
      return /* @__PURE__ */ te.jsxs("div", { style: r, ...e, children: [
        /* @__PURE__ */ te.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        t
      ] });
    default:
      return /* @__PURE__ */ te.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
const eX = Ye({});
function DHe(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, s = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ te.jsx(eX.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ te.jsx(O9, { children: t && /* @__PURE__ */ te.jsxs("aside", { className: s.trim(), ...i, children: [
    /* @__PURE__ */ te.jsx(
      ad.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ te.jsx(
      ad.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function _He(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ te.jsx("footer", { className: o.trim(), ...r });
}
function jHe(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ge(eX), a = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ te.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ te.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ te.jsx(hL, { size: 24 })
      }
    )
  ] });
}
const rL = Ye({});
function THe() {
  if (!rL)
    throw new Error("useTabContext must be used within a TabProvider");
  return ge(rL);
}
function AHe(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [a, s] = P(r || ""), [l, u] = P(!0), c = dt(null), p = `arkynTabContainer ${o || ""}`, [d, y] = P({
    width: "0px",
    left: "0px",
    transition: "none"
  }), f = (g, E) => {
    const w = g.getBoundingClientRect(), D = c.current.getBoundingClientRect(), x = E ? void 0 : "none";
    u(!1), y({
      transition: x,
      width: `${w.width}px`,
      left: `${w.left - D.left}px`
    });
  };
  h(() => {
    const g = c.current;
    if (!g) return;
    let E = null;
    E = g.querySelector("button.activeTrue"), E && f(E);
  }, []);
  const v = (g) => {
    const E = g.target;
    E && (s(E.value), E.classList.add("activeTrue"), f(E, !0), n && n(E.value));
  };
  return /* @__PURE__ */ te.jsxs("nav", { ref: c, className: p.trim(), ...i, children: [
    /* @__PURE__ */ te.jsx(rL.Provider, { value: { handleTabClick: v, showInitialTab: l, value: a }, children: t }),
    /* @__PURE__ */ te.jsx("div", { className: "activeLine", style: d })
  ] });
}
function hV(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: a, handleTabClick: s } = THe(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && a ? "showBorderBottom" : ""} ${l} ${n}`;
  function p(d) {
    s(d), r && r(d);
  }
  return /* @__PURE__ */ te.jsx(
    "button",
    {
      onClick: p,
      className: c.trim(),
      ...o,
      type: "button",
      children: t
    }
  );
}
function IHe(e) {
  const {
    action: t,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: a = "URL da imagem:",
    modalTitle: s = "Inserir imagem"
  } = e, l = uw(), [u, c] = P(!1), [p, d] = P(""), [y, f] = P("url");
  function v(g) {
    g.preventDefault(), !(!p || p === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: p, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ te.jsxs(te.Fragment, { children: [
    /* @__PURE__ */ te.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ te.jsx(rJ, {})
      }
    ),
    /* @__PURE__ */ te.jsxs(
      DHe,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ te.jsx(jHe, { children: s }),
          /* @__PURE__ */ te.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ te.jsxs(AHe, { defaultActive: y, onClick: f, children: [
              /* @__PURE__ */ te.jsx(hV, { value: "url", children: n[0] }),
              /* @__PURE__ */ te.jsx(hV, { value: "file", children: n[1] })
            ] }),
            y === "url" && /* @__PURE__ */ te.jsxs(te.Fragment, { children: [
              /* @__PURE__ */ te.jsxs(k3, { children: [
                /* @__PURE__ */ te.jsx(S3, { children: a }),
                /* @__PURE__ */ te.jsx(
                  sw,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: p,
                    onChange: (g) => d(g.target.value)
                  }
                )
              ] }),
              p && /* @__PURE__ */ te.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: p,
                  alt: "preview"
                }
              )
            ] }),
            y === "file" && /* @__PURE__ */ te.jsxs(k3, { children: [
              /* @__PURE__ */ te.jsx(S3, { children: i }),
              /* @__PURE__ */ te.jsx(
                V2e,
                {
                  name: "richTextimageURL",
                  action: t,
                  defaultValue: p,
                  onUpload: (g) => d(g || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ te.jsxs(_He, { children: [
            /* @__PURE__ */ te.jsx(
              my,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ te.jsx(my, { type: "button", onClick: v, children: o })
          ] })
        ]
      }
    )
  ] });
}
function BHe({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ te.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ te.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ te.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ te.jsx("u", { children: t })), /* @__PURE__ */ te.jsx("span", { ...e, children: t });
}
function tX(e, t) {
  const n = Q.marks(e);
  return n ? n[t] === !0 : !1;
}
function nX(e, t) {
  tX(e, t) ? Q.removeMark(e, t) : Q.addMark(e, t, !0);
}
function Gg({ format: e, icon: t }) {
  const n = uw(), o = tX(n, e) ? "activeTrue" : "activeFalse";
  function i(a) {
    a.preventDefault(), nX(n, e);
  }
  return /* @__PURE__ */ te.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ te.jsx(t, {})
    }
  );
}
function NHe({ children: e }) {
  return /* @__PURE__ */ te.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
function gV(e) {
  return e.map((t) => Ke.string(t)).join("");
}
const mV = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, Yg = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function r5e(e) {
  const {
    name: t,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: a,
    maxLimit: s = 2e3,
    onChange: l,
    isError: u
  } = e, c = On(() => yUe(kHe(ete())), []), { id: p, inputRef: d, error: y } = bi(), f = dt(null);
  function v() {
    try {
      const X = JSON.parse(o);
      return !Array.isArray(X) || X.length <= 0 ? Yg : X.every(
        (J) => typeof J == "object" && J !== null && "type" in J && "children" in J
      ) ? X : Yg;
    } catch {
      return Yg;
    }
  }
  const g = gV(v()), [E, w] = P(g.length), [D, x] = P(
    JSON.stringify(v()) || "[]"
  ), [m, C] = P(!1), S = d || f, z = u || !!y, L = Rn(BHe, []), R = Rn(MHe, []);
  function B(X) {
    const ee = gV(X);
    w(ee.length), a && a(ee.length), !(i && ee.length >= s) && (x(JSON.stringify(X)), l && l(X), c.children = X, je.setNodes(c, { children: X }));
  }
  const H = m ? "focusTrue" : "focusFalse", W = `arkynRichText ${z || s < E ? "errorTrue" : "errorFalse"} ${H}`, q = s - E;
  function Y(X) {
    return !(n != null && n.includes(X));
  }
  return /* @__PURE__ */ te.jsxs(
    LHe,
    {
      editor: c,
      initialValue: v(),
      onChange: B,
      onValueChange: B,
      children: [
        /* @__PURE__ */ te.jsxs("div", { className: W, children: [
          /* @__PURE__ */ te.jsxs(NHe, { children: [
            Y("headingOne") && /* @__PURE__ */ te.jsx(Zl, { format: "headingOne", icon: oJ }),
            Y("headingTwo") && /* @__PURE__ */ te.jsx(Zl, { format: "headingTwo", icon: iJ }),
            Y("blockQuote") && /* @__PURE__ */ te.jsx(Zl, { format: "blockQuote", icon: sJ }),
            Y("bold") && /* @__PURE__ */ te.jsx(Gg, { format: "bold", icon: aJ }),
            Y("italic") && /* @__PURE__ */ te.jsx(Gg, { format: "italic", icon: lJ }),
            Y("underline") && /* @__PURE__ */ te.jsx(Gg, { format: "underline", icon: uJ }),
            Y("code") && /* @__PURE__ */ te.jsx(Gg, { format: "code", icon: cJ }),
            Y("left") && /* @__PURE__ */ te.jsx(Zl, { format: "left", icon: pJ }),
            Y("right") && /* @__PURE__ */ te.jsx(Zl, { format: "right", icon: dJ }),
            Y("center") && /* @__PURE__ */ te.jsx(Zl, { format: "center", icon: fJ }),
            Y("justify") && /* @__PURE__ */ te.jsx(Zl, { format: "justify", icon: hJ }),
            r && Y("image") && /* @__PURE__ */ te.jsx(IHe, { ...r })
          ] }),
          /* @__PURE__ */ te.jsx(
            mHe,
            {
              className: "editorContainer",
              renderElement: R,
              renderLeaf: L,
              spellCheck: !0,
              id: p,
              onFocus: () => C(!0),
              onBlur: () => C(!1),
              onKeyDown: (X) => {
                for (const ee in mV)
                  if (gUe(ee, X)) {
                    X.preventDefault();
                    const J = mV[ee];
                    nX(c, J);
                  }
              }
            }
          ),
          q < 0 && /* @__PURE__ */ te.jsx("div", { className: "restatesCharacters", children: q })
        ] }),
        /* @__PURE__ */ te.jsx("input", { type: "hidden", ref: S, name: t, value: D }),
        /* @__PURE__ */ te.jsx("input", { type: "hidden", name: `${t}Count`, value: E })
      ]
    }
  );
}
function RHe(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: p,
    onBlur: d,
    title: y,
    style: f,
    closeOnSelect: v = !0,
    ...g
  } = e, m = `arkyn_select ${s ? "hasPrefix" : ""} ${a} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, S = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: m,
    prefix: t8(s, S, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: p,
    onBlur: d,
    title: y,
    closeOnSelect: v,
    style: f,
    iconSize: S,
    Spinner: /* @__PURE__ */ te.jsx(js, { className: "spinner", size: S, strokeWidth: 2.5 }),
    ...g
  };
}
function o5e(e) {
  var j;
  const [t, n] = P(""), [r, o] = P(!1), { inputRef: i, id: a, error: s } = bi(), l = dt(null), u = i || l, c = e.isError || !!s, {
    disabled: p,
    title: d,
    style: y,
    className: f,
    prefix: v,
    iconSize: g,
    isLoading: E,
    LeftIcon: w,
    value: D = null,
    defaultValue: x = "",
    onFocus: m,
    onBlur: C,
    Spinner: S,
    name: z,
    placeholder: L,
    onSelect: R,
    options: B,
    optionMaxHeight: H,
    closeOnSelect: V,
    isSearchable: W,
    onSearch: q,
    ...Y
  } = RHe({ ...e, id: a, isError: c }, r), [X, ee] = P(x);
  function J() {
    p || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function k(F) {
    r || (o(!0), m && m(F));
  }
  function _() {
    o(!1), C && u.current && u.current.blur();
  }
  function U(F) {
    const { label: T, value: Z } = F;
    ee(X !== Z ? Z : ""), R && R({ label: T, value: Z }), V && _();
  }
  const M = typeof D == "string" ? D : X, $ = ((j = B.find((F) => F.value === M)) == null ? void 0 : j.label) || "", O = () => {
    if (!r && $) return !0;
    if (!r && !$) return !1;
    if (r && $) return !0;
    if (r && !$) return !1;
  };
  return /* @__PURE__ */ te.jsxs(te.Fragment, { children: [
    /* @__PURE__ */ te.jsxs(
      "section",
      {
        title: d,
        style: y,
        onClick: J,
        className: `${f} placeholder_dark_${O()}`,
        children: [
          v,
          w && /* @__PURE__ */ te.jsx(w, { size: g, strokeWidth: 2.5 }),
          /* @__PURE__ */ te.jsx(
            "input",
            {
              disabled: p,
              readOnly: !0,
              placeholder: $ || L,
              onFocus: k,
              ...Y
            }
          ),
          /* @__PURE__ */ te.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: z,
              value: M || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ te.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: H },
              children: [
                W && /* @__PURE__ */ te.jsx(
                  sw,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: y9,
                    onChange: (F) => n(F.target.value)
                  }
                ),
                B.filter((F) => !!(e.onSearch || !e.isSearchable || F.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: F, value: T }) => /* @__PURE__ */ te.jsxs(
                  "div",
                  {
                    onClick: () => U({ label: F, value: T }),
                    className: M === T ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      F,
                      " ",
                      /* @__PURE__ */ te.jsx(fL, {})
                    ]
                  },
                  T
                )),
                B.length <= 0 && /* @__PURE__ */ te.jsx("p", { children: "Sem opções disponíveis" })
              ]
            }
          ),
          !E && /* @__PURE__ */ te.jsx(
            v9,
            {
              className: "arkyn_select_arrow",
              size: g,
              strokeWidth: 2.5
            }
          ),
          E && S
        ]
      }
    ),
    r && /* @__PURE__ */ te.jsx("aside", { className: "arkyn_select_overlay", onClick: _ })
  ] });
}
function i5e(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: a,
    className: s = "",
    onCheck: l,
    ...u
  } = e, [c, p] = P(n), { id: d, inputRef: y } = bi(), f = typeof r == "boolean" ? r : c;
  function v() {
    p(!c), l && l(f ? i : o || "checked");
  }
  const E = `arkynSwitch ${f ? "checkedTrue" : "checkedFalse"} ${t} ${s}`;
  return /* @__PURE__ */ te.jsx("button", { type: "button", onClick: v, className: E, ...u, children: /* @__PURE__ */ te.jsx(
    "input",
    {
      id: d,
      type: "hidden",
      name: a,
      ref: y,
      onClick: v,
      value: f ? o || "checked" : i
    }
  ) });
}
function s5e(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: a,
    onBlur: s,
    title: l,
    style: u,
    ...c
  } = e, [p, d] = P(!1), { inputRef: y, id: f, error: v } = bi(), g = dt(null), E = y || g, D = e.isError || !!v ? "errorTrue" : "errorFalse", C = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${D} ${p ? "focusedTrue" : "focusedFalse"} ${r}`;
  function S() {
    o || !(E != null && E.current) || (d(!0), E.current.focus());
  }
  function z(R) {
    d(!0), a && a(R);
  }
  function L(R) {
    d(!1), s && s(R);
  }
  return /* @__PURE__ */ te.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: S,
      className: C,
      children: /* @__PURE__ */ te.jsx(
        "textarea",
        {
          id: f,
          disabled: o,
          readOnly: i,
          ref: E,
          onFocus: z,
          onBlur: L,
          ...c
        }
      )
    }
  );
}
function a5e(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ te.jsx("nav", { className: r, ...n });
}
function l5e(e) {
  const { pathname: t } = mL(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...a
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ te.jsxs("p", { className: l, children: [
    /* @__PURE__ */ te.jsx(BO, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ te.jsxs(vJ, { to: i, className: l, ...a, children: [
    /* @__PURE__ */ te.jsx(BO, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function rX(e = "") {
  const t = mL(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([a, s]) => {
      s === void 0 ? n.delete(`${r}${a}`) : n.set(`${r}${a}`, String(s));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let a = n.toString();
      return a && (a = "?" + a), a;
    }
  };
}
function vV(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function u5e(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: a = 1,
    registerPerPage: s = 20,
    ...l
  } = e, u = C9(), { getParam: c, getScopedSearch: p } = rX(t), d = Number(c("page")) || a, y = Number(c("per_page")) || s, f = Math.ceil(n / y), v = d > 1 ? vV(d - 1 - i, d - 1) : [], g = d < f ? vV(
    d,
    Math.min(d + i, f)
  ) : [];
  function E(w) {
    u(p({ page: w }));
  }
  return /* @__PURE__ */ te.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ te.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d <= 1,
        onClick: () => E(d - 1),
        children: /* @__PURE__ */ te.jsx(gJ, {})
      }
    ),
    d > 1 + i && /* @__PURE__ */ te.jsxs(te.Fragment, { children: [
      /* @__PURE__ */ te.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => E(1),
          children: "1"
        }
      ),
      d > 2 + i && /* @__PURE__ */ te.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ te.jsx(xM, {}) })
    ] }),
    v.length > 0 && v.map((w, D) => /* @__PURE__ */ te.jsx(
      "button",
      {
        onClick: () => E(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      D
    )),
    /* @__PURE__ */ te.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: d }),
    g.length > 0 && g.map((w, D) => /* @__PURE__ */ te.jsx(
      "button",
      {
        onClick: () => E(w),
        className: "arkynPaginationPageButton",
        children: w
      },
      D
    )),
    d + i < f && /* @__PURE__ */ te.jsxs(te.Fragment, { children: [
      d + 1 + i < f && /* @__PURE__ */ te.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ te.jsx(xM, {}) }),
      /* @__PURE__ */ te.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => E(f),
          children: f
        }
      )
    ] }),
    /* @__PURE__ */ te.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: d >= f,
        onClick: () => E(d + 1),
        children: /* @__PURE__ */ te.jsx(BO, {})
      }
    )
  ] });
}
const oX = Ye({});
function c5e(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...a
  } = e, s = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ te.jsx(oX.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ te.jsx(O9, { children: t && /* @__PURE__ */ te.jsxs("aside", { className: u.trim(), ...a, children: [
    /* @__PURE__ */ te.jsx(
      ad.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ te.jsx(
      ad.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${s})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${s})` },
        children: o
      }
    )
  ] }) }) });
}
function p5e(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = ge(oX), a = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ te.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ te.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ te.jsx(hL, { size: 24 })
      }
    )
  ] });
}
function d5e(e) {
  const {
    children: t,
    button: n,
    closeOnClick: r,
    className: o = "",
    orientation: i = "bottomLeft"
  } = e, [a, s] = P(!1), u = `arkynPopover ${i} ${a ? "visibleTrue" : "visibleFalse"} ${o}`;
  function c() {
    a || s(!0);
  }
  return /* @__PURE__ */ te.jsxs("div", { className: u, onClick: c, children: [
    n,
    /* @__PURE__ */ te.jsx(
      ad.div,
      {
        style: { visibility: a ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: a ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && s(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    a && /* @__PURE__ */ te.jsx("div", { onClick: () => s(!1), className: "arkynPopoverOverlay" })
  ] });
}
function f5e(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ te.jsx(g9, {});
      case "danger":
        return /* @__PURE__ */ te.jsx(h9, {});
      default:
        return /* @__PURE__ */ te.jsx(f9, {});
    }
  }
  return /* @__PURE__ */ te.jsxs("div", { className: r, children: [
    /* @__PURE__ */ te.jsxs("div", { children: [
      /* @__PURE__ */ te.jsx("div", { className: "bg" }),
      /* @__PURE__ */ te.jsx(o, {})
    ] }),
    /* @__PURE__ */ te.jsx("p", { children: /* @__PURE__ */ te.jsx("span", { children: t }) })
  ] });
}
var go = {}, cM = {}, Uf = {}, Wf = {}, iX = "Expected a function", yV = NaN, FHe = "[object Symbol]", zHe = /^\s+|\s+$/g, UHe = /^[-+]0x[0-9a-f]+$/i, WHe = /^0b[01]+$/i, $He = /^0o[0-7]+$/i, HHe = parseInt, VHe = typeof Jn == "object" && Jn && Jn.Object === Object && Jn, ZHe = typeof self == "object" && self && self.Object === Object && self, qHe = VHe || ZHe || Function("return this")(), KHe = Object.prototype, GHe = KHe.toString, YHe = Math.max, XHe = Math.min, wO = function() {
  return qHe.Date.now();
};
function JHe(e, t, n) {
  var r, o, i, a, s, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(iX);
  t = bV(t) || 0, yy(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? YHe(bV(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function y(C) {
    var S = r, z = o;
    return r = o = void 0, u = C, a = e.apply(z, S), a;
  }
  function f(C) {
    return u = C, s = setTimeout(E, t), c ? y(C) : a;
  }
  function v(C) {
    var S = C - l, z = C - u, L = t - S;
    return p ? XHe(L, i - z) : L;
  }
  function g(C) {
    var S = C - l, z = C - u;
    return l === void 0 || S >= t || S < 0 || p && z >= i;
  }
  function E() {
    var C = wO();
    if (g(C))
      return w(C);
    s = setTimeout(E, v(C));
  }
  function w(C) {
    return s = void 0, d && r ? y(C) : (r = o = void 0, a);
  }
  function D() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function x() {
    return s === void 0 ? a : w(wO());
  }
  function m() {
    var C = wO(), S = g(C);
    if (r = arguments, o = this, l = C, S) {
      if (s === void 0)
        return f(l);
      if (p)
        return s = setTimeout(E, t), y(l);
    }
    return s === void 0 && (s = setTimeout(E, t)), a;
  }
  return m.cancel = D, m.flush = x, m;
}
function QHe(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(iX);
  return yy(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), JHe(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function yy(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function e3e(e) {
  return !!e && typeof e == "object";
}
function t3e(e) {
  return typeof e == "symbol" || e3e(e) && GHe.call(e) == FHe;
}
function bV(e) {
  if (typeof e == "number")
    return e;
  if (t3e(e))
    return yV;
  if (yy(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = yy(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(zHe, "");
  var n = WHe.test(e);
  return n || $He.test(e) ? HHe(e.slice(2), n ? 2 : 8) : UHe.test(e) ? yV : +e;
}
var n3e = QHe, $f = {};
Object.defineProperty($f, "__esModule", {
  value: !0
});
$f.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), vm.has(n) || vm.set(n, /* @__PURE__ */ new Set());
  var i = vm.get(n);
  if (!i.has(o)) {
    var a = function() {
      var s = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return s;
    }();
    t.addEventListener(n, r, a ? { passive: !0 } : !1), i.add(o);
  }
};
$f.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), vm.get(n).delete(r.name || n);
};
var vm = /* @__PURE__ */ new Map();
Object.defineProperty(Wf, "__esModule", {
  value: !0
});
var r3e = n3e, o3e = s3e(r3e), i3e = $f;
function s3e(e) {
  return e && e.__esModule ? e : { default: e };
}
var a3e = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, o3e.default)(t, n);
}, Kr = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = a3e(function(o) {
        Kr.scrollHandler(t);
      }, n);
      Kr.scrollSpyContainers.push(t), (0, i3e.addPassiveEventListener)(t, "scroll", r);
    }
  },
  isMounted: function(t) {
    return Kr.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.pageYOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = Kr.scrollSpyContainers[Kr.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(Kr.currentPositionX(t), Kr.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    Kr.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = Kr.scrollSpyContainers[Kr.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t), t(Kr.currentPositionX(n), Kr.currentPositionY(n));
  },
  updateStates: function() {
    Kr.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    Kr.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), Kr.spySetState && Kr.spySetState.length && Kr.spySetState.indexOf(t) > -1 && Kr.spySetState.splice(Kr.spySetState.indexOf(t), 1), document.removeEventListener("scroll", Kr.scrollHandler);
  },
  update: function() {
    return Kr.scrollSpyContainers.forEach(function(t) {
      return Kr.scrollHandler(t);
    });
  }
};
Wf.default = Kr;
var _c = {}, Hf = {};
Object.defineProperty(Hf, "__esModule", {
  value: !0
});
var l3e = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, a = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", a) : history.replaceState(history.state, "", a);
}, u3e = function() {
  return window.location.hash.replace(/^#/, "");
}, c3e = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, p3e = function(t) {
  return getComputedStyle(t).position !== "static";
}, CO = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, d3e = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (p3e(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = CO(n, o), a = i.offsetTop, s = i.offsetParent;
      if (s !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return a;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return CO(n, l).offsetTop - CO(t, l).offsetTop;
};
Hf.default = {
  updateHash: l3e,
  getHash: u3e,
  filterElementInContainer: c3e,
  scrollOffset: d3e
};
var cw = {}, pM = {};
Object.defineProperty(pM, "__esModule", {
  value: !0
});
pM.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var dM = {};
Object.defineProperty(dM, "__esModule", {
  value: !0
});
var f3e = $f, h3e = ["mousedown", "mousewheel", "touchmove", "keydown"];
dM.default = {
  subscribe: function(t) {
    return typeof document < "u" && h3e.forEach(function(n) {
      return (0, f3e.addPassiveEventListener)(document, n, t);
    });
  }
};
var Vf = {};
Object.defineProperty(Vf, "__esModule", {
  value: !0
});
var oL = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      oL.registered[t] = n;
    },
    remove: function(t) {
      oL.registered[t] = null;
    }
  }
};
Vf.default = oL;
Object.defineProperty(cw, "__esModule", {
  value: !0
});
var g3e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, m3e = Hf;
pw(m3e);
var v3e = pM, wV = pw(v3e), y3e = dM, b3e = pw(y3e), w3e = Vf, Ls = pw(w3e);
function pw(e) {
  return e && e.__esModule ? e : { default: e };
}
var sX = function(t) {
  return wV.default[t.smooth] || wV.default.defaultEasing;
}, C3e = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, O3e = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, iL = function() {
  return O3e() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), aX = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, lX = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, uX = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, x3e = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, E3e = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, L3e = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Ls.default.registered.end && Ls.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    iL.call(window, i);
    return;
  }
  Ls.default.registered.end && Ls.default.registered.end(o.to, o.target, o.currentPosition);
}, fM = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, Zf = function(t, n, r, o) {
  n.data = n.data || aX(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (b3e.default.subscribe(i), fM(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? lX(n) : uX(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    Ls.default.registered.end && Ls.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = C3e(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var a = sX(n), s = L3e.bind(null, a, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      Ls.default.registered.begin && Ls.default.registered.begin(n.data.to, n.data.target), iL.call(window, s);
    }, n.delay);
    return;
  }
  Ls.default.registered.begin && Ls.default.registered.begin(n.data.to, n.data.target), iL.call(window, s);
}, dw = function(t) {
  return t = g3e({}, t), t.data = t.data || aX(), t.absolute = !0, t;
}, P3e = function(t) {
  Zf(0, dw(t));
}, k3e = function(t, n) {
  Zf(t, dw(n));
}, S3e = function(t) {
  t = dw(t), fM(t), Zf(t.horizontal ? x3e(t) : E3e(t), t);
}, M3e = function(t, n) {
  n = dw(n), fM(n);
  var r = n.horizontal ? lX(n) : uX(n);
  Zf(t + r, n);
};
cw.default = {
  animateTopScroll: Zf,
  getAnimationType: sX,
  scrollToTop: P3e,
  scrollToBottom: S3e,
  scrollTo: k3e,
  scrollMore: M3e
};
Object.defineProperty(_c, "__esModule", {
  value: !0
});
var D3e = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, _3e = Hf, j3e = hM(_3e), T3e = cw, A3e = hM(T3e), I3e = Vf, Xg = hM(I3e);
function hM(e) {
  return e && e.__esModule ? e : { default: e };
}
var Jg = {}, CV = void 0;
_c.default = {
  unmount: function() {
    Jg = {};
  },
  register: function(t, n) {
    Jg[t] = n;
  },
  unregister: function(t) {
    delete Jg[t];
  },
  get: function(t) {
    return Jg[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return CV = t;
  },
  getActiveLink: function() {
    return CV;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = D3e({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, a = void 0;
    o ? a = document.getElementById(o) : i && i.nodeType ? a = i : a = document, n.absolute = !0;
    var s = n.horizontal, l = j3e.default.scrollOffset(a, r, s) + (n.offset || 0);
    if (!n.smooth) {
      Xg.default.registered.begin && Xg.default.registered.begin(t, r), a === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : a.scrollTop = l, Xg.default.registered.end && Xg.default.registered.end(t, r);
      return;
    }
    A3e.default.animateTopScroll(l, n, t, r);
  }
};
var sL = { exports: {} }, Qg = { exports: {} }, Bn = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var OV;
function B3e() {
  if (OV) return Bn;
  OV = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
  function D(m) {
    if (typeof m == "object" && m !== null) {
      var C = m.$$typeof;
      switch (C) {
        case t:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case f:
                case y:
                case a:
                  return m;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function x(m) {
    return D(m) === u;
  }
  return Bn.AsyncMode = l, Bn.ConcurrentMode = u, Bn.ContextConsumer = s, Bn.ContextProvider = a, Bn.Element = t, Bn.ForwardRef = c, Bn.Fragment = r, Bn.Lazy = f, Bn.Memo = y, Bn.Portal = n, Bn.Profiler = i, Bn.StrictMode = o, Bn.Suspense = p, Bn.isAsyncMode = function(m) {
    return x(m) || D(m) === l;
  }, Bn.isConcurrentMode = x, Bn.isContextConsumer = function(m) {
    return D(m) === s;
  }, Bn.isContextProvider = function(m) {
    return D(m) === a;
  }, Bn.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === t;
  }, Bn.isForwardRef = function(m) {
    return D(m) === c;
  }, Bn.isFragment = function(m) {
    return D(m) === r;
  }, Bn.isLazy = function(m) {
    return D(m) === f;
  }, Bn.isMemo = function(m) {
    return D(m) === y;
  }, Bn.isPortal = function(m) {
    return D(m) === n;
  }, Bn.isProfiler = function(m) {
    return D(m) === i;
  }, Bn.isStrictMode = function(m) {
    return D(m) === o;
  }, Bn.isSuspense = function(m) {
    return D(m) === p;
  }, Bn.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === p || m === d || typeof m == "object" && m !== null && (m.$$typeof === f || m.$$typeof === y || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === g || m.$$typeof === E || m.$$typeof === w || m.$$typeof === v);
  }, Bn.typeOf = D, Bn;
}
var Nn = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xV;
function N3e() {
  return xV || (xV = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, a = e ? Symbol.for("react.provider") : 60109, s = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, y = e ? Symbol.for("react.memo") : 60115, f = e ? Symbol.for("react.lazy") : 60116, v = e ? Symbol.for("react.block") : 60121, g = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, w = e ? Symbol.for("react.scope") : 60119;
    function D(N) {
      return typeof N == "string" || typeof N == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      N === r || N === u || N === i || N === o || N === p || N === d || typeof N == "object" && N !== null && (N.$$typeof === f || N.$$typeof === y || N.$$typeof === a || N.$$typeof === s || N.$$typeof === c || N.$$typeof === g || N.$$typeof === E || N.$$typeof === w || N.$$typeof === v);
    }
    function x(N) {
      if (typeof N == "object" && N !== null) {
        var ue = N.$$typeof;
        switch (ue) {
          case t:
            var fe = N.type;
            switch (fe) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return fe;
              default:
                var oe = fe && fe.$$typeof;
                switch (oe) {
                  case s:
                  case c:
                  case f:
                  case y:
                  case a:
                    return oe;
                  default:
                    return ue;
                }
            }
          case n:
            return ue;
        }
      }
    }
    var m = l, C = u, S = s, z = a, L = t, R = c, B = r, H = f, V = y, W = n, q = i, Y = o, X = p, ee = !1;
    function J(N) {
      return ee || (ee = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), k(N) || x(N) === l;
    }
    function k(N) {
      return x(N) === u;
    }
    function _(N) {
      return x(N) === s;
    }
    function U(N) {
      return x(N) === a;
    }
    function M(N) {
      return typeof N == "object" && N !== null && N.$$typeof === t;
    }
    function $(N) {
      return x(N) === c;
    }
    function O(N) {
      return x(N) === r;
    }
    function j(N) {
      return x(N) === f;
    }
    function F(N) {
      return x(N) === y;
    }
    function T(N) {
      return x(N) === n;
    }
    function Z(N) {
      return x(N) === i;
    }
    function A(N) {
      return x(N) === o;
    }
    function G(N) {
      return x(N) === p;
    }
    Nn.AsyncMode = m, Nn.ConcurrentMode = C, Nn.ContextConsumer = S, Nn.ContextProvider = z, Nn.Element = L, Nn.ForwardRef = R, Nn.Fragment = B, Nn.Lazy = H, Nn.Memo = V, Nn.Portal = W, Nn.Profiler = q, Nn.StrictMode = Y, Nn.Suspense = X, Nn.isAsyncMode = J, Nn.isConcurrentMode = k, Nn.isContextConsumer = _, Nn.isContextProvider = U, Nn.isElement = M, Nn.isForwardRef = $, Nn.isFragment = O, Nn.isLazy = j, Nn.isMemo = F, Nn.isPortal = T, Nn.isProfiler = Z, Nn.isStrictMode = A, Nn.isSuspense = G, Nn.isValidElementType = D, Nn.typeOf = x;
  }()), Nn;
}
var EV;
function cX() {
  return EV || (EV = 1, process.env.NODE_ENV === "production" ? Qg.exports = B3e() : Qg.exports = N3e()), Qg.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var OO, LV;
function R3e() {
  if (LV) return OO;
  LV = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return OO = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var p in s)
        t.call(s, p) && (l[p] = s[p]);
      if (e) {
        u = e(s);
        for (var d = 0; d < u.length; d++)
          n.call(s, u[d]) && (l[u[d]] = s[u[d]]);
      }
    }
    return l;
  }, OO;
}
var xO, PV;
function gM() {
  if (PV) return xO;
  PV = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return xO = e, xO;
}
var EO, kV;
function pX() {
  return kV || (kV = 1, EO = Function.call.bind(Object.prototype.hasOwnProperty)), EO;
}
var LO, SV;
function F3e() {
  if (SV) return LO;
  SV = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = gM(), n = {}, r = pX();
    e = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](a, c, l, s, null, t);
          } catch (f) {
            p = f;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var y = u ? u() : "";
            e(
              "Failed " + s + " type: " + p.message + (y ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, LO = o, LO;
}
var PO, MV;
function z3e() {
  if (MV) return PO;
  MV = 1;
  var e = cX(), t = R3e(), n = gM(), r = pX(), o = F3e(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return PO = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(k) {
      var _ = k && (u && k[u] || k[c]);
      if (typeof _ == "function")
        return _;
    }
    var d = "<<anonymous>>", y = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: w(),
      arrayOf: D,
      element: x(),
      elementType: m(),
      instanceOf: C,
      node: R(),
      objectOf: z,
      oneOf: S,
      oneOfType: L,
      shape: H,
      exact: V
    };
    function f(k, _) {
      return k === _ ? k !== 0 || 1 / k === 1 / _ : k !== k && _ !== _;
    }
    function v(k, _) {
      this.message = k, this.data = _ && typeof _ == "object" ? _ : {}, this.stack = "";
    }
    v.prototype = Error.prototype;
    function g(k) {
      if (process.env.NODE_ENV !== "production")
        var _ = {}, U = 0;
      function M(O, j, F, T, Z, A, G) {
        if (T = T || d, A = A || F, G !== n) {
          if (l) {
            var N = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw N.name = "Invariant Violation", N;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var ue = T + ":" + F;
            !_[ue] && // Avoid spamming the console because they are often not actionable except for lib authors
            U < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + A + "` prop on `" + T + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), _[ue] = !0, U++);
          }
        }
        return j[F] == null ? O ? j[F] === null ? new v("The " + Z + " `" + A + "` is marked as required " + ("in `" + T + "`, but its value is `null`.")) : new v("The " + Z + " `" + A + "` is marked as required in " + ("`" + T + "`, but its value is `undefined`.")) : null : k(j, F, T, Z, A);
      }
      var $ = M.bind(null, !1);
      return $.isRequired = M.bind(null, !0), $;
    }
    function E(k) {
      function _(U, M, $, O, j, F) {
        var T = U[M], Z = Y(T);
        if (Z !== k) {
          var A = X(T);
          return new v(
            "Invalid " + O + " `" + j + "` of type " + ("`" + A + "` supplied to `" + $ + "`, expected ") + ("`" + k + "`."),
            { expectedType: k }
          );
        }
        return null;
      }
      return g(_);
    }
    function w() {
      return g(a);
    }
    function D(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside arrayOf.");
        var F = U[M];
        if (!Array.isArray(F)) {
          var T = Y(F);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an array."));
        }
        for (var Z = 0; Z < F.length; Z++) {
          var A = k(F, Z, $, O, j + "[" + Z + "]", n);
          if (A instanceof Error)
            return A;
        }
        return null;
      }
      return g(_);
    }
    function x() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!s(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement."));
        }
        return null;
      }
      return g(k);
    }
    function m() {
      function k(_, U, M, $, O) {
        var j = _[U];
        if (!e.isValidElementType(j)) {
          var F = Y(j);
          return new v("Invalid " + $ + " `" + O + "` of type " + ("`" + F + "` supplied to `" + M + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return g(k);
    }
    function C(k) {
      function _(U, M, $, O, j) {
        if (!(U[M] instanceof k)) {
          var F = k.name || d, T = J(U[M]);
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return g(_);
    }
    function S(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function _(U, M, $, O, j) {
        for (var F = U[M], T = 0; T < k.length; T++)
          if (f(F, k[T]))
            return null;
        var Z = JSON.stringify(k, function(G, N) {
          var ue = X(N);
          return ue === "symbol" ? String(N) : N;
        });
        return new v("Invalid " + O + " `" + j + "` of value `" + String(F) + "` " + ("supplied to `" + $ + "`, expected one of " + Z + "."));
      }
      return g(_);
    }
    function z(k) {
      function _(U, M, $, O, j) {
        if (typeof k != "function")
          return new v("Property `" + j + "` of component `" + $ + "` has invalid PropType notation inside objectOf.");
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type " + ("`" + T + "` supplied to `" + $ + "`, expected an object."));
        for (var Z in F)
          if (r(F, Z)) {
            var A = k(F, Z, $, O, j + "." + Z, n);
            if (A instanceof Error)
              return A;
          }
        return null;
      }
      return g(_);
    }
    function L(k) {
      if (!Array.isArray(k))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var _ = 0; _ < k.length; _++) {
        var U = k[_];
        if (typeof U != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + ee(U) + " at index " + _ + "."
          ), a;
      }
      function M($, O, j, F, T) {
        for (var Z = [], A = 0; A < k.length; A++) {
          var G = k[A], N = G($, O, j, F, T, n);
          if (N == null)
            return null;
          N.data && r(N.data, "expectedType") && Z.push(N.data.expectedType);
        }
        var ue = Z.length > 0 ? ", expected one of type [" + Z.join(", ") + "]" : "";
        return new v("Invalid " + F + " `" + T + "` supplied to " + ("`" + j + "`" + ue + "."));
      }
      return g(M);
    }
    function R() {
      function k(_, U, M, $, O) {
        return W(_[U]) ? null : new v("Invalid " + $ + " `" + O + "` supplied to " + ("`" + M + "`, expected a ReactNode."));
      }
      return g(k);
    }
    function B(k, _, U, M, $) {
      return new v(
        (k || "React class") + ": " + _ + " type `" + U + "." + M + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + $ + "`."
      );
    }
    function H(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        for (var Z in k) {
          var A = k[Z];
          if (typeof A != "function")
            return B($, O, j, Z, X(A));
          var G = A(F, Z, $, O, j + "." + Z, n);
          if (G)
            return G;
        }
        return null;
      }
      return g(_);
    }
    function V(k) {
      function _(U, M, $, O, j) {
        var F = U[M], T = Y(F);
        if (T !== "object")
          return new v("Invalid " + O + " `" + j + "` of type `" + T + "` " + ("supplied to `" + $ + "`, expected `object`."));
        var Z = t({}, U[M], k);
        for (var A in Z) {
          var G = k[A];
          if (r(k, A) && typeof G != "function")
            return B($, O, j, A, X(G));
          if (!G)
            return new v(
              "Invalid " + O + " `" + j + "` key `" + A + "` supplied to `" + $ + "`.\nBad object: " + JSON.stringify(U[M], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(k), null, "  ")
            );
          var N = G(F, A, $, O, j + "." + A, n);
          if (N)
            return N;
        }
        return null;
      }
      return g(_);
    }
    function W(k) {
      switch (typeof k) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !k;
        case "object":
          if (Array.isArray(k))
            return k.every(W);
          if (k === null || s(k))
            return !0;
          var _ = p(k);
          if (_) {
            var U = _.call(k), M;
            if (_ !== k.entries) {
              for (; !(M = U.next()).done; )
                if (!W(M.value))
                  return !1;
            } else
              for (; !(M = U.next()).done; ) {
                var $ = M.value;
                if ($ && !W($[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function q(k, _) {
      return k === "symbol" ? !0 : _ ? _["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && _ instanceof Symbol : !1;
    }
    function Y(k) {
      var _ = typeof k;
      return Array.isArray(k) ? "array" : k instanceof RegExp ? "object" : q(_, k) ? "symbol" : _;
    }
    function X(k) {
      if (typeof k > "u" || k === null)
        return "" + k;
      var _ = Y(k);
      if (_ === "object") {
        if (k instanceof Date)
          return "date";
        if (k instanceof RegExp)
          return "regexp";
      }
      return _;
    }
    function ee(k) {
      var _ = X(k);
      switch (_) {
        case "array":
        case "object":
          return "an " + _;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + _;
        default:
          return _;
      }
    }
    function J(k) {
      return !k.constructor || !k.constructor.name ? d : k.constructor.name;
    }
    return y.checkPropTypes = o, y.resetWarningCache = o.resetWarningCache, y.PropTypes = y, y;
  }, PO;
}
var kO, DV;
function U3e() {
  if (DV) return kO;
  DV = 1;
  var e = gM();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, kO = function() {
    function r(a, s, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, kO;
}
if (process.env.NODE_ENV !== "production") {
  var W3e = cX(), $3e = !0;
  sL.exports = z3e()(W3e.isElement, $3e);
} else
  sL.exports = U3e()();
var fw = sL.exports, hw = {};
Object.defineProperty(hw, "__esModule", {
  value: !0
});
var H3e = Hf, SO = V3e(H3e);
function V3e(e) {
  return e && e.__esModule ? e : { default: e };
}
var Z3e = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return SO.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && SO.default.getHash() !== t && SO.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
hw.default = Z3e;
Object.defineProperty(Uf, "__esModule", {
  value: !0
});
var em = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, q3e = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), K3e = Ce, _V = qf(K3e), G3e = Wf, tm = qf(G3e), Y3e = _c, X3e = qf(Y3e), J3e = fw, zr = qf(J3e), Q3e = hw, Ba = qf(Q3e);
function qf(e) {
  return e && e.__esModule ? e : { default: e };
}
function eVe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function tVe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function nVe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var jV = {
  to: zr.default.string.isRequired,
  containerId: zr.default.string,
  container: zr.default.object,
  activeClass: zr.default.string,
  activeStyle: zr.default.object,
  spy: zr.default.bool,
  horizontal: zr.default.bool,
  smooth: zr.default.oneOfType([zr.default.bool, zr.default.string]),
  offset: zr.default.number,
  delay: zr.default.number,
  isDynamic: zr.default.bool,
  onClick: zr.default.func,
  duration: zr.default.oneOfType([zr.default.number, zr.default.func]),
  absolute: zr.default.bool,
  onSetActive: zr.default.func,
  onSetInactive: zr.default.func,
  ignoreCancelEvents: zr.default.bool,
  hashSpy: zr.default.bool,
  saveHashHistory: zr.default.bool,
  spyThrottle: zr.default.number
};
Uf.default = function(e, t) {
  var n = t || X3e.default, r = function(i) {
    nVe(a, i);
    function a(s) {
      eVe(this, a);
      var l = tVe(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return q3e(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          tm.default.isMounted(l) || tm.default.mount(l, this.props.spyThrottle), this.props.hashSpy && (Ba.default.isMounted() || Ba.default.mount(n), Ba.default.mapContainer(this.props.to, l)), tm.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        tm.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = em({}, this.props.style, this.props.activeStyle) : u = em({}, this.props.style);
        var c = em({}, this.props);
        for (var p in jV)
          c.hasOwnProperty(p) && delete c[p];
        return c.className = l, c.style = u, c.onClick = this.handleClick, _V.default.createElement(e, c);
      }
    }]), a;
  }(_V.default.PureComponent), o = function() {
    var a = this;
    this.scrollTo = function(s, l) {
      n.scrollTo(s, em({}, a.state, l));
    }, this.handleClick = function(s) {
      a.props.onClick && a.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), a.scrollTo(a.props.to, a.props);
    }, this.spyHandler = function(s, l) {
      var u = a.getScrollSpyContainer();
      if (!(Ba.default.isMounted() && !Ba.default.isInitialized())) {
        var c = a.props.horizontal, p = a.props.to, d = null, y = void 0, f = void 0;
        if (c) {
          var v = 0, g = 0, E = 0;
          if (u.getBoundingClientRect) {
            var w = u.getBoundingClientRect();
            E = w.left;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var D = d.getBoundingClientRect();
            v = D.left - E + s, g = v + D.width;
          }
          var x = s - a.props.offset;
          y = x >= Math.floor(v) && x < Math.floor(g), f = x < Math.floor(v) || x >= Math.floor(g);
        } else {
          var m = 0, C = 0, S = 0;
          if (u.getBoundingClientRect) {
            var z = u.getBoundingClientRect();
            S = z.top;
          }
          if (!d || a.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var L = d.getBoundingClientRect();
            m = L.top - S + l, C = m + L.height;
          }
          var R = l - a.props.offset;
          y = R >= Math.floor(m) && R < Math.floor(C), f = R < Math.floor(m) || R >= Math.floor(C);
        }
        var B = n.getActiveLink();
        if (f) {
          if (p === B && n.setActiveLink(void 0), a.props.hashSpy && Ba.default.getHash() === p) {
            var H = a.props.saveHashHistory, V = H === void 0 ? !1 : H;
            Ba.default.changeHash("", V);
          }
          a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive(p, d));
        }
        if (y && (B !== p || a.state.active === !1)) {
          n.setActiveLink(p);
          var W = a.props.saveHashHistory, q = W === void 0 ? !1 : W;
          a.props.hashSpy && Ba.default.changeHash(p, q), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(p, d));
        }
      }
    };
  };
  return r.propTypes = jV, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(cM, "__esModule", {
  value: !0
});
var rVe = Ce, TV = dX(rVe), oVe = Uf, iVe = dX(oVe);
function dX(e) {
  return e && e.__esModule ? e : { default: e };
}
function sVe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function AV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function aVe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var lVe = function(e) {
  aVe(t, e);
  function t() {
    var n, r, o, i;
    sVe(this, t);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = AV(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return TV.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), AV(o, i);
  }
  return t;
}(TV.default.Component);
cM.default = (0, iVe.default)(lVe);
var mM = {};
Object.defineProperty(mM, "__esModule", {
  value: !0
});
var uVe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), cVe = Ce, IV = fX(cVe), pVe = Uf, dVe = fX(pVe);
function fX(e) {
  return e && e.__esModule ? e : { default: e };
}
function fVe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function hVe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function gVe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var mVe = function(e) {
  gVe(t, e);
  function t() {
    return fVe(this, t), hVe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return uVe(t, [{
    key: "render",
    value: function() {
      return IV.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(IV.default.Component);
mM.default = (0, dVe.default)(mVe);
var vM = {}, gw = {};
Object.defineProperty(gw, "__esModule", {
  value: !0
});
var vVe = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, yVe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), bVe = Ce, BV = mw(bVe), wVe = pl;
mw(wVe);
var CVe = _c, NV = mw(CVe), OVe = fw, RV = mw(OVe);
function mw(e) {
  return e && e.__esModule ? e : { default: e };
}
function xVe(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function EVe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function LVe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
gw.default = function(e) {
  var t = function(n) {
    LVe(r, n);
    function r(o) {
      xVe(this, r);
      var i = EVe(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return yVe(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        NV.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        NV.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return BV.default.createElement(e, vVe({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(BV.default.Component);
  return t.propTypes = {
    name: RV.default.string,
    id: RV.default.string
  }, t;
};
Object.defineProperty(vM, "__esModule", {
  value: !0
});
var FV = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, PVe = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), kVe = Ce, zV = yM(kVe), SVe = gw, MVe = yM(SVe), DVe = fw, UV = yM(DVe);
function yM(e) {
  return e && e.__esModule ? e : { default: e };
}
function _Ve(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function jVe(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function TVe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var hX = function(e) {
  TVe(t, e);
  function t() {
    return _Ve(this, t), jVe(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return PVe(t, [{
    key: "render",
    value: function() {
      var r = this, o = FV({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, zV.default.createElement(
        "div",
        FV({}, o, { ref: function(a) {
          r.props.parentBindings.domNode = a;
        } }),
        this.props.children
      );
    }
  }]), t;
}(zV.default.Component);
hX.propTypes = {
  name: UV.default.string,
  id: UV.default.string
};
vM.default = (0, MVe.default)(hX);
var MO = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, WV = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function $V(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function HV(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function VV(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var nm = Ce, ql = Wf, DO = _c, to = fw, Na = hw, ZV = {
  to: to.string.isRequired,
  containerId: to.string,
  container: to.object,
  activeClass: to.string,
  spy: to.bool,
  smooth: to.oneOfType([to.bool, to.string]),
  offset: to.number,
  delay: to.number,
  isDynamic: to.bool,
  onClick: to.func,
  duration: to.oneOfType([to.number, to.func]),
  absolute: to.bool,
  onSetActive: to.func,
  onSetInactive: to.func,
  ignoreCancelEvents: to.bool,
  hashSpy: to.bool,
  spyThrottle: to.number
}, AVe = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || DO, o = function(a) {
      VV(s, a);
      function s(l) {
        $V(this, s);
        var u = HV(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return WV(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            ql.isMounted(u) || ql.mount(u, this.props.spyThrottle), this.props.hashSpy && (Na.isMounted() || Na.mount(r), Na.mapContainer(this.props.to, u)), this.props.spy && ql.addStateHandler(this.stateHandler), ql.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          ql.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = MO({}, this.props);
          for (var p in ZV)
            c.hasOwnProperty(p) && delete c[p];
          return c.className = u, c.onClick = this.handleClick, nm.createElement(t, c);
        }
      }]), s;
    }(nm.Component), i = function() {
      var s = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, MO({}, s.state, u));
      }, this.handleClick = function(l) {
        s.props.onClick && s.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), s.scrollTo(s.props.to, s.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== s.props.to && (s.state !== null && s.state.active && s.props.onSetInactive && s.props.onSetInactive(), s.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = s.getScrollSpyContainer();
        if (!(Na.isMounted() && !Na.isInitialized())) {
          var c = s.props.to, p = null, d = 0, y = 0, f = 0;
          if (u.getBoundingClientRect) {
            var v = u.getBoundingClientRect();
            f = v.top;
          }
          if (!p || s.props.isDynamic) {
            if (p = r.get(c), !p)
              return;
            var g = p.getBoundingClientRect();
            d = g.top - f + l, y = d + g.height;
          }
          var E = l - s.props.offset, w = E >= Math.floor(d) && E < Math.floor(y), D = E < Math.floor(d) || E >= Math.floor(y), x = r.getActiveLink();
          if (D)
            return c === x && r.setActiveLink(void 0), s.props.hashSpy && Na.getHash() === c && Na.changeHash(), s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive()), ql.updateStates();
          if (w && x !== c)
            return r.setActiveLink(c), s.props.hashSpy && Na.changeHash(c), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(c)), ql.updateStates();
        }
      };
    };
    return o.propTypes = ZV, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      VV(o, r);
      function o(i) {
        $V(this, o);
        var a = HV(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return a.childBindings = {
          domNode: null
        }, a;
      }
      return WV(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(a) {
          this.props.name !== a.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          DO.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(a) {
          DO.register(a, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return nm.createElement(t, MO({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(nm.Component);
    return n.propTypes = {
      name: to.string,
      id: to.string
    }, n;
  }
}, IVe = AVe;
Object.defineProperty(go, "__esModule", {
  value: !0
});
go.Helpers = go.ScrollElement = go.ScrollLink = LX = go.animateScroll = go.scrollSpy = go.Events = go.scroller = go.Element = go.Button = go.Link = void 0;
var BVe = cM, gX = Fs(BVe), NVe = mM, mX = Fs(NVe), RVe = vM, vX = Fs(RVe), FVe = _c, yX = Fs(FVe), zVe = Vf, bX = Fs(zVe), UVe = Wf, wX = Fs(UVe), WVe = cw, CX = Fs(WVe), $Ve = Uf, OX = Fs($Ve), HVe = gw, xX = Fs(HVe), VVe = IVe, EX = Fs(VVe);
function Fs(e) {
  return e && e.__esModule ? e : { default: e };
}
go.Link = gX.default;
go.Button = mX.default;
go.Element = vX.default;
go.scroller = yX.default;
go.Events = bX.default;
go.scrollSpy = wX.default;
var LX = go.animateScroll = CX.default;
go.ScrollLink = OX.default;
go.ScrollElement = xX.default;
go.Helpers = EX.default;
go.default = { Link: gX.default, Button: mX.default, Element: vX.default, scroller: yX.default, Events: bX.default, scrollSpy: wX.default, animateScroll: CX.default, ScrollLink: OX.default, ScrollElement: xX.default, Helpers: EX.default };
const bM = Ye({}), PX = Ye({});
function ZVe() {
  const e = ge(PX);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function qV(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function h5e() {
  const e = gL(), { closeModal: t, closeAll: n } = ge(bM), { showToast: r } = ZVe(), { getParam: o } = rX(), { pathname: i } = mL(), a = C9(), s = o("closeAllModals");
  h(() => {
    s === "true" && (n(), a(i));
  }, [s]), h(() => {
    const l = e == null ? void 0 : e.closeModalKey;
    l && t(l);
  }, [e]), h(() => {
    const l = e == null ? void 0 : e.closeAllModals;
    typeof l == "boolean" && l && n();
  }, [e]), h(() => {
    const l = e == null ? void 0 : e.toast, u = e == null ? void 0 : e.message;
    qV(l) && r(l), !qV(l) && u && r({ message: u, type: "danger" });
  }, [e]), h(() => {
    var l, u;
    if (typeof ((l = e == null ? void 0 : e.data) == null ? void 0 : l.scrollTo) == "string") {
      const c = document.getElementById((u = e == null ? void 0 : e.data) == null ? void 0 : u.scrollTo);
      c && LX.scrollTo(c.offsetTop - 200);
    }
  }, [e]);
}
const kX = Ye({});
function g5e(e) {
  const t = ge(kX);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, a = r(e), s = n(e);
    return { drawerIsOpen: a, drawerData: s, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function qVe() {
  return () => {
  };
}
function KVe() {
  return QX(
    qVe,
    () => !0,
    () => !1
  );
}
function m5e(e) {
  const t = ge(bM);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, a = r(e), s = n(e);
    return { modalIsOpen: a, modalData: s, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function v5e(e) {
  const { children: t = !1 } = e, [n, r] = P([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function a(l, u) {
    const c = o(l);
    r(c ? (p) => [...p.filter((y) => y.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function s(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ te.jsx(
    kX.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: a, closeDrawer: s },
      children: t
    }
  );
}
function Xd(e) {
  "@babel/helpers - typeof";
  return Xd = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Xd(e);
}
function GVe(e, t) {
  if (Xd(e) != "object" || !e) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Xd(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function YVe(e) {
  var t = GVe(e, "string");
  return Xd(t) == "symbol" ? t : t + "";
}
function ye(e, t, n) {
  return (t = YVe(t)) in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function SX(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var _O, KV;
function XVe() {
  if (KV) return _O;
  KV = 1;
  var e = process.env.NODE_ENV, t = function(r, o, i, a, s, l, u, c) {
    if (e !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var p;
      if (o === void 0)
        p = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [i, a, s, l, u, c], y = 0;
        p = new Error(o.replace(/%s/g, function() {
          return d[y++];
        })), p.name = "Invariant Violation";
      }
      throw p.framesToPop = 1, p;
    }
  };
  return _O = t, _O;
}
var JVe = XVe(), Eo = /* @__PURE__ */ SX(JVe), Tt = Ye(null);
function QVe() {
  Eo(!!ge, "useGoogleMap is React hook and requires React version 16.8+");
  var e = ge(Tt);
  return Eo(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function e6e(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function t6e(e, t) {
  Object.keys(e).forEach((n) => t(e[n], n));
}
function n6e(e, t, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== t[s] && (o[s] = l, a(r, l));
  };
  return t6e(e, i), o;
}
function r6e(e, t, n) {
  var r = e6e(n, function(i, a, s) {
    return typeof e[s] == "function" && i.push(google.maps.event.addListener(t, a, e[s])), i;
  }, []);
  return r;
}
function o6e(e) {
  google.maps.event.removeListener(e);
}
function tn() {
  var e = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  e.forEach(o6e);
}
function qt(e) {
  var {
    updaterMap: t,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = e, a = r6e(o, i, n);
  return n6e(t, r, o, i), a;
}
var GV = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, YV = {
  extraMapTypes(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center(e, t) {
    e.setCenter(t);
  },
  clickableIcons(e, t) {
    e.setClickableIcons(t);
  },
  heading(e, t) {
    e.setHeading(t);
  },
  mapTypeId(e, t) {
    e.setMapTypeId(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  streetView(e, t) {
    e.setStreetView(t);
  },
  tilt(e, t) {
    e.setTilt(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
function i6e(e) {
  var {
    children: t,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: p,
    onMouseMove: d,
    onMouseOut: y,
    onMouseOver: f,
    onMouseDown: v,
    onMouseUp: g,
    onRightClick: E,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: w,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: D,
    onUnmount: x
  } = e, [m, C] = P(null), S = dt(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null), [A, G] = P(null);
  return h(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), h(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), h(() => {
    m && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), h(() => {
    m && c && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), h(() => {
    m && p && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(m, "dragstart", p)));
  }, [p]), h(() => {
    m && v && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(m, "mousedown", v)));
  }, [v]), h(() => {
    m && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(m, "mousemove", d)));
  }, [d]), h(() => {
    m && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(m, "mouseout", y)));
  }, [y]), h(() => {
    m && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), h(() => {
    m && g && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(m, "mouseup", g)));
  }, [g]), h(() => {
    m && E && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(m, "rightclick", E)));
  }, [E]), h(() => {
    m && s && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(m, "click", s)));
  }, [s]), h(() => {
    m && u && (A !== null && google.maps.event.removeListener(A), G(google.maps.event.addListener(m, "drag", u)));
  }, [u]), h(() => {
    m && w && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(m, "center_changed", w)));
  }, [s]), h(() => {
    var N = S.current === null ? null : new google.maps.Map(S.current, n);
    return C(N), N !== null && D && D(N), () => {
      N !== null && x && x(N);
    };
  }, []), te.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: te.jsx(Tt.Provider, {
      value: m,
      children: m !== null ? t : null
    })
  });
}
ve(i6e);
let s6e = class extends pe {
  constructor() {
    super(...arguments), ye(this, "state", {
      map: null
    }), ye(this, "registeredEvents", []), ye(this, "mapRef", null), ye(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), ye(this, "panTo", (t) => {
      var n = this.getInstance();
      n && n.panTo(t);
    }), ye(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), ye(this, "getRef", (t) => {
      this.mapRef = t;
    });
  }
  componentDidMount() {
    var t = this.getInstance();
    this.registeredEvents = qt({
      updaterMap: YV,
      eventMap: GV,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        map: t
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(t) {
    this.state.map !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: YV,
      eventMap: GV,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), tn(this.registeredEvents));
  }
  render() {
    return te.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: te.jsx(Tt.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function XV(e, t, n, r, o, i, a) {
  try {
    var s = e[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? t(l) : Promise.resolve(l).then(r, o);
}
function MX(e) {
  return function() {
    var t = this, n = arguments;
    return new Promise(function(r, o) {
      var i = e.apply(t, n);
      function a(l) {
        XV(i, r, o, a, s, "next", l);
      }
      function s(l) {
        XV(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function DX(e) {
  var {
    googleMapsApiKey: t,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = e, c = [];
  return Eo(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? c.push("key=".concat(t)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var yu = typeof document < "u";
function _X(e) {
  var {
    url: t,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = e;
  return yu ? new Promise(function(i, a) {
    var s = document.getElementById(n), l = window;
    if (s) {
      var u = s.getAttribute("data-state");
      if (s.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, p = s.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, s.onerror = function(y) {
          p && p(y), a(y);
        };
        return;
      } else
        s.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(f) {
      d.setAttribute("data-state", "error"), a(f);
    }, l.initMap = function() {
      d.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function JV(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function jX() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return JV(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return JV(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
var hp = !1;
function TX() {
  return te.jsx("div", {
    children: "Loading..."
  });
}
var aL = {
  id: "script-loader",
  version: "weekly"
};
class AX extends pe {
  constructor() {
    super(...arguments), ye(this, "check", ir()), ye(this, "state", {
      loaded: !1
    }), ye(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ye(this, "isCleaningUp", /* @__PURE__ */ MX(function* () {
      function t(n) {
        if (!hp)
          n();
        else if (yu)
          var r = window.setInterval(function() {
            hp || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(t);
    })), ye(this, "cleanup", () => {
      hp = !0;
      var t = document.getElementById(this.props.id);
      t && t.parentNode && t.parentNode.removeChild(t), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), ye(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && jX(), Eo(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var t = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: DX(this.props)
      };
      _X(t).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (yu) {
      if (window.google && window.google.maps && !hp) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(t) {
    this.props.libraries !== t.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), yu && t.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (yu) {
      this.cleanup();
      var t = () => {
        this.check.current || (delete window.google, hp = !1);
      };
      window.setTimeout(t, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return te.jsxs(te.Fragment, {
      children: [te.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || te.jsx(TX, {})]
    });
  }
}
ye(AX, "defaultProps", aL);
function a6e(e, t) {
  if (e == null) return {};
  var n = {};
  for (var r in e) if ({}.hasOwnProperty.call(e, r)) {
    if (t.includes(r)) continue;
    n[r] = e[r];
  }
  return n;
}
function wM(e, t) {
  if (e == null) return {};
  var n, r, o = a6e(e, t);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (r = 0; r < i.length; r++) n = i[r], t.includes(n) || {}.propertyIsEnumerable.call(e, n) && (o[n] = e[n]);
  }
  return o;
}
var QV;
function l6e(e) {
  var {
    id: t = aL.id,
    version: n = aL.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  } = e, y = dt(!1), [f, v] = P(!1), [g, E] = P(void 0);
  h(function() {
    return y.current = !0, () => {
      y.current = !1;
    };
  }, []), h(function() {
    yu && u && jX();
  }, [u]), h(function() {
    f && Eo(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [f]);
  var w = DX({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: p,
    authReferrerPolicy: d
  });
  h(function() {
    if (!yu)
      return;
    function m() {
      y.current && (v(!0), QV = w);
    }
    if (window.google && window.google.maps && QV === w) {
      m();
      return;
    }
    _X({
      id: t,
      url: w,
      nonce: r
    }).then(m).catch(function(S) {
      y.current && E(S), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(S);
    });
  }, [t, w, r]);
  var D = dt();
  return h(function() {
    D.current && l !== D.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), D.current = l;
  }, [l]), {
    isLoaded: f,
    loadError: g,
    url: w
  };
}
var u6e = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], c6e = te.jsx(TX, {});
function p6e(e) {
  var {
    loadingElement: t,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = e, a = wM(e, u6e), {
    isLoaded: s,
    loadError: l
  } = l6e(a);
  return h(function() {
    s && typeof n == "function" && n();
  }, [s, n]), h(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), h(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : t || c6e;
}
ve(p6e);
var e6;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(e6 || (e6 = {}));
function t6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function by(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? t6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : t6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var n6 = {}, r6 = {
  options(e, t) {
    e.setOptions(t);
  }
};
function d6e(e) {
  var {
    options: t,
    onLoad: n,
    onUnmount: r
  } = e, o = ge(Tt), [i, a] = P(null);
  return h(() => {
    i !== null && i.setMap(o);
  }, [o]), h(() => {
    t && i !== null && i.setOptions(t);
  }, [i, t]), h(() => {
    var s = new google.maps.TrafficLayer(by(by({}, t), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
ve(d6e);
class f6e extends pe {
  constructor() {
    super(...arguments), ye(this, "state", {
      trafficLayer: null
    }), ye(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ye(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = new google.maps.TrafficLayer(by(by({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = qt({
      updaterMap: r6,
      eventMap: n6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        trafficLayer: t
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.trafficLayer !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: r6,
      eventMap: n6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), tn(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ye(f6e, "contextType", Tt);
function h6e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Tt), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
ve(h6e);
class g6e extends pe {
  constructor() {
    super(...arguments), ye(this, "state", {
      bicyclingLayer: null
    }), ye(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: t
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ye(g6e, "contextType", Tt);
function m6e(e) {
  var {
    onLoad: t,
    onUnmount: n
  } = e, r = ge(Tt), [o, i] = P(null);
  return h(() => {
    o !== null && o.setMap(r);
  }, [r]), h(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), t && t(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
ve(m6e);
class v6e extends pe {
  constructor() {
    super(...arguments), ye(this, "state", {
      transitLayer: null
    }), ye(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var t = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: t
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ye(v6e, "contextType", Tt);
function o6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? o6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : o6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var i6 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, s6 = {
  drawingMode(e, t) {
    e.setDrawingMode(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function y6e(e) {
  var {
    options: t,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = e, p = ge(Tt), [d, y] = P(null), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null);
  return h(() => {
    d !== null && d.setMap(p);
  }, [p]), h(() => {
    t && d !== null && d.setOptions(t);
  }, [d, t]), h(() => {
    d !== null && d.setDrawingMode(n ?? null);
  }, [d, n]), h(() => {
    d && r && (f !== null && google.maps.event.removeListener(f), v(google.maps.event.addListener(d, "circlecomplete", r)));
  }, [d, r]), h(() => {
    d && o && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(d, "markercomplete", o)));
  }, [d, o]), h(() => {
    d && i && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(d, "overlaycomplete", i)));
  }, [d, i]), h(() => {
    d && a && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(d, "polygoncomplete", a)));
  }, [d, a]), h(() => {
    d && s && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(d, "polylinecomplete", s)));
  }, [d, s]), h(() => {
    d && l && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(d, "rectanglecomplete", l)));
  }, [d, l]), h(() => {
    Eo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var R = new google.maps.drawing.DrawingManager(wy(wy({}, t), {}, {
      map: p
    }));
    return n && R.setDrawingMode(n), r && v(google.maps.event.addListener(R, "circlecomplete", r)), o && E(google.maps.event.addListener(R, "markercomplete", o)), i && D(google.maps.event.addListener(R, "overlaycomplete", i)), a && m(google.maps.event.addListener(R, "polygoncomplete", a)), s && S(google.maps.event.addListener(R, "polylinecomplete", s)), l && L(google.maps.event.addListener(R, "rectanglecomplete", l)), y(R), u && u(R), () => {
      d !== null && (f && google.maps.event.removeListener(f), g && google.maps.event.removeListener(g), w && google.maps.event.removeListener(w), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), c && c(d), d.setMap(null));
    };
  }, []), null;
}
ve(y6e);
class b6e extends pe {
  constructor(t) {
    super(t), ye(this, "registeredEvents", []), ye(this, "state", {
      drawingManager: null
    }), ye(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Eo(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var t = new google.maps.drawing.DrawingManager(wy(wy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = qt({
      updaterMap: s6,
      eventMap: i6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        drawingManager: t
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(t) {
    this.state.drawingManager !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: s6,
      eventMap: i6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), tn(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ye(b6e, "contextType", Tt);
function a6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function nc(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? a6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : a6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var l6 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, u6 = {
  animation(e, t) {
    e.setAnimation(t);
  },
  clickable(e, t) {
    e.setClickable(t);
  },
  cursor(e, t) {
    e.setCursor(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  icon(e, t) {
    e.setIcon(t);
  },
  label(e, t) {
    e.setLabel(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  opacity(e, t) {
    e.setOpacity(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  shape(e, t) {
    e.setShape(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, Cy = {};
function w6e(e) {
  var {
    position: t,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: p,
    label: d,
    opacity: y,
    shape: f,
    title: v,
    zIndex: g,
    onClick: E,
    onDblClick: w,
    onDrag: D,
    onDragEnd: x,
    onDragStart: m,
    onMouseOut: C,
    onMouseOver: S,
    onMouseUp: z,
    onMouseDown: L,
    onRightClick: R,
    onClickableChanged: B,
    onCursorChanged: H,
    onAnimationChanged: V,
    onDraggableChanged: W,
    onFlatChanged: q,
    onIconChanged: Y,
    onPositionChanged: X,
    onShapeChanged: ee,
    onTitleChanged: J,
    onVisibleChanged: k,
    onZindexChanged: _,
    onLoad: U,
    onUnmount: M
  } = e, $ = ge(Tt), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null), [oe, Ie] = P(null), [qe, Ge] = P(null), [Be, et] = P(null), [Xe, Me] = P(null), [Je, at] = P(null), [Se, _e] = P(null), [Ae, Ve] = P(null), [Ne, nt] = P(null), [we, mt] = P(null), [ot, st] = P(null), [ut, vt] = P(null), [ct, yt] = P(null), [Qe, ft] = P(null), [tt, bt] = P(null), [pt, Dt] = P(null), [wt, _t] = P(null), [Ct, jt] = P(null);
  h(() => {
    O !== null && O.setMap($);
  }, [$]), h(() => {
    typeof n < "u" && O !== null && O.setOptions(n);
  }, [O, n]), h(() => {
    typeof a < "u" && O !== null && O.setDraggable(a);
  }, [O, a]), h(() => {
    t && O !== null && O.setPosition(t);
  }, [O, t]), h(() => {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), h(() => {
    O == null || O.setAnimation(l);
  }, [O, l]), h(() => {
    O && u !== void 0 && O.setClickable(u);
  }, [O, u]), h(() => {
    O && c !== void 0 && O.setCursor(c);
  }, [O, c]), h(() => {
    O && p !== void 0 && O.setIcon(p);
  }, [O, p]), h(() => {
    O && d !== void 0 && O.setLabel(d);
  }, [O, d]), h(() => {
    O && y !== void 0 && O.setOpacity(y);
  }, [O, y]), h(() => {
    O && f !== void 0 && O.setShape(f);
  }, [O, f]), h(() => {
    O && v !== void 0 && O.setTitle(v);
  }, [O, v]), h(() => {
    O && g !== void 0 && O.setZIndex(g);
  }, [O, g]), h(() => {
    O && w && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(O, "dblclick", w)));
  }, [w]), h(() => {
    O && x && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(O, "dragend", x)));
  }, [x]), h(() => {
    O && m && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(O, "dragstart", m)));
  }, [m]), h(() => {
    O && L && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(O, "mousedown", L)));
  }, [L]), h(() => {
    O && C && (oe !== null && google.maps.event.removeListener(oe), Ie(google.maps.event.addListener(O, "mouseout", C)));
  }, [C]), h(() => {
    O && S && (qe !== null && google.maps.event.removeListener(qe), Ge(google.maps.event.addListener(O, "mouseover", S)));
  }, [S]), h(() => {
    O && z && (Be !== null && google.maps.event.removeListener(Be), et(google.maps.event.addListener(O, "mouseup", z)));
  }, [z]), h(() => {
    O && R && (Xe !== null && google.maps.event.removeListener(Xe), Me(google.maps.event.addListener(O, "rightclick", R)));
  }, [R]), h(() => {
    O && E && (Je !== null && google.maps.event.removeListener(Je), at(google.maps.event.addListener(O, "click", E)));
  }, [E]), h(() => {
    O && D && (Se !== null && google.maps.event.removeListener(Se), _e(google.maps.event.addListener(O, "drag", D)));
  }, [D]), h(() => {
    O && B && (Ae !== null && google.maps.event.removeListener(Ae), Ve(google.maps.event.addListener(O, "clickable_changed", B)));
  }, [B]), h(() => {
    O && H && (Ne !== null && google.maps.event.removeListener(Ne), nt(google.maps.event.addListener(O, "cursor_changed", H)));
  }, [H]), h(() => {
    O && V && (we !== null && google.maps.event.removeListener(we), mt(google.maps.event.addListener(O, "animation_changed", V)));
  }, [V]), h(() => {
    O && W && (ot !== null && google.maps.event.removeListener(ot), st(google.maps.event.addListener(O, "draggable_changed", W)));
  }, [W]), h(() => {
    O && q && (ut !== null && google.maps.event.removeListener(ut), vt(google.maps.event.addListener(O, "flat_changed", q)));
  }, [q]), h(() => {
    O && Y && (ct !== null && google.maps.event.removeListener(ct), yt(google.maps.event.addListener(O, "icon_changed", Y)));
  }, [Y]), h(() => {
    O && X && (Qe !== null && google.maps.event.removeListener(Qe), ft(google.maps.event.addListener(O, "position_changed", X)));
  }, [X]), h(() => {
    O && ee && (tt !== null && google.maps.event.removeListener(tt), bt(google.maps.event.addListener(O, "shape_changed", ee)));
  }, [ee]), h(() => {
    O && J && (pt !== null && google.maps.event.removeListener(pt), Dt(google.maps.event.addListener(O, "title_changed", J)));
  }, [J]), h(() => {
    O && k && (wt !== null && google.maps.event.removeListener(wt), _t(google.maps.event.addListener(O, "visible_changed", k)));
  }, [k]), h(() => {
    O && _ && (Ct !== null && google.maps.event.removeListener(Ct), jt(google.maps.event.addListener(O, "zindex_changed", _)));
  }, [_]), h(() => {
    var ht = nc(nc(nc({}, n || Cy), r ? Cy : {
      map: $
    }), {}, {
      position: t
    }), re = new google.maps.Marker(ht);
    return r ? r.addMarker(re, !!o) : re.setMap($), t && re.setPosition(t), typeof s < "u" && re.setVisible(s), typeof a < "u" && re.setDraggable(a), typeof u < "u" && re.setClickable(u), typeof c == "string" && re.setCursor(c), p && re.setIcon(p), typeof d < "u" && re.setLabel(d), typeof y < "u" && re.setOpacity(y), f && re.setShape(f), typeof v == "string" && re.setTitle(v), typeof g == "number" && re.setZIndex(g), w && T(google.maps.event.addListener(re, "dblclick", w)), x && A(google.maps.event.addListener(re, "dragend", x)), m && N(google.maps.event.addListener(re, "dragstart", m)), L && fe(google.maps.event.addListener(re, "mousedown", L)), C && Ie(google.maps.event.addListener(re, "mouseout", C)), S && Ge(google.maps.event.addListener(re, "mouseover", S)), z && et(google.maps.event.addListener(re, "mouseup", z)), R && Me(google.maps.event.addListener(re, "rightclick", R)), E && at(google.maps.event.addListener(re, "click", E)), D && _e(google.maps.event.addListener(re, "drag", D)), B && Ve(google.maps.event.addListener(re, "clickable_changed", B)), H && nt(google.maps.event.addListener(re, "cursor_changed", H)), V && mt(google.maps.event.addListener(re, "animation_changed", V)), W && st(google.maps.event.addListener(re, "draggable_changed", W)), q && vt(google.maps.event.addListener(re, "flat_changed", q)), Y && yt(google.maps.event.addListener(re, "icon_changed", Y)), X && ft(google.maps.event.addListener(re, "position_changed", X)), ee && bt(google.maps.event.addListener(re, "shape_changed", ee)), J && Dt(google.maps.event.addListener(re, "title_changed", J)), k && _t(google.maps.event.addListener(re, "visible_changed", k)), _ && jt(google.maps.event.addListener(re, "zindex_changed", _)), j(re), U && U(re), () => {
      F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), oe !== null && google.maps.event.removeListener(oe), qe !== null && google.maps.event.removeListener(qe), Be !== null && google.maps.event.removeListener(Be), Xe !== null && google.maps.event.removeListener(Xe), Je !== null && google.maps.event.removeListener(Je), Ae !== null && google.maps.event.removeListener(Ae), Ne !== null && google.maps.event.removeListener(Ne), we !== null && google.maps.event.removeListener(we), ot !== null && google.maps.event.removeListener(ot), ut !== null && google.maps.event.removeListener(ut), ct !== null && google.maps.event.removeListener(ct), Qe !== null && google.maps.event.removeListener(Qe), pt !== null && google.maps.event.removeListener(pt), wt !== null && google.maps.event.removeListener(wt), Ct !== null && google.maps.event.removeListener(Ct), M && M(re), r ? r.removeMarker(re, !!o) : re && re.setMap(null);
    };
  }, []);
  var Cn = On(() => i ? lt.map(i, (ht) => {
    if (!mi(ht))
      return ht;
    var re = ht;
    return vi(re, {
      anchor: O
    });
  }) : null, [i, O]);
  return te.jsx(te.Fragment, {
    children: Cn
  }) || null;
}
ve(w6e);
class IX extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this;
    return MX(function* () {
      var n = nc(nc(nc({}, t.props.options || Cy), t.props.clusterer ? Cy : {
        map: t.context
      }), {}, {
        position: t.props.position
      });
      t.marker = new google.maps.Marker(n), t.props.clusterer ? t.props.clusterer.addMarker(t.marker, !!t.props.noClustererRedraw) : t.marker.setMap(t.context), t.registeredEvents = qt({
        updaterMap: u6,
        eventMap: l6,
        prevProps: {},
        nextProps: t.props,
        instance: t.marker
      }), t.props.onLoad && t.props.onLoad(t.marker);
    })();
  }
  componentDidUpdate(t) {
    this.marker && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: u6,
      eventMap: l6,
      prevProps: t,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), tn(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var t = this.props.children ? lt.map(this.props.children, (n) => {
      if (!mi(n))
        return n;
      var r = n;
      return vi(r, {
        anchor: this.marker
      });
    }) : null;
    return t || null;
  }
}
ye(IX, "contextType", Tt);
var C6e = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = s, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var y = document.createElement("div");
        y.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (y.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (y.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(y), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), O6e = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new C6e(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && t.extend(a);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function x6e(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var E6e = 2e3, L6e = 500, P6e = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", k6e = "png", S6e = [53, 56, 66, 78, 90], M6e = "cluster", BX = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || P6e, this.imageExtension = r.imageExtension || k6e, this.imageSizes = r.imageSizes || S6e, this.calculator = r.calculator || x6e, this.batchSize = r.batchSize || E6e, this.batchSizeIE = r.batchSizeIE || L6e, this.clusterClass = r.clusterClass || M6e, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(t, "idle", this.onIdle)]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && t.extend(a);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, t && s.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new O6e(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var y = d[p];
            y.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var a = i;
          this.prototype[a] = o.prototype[a];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
);
function c6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function D6e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? c6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : c6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ss = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Mn = {
  averageCenter(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator(e, t) {
    e.setCalculator(t);
  },
  clusterClass(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension(e, t) {
    e.setImageExtension(t);
  },
  imagePath(e, t) {
    e.setImagePath(t);
  },
  imageSizes(e, t) {
    e.setImageSizes(t);
  },
  maxZoom(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles(e, t) {
    e.setStyles(t);
  },
  title(e, t) {
    e.setTitle(t);
  },
  zoomOnClick(e, t) {
    e.setZoomOnClick(t);
  }
}, _6e = {};
function j6e(e) {
  var {
    children: t,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: p,
    imageSizes: d,
    maxZoom: y,
    minimumClusterSize: f,
    styles: v,
    title: g,
    zoomOnClick: E,
    onClick: w,
    onClusteringBegin: D,
    onClusteringEnd: x,
    onMouseOver: m,
    onMouseOut: C,
    onLoad: S,
    onUnmount: z
  } = e, [L, R] = P(null), B = ge(Tt), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null);
  return h(() => {
    L && C && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(L, ss.onMouseOut, C)));
  }, [C]), h(() => {
    L && m && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(L, ss.onMouseOver, m)));
  }, [m]), h(() => {
    L && w && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(L, ss.onClick, w)));
  }, [w]), h(() => {
    L && D && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(L, ss.onClusteringBegin, D)));
  }, [D]), h(() => {
    L && x && (Y !== null && google.maps.event.removeListener(Y), q(google.maps.event.addListener(L, ss.onClusteringEnd, x)));
  }, [x]), h(() => {
    typeof r < "u" && L !== null && Mn.averageCenter(L, r);
  }, [L, r]), h(() => {
    typeof o < "u" && L !== null && Mn.batchSizeIE(L, o);
  }, [L, o]), h(() => {
    typeof i < "u" && L !== null && Mn.calculator(L, i);
  }, [L, i]), h(() => {
    typeof a < "u" && L !== null && Mn.clusterClass(L, a);
  }, [L, a]), h(() => {
    typeof s < "u" && L !== null && Mn.enableRetinaIcons(L, s);
  }, [L, s]), h(() => {
    typeof l < "u" && L !== null && Mn.gridSize(L, l);
  }, [L, l]), h(() => {
    typeof u < "u" && L !== null && Mn.ignoreHidden(L, u);
  }, [L, u]), h(() => {
    typeof c < "u" && L !== null && Mn.imageExtension(L, c);
  }, [L, c]), h(() => {
    typeof p < "u" && L !== null && Mn.imagePath(L, p);
  }, [L, p]), h(() => {
    typeof d < "u" && L !== null && Mn.imageSizes(L, d);
  }, [L, d]), h(() => {
    typeof y < "u" && L !== null && Mn.maxZoom(L, y);
  }, [L, y]), h(() => {
    typeof f < "u" && L !== null && Mn.minimumClusterSize(L, f);
  }, [L, f]), h(() => {
    typeof v < "u" && L !== null && Mn.styles(L, v);
  }, [L, v]), h(() => {
    typeof g < "u" && L !== null && Mn.title(L, g);
  }, [L, g]), h(() => {
    typeof E < "u" && L !== null && Mn.zoomOnClick(L, E);
  }, [L, E]), h(() => {
    if (B) {
      var U = D6e({}, n || _6e), M = new BX(B, [], U);
      return r && Mn.averageCenter(M, r), o && Mn.batchSizeIE(M, o), i && Mn.calculator(M, i), a && Mn.clusterClass(M, a), s && Mn.enableRetinaIcons(M, s), l && Mn.gridSize(M, l), u && Mn.ignoreHidden(M, u), c && Mn.imageExtension(M, c), p && Mn.imagePath(M, p), d && Mn.imageSizes(M, d), y && Mn.maxZoom(M, y), f && Mn.minimumClusterSize(M, f), v && Mn.styles(M, v), g && Mn.title(M, g), E && Mn.zoomOnClick(M, E), C && J(google.maps.event.addListener(M, ss.onMouseOut, C)), m && _(google.maps.event.addListener(M, ss.onMouseOver, m)), w && V(google.maps.event.addListener(M, ss.onClick, w)), D && q(google.maps.event.addListener(M, ss.onClusteringBegin, D)), x && X(google.maps.event.addListener(M, ss.onClusteringEnd, x)), R(M), S && S(M), () => {
        ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), z && z(M);
      };
    }
  }, []), L !== null && t(L) || null;
}
ve(j6e);
class T6e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      markerClusterer: null
    }), ye(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var t = new BX(this.context, [], this.props.options);
      this.registeredEvents = qt({
        updaterMap: Mn,
        eventMap: ss,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        markerClusterer: t
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.markerClusterer && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: Mn,
      eventMap: ss,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), tn(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ye(T6e, "contextType", Tt);
function p6(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var NX = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), t.enableEventPropagation || p6(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, p6));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, y = this.infoBoxClearance.width, f = this.infoBoxClearance.height, v = this.getProjection(), g = v.fromLatLngToContainerPixel(this.position);
          g !== null && (g.x < -u + y ? r = g.x + u - y : g.x + p + u + y > s && (r = g.x + p + u + y - s), this.alignBottom ? g.y < -c + f + d ? o = g.y + c - f - d : g.y + c + f > l && (o = g.y + c + f - l) : g.y < -c + f ? o = g.y + c - f : g.y + d + c + f > l && (o = g.y + d + c + f - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), A6e = ["position"], I6e = ["position"];
function d6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Oy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? d6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : d6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var f6 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, h6 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
}, B6e = {};
function N6e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Tt), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    y && f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    if (o && f !== null) {
      var B = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      f.setPosition(B);
    }
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    if (y) {
      var B = r || B6e, {
        position: H
      } = B, V = wM(B, A6e), W;
      H && !(H instanceof google.maps.LatLng) && (W = new google.maps.LatLng(H.lat, H.lng));
      var q = new NX(Oy(Oy({}, V), W ? {
        position: W
      } : {}));
      R.current = document.createElement("div"), v(q), a && E(google.maps.event.addListener(q, "closeclick", a)), s && D(google.maps.event.addListener(q, "domready", s)), l && m(google.maps.event.addListener(q, "content_changed", l)), u && S(google.maps.event.addListener(q, "position_changed", u)), c && L(google.maps.event.addListener(q, "zindex_changed", c)), q.setContent(R.current), n ? q.open(y, n) : q.getPosition() ? q.open(y) : Eo(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(q);
    }
    return () => {
      f !== null && (g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(f), f.close());
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(N6e);
class R6e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "containerElement", null), ye(this, "state", {
      infoBox: null
    }), ye(this, "open", (t, n) => {
      n ? this.context !== null && t.open(this.context, n) : t.getPosition() ? this.context !== null && t.open(this.context) : Eo(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ye(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var t = this.props.options || {}, {
      position: n
    } = t, r = wM(t, I6e), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new NX(Oy(Oy({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = qt({
      updaterMap: h6,
      eventMap: f6,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(t) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: h6,
      eventMap: f6,
      prevProps: t,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: t
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (t && t(n), tn(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
ye(R6e, "contextType", Tt);
var jO, g6;
function F6e() {
  return g6 || (g6 = 1, jO = function e(t, n) {
    if (t === n) return !0;
    if (t && n && typeof t == "object" && typeof n == "object") {
      if (t.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(t)) {
        if (r = t.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!e(t[o], n[o])) return !1;
        return !0;
      }
      if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
      if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
      if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
      if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!e(t[a], n[a])) return !1;
      }
      return !0;
    }
    return t !== t && n !== n;
  }), jO;
}
var z6e = F6e(), m6 = /* @__PURE__ */ SX(z6e), v6 = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], TO = 1, gp = 8;
class CM {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== TO)
      throw new Error("Got v".concat(o, " data when expected v").concat(TO, "."));
    var i = v6[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(t, 2, 1), [s] = new Uint32Array(t, 4, 1);
    return new CM(s, a, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(t) || t < 0) throw new Error("Unpexpected numItems value: ".concat(t, "."));
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    var i = v6.indexOf(this.ArrayType), a = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, gp, t), this.coords = new this.ArrayType(this.data, gp + s + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(gp + a + s + l), this.ids = new this.IndexArrayType(this.data, gp, t), this.coords = new this.ArrayType(this.data, gp + s + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (TO << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error("Added ".concat(t, " items when expected ").concat(this.numItems, "."));
    return lL(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= s) {
        for (var y = d; y <= p; y++) {
          var f = a[2 * y], v = a[2 * y + 1];
          f >= t && f <= r && v >= n && v <= o && u.push(i[y]);
        }
        continue;
      }
      var g = d + p >> 1, E = a[2 * g], w = a[2 * g + 1];
      E >= t && E <= r && w >= n && w <= o && u.push(i[g]), (c === 0 ? t <= E : n <= w) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= E : o >= w) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, p = s.pop() || 0, d = s.pop() || 0;
      if (p - d <= a) {
        for (var y = d; y <= p; y++)
          y6(i[2 * y], i[2 * y + 1], t, n) <= u && l.push(o[y]);
        continue;
      }
      var f = d + p >> 1, v = i[2 * f], g = i[2 * f + 1];
      y6(v, g, t, n) <= u && l.push(o[f]), (c === 0 ? t - r <= v : n - r <= g) && (s.push(d), s.push(f - 1), s.push(1 - c)), (c === 0 ? t + r >= v : n + r >= g) && (s.push(f + 1), s.push(p), s.push(1 - c));
    }
    return l;
  }
}
function lL(e, t, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    RX(e, t, a, r, o, i), lL(e, t, n, r, a - 1, 1 - i), lL(e, t, n, a + 1, o, 1 - i);
  }
}
function RX(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), p = Math.max(r, Math.floor(n - s * u / a + c)), d = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      RX(e, t, n, p, d, i);
    }
    var y = t[2 * n + i], f = r, v = o;
    for (mp(e, t, r, n), t[2 * o + i] > y && mp(e, t, r, o); f < v; ) {
      for (mp(e, t, f, v), f++, v--; t[2 * f + i] < y; ) f++;
      for (; t[2 * v + i] > y; ) v--;
    }
    t[2 * r + i] === y ? mp(e, t, r, v) : (v++, mp(e, t, v, o)), v <= n && (r = v + 1), n <= v && (o = v - 1);
  }
}
function mp(e, t, n, r) {
  AO(e, n, r), AO(t, 2 * n, 2 * r), AO(t, 2 * n + 1, 2 * r + 1);
}
function AO(e, t, n) {
  var r = e[t];
  e[t] = e[n], e[n] = r;
}
function y6(e, t, n, r) {
  var o = e - n, i = t - r;
  return o * o + i * i;
}
var U6e = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, b6 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Kl = 2, Qa = 3, IO = 4, Ha = 5, FX = 6;
class W6e {
  constructor(t) {
    this.options = Object.assign(Object.create(U6e), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(t.length, " points");
    n && console.time(i), this.points = t;
    for (var a = [], s = 0; s < t.length; s++) {
      var l = t[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, p = b6(rm(u)), d = b6(om(c));
        a.push(
          p,
          d,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var y = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var f = o; f >= r; f--) {
      var v = +Date.now();
      y = this.trees[f] = this._createTree(this._cluster(y, f)), n && console.log("z%d: %d clusters in %dms", f, y.numItems, +Date.now() - v);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    var r = ((t[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, t[1])), i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(rm(r), om(a), rm(i), om(o)), p = u.data, d = [];
    for (var y of c) {
      var f = this.stride * y;
      d.push(p[f + Ha] > 1 ? w6(p, f, this.clusterProps) : this.points[p[f + Qa]]);
    }
    return d;
  }
  getChildren(t) {
    var n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), p = [];
    for (var d of c) {
      var y = d * this.stride;
      a[y + IO] === t && p.push(a[y + Ha] > 1 ? w6(a, y, this.clusterProps) : this.points[a[y + Qa]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    var o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, p), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, p), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, p), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    for (var n = this._getOriginZoom(t) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(s), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    for (var n = new CM(t.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, a) {
    for (var s of t) {
      var l = s * this.stride, u = n[l + Ha] > 1, c = void 0, p = void 0, d = void 0;
      if (u)
        c = zX(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        var y = this.points[n[l + Qa]];
        c = y.properties;
        var [f, v] = y.geometry.coordinates;
        p = rm(f), d = om(v);
      }
      var g = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (p * i - r)), Math.round(this.options.extent * (d * i - o))]],
        tags: c
      }, E = void 0;
      u || this.options.generateId ? E = n[l + Qa] : E = this.points[n[l + Qa]].id, E !== void 0 && (g.id = E), a.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride, p = 0; p < l.length; p += c)
      if (!(l[p + Kl] <= n)) {
        l[p + Kl] = n;
        var d = l[p], y = l[p + 1], f = t.within(l[p], l[p + 1], s), v = l[p + Ha], g = v;
        for (var E of f) {
          var w = E * c;
          l[w + Kl] > n && (g += l[w + Ha]);
        }
        if (g > v && g >= a) {
          var D = d * v, x = y * v, m = void 0, C = -1, S = ((p / c | 0) << 5) + (n + 1) + this.points.length;
          for (var z of f) {
            var L = z * c;
            if (!(l[L + Kl] <= n)) {
              l[L + Kl] = n;
              var R = l[L + Ha];
              D += l[L] * R, x += l[L + 1] * R, l[L + IO] = S, i && (m || (m = this._map(l, p, !0), C = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, L)));
            }
          }
          l[p + IO] = S, u.push(D / g, x / g, 1 / 0, S, -1, g), i && u.push(C);
        } else {
          for (var B = 0; B < c; B++) u.push(l[p + B]);
          if (g > 1)
            for (var H of f) {
              var V = H * c;
              if (!(l[V + Kl] <= n)) {
                l[V + Kl] = n;
                for (var W = 0; W < c; W++) u.push(l[V + W]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + Ha] > 1) {
      var o = this.clusterProps[t[n + FX]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[t[n + Qa]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function w6(e, t, n) {
  return {
    type: "Feature",
    id: e[t + Qa],
    properties: zX(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [$6e(e[t]), H6e(e[t + 1])]
    }
  };
}
function zX(e, t, n) {
  var r = e[t + Ha], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = e[t + FX], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: e[t + Qa],
    point_count: r,
    point_count_abbreviated: o
  });
}
function rm(e) {
  return e / 360 + 0.5;
}
function om(e) {
  var t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function $6e(e) {
  return (e - 0.5) * 360;
}
function H6e(e) {
  var t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function V6e(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
    t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Ri {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class uL {
  constructor(t) {
    var {
      markers: n,
      position: r
    } = t;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var t = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        t.extend(Ri.getPosition(n));
      return t;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Ri.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Ri.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Z6e {
  constructor(t) {
    var {
      maxZoom: n = 16
    } = t;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(t) {
    var {
      markers: n
    } = t;
    return q6e(n);
  }
}
var q6e = (e) => {
  var t = e.map((n) => new uL({
    position: Ri.getPosition(n),
    markers: [n]
  }));
  return t;
};
class K6e extends Z6e {
  constructor(t) {
    var {
      maxZoom: n,
      radius: r = 60
    } = t, o = V6e(t, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new W6e(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(t) {
    var n = !1, r = {
      zoom: t.map.getZoom()
    };
    if (!m6(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      var o = this.markers.map((i) => {
        var a = Ri.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !m6(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(t) {
    var {
      map: n
    } = t;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(t) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = t;
    if (o.cluster)
      return new uL({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new uL({
      markers: [i],
      position: Ri.getPosition(i)
    });
  }
}
class G6e {
  constructor(t, n) {
    this.markers = {
      sum: t.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class Y6e {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(t, n, r) {
    var {
      count: o,
      position: i
    } = t, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Ri.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), p = c.parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      var d = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    var y = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(y);
  }
}
function X6e(e, t) {
  for (var n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class OM {
  constructor() {
    X6e(OM, google.maps.OverlayView);
  }
}
var sd;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(sd || (sd = {}));
var J6e = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class Q6e extends OM {
  constructor(t) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new K6e(o),
      renderer: a = new Y6e(),
      onClusterClick: s = J6e
    } = t;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    var r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Ri.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    var r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, sd.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Ri.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Ri.setMap(l, null)));
      }
      google.maps.event.trigger(this, sd.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Ri.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    var t = new G6e(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Ri.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, sd.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Ri.setMap(r.marker, n);
    });
  }
}
function C6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function O6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? C6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : C6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function e9e(e) {
  var t = QVe(), [n, r] = P(null);
  return h(() => {
    if (t && n === null) {
      var o = new Q6e(O6(O6({}, e), {}, {
        map: t
      }));
      r(o);
    }
  }, [t]), n;
}
function t9e(e) {
  var {
    children: t,
    options: n
  } = e, r = e9e(n);
  return r !== null ? t(r) : null;
}
ve(t9e);
var x6 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, E6 = {
  options(e, t) {
    e.setOptions(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
function n9e(e) {
  var {
    children: t,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: p,
    onUnmount: d
  } = e, y = ge(Tt), [f, v] = P(null), [g, E] = P(null), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), R = dt(null);
  return h(() => {
    f !== null && (f.close(), n ? f.open(y, n) : f.getPosition() && f.open(y));
  }, [y, f, n]), h(() => {
    r && f !== null && f.setOptions(r);
  }, [f, r]), h(() => {
    o && f !== null && f.setPosition(o);
  }, [o]), h(() => {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), h(() => {
    f && a && (g !== null && google.maps.event.removeListener(g), E(google.maps.event.addListener(f, "closeclick", a)));
  }, [a]), h(() => {
    f && s && (w !== null && google.maps.event.removeListener(w), D(google.maps.event.addListener(f, "domready", s)));
  }, [s]), h(() => {
    f && l && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), h(() => {
    f && u && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), h(() => {
    f && c && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), h(() => {
    var B = new google.maps.InfoWindow(r);
    return v(B), R.current = document.createElement("div"), a && E(google.maps.event.addListener(B, "closeclick", a)), s && D(google.maps.event.addListener(B, "domready", s)), l && m(google.maps.event.addListener(B, "content_changed", l)), u && S(google.maps.event.addListener(B, "position_changed", u)), c && L(google.maps.event.addListener(B, "zindex_changed", c)), B.setContent(R.current), o && B.setPosition(o), i && B.setZIndex(i), n ? B.open(y, n) : B.getPosition() ? B.open(y) : Eo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(B), () => {
      g && google.maps.event.removeListener(g), x && google.maps.event.removeListener(x), w && google.maps.event.removeListener(w), C && google.maps.event.removeListener(C), z && google.maps.event.removeListener(z), d && d(B), B.close();
    };
  }, []), R.current ? sr(lt.only(t), R.current) : null;
}
ve(n9e);
class r9e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "containerElement", null), ye(this, "state", {
      infoWindow: null
    }), ye(this, "open", (t, n) => {
      n ? t.open(this.context, n) : t.getPosition() ? t.open(this.context) : Eo(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ye(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var t = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = qt({
      updaterMap: E6,
      eventMap: x6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(() => ({
      infoWindow: t
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(t) {
    this.state.infoWindow !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: E6,
      eventMap: x6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (tn(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? sr(lt.only(this.props.children), this.containerElement) : null;
  }
}
ye(r9e, "contextType", Tt);
function L6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function xy(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? L6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : L6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var P6 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, k6 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, o9e = {};
function i9e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onLoad: E,
    onUnmount: w
  } = e, D = ge(Tt), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null);
  return h(() => {
    x !== null && x.setMap(D);
  }, [D]), h(() => {
    typeof t < "u" && x !== null && x.setOptions(t);
  }, [x, t]), h(() => {
    typeof n < "u" && x !== null && x.setDraggable(n);
  }, [x, n]), h(() => {
    typeof r < "u" && x !== null && x.setEditable(r);
  }, [x, r]), h(() => {
    typeof o < "u" && x !== null && x.setVisible(o);
  }, [x, o]), h(() => {
    typeof i < "u" && x !== null && x.setPath(i);
  }, [x, i]), h(() => {
    x && a && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(x, "dblclick", a)));
  }, [a]), h(() => {
    x && s && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(x, "dragend", s)));
  }, [s]), h(() => {
    x && l && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(x, "dragstart", l)));
  }, [l]), h(() => {
    x && u && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(x, "mousedown", u)));
  }, [u]), h(() => {
    x && c && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(x, "mousemove", c)));
  }, [c]), h(() => {
    x && p && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(x, "mouseout", p)));
  }, [p]), h(() => {
    x && d && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(x, "mouseover", d)));
  }, [d]), h(() => {
    x && y && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(x, "mouseup", y)));
  }, [y]), h(() => {
    x && f && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(x, "rightclick", f)));
  }, [f]), h(() => {
    x && v && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(x, "click", v)));
  }, [v]), h(() => {
    x && g && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(x, "drag", g)));
  }, [g]), h(() => {
    var T = new google.maps.Polyline(xy(xy({}, t || o9e), {}, {
      map: D
    }));
    return i && T.setPath(i), typeof o < "u" && T.setVisible(o), typeof r < "u" && T.setEditable(r), typeof n < "u" && T.setDraggable(n), a && S(google.maps.event.addListener(T, "dblclick", a)), s && L(google.maps.event.addListener(T, "dragend", s)), l && B(google.maps.event.addListener(T, "dragstart", l)), u && V(google.maps.event.addListener(T, "mousedown", u)), c && q(google.maps.event.addListener(T, "mousemove", c)), p && X(google.maps.event.addListener(T, "mouseout", p)), d && J(google.maps.event.addListener(T, "mouseover", d)), y && _(google.maps.event.addListener(T, "mouseup", y)), f && M(google.maps.event.addListener(T, "rightclick", f)), v && O(google.maps.event.addListener(T, "click", v)), g && F(google.maps.event.addListener(T, "drag", g)), m(T), E && E(T), () => {
      C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), w && w(T), T.setMap(null);
    };
  }, []), null;
}
ve(i9e);
class s9e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      polyline: null
    }), ye(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var t = new google.maps.Polyline(xy(xy({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = qt({
      updaterMap: k6,
      eventMap: P6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        polyline: t
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(t) {
    this.state.polyline !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: k6,
      eventMap: P6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), tn(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ye(s9e, "contextType", Tt);
function S6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function M6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? S6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : S6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var D6 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, _6 = {
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  path(e, t) {
    e.setPath(t);
  },
  paths(e, t) {
    e.setPaths(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function a9e(e) {
  var {
    options: t,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onLoad: w,
    onUnmount: D,
    onEdit: x
  } = e, m = ge(Tt), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    C !== null && C.setMap(m);
  }, [m]), h(() => {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), h(() => {
    typeof n < "u" && C !== null && C.setDraggable(n);
  }, [C, n]), h(() => {
    typeof r < "u" && C !== null && C.setEditable(r);
  }, [C, r]), h(() => {
    typeof o < "u" && C !== null && C.setVisible(o);
  }, [C, o]), h(() => {
    typeof i < "u" && C !== null && C.setPath(i);
  }, [C, i]), h(() => {
    typeof a < "u" && C !== null && C.setPaths(a);
  }, [C, a]), h(() => {
    C && typeof s == "function" && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), h(() => {
    C && (google.maps.event.addListener(C.getPath(), "insert_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "set_at", () => {
      x == null || x(C);
    }), google.maps.event.addListener(C.getPath(), "remove_at", () => {
      x == null || x(C);
    }));
  }, [C, x]), h(() => {
    C && typeof l == "function" && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(C, "dragend", l)));
  }, [l]), h(() => {
    C && typeof u == "function" && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(C, "dragstart", u)));
  }, [u]), h(() => {
    C && typeof c == "function" && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(C, "mousedown", c)));
  }, [c]), h(() => {
    C && typeof p == "function" && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(C, "mousemove", p)));
  }, [p]), h(() => {
    C && typeof d == "function" && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(C, "mouseout", d)));
  }, [d]), h(() => {
    C && typeof y == "function" && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(C, "mouseover", y)));
  }, [y]), h(() => {
    C && typeof f == "function" && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(C, "mouseup", f)));
  }, [f]), h(() => {
    C && typeof v == "function" && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(C, "rightclick", v)));
  }, [v]), h(() => {
    C && typeof g == "function" && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(C, "click", g)));
  }, [g]), h(() => {
    C && typeof E == "function" && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(C, "drag", E)));
  }, [E]), h(() => {
    var A = new google.maps.Polygon(M6(M6({}, t), {}, {
      map: m
    }));
    return i && A.setPath(i), a && A.setPaths(a), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), s && L(google.maps.event.addListener(A, "dblclick", s)), l && B(google.maps.event.addListener(A, "dragend", l)), u && V(google.maps.event.addListener(A, "dragstart", u)), c && q(google.maps.event.addListener(A, "mousedown", c)), p && X(google.maps.event.addListener(A, "mousemove", p)), d && J(google.maps.event.addListener(A, "mouseout", d)), y && _(google.maps.event.addListener(A, "mouseover", y)), f && M(google.maps.event.addListener(A, "mouseup", f)), v && O(google.maps.event.addListener(A, "rightclick", v)), g && F(google.maps.event.addListener(A, "click", g)), E && Z(google.maps.event.addListener(A, "drag", E)), S(A), w && w(A), () => {
      z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), D && D(A), A.setMap(null);
    };
  }, []), null;
}
ve(a9e);
class l9e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []);
  }
  componentDidMount() {
    var t = this.props.options || {};
    this.polygon = new google.maps.Polygon(t), this.polygon.setMap(this.context), this.registeredEvents = qt({
      updaterMap: _6,
      eventMap: D6,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(t) {
    this.polygon && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: _6,
      eventMap: D6,
      prevProps: t,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), tn(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ye(l9e, "contextType", Tt);
function j6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ey(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? j6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : j6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var T6 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, A6 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
};
function u9e(e) {
  var {
    options: t,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: p,
    onMouseOver: d,
    onMouseUp: y,
    onRightClick: f,
    onClick: v,
    onDrag: g,
    onBoundsChanged: E,
    onLoad: w,
    onUnmount: D
  } = e, x = ge(Tt), [m, C] = P(null), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null);
  return h(() => {
    m !== null && m.setMap(x);
  }, [x]), h(() => {
    typeof t < "u" && m !== null && m.setOptions(t);
  }, [m, t]), h(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), h(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), h(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), h(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), h(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), z(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), h(() => {
    m && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), h(() => {
    m && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), h(() => {
    m && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), h(() => {
    m && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), h(() => {
    m && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(m, "mouseout", p)));
  }, [p]), h(() => {
    m && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(m, "mouseover", d)));
  }, [d]), h(() => {
    m && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(m, "mouseup", y)));
  }, [y]), h(() => {
    m && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(m, "rightclick", f)));
  }, [f]), h(() => {
    m && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(m, "click", v)));
  }, [v]), h(() => {
    m && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(m, "drag", g)));
  }, [g]), h(() => {
    m && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(m, "bounds_changed", E)));
  }, [E]), h(() => {
    var G = new google.maps.Rectangle(Ey(Ey({}, t), {}, {
      map: x
    }));
    return typeof i < "u" && G.setVisible(i), typeof o < "u" && G.setEditable(o), typeof r < "u" && G.setDraggable(r), typeof n < "u" && G.setBounds(n), a && z(google.maps.event.addListener(G, "dblclick", a)), s && R(google.maps.event.addListener(G, "dragend", s)), l && H(google.maps.event.addListener(G, "dragstart", l)), u && W(google.maps.event.addListener(G, "mousedown", u)), c && Y(google.maps.event.addListener(G, "mousemove", c)), p && ee(google.maps.event.addListener(G, "mouseout", p)), d && k(google.maps.event.addListener(G, "mouseover", d)), y && U(google.maps.event.addListener(G, "mouseup", y)), f && $(google.maps.event.addListener(G, "rightclick", f)), v && j(google.maps.event.addListener(G, "click", v)), g && T(google.maps.event.addListener(G, "drag", g)), E && A(google.maps.event.addListener(G, "bounds_changed", E)), C(G), w && w(G), () => {
      S !== null && google.maps.event.removeListener(S), L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), Z !== null && google.maps.event.removeListener(Z), D && D(G), G.setMap(null);
    };
  }, []), null;
}
ve(u9e);
class c9e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      rectangle: null
    }), ye(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Rectangle(Ey(Ey({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = qt({
      updaterMap: A6,
      eventMap: T6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        rectangle: t
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(t) {
    this.state.rectangle !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: A6,
      eventMap: T6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), tn(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ye(c9e, "contextType", Tt);
function I6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ly(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? I6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : I6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var B6 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, N6 = {
  center(e, t) {
    e.setCenter(t);
  },
  draggable(e, t) {
    e.setDraggable(t);
  },
  editable(e, t) {
    e.setEditable(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  radius(e, t) {
    e.setRadius(t);
  },
  visible(e, t) {
    e.setVisible(t);
  }
}, p9e = {};
function d9e(e) {
  var {
    options: t,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: p,
    onMouseOut: d,
    onMouseOver: y,
    onMouseUp: f,
    onRightClick: v,
    onClick: g,
    onDrag: E,
    onCenterChanged: w,
    onRadiusChanged: D,
    onLoad: x,
    onUnmount: m
  } = e, C = ge(Tt), [S, z] = P(null), [L, R] = P(null), [B, H] = P(null), [V, W] = P(null), [q, Y] = P(null), [X, ee] = P(null), [J, k] = P(null), [_, U] = P(null), [M, $] = P(null), [O, j] = P(null), [F, T] = P(null), [Z, A] = P(null), [G, N] = P(null), [ue, fe] = P(null);
  return h(() => {
    S !== null && S.setMap(C);
  }, [C]), h(() => {
    typeof t < "u" && S !== null && S.setOptions(t);
  }, [S, t]), h(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), h(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), h(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), h(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), h(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), h(() => {
    S && s && (L !== null && google.maps.event.removeListener(L), R(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), h(() => {
    S && l && (B !== null && google.maps.event.removeListener(B), H(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), h(() => {
    S && u && (V !== null && google.maps.event.removeListener(V), W(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), h(() => {
    S && c && (q !== null && google.maps.event.removeListener(q), Y(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), h(() => {
    S && p && (X !== null && google.maps.event.removeListener(X), ee(google.maps.event.addListener(S, "mousemove", p)));
  }, [p]), h(() => {
    S && d && (J !== null && google.maps.event.removeListener(J), k(google.maps.event.addListener(S, "mouseout", d)));
  }, [d]), h(() => {
    S && y && (_ !== null && google.maps.event.removeListener(_), U(google.maps.event.addListener(S, "mouseover", y)));
  }, [y]), h(() => {
    S && f && (M !== null && google.maps.event.removeListener(M), $(google.maps.event.addListener(S, "mouseup", f)));
  }, [f]), h(() => {
    S && v && (O !== null && google.maps.event.removeListener(O), j(google.maps.event.addListener(S, "rightclick", v)));
  }, [v]), h(() => {
    S && g && (F !== null && google.maps.event.removeListener(F), T(google.maps.event.addListener(S, "click", g)));
  }, [g]), h(() => {
    S && E && (Z !== null && google.maps.event.removeListener(Z), A(google.maps.event.addListener(S, "drag", E)));
  }, [E]), h(() => {
    S && w && (G !== null && google.maps.event.removeListener(G), N(google.maps.event.addListener(S, "center_changed", w)));
  }, [g]), h(() => {
    S && D && (ue !== null && google.maps.event.removeListener(ue), fe(google.maps.event.addListener(S, "radius_changed", D)));
  }, [D]), h(() => {
    var oe = new google.maps.Circle(Ly(Ly({}, t || p9e), {}, {
      map: C
    }));
    return typeof r == "number" && oe.setRadius(r), typeof n < "u" && oe.setCenter(n), typeof r == "number" && oe.setRadius(r), typeof a < "u" && oe.setVisible(a), typeof i < "u" && oe.setEditable(i), typeof o < "u" && oe.setDraggable(o), s && R(google.maps.event.addListener(oe, "dblclick", s)), l && H(google.maps.event.addListener(oe, "dragend", l)), u && W(google.maps.event.addListener(oe, "dragstart", u)), c && Y(google.maps.event.addListener(oe, "mousedown", c)), p && ee(google.maps.event.addListener(oe, "mousemove", p)), d && k(google.maps.event.addListener(oe, "mouseout", d)), y && U(google.maps.event.addListener(oe, "mouseover", y)), f && $(google.maps.event.addListener(oe, "mouseup", f)), v && j(google.maps.event.addListener(oe, "rightclick", v)), g && T(google.maps.event.addListener(oe, "click", g)), E && A(google.maps.event.addListener(oe, "drag", E)), w && N(google.maps.event.addListener(oe, "center_changed", w)), D && fe(google.maps.event.addListener(oe, "radius_changed", D)), z(oe), x && x(oe), () => {
      L !== null && google.maps.event.removeListener(L), B !== null && google.maps.event.removeListener(B), V !== null && google.maps.event.removeListener(V), q !== null && google.maps.event.removeListener(q), X !== null && google.maps.event.removeListener(X), J !== null && google.maps.event.removeListener(J), _ !== null && google.maps.event.removeListener(_), M !== null && google.maps.event.removeListener(M), O !== null && google.maps.event.removeListener(O), F !== null && google.maps.event.removeListener(F), G !== null && google.maps.event.removeListener(G), ue !== null && google.maps.event.removeListener(ue), m && m(oe), oe.setMap(null);
    };
  }, []), null;
}
ve(d9e);
class f9e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      circle: null
    }), ye(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var t = new google.maps.Circle(Ly(Ly({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = qt({
      updaterMap: N6,
      eventMap: B6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        circle: t
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(t) {
    this.state.circle !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: N6,
      eventMap: B6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var t;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), tn(this.registeredEvents), (t = this.state.circle) === null || t === void 0 || t.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ye(f9e, "contextType", Tt);
function R6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Py(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? R6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : R6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var F6 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, z6 = {
  add(e, t) {
    e.add(t);
  },
  addgeojson(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains(e, t) {
    e.contains(t);
  },
  foreach(e, t) {
    e.forEach(t);
  },
  loadgeojson(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove(e, t) {
    e.remove(t);
  },
  revertstyle(e, t) {
    e.revertStyle(t);
  },
  controlposition(e, t) {
    e.setControlPosition(t);
  },
  controls(e, t) {
    e.setControls(t);
  },
  drawingmode(e, t) {
    e.setDrawingMode(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  style(e, t) {
    e.setStyle(t);
  },
  togeojson(e, t) {
    e.toGeoJson(t);
  }
};
function h9e(e) {
  var {
    options: t,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: p,
    onRemoveProperty: d,
    onSetGeometry: y,
    onSetProperty: f,
    onLoad: v,
    onUnmount: g
  } = e, E = ge(Tt), [w, D] = P(null), [x, m] = P(null), [C, S] = P(null), [z, L] = P(null), [R, B] = P(null), [H, V] = P(null), [W, q] = P(null), [Y, X] = P(null), [ee, J] = P(null), [k, _] = P(null), [U, M] = P(null), [$, O] = P(null), [j, F] = P(null), [T, Z] = P(null);
  return h(() => {
    w !== null && w.setMap(E);
  }, [E]), h(() => {
    w && r && (x !== null && google.maps.event.removeListener(x), m(google.maps.event.addListener(w, "dblclick", r)));
  }, [r]), h(() => {
    w && o && (C !== null && google.maps.event.removeListener(C), S(google.maps.event.addListener(w, "mousedown", o)));
  }, [o]), h(() => {
    w && i && (z !== null && google.maps.event.removeListener(z), L(google.maps.event.addListener(w, "mousemove", i)));
  }, [i]), h(() => {
    w && a && (R !== null && google.maps.event.removeListener(R), B(google.maps.event.addListener(w, "mouseout", a)));
  }, [a]), h(() => {
    w && s && (H !== null && google.maps.event.removeListener(H), V(google.maps.event.addListener(w, "mouseover", s)));
  }, [s]), h(() => {
    w && l && (W !== null && google.maps.event.removeListener(W), q(google.maps.event.addListener(w, "mouseup", l)));
  }, [l]), h(() => {
    w && u && (Y !== null && google.maps.event.removeListener(Y), X(google.maps.event.addListener(w, "rightclick", u)));
  }, [u]), h(() => {
    w && n && (ee !== null && google.maps.event.removeListener(ee), J(google.maps.event.addListener(w, "click", n)));
  }, [n]), h(() => {
    w && c && (k !== null && google.maps.event.removeListener(k), _(google.maps.event.addListener(w, "addfeature", c)));
  }, [c]), h(() => {
    w && p && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(w, "removefeature", p)));
  }, [p]), h(() => {
    w && d && ($ !== null && google.maps.event.removeListener($), O(google.maps.event.addListener(w, "removeproperty", d)));
  }, [d]), h(() => {
    w && y && (j !== null && google.maps.event.removeListener(j), F(google.maps.event.addListener(w, "setgeometry", y)));
  }, [y]), h(() => {
    w && f && (T !== null && google.maps.event.removeListener(T), Z(google.maps.event.addListener(w, "setproperty", f)));
  }, [f]), h(() => {
    if (E !== null) {
      var A = new google.maps.Data(Py(Py({}, t), {}, {
        map: E
      }));
      r && m(google.maps.event.addListener(A, "dblclick", r)), o && S(google.maps.event.addListener(A, "mousedown", o)), i && L(google.maps.event.addListener(A, "mousemove", i)), a && B(google.maps.event.addListener(A, "mouseout", a)), s && V(google.maps.event.addListener(A, "mouseover", s)), l && q(google.maps.event.addListener(A, "mouseup", l)), u && X(google.maps.event.addListener(A, "rightclick", u)), n && J(google.maps.event.addListener(A, "click", n)), c && _(google.maps.event.addListener(A, "addfeature", c)), p && M(google.maps.event.addListener(A, "removefeature", p)), d && O(google.maps.event.addListener(A, "removeproperty", d)), y && F(google.maps.event.addListener(A, "setgeometry", y)), f && Z(google.maps.event.addListener(A, "setproperty", f)), D(A), v && v(A);
    }
    return () => {
      w && (x !== null && google.maps.event.removeListener(x), C !== null && google.maps.event.removeListener(C), z !== null && google.maps.event.removeListener(z), R !== null && google.maps.event.removeListener(R), H !== null && google.maps.event.removeListener(H), W !== null && google.maps.event.removeListener(W), Y !== null && google.maps.event.removeListener(Y), ee !== null && google.maps.event.removeListener(ee), k !== null && google.maps.event.removeListener(k), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), j !== null && google.maps.event.removeListener(j), T !== null && google.maps.event.removeListener(T), g && g(w), w.setMap(null));
    };
  }, []), null;
}
ve(h9e);
class g9e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      data: null
    }), ye(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var t = new google.maps.Data(Py(Py({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = qt({
        updaterMap: z6,
        eventMap: F6,
        prevProps: {},
        nextProps: this.props,
        instance: t
      }), this.setState(() => ({
        data: t
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(t) {
    this.state.data !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: z6,
      eventMap: F6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), tn(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ye(g9e, "contextType", Tt);
function U6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function W6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? U6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : U6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var $6 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, H6 = {
  options(e, t) {
    e.setOptions(t);
  },
  url(e, t) {
    e.setUrl(t);
  },
  zIndex(e, t) {
    e.setZIndex(t);
  }
};
class m9e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      kmlLayer: null
    }), ye(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var t = new google.maps.KmlLayer(W6(W6({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = qt({
      updaterMap: H6,
      eventMap: $6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        kmlLayer: t
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(t) {
    this.state.kmlLayer !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: H6,
      eventMap: $6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), tn(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ye(m9e, "contextType", Tt);
function UX(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function v9e(e, t) {
  return new t(e.lat, e.lng);
}
function y9e(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function b9e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function w9e(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function C9e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function O9e(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function WX(e, t, n, r) {
  return n !== void 0 ? C9e(e, t, w9e(n, google.maps.LatLngBounds, y9e)) : O9e(e, t, b9e(r, google.maps.LatLng, v9e));
}
function x9e(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function V6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function E9e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? V6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : V6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function L9e(e, t, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = E9e({}, this.container ? UX(this.container, o) : {
        x: 0,
        y: 0
      }), u = WX(s, l, this.bounds, this.position);
      for (var [c, p] of Object.entries(u))
        this.container.style[c] = p;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(e, t, n, r);
}
function Z6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function P9e(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Z6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Z6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
function q6(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function K6(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function k9e(e) {
  var {
    position: t,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = e, u = ge(Tt), c = On(() => {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = On(() => L9e(c, r, t, n, s), [c, r, t, n]);
  return h(() => (i == null || i(p), p == null || p.setMap(u), () => {
    a == null || a(p), p == null || p.setMap(null);
  }), [u, p]), h(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), yi.createPortal(l, c);
}
ve(k9e);
class jc extends pe {
  constructor(t) {
    super(t), ye(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ye(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Eo(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ye(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ye(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = P9e({
        x: 0,
        y: 0
      }, this.containerRef.current ? UX(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = WX(r, o, this.props.bounds, this.props.position);
      if (!x9e(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ye(this, "draw", () => {
      this.onPositionElement();
    }), ye(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = ir();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(t) {
    var n = q6(t.position), r = q6(this.props.position), o = K6(t.bounds), i = K6(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), t.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var t = this.state.paneEl;
    return t ? yi.createPortal(te.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: lt.only(this.props.children)
    }), t) : null;
  }
}
ye(jc, "FLOAT_PANE", "floatPane");
ye(jc, "MAP_PANE", "mapPane");
ye(jc, "MARKER_LAYER", "markerLayer");
ye(jc, "OVERLAY_LAYER", "overlayLayer");
ye(jc, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ye(jc, "contextType", Tt);
function S9e() {
}
function G6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Y6(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? G6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : G6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var X6 = {
  onDblClick: "dblclick",
  onClick: "click"
}, J6 = {
  opacity(e, t) {
    e.setOpacity(t);
  }
};
function M9e(e) {
  var {
    url: t,
    bounds: n,
    options: r,
    visible: o
  } = e, i = ge(Tt), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = On(() => new google.maps.GroundOverlay(t, a, r), []);
  return h(() => {
    s !== null && s.setMap(i);
  }, [i]), h(() => {
    typeof t < "u" && s !== null && (s.set("url", t), s.setMap(i));
  }, [s, t]), h(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), h(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
ve(M9e);
class $X extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      groundOverlay: null
    }), ye(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Eo(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var t = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Y6(Y6({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = qt({
      updaterMap: J6,
      eventMap: X6,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        groundOverlay: t
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(t) {
    this.state.groundOverlay !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: J6,
      eventMap: X6,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ye($X, "defaultProps", {
  onLoad: S9e
});
ye($X, "contextType", Tt);
function Q6(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ky(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Q6(Object(n), !0).forEach(function(r) {
      ye(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Q6(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var e9 = {}, t9 = {
  data(e, t) {
    e.setData(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  }
};
function D9e(e) {
  var {
    data: t,
    onLoad: n,
    onUnmount: r,
    options: o
  } = e, i = ge(Tt), [a, s] = P(null);
  return h(() => {
    google.maps.visualization || Eo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), h(() => {
    Eo(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), h(() => {
    a !== null && a.setMap(i);
  }, [i]), h(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), h(() => {
    var l = new google.maps.visualization.HeatmapLayer(ky(ky({}, o), {}, {
      data: t,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
ve(D9e);
class _9e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      heatmapLayer: null
    }), ye(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Eo(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Eo(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var t = new google.maps.visualization.HeatmapLayer(ky(ky({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = qt({
      updaterMap: t9,
      eventMap: e9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        heatmapLayer: t
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(t) {
    tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: t9,
      eventMap: e9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), tn(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ye(_9e, "contextType", Tt);
var n9 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, r9 = {
  register(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links(e, t) {
    e.setLinks(t);
  },
  motionTracking(e, t) {
    e.setMotionTracking(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  pano(e, t) {
    e.setPano(t);
  },
  position(e, t) {
    e.setPosition(t);
  },
  pov(e, t) {
    e.setPov(t);
  },
  visible(e, t) {
    e.setVisible(t);
  },
  zoom(e, t) {
    e.setZoom(t);
  }
};
class j9e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      streetViewPanorama: null
    }), ye(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var t, n, r = (t = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && t !== void 0 ? t : null;
    this.registeredEvents = qt({
      updaterMap: r9,
      eventMap: n9,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(t) {
    this.state.streetViewPanorama !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: r9,
      eventMap: n9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), tn(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ye(j9e, "contextType", Tt);
class T9e extends pe {
  constructor() {
    super(...arguments), ye(this, "state", {
      streetViewService: null
    }), ye(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var t = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: t
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ye(T9e, "contextType", Tt);
var o9 = {
  onDirectionsChanged: "directions_changed"
}, i9 = {
  directions(e, t) {
    e.setDirections(t);
  },
  map(e, t) {
    e.setMap(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  panel(e, t) {
    e.setPanel(t);
  },
  routeIndex(e, t) {
    e.setRouteIndex(t);
  }
};
class A9e extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "state", {
      directionsRenderer: null
    }), ye(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var t = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = qt({
      updaterMap: i9,
      eventMap: o9,
      prevProps: {},
      nextProps: this.props,
      instance: t
    }), this.setState(function() {
      return {
        directionsRenderer: t
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(t) {
    this.state.directionsRenderer !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: i9,
      eventMap: o9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), tn(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ye(A9e, "contextType", Tt);
var s9 = {
  onPlacesChanged: "places_changed"
}, a9 = {
  bounds(e, t) {
    e.setBounds(t);
  }
};
class HX extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "containerElement", ir()), ye(this, "state", {
      searchBox: null
    }), ye(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Eo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var t = this.containerElement.current.querySelector("input");
      if (t !== null) {
        var n = new google.maps.places.SearchBox(t, this.props.options);
        this.registeredEvents = qt({
          updaterMap: a9,
          eventMap: s9,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(t) {
    this.state.searchBox !== null && (tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: a9,
      eventMap: s9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), tn(this.registeredEvents));
  }
  render() {
    return te.jsx("div", {
      ref: this.containerElement,
      children: lt.only(this.props.children)
    });
  }
}
ye(HX, "contextType", Tt);
var l9 = {
  onPlaceChanged: "place_changed"
}, u9 = {
  bounds(e, t) {
    e.setBounds(t);
  },
  restrictions(e, t) {
    e.setComponentRestrictions(t);
  },
  fields(e, t) {
    e.setFields(t);
  },
  options(e, t) {
    e.setOptions(t);
  },
  types(e, t) {
    e.setTypes(t);
  }
};
class VX extends pe {
  constructor() {
    super(...arguments), ye(this, "registeredEvents", []), ye(this, "containerElement", ir()), ye(this, "state", {
      autocomplete: null
    }), ye(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var t;
    Eo(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (t = this.containerElement.current) === null || t === void 0 ? void 0 : t.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = qt({
        updaterMap: u9,
        eventMap: l9,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(t) {
    tn(this.registeredEvents), this.registeredEvents = qt({
      updaterMap: u9,
      eventMap: l9,
      prevProps: t,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && tn(this.registeredEvents);
  }
  render() {
    return te.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: lt.only(this.props.children)
    });
  }
}
ye(VX, "defaultProps", {
  className: ""
});
ye(VX, "contextType", Tt);
function b5e({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ te.jsx(
    AX,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function w5e(e) {
  const { children: t = !1 } = e, [n, r] = P([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((p) => p.key === u)) == null ? void 0 : c.data;
  }
  function a(u, c) {
    const p = o(u);
    r(p ? (d) => [...d.filter((f) => f.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function s(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ te.jsx(
    bM.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: a, closeModal: s, closeAll: l },
      children: t
    }
  );
}
let I9e = { data: "" }, B9e = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || I9e, N9e = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, R9e = /\/\*[^]*?\*\/|  +/g, c9 = /\n+/g, sl = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let a = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? sl(a, i) : i + "{" + sl(a, i[1] == "k" ? "" : t) + "}" : typeof a == "object" ? r += sl(a, t ? t.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += sl.p ? sl.p(i, a) : i + ":" + a + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Qs = {}, ZX = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + ZX(e[n]);
    return t;
  }
  return e;
}, F9e = (e, t, n, r, o) => {
  let i = ZX(e), a = Qs[i] || (Qs[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Qs[a]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = N9e.exec(u.replace(R9e, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(c9, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(c9, " ").trim();
      return d[0];
    })(e);
    Qs[a] = sl(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Qs.g ? Qs.g : null;
  return n && (Qs.g = Qs[a]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Qs[a], t, r, s), a;
}, z9e = (e, t, n) => e.reduce((r, o, i) => {
  let a = t[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : sl(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function vw(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return F9e(n.unshift ? n.raw ? z9e(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, B9e(t.target), t.g, t.o, t.k);
}
let qX, cL, pL;
vw.bind({ g: 1 });
let ha = vw.bind({ k: 1 });
function U9e(e, t, n, r) {
  sl.p = t, qX = e, cL = n, pL = r;
}
function Tl(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: cL && cL() }, s), n.o = / *go\d+/.test(l), s.className = vw.apply(n, r) + (l ? " " + l : "");
      let u = e;
      return e[0] && (u = s.as || e, delete s.as), pL && u[0] && pL(s), qX(u, s);
    }
    return o;
  };
}
var W9e = (e) => typeof e == "function", Sy = (e, t) => W9e(e) ? e(t) : e, $9e = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), KX = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), H9e = 20, ym = /* @__PURE__ */ new Map(), V9e = 1e3, p9 = (e) => {
  if (ym.has(e)) return;
  let t = setTimeout(() => {
    ym.delete(e), Hu({ type: 4, toastId: e });
  }, V9e);
  ym.set(e, t);
}, Z9e = (e) => {
  let t = ym.get(e);
  t && clearTimeout(t);
}, dL = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, H9e) };
    case 1:
      return t.toast.id && Z9e(t.toast.id), { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return e.toasts.find((i) => i.id === n.id) ? dL(e, { type: 1, toast: n }) : dL(e, { type: 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return r ? p9(r) : e.toasts.forEach((i) => {
        p9(i.id);
      }), { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, bm = [], wm = { toasts: [], pausedAt: void 0 }, Hu = (e) => {
  wm = dL(wm, e), bm.forEach((t) => {
    t(wm);
  });
}, q9e = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, K9e = (e = {}) => {
  let [t, n] = P(wm);
  h(() => (bm.push(n), () => {
    let o = bm.indexOf(n);
    o > -1 && bm.splice(o, 1);
  }), [t]);
  let r = t.toasts.map((o) => {
    var i, a;
    return { ...e, ...e[o.type], ...o, duration: o.duration || ((i = e[o.type]) == null ? void 0 : i.duration) || (e == null ? void 0 : e.duration) || q9e[o.type], style: { ...e.style, ...(a = e[o.type]) == null ? void 0 : a.style, ...o.style } };
  });
  return { ...t, toasts: r };
}, G9e = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || $9e() }), Kf = (e) => (t, n) => {
  let r = G9e(t, e, n);
  return Hu({ type: 2, toast: r }), r.id;
}, Fi = (e, t) => Kf("blank")(e, t);
Fi.error = Kf("error");
Fi.success = Kf("success");
Fi.loading = Kf("loading");
Fi.custom = Kf("custom");
Fi.dismiss = (e) => {
  Hu({ type: 3, toastId: e });
};
Fi.remove = (e) => Hu({ type: 4, toastId: e });
Fi.promise = (e, t, n) => {
  let r = Fi.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return e.then((o) => (Fi.success(Sy(t.success, o), { id: r, ...n, ...n == null ? void 0 : n.success }), o)).catch((o) => {
    Fi.error(Sy(t.error, o), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), e;
};
var Y9e = (e, t) => {
  Hu({ type: 1, toast: { id: e, height: t } });
}, X9e = () => {
  Hu({ type: 5, time: Date.now() });
}, J9e = (e) => {
  let { toasts: t, pausedAt: n } = K9e(e);
  h(() => {
    if (n) return;
    let i = Date.now(), a = t.map((s) => {
      if (s.duration === 1 / 0) return;
      let l = (s.duration || 0) + s.pauseDuration - (i - s.createdAt);
      if (l < 0) {
        s.visible && Fi.dismiss(s.id);
        return;
      }
      return setTimeout(() => Fi.dismiss(s.id), l);
    });
    return () => {
      a.forEach((s) => s && clearTimeout(s));
    };
  }, [t, n]);
  let r = Rn(() => {
    n && Hu({ type: 6, time: Date.now() });
  }, [n]), o = Rn((i, a) => {
    let { reverseOrder: s = !1, gutter: l = 8, defaultPosition: u } = a || {}, c = t.filter((y) => (y.position || u) === (i.position || u) && y.height), p = c.findIndex((y) => y.id === i.id), d = c.filter((y, f) => f < p && y.visible).length;
    return c.filter((y) => y.visible).slice(...s ? [d + 1] : [0, d]).reduce((y, f) => y + (f.height || 0) + l, 0);
  }, [t]);
  return { toasts: t, handlers: { updateHeight: Y9e, startPause: X9e, endPause: r, calculateOffset: o } };
}, Q9e = ha`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, e8e = ha`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, t8e = ha`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, n8e = Tl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${Q9e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${e8e} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${t8e} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, r8e = ha`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, o8e = Tl("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${r8e} 1s linear infinite;
`, i8e = ha`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, s8e = ha`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, a8e = Tl("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${i8e} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${s8e} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, l8e = Tl("div")`
  position: absolute;
`, u8e = Tl("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, c8e = ha`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, p8e = Tl("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${c8e} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, d8e = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Re.createElement(p8e, null, t) : t : n === "blank" ? null : Re.createElement(u8e, null, Re.createElement(o8e, { ...r }), n !== "loading" && Re.createElement(l8e, null, n === "error" ? Re.createElement(n8e, { ...r }) : Re.createElement(a8e, { ...r })));
}, f8e = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, h8e = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, g8e = "0%{opacity:0;} 100%{opacity:1;}", m8e = "0%{opacity:1;} 100%{opacity:0;}", v8e = Tl("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, y8e = Tl("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, b8e = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = KX() ? [g8e, m8e] : [f8e(n), h8e(n)];
  return { animation: t ? `${ha(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${ha(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, w8e = Re.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? b8e(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Re.createElement(d8e, { toast: e }), a = Re.createElement(y8e, { ...e.ariaProps }, Sy(e.message, e));
  return Re.createElement(v8e, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: a }) : Re.createElement(Re.Fragment, null, i, a));
});
U9e(Re.createElement);
var C8e = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = Re.useCallback((a) => {
    if (a) {
      let s = () => {
        let l = a.getBoundingClientRect().height;
        r(e, l);
      };
      s(), new MutationObserver(s).observe(a, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return Re.createElement("div", { ref: i, className: t, style: n }, o);
}, O8e = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: KX() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, x8e = vw`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, im = 16, E8e = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: a }) => {
  let { toasts: s, handlers: l } = J9e(n);
  return Re.createElement("div", { style: { position: "fixed", zIndex: 9999, top: im, left: im, right: im, bottom: im, pointerEvents: "none", ...i }, className: a, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, s.map((u) => {
    let c = u.position || t, p = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), d = O8e(c, p);
    return Re.createElement(C8e, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? x8e : "", style: d }, u.type === "custom" ? Sy(u.message, u) : o ? o(u) : Re.createElement(w8e, { toast: u, position: c }));
  }));
}, d9 = Fi;
function C5e({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return d9.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return d9.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ te.jsxs(PX.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ te.jsx(
      E8e,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
function L8e({ children: e, fallback: t = null }) {
  return KVe() ? /* @__PURE__ */ te.jsx(te.Fragment, { children: e() }) : /* @__PURE__ */ te.jsx(te.Fragment, { children: t });
}
function O5e({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ te.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ te.jsx(
    s6e,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ te.jsx(IX, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ te.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ te.jsx(mJ, {}) });
}
function x5e({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = P(null), a = (l) => i(l), s = () => {
    var y, f, v, g;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function p(E) {
      const w = c.find((D) => D.types[0] === E);
      return w ? w.long_name : "";
    }
    function d(E) {
      const w = c.find((D) => D.types[0] === E);
      return w ? w.short_name : "";
    }
    if (u) {
      const E = p("route"), w = p("street_number"), D = p("sublocality_level_1"), x = p("administrative_area_level_2"), m = p("administrative_area_level_1"), C = d("administrative_area_level_1"), S = p("postal_code"), z = (f = (y = u.geometry) == null ? void 0 : y.location) == null ? void 0 : f.lat(), L = (g = (v = u.geometry) == null ? void 0 : v.location) == null ? void 0 : g.lng();
      t && t({
        street: E,
        city: x,
        state: m,
        district: D,
        cep: S,
        streetNumber: w,
        stateShortName: C,
        coordinates: { lat: z, lng: L }
      });
    }
  };
  return /* @__PURE__ */ te.jsx(
    HX,
    {
      onLoad: a,
      onPlacesChanged: s,
      options: n,
      children: /* @__PURE__ */ te.jsx(sw, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function GX(e) {
  const { dataLayer: t, dataLayerName: n } = e;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(t)})`;
}
function P8e(e) {
  const { id: t, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: a } = e, s = `&gtm_auth=${a}`, l = `&gtm_preview=${i}`;
  t || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${t}${s}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${s}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${t}');`, p = GX({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: p
  };
}
let k8e = class {
  initializeDataScript(t) {
    const n = document.createElement("script");
    return n.innerHTML = t, n;
  }
  initializeGTMElements(t) {
    const n = P8e(t), r = () => {
      const a = document.createElement("noscript");
      return a.innerHTML = n.iframe, a;
    }, o = () => {
      const a = document.createElement("script");
      return a.innerHTML = n.script, a;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(t) {
    const { dataLayer: n, dataLayerName: r } = t;
    if (window[r]) return window[r].push(n);
    const o = GX({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(t) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: a = "",
      dataLayerName: s = "dataLayer"
    } = t, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: s,
      auth: i,
      preview: a
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function S8e(e) {
  return new k8e().initialize(e), /* @__PURE__ */ te.jsx(te.Fragment, {});
}
function L5e(e) {
  const {
    gtmId: t,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: a = {}
  } = e;
  return /* @__PURE__ */ te.jsx(L8e, { children: () => /* @__PURE__ */ te.jsx(
    S8e,
    {
      auth: n,
      dataLayer: a,
      dataLayerName: o,
      events: i,
      gtmId: t,
      preview: r
    }
  ) });
}
export {
  I8e as AlertContainer,
  B8e as AlertContent,
  N8e as AlertDescription,
  R8e as AlertIcon,
  CJ as AlertTitle,
  X8e as AudioUpload,
  W8e as Badge,
  a5e as BreadcrumbContainer,
  l5e as BreadcrumbLink,
  my as Button,
  $8e as Card,
  J8e as Checkbox,
  L8e as ClientOnly,
  H8e as Divider,
  c5e as DrawerContainer,
  p5e as DrawerHeader,
  v5e as DrawerProvider,
  k3 as FormController,
  Q8e as FormError,
  S3 as FormLabel,
  O5e as GoogleMap,
  b5e as GoogleProvider,
  x5e as GoogleSearchPlaces,
  L5e as GoogleTagManager,
  F2e as IconButton,
  V2e as ImageUpload,
  sw as Input,
  DHe as ModalContainer,
  _He as ModalFooter,
  jHe as ModalHeader,
  w5e as ModalProvider,
  e5e as MultiSelect,
  u5e as Pagination,
  d5e as Popover,
  n5e as RadioBox,
  t5e as RadioGroup,
  r5e as RichText,
  o5e as Select,
  V8e as Skeleton,
  B2e as Slider,
  i5e as Switch,
  hV as TabButton,
  AHe as TabContainer,
  Z8e as TableBody,
  q8e as TableCaption,
  K8e as TableContainer,
  G8e as TableFooter,
  Y8e as TableHeader,
  s5e as Textarea,
  f5e as Toast,
  C5e as ToastProvider,
  z2e as Tooltip,
  F8e as getHtmlFromRichTextValue,
  z8e as getRichTextValueFromHtml,
  U8e as isHtml,
  t8 as morpheme,
  h5e as useAutomation,
  g5e as useDrawer,
  cY as useFieldErrors,
  bi as useFormController,
  KVe as useHydrated,
  m5e as useModal,
  rX as useScopedParams,
  ZVe as useToast
};
