import * as Ve from "react";
import Be, { createContext as Ye, useContext as _e, memo as Re, Children as Mt, isValidElement as Li, cloneElement as ki, useState as D, useRef as rt, useEffect as v, PureComponent as ke, createRef as xr, useMemo as rr, useId as eB, forwardRef as Fs, Component as Yc, useCallback as Zt, useReducer as tB, useLayoutEffect as nB } from "react";
import { Info as FD, AlertTriangle as rB, XCircle as RD, CheckCircle2 as zD, MapPinned as oB, Loader2 as Zo, Check as UD, RefreshCw as iB, Heading1 as sB, Heading2 as aB, Quote as lB, Bold as uB, Italic as cB, Underline as pB, Code as dB, AlignLeft as fB, AlignRight as hB, AlignCenter as gB, AlignJustify as mB, Search as vB, ChevronDown as yB, ChevronRight as Eh, ChevronLeft as bB, Ellipsis as Ty, X as $D } from "lucide-react";
import * as Di from "react-dom";
import pl, { createPortal as Lr } from "react-dom";
import { useActionData as rm, useNavigation as WD, useFetchers as HD, useLocation as om, Link as wB, useNavigate as VD } from "@remix-run/react";
import { InputMask as CB } from "@react-input/mask";
import { AnimatePresence as ZD, motion as $a } from "framer-motion";
var en = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Xc(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var xh = { exports: {} }, qs = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ay;
function EB() {
  if (Ay) return qs;
  Ay = 1;
  var e = Be, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: g, props: p, _owner: o.current };
  }
  return qs.Fragment = n, qs.jsx = s, qs.jsxs = s, qs;
}
var Gs = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var By;
function xB() {
  return By || (By = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Be, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), m = Symbol.iterator, f = "@@iterator";
    function h(y) {
      if (y === null || typeof y != "object")
        return null;
      var _ = m && y[m] || y[f];
      return typeof _ == "function" ? _ : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function L(y) {
      {
        for (var _ = arguments.length, K = new Array(_ > 1 ? _ - 1 : 0), ie = 1; ie < _; ie++)
          K[ie - 1] = arguments[ie];
        x("error", y, K);
      }
    }
    function x(y, _, K) {
      {
        var ie = E.ReactDebugCurrentFrame, ve = ie.getStackAddendum();
        ve !== "" && (_ += "%s", K = K.concat([ve]));
        var we = K.map(function(fe) {
          return String(fe);
        });
        we.unshift("Warning: " + _), Function.prototype.apply.call(console[y], console, we);
      }
    }
    var T = !1, w = !1, C = !1, k = !1, O = !1, U;
    U = Symbol.for("react.module.reference");
    function M(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === i || O || y === o || y === u || y === c || k || y === g || T || w || C || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === p || y.$$typeof === s || y.$$typeof === a || y.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === U || y.getModuleId !== void 0));
    }
    function V(y, _, K) {
      var ie = y.displayName;
      if (ie)
        return ie;
      var ve = _.displayName || _.name || "";
      return ve !== "" ? K + "(" + ve + ")" : K;
    }
    function $(y) {
      return y.displayName || "Context";
    }
    function W(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && L("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case a:
            var _ = y;
            return $(_) + ".Consumer";
          case s:
            var K = y;
            return $(K._context) + ".Provider";
          case l:
            return V(y, y.render, "ForwardRef");
          case p:
            var ie = y.displayName || null;
            return ie !== null ? ie : W(y.type) || "Memo";
          case d: {
            var ve = y, we = ve._payload, fe = ve._init;
            try {
              return W(fe(we));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var R = Object.assign, H = 0, X, I, J, te, S, P, q;
    function j() {
    }
    j.__reactDisabledLog = !0;
    function Z() {
      {
        if (H === 0) {
          X = console.log, I = console.info, J = console.warn, te = console.error, S = console.group, P = console.groupCollapsed, q = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: j,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        H++;
      }
    }
    function G() {
      {
        if (H--, H === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: R({}, y, {
              value: X
            }),
            info: R({}, y, {
              value: I
            }),
            warn: R({}, y, {
              value: J
            }),
            error: R({}, y, {
              value: te
            }),
            group: R({}, y, {
              value: S
            }),
            groupCollapsed: R({}, y, {
              value: P
            }),
            groupEnd: R({}, y, {
              value: q
            })
          });
        }
        H < 0 && L("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var b = E.ReactCurrentDispatcher, F;
    function z(y, _, K) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ve) {
            var ie = ve.stack.trim().match(/\n( *(at )?)/);
            F = ie && ie[1] || "";
          }
        return `
` + F + y;
      }
    }
    var A = !1, Y;
    {
      var ee = typeof WeakMap == "function" ? WeakMap : Map;
      Y = new ee();
    }
    function B(y, _) {
      if (!y || A)
        return "";
      {
        var K = Y.get(y);
        if (K !== void 0)
          return K;
      }
      var ie;
      A = !0;
      var ve = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var we;
      we = b.current, b.current = null, Z();
      try {
        if (_) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (je) {
              ie = je;
            }
            Reflect.construct(y, [], fe);
          } else {
            try {
              fe.call();
            } catch (je) {
              ie = je;
            }
            y.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ie = je;
          }
          y();
        }
      } catch (je) {
        if (je && ie && typeof je.stack == "string") {
          for (var pe = je.stack.split(`
`), Ie = ie.stack.split(`
`), De = pe.length - 1, Se = Ie.length - 1; De >= 1 && Se >= 0 && pe[De] !== Ie[Se]; )
            Se--;
          for (; De >= 1 && Se >= 0; De--, Se--)
            if (pe[De] !== Ie[Se]) {
              if (De !== 1 || Se !== 1)
                do
                  if (De--, Se--, Se < 0 || pe[De] !== Ie[Se]) {
                    var ze = `
` + pe[De].replace(" at new ", " at ");
                    return y.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", y.displayName)), typeof y == "function" && Y.set(y, ze), ze;
                  }
                while (De >= 1 && Se >= 0);
              break;
            }
        }
      } finally {
        A = !1, b.current = we, G(), Error.prepareStackTrace = ve;
      }
      var ct = y ? y.displayName || y.name : "", pt = ct ? z(ct) : "";
      return typeof y == "function" && Y.set(y, pt), pt;
    }
    function se(y, _, K) {
      return B(y, !1);
    }
    function ue(y) {
      var _ = y.prototype;
      return !!(_ && _.isReactComponent);
    }
    function ce(y, _, K) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return B(y, ue(y));
      if (typeof y == "string")
        return z(y);
      switch (y) {
        case u:
          return z("Suspense");
        case c:
          return z("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case l:
            return se(y.render);
          case p:
            return ce(y.type, _, K);
          case d: {
            var ie = y, ve = ie._payload, we = ie._init;
            try {
              return ce(we(ve), _, K);
            } catch {
            }
          }
        }
      return "";
    }
    var de = Object.prototype.hasOwnProperty, be = {}, ge = E.ReactDebugCurrentFrame;
    function me(y) {
      if (y) {
        var _ = y._owner, K = ce(y.type, y._source, _ ? _.type : null);
        ge.setExtraStackFrame(K);
      } else
        ge.setExtraStackFrame(null);
    }
    function ae(y, _, K, ie, ve) {
      {
        var we = Function.call.bind(de);
        for (var fe in y)
          if (we(y, fe)) {
            var pe = void 0;
            try {
              if (typeof y[fe] != "function") {
                var Ie = Error((ie || "React class") + ": " + K + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ie.name = "Invariant Violation", Ie;
              }
              pe = y[fe](_, fe, ie, K, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (De) {
              pe = De;
            }
            pe && !(pe instanceof Error) && (me(ve), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ie || "React class", K, fe, typeof pe), me(null)), pe instanceof Error && !(pe.message in be) && (be[pe.message] = !0, me(ve), L("Failed %s type: %s", K, pe.message), me(null));
          }
      }
    }
    var xe = Array.isArray;
    function re(y) {
      return xe(y);
    }
    function Te(y) {
      {
        var _ = typeof Symbol == "function" && Symbol.toStringTag, K = _ && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return K;
      }
    }
    function ne(y) {
      try {
        return Ee(y), !1;
      } catch {
        return !0;
      }
    }
    function Ee(y) {
      return "" + y;
    }
    function Ne(y) {
      if (ne(y))
        return L("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Te(y)), Ee(y);
    }
    var Fe = E.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, he, Xe, He;
    He = {};
    function qt(y) {
      if (de.call(y, "ref")) {
        var _ = Object.getOwnPropertyDescriptor(y, "ref").get;
        if (_ && _.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function lt(y) {
      if (de.call(y, "key")) {
        var _ = Object.getOwnPropertyDescriptor(y, "key").get;
        if (_ && _.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function mt(y, _) {
      if (typeof y.ref == "string" && Fe.current && _ && Fe.current.stateNode !== _) {
        var K = W(Fe.current.type);
        He[K] || (L('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', W(Fe.current.type), y.ref), He[K] = !0);
      }
    }
    function on(y, _) {
      {
        var K = function() {
          he || (he = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _));
        };
        K.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: K,
          configurable: !0
        });
      }
    }
    function sn(y, _) {
      {
        var K = function() {
          Xe || (Xe = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _));
        };
        K.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: K,
          configurable: !0
        });
      }
    }
    var an = function(y, _, K, ie, ve, we, fe) {
      var pe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: _,
        ref: K,
        props: fe,
        // Record the component responsible for creating this element.
        _owner: we
      };
      return pe._store = {}, Object.defineProperty(pe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ie
      }), Object.defineProperty(pe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ve
      }), Object.freeze && (Object.freeze(pe.props), Object.freeze(pe)), pe;
    };
    function ln(y, _, K, ie, ve) {
      {
        var we, fe = {}, pe = null, Ie = null;
        K !== void 0 && (Ne(K), pe = "" + K), lt(_) && (Ne(_.key), pe = "" + _.key), qt(_) && (Ie = _.ref, mt(_, ve));
        for (we in _)
          de.call(_, we) && !Ue.hasOwnProperty(we) && (fe[we] = _[we]);
        if (y && y.defaultProps) {
          var De = y.defaultProps;
          for (we in De)
            fe[we] === void 0 && (fe[we] = De[we]);
        }
        if (pe || Ie) {
          var Se = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          pe && on(fe, Se), Ie && sn(fe, Se);
        }
        return an(y, pe, Ie, ve, ie, Fe.current, fe);
      }
    }
    var nt = E.ReactCurrentOwner, Rt = E.ReactDebugCurrentFrame;
    function ut(y) {
      if (y) {
        var _ = y._owner, K = ce(y.type, y._source, _ ? _.type : null);
        Rt.setExtraStackFrame(K);
      } else
        Rt.setExtraStackFrame(null);
    }
    var Bt;
    Bt = !1;
    function un(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function jn() {
      {
        if (nt.current) {
          var y = W(nt.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function cn(y) {
      {
        if (y !== void 0) {
          var _ = y.fileName.replace(/^.*[\\\/]/, ""), K = y.lineNumber;
          return `

Check your code at ` + _ + ":" + K + ".";
        }
        return "";
      }
    }
    var Nn = {};
    function lr(y) {
      {
        var _ = jn();
        if (!_) {
          var K = typeof y == "string" ? y : y.displayName || y.name;
          K && (_ = `

Check the top-level render call using <` + K + ">.");
        }
        return _;
      }
    }
    function zt(y, _) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var K = lr(_);
        if (Nn[K])
          return;
        Nn[K] = !0;
        var ie = "";
        y && y._owner && y._owner !== nt.current && (ie = " It was passed a child from " + W(y._owner.type) + "."), ut(y), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', K, ie), ut(null);
      }
    }
    function Fn(y, _) {
      {
        if (typeof y != "object")
          return;
        if (re(y))
          for (var K = 0; K < y.length; K++) {
            var ie = y[K];
            un(ie) && zt(ie, _);
          }
        else if (un(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var ve = h(y);
          if (typeof ve == "function" && ve !== y.entries)
            for (var we = ve.call(y), fe; !(fe = we.next()).done; )
              un(fe.value) && zt(fe.value, _);
        }
      }
    }
    function ur(y) {
      {
        var _ = y.type;
        if (_ == null || typeof _ == "string")
          return;
        var K;
        if (typeof _ == "function")
          K = _.propTypes;
        else if (typeof _ == "object" && (_.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        _.$$typeof === p))
          K = _.propTypes;
        else
          return;
        if (K) {
          var ie = W(_);
          ae(K, y.props, "prop", ie, y);
        } else if (_.PropTypes !== void 0 && !Bt) {
          Bt = !0;
          var ve = W(_);
          L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ve || "Unknown");
        }
        typeof _.getDefaultProps == "function" && !_.getDefaultProps.isReactClassApproved && L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function pn(y) {
      {
        for (var _ = Object.keys(y.props), K = 0; K < _.length; K++) {
          var ie = _[K];
          if (ie !== "children" && ie !== "key") {
            ut(y), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ie), ut(null);
            break;
          }
        }
        y.ref !== null && (ut(y), L("Invalid attribute `ref` supplied to `React.Fragment`."), ut(null));
      }
    }
    var Rn = {};
    function zn(y, _, K, ie, ve, we) {
      {
        var fe = M(y);
        if (!fe) {
          var pe = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ie = cn(ve);
          Ie ? pe += Ie : pe += jn();
          var De;
          y === null ? De = "null" : re(y) ? De = "array" : y !== void 0 && y.$$typeof === t ? (De = "<" + (W(y.type) || "Unknown") + " />", pe = " Did you accidentally export a JSX literal instead of a component?") : De = typeof y, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", De, pe);
        }
        var Se = ln(y, _, K, ve, we);
        if (Se == null)
          return Se;
        if (fe) {
          var ze = _.children;
          if (ze !== void 0)
            if (ie)
              if (re(ze)) {
                for (var ct = 0; ct < ze.length; ct++)
                  Fn(ze[ct], y);
                Object.freeze && Object.freeze(ze);
              } else
                L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Fn(ze, y);
        }
        if (de.call(_, "key")) {
          var pt = W(y), je = Object.keys(_).filter(function(Ui) {
            return Ui !== "key";
          }), le = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Rn[pt + le]) {
            var zi = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            L(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, le, pt, zi, pt), Rn[pt + le] = !0;
          }
        }
        return y === r ? pn(Se) : ur(Se), Se;
      }
    }
    function dn(y, _, K) {
      return zn(y, _, K, !0);
    }
    function cr(y, _, K) {
      return zn(y, _, K, !1);
    }
    var pr = cr, fn = dn;
    Gs.Fragment = r, Gs.jsx = pr, Gs.jsxs = fn;
  }()), Gs;
}
process.env.NODE_ENV === "production" ? xh.exports = EB() : xh.exports = xB();
var Q = xh.exports;
function LB(e) {
  const { className: t, ...n } = e, r = `arkynAlertTitle ${t}`;
  return /* @__PURE__ */ Q.jsx("div", { className: r.trim(), ...n });
}
const qD = Ye({});
function kB() {
  return _e(qD);
}
function jne(e) {
  const { schema: t, children: n, className: r, ...o } = e, a = !((u) => {
    let c = !1;
    const p = (d) => {
      Array.isArray(d) ? d.forEach(p) : d && typeof d == "object" && "type" in d && (d.type === LB ? c = !0 : d.props && d.props.children && p(d.props.children));
    };
    return p(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${t} ${a} ${r}`;
  return /* @__PURE__ */ Q.jsx(qD.Provider, { value: e, children: /* @__PURE__ */ Q.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function Nne(e) {
  const { className: t, ...n } = e, r = `arkynAlertContent ${t}`;
  return /* @__PURE__ */ Q.jsx("div", { className: r.trim(), ...n });
}
function Fne(e) {
  const { className: t, ...n } = e, r = `arkynAlertDescription ${t}`;
  return /* @__PURE__ */ Q.jsx("div", { className: r.trim(), ...n });
}
function Rne(e) {
  const { className: t, ...n } = e, { schema: r } = kB(), o = `arkynAlertIcon ${r} ${t}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ Q.jsx(zD, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ Q.jsx(RD, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ Q.jsx(rB, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ Q.jsx(FD, { className: o, ...n });
  }
}
function gc(e, t) {
  return t ? /* @__PURE__ */ Q.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function GD(e, t) {
  return [...new Array(t - e)].map((n, r) => e + r + 1).filter((n) => n > 0);
}
function DB(e, t, n) {
  return e >= n ? [] : GD(e, e + t);
}
function SB(e, t) {
  return e <= 1 ? [] : GD(e - 1 - t, e - 1);
}
function OB(e, t, n) {
  if (!e) return /* @__PURE__ */ Q.jsx(Q.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ Q.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ Q.jsx("p", { className: n, children: /* @__PURE__ */ Q.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function zne(e) {
  const {
    variant: t = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: s = "",
    children: a,
    ...l
  } = e, c = { md: 12, lg: 14 }[r], p = `arkynBadge ${t} ${n} ${r} ${s}`;
  return /* @__PURE__ */ Q.jsxs("div", { className: p.trim(), ...l, children: [
    gc(c, o),
    a,
    gc(c, o)
  ] });
}
function Une(e) {
  const { className: t, ...n } = e, r = `arkynCard ${t}`;
  return /* @__PURE__ */ Q.jsx("div", { className: r.trim(), ...n });
}
function $ne(e) {
  const {
    className: t,
    orientation: n = "horizontal",
    ...r
  } = e, o = `arkynDivider ${n} ${t}`;
  return /* @__PURE__ */ Q.jsx("div", { className: o.trim(), ...r });
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Lh = function(e, t) {
  return Lh = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
  }, Lh(e, t);
};
function hn(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Lh(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Ze = function() {
  return Ze = Object.assign || function(t) {
    for (var n, r = 1, o = arguments.length; r < o; r++) {
      n = arguments[r];
      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);
    }
    return t;
  }, Ze.apply(this, arguments);
};
function im(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function MB(e, t, n, r) {
  function o(i) {
    return i instanceof n ? i : new n(function(s) {
      s(i);
    });
  }
  return new (n || (n = Promise))(function(i, s) {
    function a(c) {
      try {
        u(r.next(c));
      } catch (p) {
        s(p);
      }
    }
    function l(c) {
      try {
        u(r.throw(c));
      } catch (p) {
        s(p);
      }
    }
    function u(c) {
      c.done ? i(c.value) : o(c.value).then(a, l);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function PB(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(c) {
      return l([u, c]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, o && (i = u[0] & 2 ? o.return : u[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, u[1])).done) return i;
      switch (o = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
        case 0:
        case 1:
          i = u;
          break;
        case 4:
          return n.label++, { value: u[1], done: !1 };
        case 5:
          n.label++, o = u[1], u = [0];
          continue;
        case 7:
          u = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            n = 0;
            continue;
          }
          if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
            n.label = u[1];
            break;
          }
          if (u[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = u;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(u);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      u = t.call(e, n);
    } catch (c) {
      u = [6, c], o = 0;
    } finally {
      r = i = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function KD(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var TB = process.env.NODE_ENV, AB = function(e, t, n, r, o, i, s, a) {
  if (TB !== "production" && t === void 0)
    throw new Error("invariant requires an error message argument");
  if (!e) {
    var l;
    if (t === void 0)
      l = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var u = [n, r, o, i, s, a], c = 0;
      l = new Error(
        t.replace(/%s/g, function() {
          return u[c++];
        })
      ), l.name = "Invariant Violation";
    }
    throw l.framesToPop = 1, l;
  }
}, BB = AB, or = /* @__PURE__ */ KD(BB), ot = Ye(null);
function _B() {
  or(!!_e, "useGoogleMap is React hook and requires React version 16.8+");
  var e = _e(ot);
  return or(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function IB(e, t, n) {
  return Object.keys(e).reduce(function(o, i) {
    return t(o, e[i], i);
  }, n);
}
function jB(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function NB(e, t, n, r) {
  var o = {}, i = function(s, a) {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return jB(e, i), o;
}
function FB(e, t, n) {
  var r = IB(n, function(i, s, a) {
    return typeof e[a] == "function" && i.push(google.maps.event.addListener(t, s, e[a])), i;
  }, []);
  return r;
}
function RB(e) {
  google.maps.event.removeListener(e);
}
function kt(e) {
  e === void 0 && (e = []), e.forEach(RB);
}
function vt(e) {
  var t = e.updaterMap, n = e.eventMap, r = e.prevProps, o = e.nextProps, i = e.instance, s = FB(o, i, n);
  return NB(t, r, o, i), s;
}
var _y = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, Iy = {
  extraMapTypes: function(e, t) {
    t.forEach(function(r, o) {
      e.mapTypes.set(String(o), r);
    });
  },
  center: function(e, t) {
    e.setCenter(t);
  },
  clickableIcons: function(e, t) {
    e.setClickableIcons(t);
  },
  heading: function(e, t) {
    e.setHeading(t);
  },
  mapTypeId: function(e, t) {
    e.setMapTypeId(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  streetView: function(e, t) {
    e.setStreetView(t);
  },
  tilt: function(e, t) {
    e.setTilt(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
function zB(e) {
  var t = e.children, n = e.options, r = e.id, o = e.mapContainerStyle, i = e.mapContainerClassName, s = e.center, a = e.onClick, l = e.onDblClick, u = e.onDrag, c = e.onDragEnd, p = e.onDragStart, d = e.onMouseMove, g = e.onMouseOut, m = e.onMouseOver, f = e.onMouseDown, h = e.onMouseUp, E = e.onRightClick, L = e.onCenterChanged, x = e.onLoad, T = e.onUnmount, w = D(null), C = w[0], k = w[1], O = rt(null), U = D(null), M = U[0], V = U[1], $ = D(null), W = $[0], R = $[1], H = D(null), X = H[0], I = H[1], J = D(null), te = J[0], S = J[1], P = D(null), q = P[0], j = P[1], Z = D(null), G = Z[0], b = Z[1], F = D(null), z = F[0], A = F[1], Y = D(null), ee = Y[0], B = Y[1], se = D(null), ue = se[0], ce = se[1], de = D(null), be = de[0], ge = de[1], me = D(null), ae = me[0], xe = me[1], re = D(null), Te = re[0], ne = re[1];
  return v(function() {
    n && C !== null && C.setOptions(n);
  }, [C, n]), v(function() {
    C !== null && typeof s < "u" && C.setCenter(s);
  }, [C, s]), v(function() {
    C && l && (W !== null && google.maps.event.removeListener(W), R(google.maps.event.addListener(C, "dblclick", l)));
  }, [l]), v(function() {
    C && c && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(C, "dragend", c)));
  }, [c]), v(function() {
    C && p && (te !== null && google.maps.event.removeListener(te), S(google.maps.event.addListener(C, "dragstart", p)));
  }, [p]), v(function() {
    C && f && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "mousedown", f)));
  }, [f]), v(function() {
    C && d && (G !== null && google.maps.event.removeListener(G), b(google.maps.event.addListener(C, "mousemove", d)));
  }, [d]), v(function() {
    C && g && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(C, "mouseout", g)));
  }, [g]), v(function() {
    C && m && (ee !== null && google.maps.event.removeListener(ee), B(google.maps.event.addListener(C, "mouseover", m)));
  }, [m]), v(function() {
    C && h && (ue !== null && google.maps.event.removeListener(ue), ce(google.maps.event.addListener(C, "mouseup", h)));
  }, [h]), v(function() {
    C && E && (be !== null && google.maps.event.removeListener(be), ge(google.maps.event.addListener(C, "rightclick", E)));
  }, [E]), v(function() {
    C && a && (ae !== null && google.maps.event.removeListener(ae), xe(google.maps.event.addListener(C, "click", a)));
  }, [a]), v(function() {
    C && u && (Te !== null && google.maps.event.removeListener(Te), ne(google.maps.event.addListener(C, "drag", u)));
  }, [u]), v(function() {
    C && L && (M !== null && google.maps.event.removeListener(M), V(google.maps.event.addListener(C, "center_changed", L)));
  }, [a]), v(function() {
    var Ee = O.current === null ? null : new google.maps.Map(O.current, n);
    return k(Ee), Ee !== null && x && x(Ee), function() {
      Ee !== null && T && T(Ee);
    };
  }, []), Q.jsx("div", { id: r, ref: O, style: o, className: i, children: Q.jsx(ot.Provider, { value: C, children: C !== null ? t : null }) });
}
Re(zB);
var UB = (
  /** @class */
  function(e) {
    hn(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.state = {
        map: null
      }, n.registeredEvents = [], n.mapRef = null, n.getInstance = function() {
        return n.mapRef === null ? null : new google.maps.Map(n.mapRef, n.props.options);
      }, n.panTo = function(r) {
        var o = n.getInstance();
        o && o.panTo(r);
      }, n.setMapCallback = function() {
        n.state.map !== null && n.props.onLoad && n.props.onLoad(n.state.map);
      }, n.getRef = function(r) {
        n.mapRef = r;
      }, n;
    }
    return t.prototype.componentDidMount = function() {
      var n = this.getInstance();
      this.registeredEvents = vt({
        updaterMap: Iy,
        eventMap: _y,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          map: n
        };
      }, this.setMapCallback);
    }, t.prototype.componentDidUpdate = function(n) {
      this.state.map !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
        updaterMap: Iy,
        eventMap: _y,
        prevProps: n,
        nextProps: this.props,
        instance: this.state.map
      }));
    }, t.prototype.componentWillUnmount = function() {
      this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), kt(this.registeredEvents));
    }, t.prototype.render = function() {
      return Q.jsx("div", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: Q.jsx(ot.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : null }) });
    }, t;
  }(ke)
), ss = typeof document < "u";
function YD(e) {
  var t = e.url, n = e.id, r = e.nonce;
  return ss ? new Promise(function(i, s) {
    var a = document.getElementById(n), l = window;
    if (a) {
      var u = a.getAttribute("data-state");
      if (a.src === t && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, p = a.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, a.onerror = function(g) {
          p && p(g), s(g);
        };
        return;
      } else
        a.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = t, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(m) {
      d.setAttribute("data-state", "error"), s(m);
    }, l.initMap = function() {
      d.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(d);
  }).catch(function(o) {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function jy(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function XD() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(o, i) {
      return jy(o) || Reflect.apply(t, e, [o, i]), o;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(o) {
      return jy(o) || Reflect.apply(n, e, [o]), o;
    };
  }
}
function QD(e) {
  var t = e.googleMapsApiKey, n = e.googleMapsClientId, r = e.version, o = r === void 0 ? "weekly" : r, i = e.language, s = e.region, a = e.libraries, l = e.channel, u = e.mapIds, c = e.authReferrerPolicy, p = [];
  return or(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? p.push("key=".concat(t)) : n && p.push("client=".concat(n)), o && p.push("v=".concat(o)), i && p.push("language=".concat(i)), s && p.push("region=".concat(s)), a && a.length && p.push("libraries=".concat(a.sort().join(","))), l && p.push("channel=".concat(l)), u && u.length && p.push("map_ids=".concat(u.join(","))), c && p.push("auth_referrer_policy=".concat(c)), p.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(p.join("&"));
}
var Ks = !1;
function JD() {
  return Q.jsx("div", { children: "Loading..." });
}
var kh = {
  id: "script-loader",
  version: "weekly"
}, $B = (
  /** @class */
  function(e) {
    hn(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.check = xr(), n.state = {
        loaded: !1
      }, n.cleanupCallback = function() {
        delete window.google.maps, n.injectScript();
      }, n.isCleaningUp = function() {
        return MB(n, void 0, void 0, function() {
          function r(o) {
            if (!Ks)
              o();
            else if (ss)
              var i = window.setInterval(function() {
                Ks || (window.clearInterval(i), o());
              }, 1);
          }
          return PB(this, function(o) {
            return [2, new Promise(r)];
          });
        });
      }, n.cleanup = function() {
        Ks = !0;
        var r = document.getElementById(n.props.id);
        r && r.parentNode && r.parentNode.removeChild(r), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(i) {
          return typeof i.src == "string" && i.src.includes("maps.googleapis");
        }).forEach(function(i) {
          i.parentNode && i.parentNode.removeChild(i);
        }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(i) {
          return i.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
        }).forEach(function(i) {
          i.parentNode && i.parentNode.removeChild(i);
        }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(i) {
          return i.innerText !== void 0 && i.innerText.length > 0 && i.innerText.includes(".gm-");
        }).forEach(function(i) {
          i.parentNode && i.parentNode.removeChild(i);
        });
      }, n.injectScript = function() {
        n.props.preventGoogleFontsLoading && XD(), or(!!n.props.id, 'LoadScript requires "id" prop to be a string: %s', n.props.id);
        var r = {
          id: n.props.id,
          nonce: n.props.nonce,
          url: QD(n.props)
        };
        YD(r).then(function() {
          n.props.onLoad && n.props.onLoad(), n.setState(function() {
            return {
              loaded: !0
            };
          });
        }).catch(function(o) {
          n.props.onError && n.props.onError(o), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(n.props.googleMapsApiKey || "-", ") or Client ID (").concat(n.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
        });
      }, n;
    }
    return t.prototype.componentDidMount = function() {
      if (ss) {
        if (window.google && window.google.maps && !Ks) {
          console.error("google api is already presented");
          return;
        }
        this.isCleaningUp().then(this.injectScript).catch(function(r) {
          console.error("Error at injecting script after cleaning up: ", r);
        });
      }
    }, t.prototype.componentDidUpdate = function(n) {
      this.props.libraries !== n.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), ss && n.language !== this.props.language && (this.cleanup(), this.setState(function() {
        return {
          loaded: !1
        };
      }, this.cleanupCallback));
    }, t.prototype.componentWillUnmount = function() {
      var n = this;
      if (ss) {
        this.cleanup();
        var r = function() {
          n.check.current || (delete window.google, Ks = !1);
        };
        window.setTimeout(r, 1), this.props.onUnmount && this.props.onUnmount();
      }
    }, t.prototype.render = function() {
      return Q.jsxs(Q.Fragment, { children: [Q.jsx("div", { ref: this.check }), this.state.loaded ? this.props.children : this.props.loadingElement || Q.jsx(JD, {})] });
    }, t.defaultProps = kh, t;
  }(ke)
), Ny;
function WB(e) {
  var t = e.id, n = t === void 0 ? kh.id : t, r = e.version, o = r === void 0 ? kh.version : r, i = e.nonce, s = e.googleMapsApiKey, a = e.googleMapsClientId, l = e.language, u = e.region, c = e.libraries, p = e.preventGoogleFontsLoading, d = e.channel, g = e.mapIds, m = e.authReferrerPolicy, f = rt(!1), h = D(!1), E = h[0], L = h[1], x = D(void 0), T = x[0], w = x[1];
  v(function() {
    return f.current = !0, function() {
      f.current = !1;
    };
  }, []), v(function() {
    ss && p && XD();
  }, [p]), v(function() {
    E && or(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [E]);
  var C = QD({
    version: o,
    googleMapsApiKey: s,
    googleMapsClientId: a,
    language: l,
    region: u,
    libraries: c,
    channel: d,
    mapIds: g,
    authReferrerPolicy: m
  });
  v(function() {
    if (!ss)
      return;
    function U() {
      f.current && (L(!0), Ny = C);
    }
    if (window.google && window.google.maps && Ny === C) {
      U();
      return;
    }
    YD({ id: n, url: C, nonce: i }).then(U).catch(function(V) {
      f.current && w(V), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(s || "-", ") or Client ID (").concat(a || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(V);
    });
  }, [n, C, i]);
  var k = rt();
  return v(function() {
    k.current && c !== k.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), k.current = c;
  }, [c]), { isLoaded: E, loadError: T, url: C };
}
var HB = Q.jsx(JD, {});
function VB(e) {
  var t = e.loadingElement, n = e.onLoad, r = e.onError, o = e.onUnmount, i = e.children, s = im(e, ["loadingElement", "onLoad", "onError", "onUnmount", "children"]), a = WB(s), l = a.isLoaded, u = a.loadError;
  return v(function() {
    l && typeof n == "function" && n();
  }, [l, n]), v(function() {
    u && typeof r == "function" && r(u);
  }, [u, r]), v(function() {
    return function() {
      o && o();
    };
  }, [o]), l ? i : t || HB;
}
Re(VB);
var Fy;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Fy || (Fy = {}));
var Ry = {}, zy = {
  options: function(e, t) {
    e.setOptions(t);
  }
};
function ZB(e) {
  var t = e.options, n = e.onLoad, r = e.onUnmount, o = _e(ot), i = D(null), s = i[0], a = i[1];
  return v(function() {
    s !== null && s.setMap(o);
  }, [o]), v(function() {
    t && s !== null && s.setOptions(t);
  }, [s, t]), v(function() {
    var l = new google.maps.TrafficLayer(Ze(Ze({}, t || {}), { map: o }));
    return a(l), n && n(l), function() {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Re(ZB);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      trafficLayer: null
    }, n.setTrafficLayerCallback = function() {
      n.state.trafficLayer !== null && n.props.onLoad && n.props.onLoad(n.state.trafficLayer);
    }, n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TrafficLayer(Ze(Ze({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = vt({
      updaterMap: zy,
      eventMap: Ry,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        trafficLayer: n
      };
    }, this.setTrafficLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.trafficLayer !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: zy,
      eventMap: Ry,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), kt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
function qB(e) {
  var t = e.onLoad, n = e.onUnmount, r = _e(ot), o = D(null), i = o[0], s = o[1];
  return v(function() {
    i !== null && i.setMap(r);
  }, [r]), v(function() {
    var a = new google.maps.BicyclingLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Re(qB);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      bicyclingLayer: null
    }, n.setBicyclingLayerCallback = function() {
      n.state.bicyclingLayer !== null && (n.state.bicyclingLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.bicyclingLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.BicyclingLayer();
    this.setState(function() {
      return {
        bicyclingLayer: n
      };
    }, this.setBicyclingLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
function GB(e) {
  var t = e.onLoad, n = e.onUnmount, r = _e(ot), o = D(null), i = o[0], s = o[1];
  return v(function() {
    i !== null && i.setMap(r);
  }, [r]), v(function() {
    var a = new google.maps.TransitLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      i !== null && (n && n(i), i.setMap(null));
    };
  }, []), null;
}
Re(GB);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      transitLayer: null
    }, n.setTransitLayerCallback = function() {
      n.state.transitLayer !== null && (n.state.transitLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.transitLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: n
      };
    }, this.setTransitLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
var Uy = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, $y = {
  drawingMode: function(e, t) {
    e.setDrawingMode(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function KB(e) {
  var t = e.options, n = e.drawingMode, r = e.onCircleComplete, o = e.onMarkerComplete, i = e.onOverlayComplete, s = e.onPolygonComplete, a = e.onPolylineComplete, l = e.onRectangleComplete, u = e.onLoad, c = e.onUnmount, p = _e(ot), d = D(null), g = d[0], m = d[1], f = D(null), h = f[0], E = f[1], L = D(null), x = L[0], T = L[1], w = D(null), C = w[0], k = w[1], O = D(null), U = O[0], M = O[1], V = D(null), $ = V[0], W = V[1], R = D(null), H = R[0], X = R[1];
  return v(function() {
    g !== null && g.setMap(p);
  }, [p]), v(function() {
    t && g !== null && g.setOptions(t);
  }, [g, t]), v(function() {
    g !== null && g.setDrawingMode(n ?? null);
  }, [g, n]), v(function() {
    g && r && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(g, "circlecomplete", r)));
  }, [g, r]), v(function() {
    g && o && (x !== null && google.maps.event.removeListener(x), T(google.maps.event.addListener(g, "markercomplete", o)));
  }, [g, o]), v(function() {
    g && i && (C !== null && google.maps.event.removeListener(C), k(google.maps.event.addListener(g, "overlaycomplete", i)));
  }, [g, i]), v(function() {
    g && s && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(g, "polygoncomplete", s)));
  }, [g, s]), v(function() {
    g && a && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(g, "polylinecomplete", a)));
  }, [g, a]), v(function() {
    g && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(g, "rectanglecomplete", l)));
  }, [g, l]), v(function() {
    or(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var I = new google.maps.drawing.DrawingManager(Ze(Ze({}, t || {}), { map: p }));
    return n && I.setDrawingMode(n), r && E(google.maps.event.addListener(I, "circlecomplete", r)), o && T(google.maps.event.addListener(I, "markercomplete", o)), i && k(google.maps.event.addListener(I, "overlaycomplete", i)), s && M(google.maps.event.addListener(I, "polygoncomplete", s)), a && W(google.maps.event.addListener(I, "polylinecomplete", a)), l && X(google.maps.event.addListener(I, "rectanglecomplete", l)), m(I), u && u(I), function() {
      g !== null && (h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), $ && google.maps.event.removeListener($), H && google.maps.event.removeListener(H), c && c(g), g.setMap(null));
    };
  }, []), null;
}
Re(KB);
(function(e) {
  hn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    return r.registeredEvents = [], r.state = {
      drawingManager: null
    }, r.setDrawingManagerCallback = function() {
      r.state.drawingManager !== null && r.props.onLoad && r.props.onLoad(r.state.drawingManager);
    }, or(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing), r;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.drawing.DrawingManager(Ze(Ze({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = vt({
      updaterMap: $y,
      eventMap: Uy,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        drawingManager: n
      };
    }, this.setDrawingManagerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.drawingManager !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: $y,
      eventMap: Uy,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), kt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
var Wy = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, Hy = {
  animation: function(e, t) {
    e.setAnimation(t);
  },
  clickable: function(e, t) {
    e.setClickable(t);
  },
  cursor: function(e, t) {
    e.setCursor(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  icon: function(e, t) {
    e.setIcon(t);
  },
  label: function(e, t) {
    e.setLabel(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  opacity: function(e, t) {
    e.setOpacity(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  shape: function(e, t) {
    e.setShape(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, mc = {};
function YB(e) {
  var t = e.position, n = e.options, r = e.clusterer, o = e.noClustererRedraw, i = e.children, s = e.draggable, a = e.visible, l = e.animation, u = e.clickable, c = e.cursor, p = e.icon, d = e.label, g = e.opacity, m = e.shape, f = e.title, h = e.zIndex, E = e.onClick, L = e.onDblClick, x = e.onDrag, T = e.onDragEnd, w = e.onDragStart, C = e.onMouseOut, k = e.onMouseOver, O = e.onMouseUp, U = e.onMouseDown, M = e.onRightClick, V = e.onClickableChanged, $ = e.onCursorChanged, W = e.onAnimationChanged, R = e.onDraggableChanged, H = e.onFlatChanged, X = e.onIconChanged, I = e.onPositionChanged, J = e.onShapeChanged, te = e.onTitleChanged, S = e.onVisibleChanged, P = e.onZindexChanged, q = e.onLoad, j = e.onUnmount, Z = _e(ot), G = D(null), b = G[0], F = G[1], z = D(null), A = z[0], Y = z[1], ee = D(null), B = ee[0], se = ee[1], ue = D(null), ce = ue[0], de = ue[1], be = D(null), ge = be[0], me = be[1], ae = D(null), xe = ae[0], re = ae[1], Te = D(null), ne = Te[0], Ee = Te[1], Ne = D(null), Fe = Ne[0], Ue = Ne[1], he = D(null), Xe = he[0], He = he[1], qt = D(null), lt = qt[0], mt = qt[1], on = D(null), sn = on[0], an = on[1], ln = D(null), nt = ln[0], Rt = ln[1], ut = D(null), Bt = ut[0], un = ut[1], jn = D(null), cn = jn[0], Nn = jn[1], lr = D(null), zt = lr[0], Fn = lr[1], ur = D(null), pn = ur[0], Rn = ur[1], zn = D(null), dn = zn[0], cr = zn[1], pr = D(null), fn = pr[0], y = pr[1], _ = D(null), K = _[0], ie = _[1], ve = D(null), we = ve[0], fe = ve[1], pe = D(null), Ie = pe[0], De = pe[1], Se = D(null), ze = Se[0], ct = Se[1];
  v(function() {
    b !== null && b.setMap(Z);
  }, [Z]), v(function() {
    typeof n < "u" && b !== null && b.setOptions(n);
  }, [b, n]), v(function() {
    typeof s < "u" && b !== null && b.setDraggable(s);
  }, [b, s]), v(function() {
    t && b !== null && b.setPosition(t);
  }, [b, t]), v(function() {
    typeof a < "u" && b !== null && b.setVisible(a);
  }, [b, a]), v(function() {
    b == null || b.setAnimation(l);
  }, [b, l]), v(function() {
    b && u !== void 0 && b.setClickable(u);
  }, [b, u]), v(function() {
    b && c !== void 0 && b.setCursor(c);
  }, [b, c]), v(function() {
    b && p !== void 0 && b.setIcon(p);
  }, [b, p]), v(function() {
    b && d !== void 0 && b.setLabel(d);
  }, [b, d]), v(function() {
    b && g !== void 0 && b.setOpacity(g);
  }, [b, g]), v(function() {
    b && m !== void 0 && b.setShape(m);
  }, [b, m]), v(function() {
    b && f !== void 0 && b.setTitle(f);
  }, [b, f]), v(function() {
    b && h !== void 0 && b.setZIndex(h);
  }, [b, h]), v(function() {
    b && L && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(b, "dblclick", L)));
  }, [L]), v(function() {
    b && T && (B !== null && google.maps.event.removeListener(B), se(google.maps.event.addListener(b, "dragend", T)));
  }, [T]), v(function() {
    b && w && (ce !== null && google.maps.event.removeListener(ce), de(google.maps.event.addListener(b, "dragstart", w)));
  }, [w]), v(function() {
    b && U && (ge !== null && google.maps.event.removeListener(ge), me(google.maps.event.addListener(b, "mousedown", U)));
  }, [U]), v(function() {
    b && C && (xe !== null && google.maps.event.removeListener(xe), re(google.maps.event.addListener(b, "mouseout", C)));
  }, [C]), v(function() {
    b && k && (ne !== null && google.maps.event.removeListener(ne), Ee(google.maps.event.addListener(b, "mouseover", k)));
  }, [k]), v(function() {
    b && O && (Fe !== null && google.maps.event.removeListener(Fe), Ue(google.maps.event.addListener(b, "mouseup", O)));
  }, [O]), v(function() {
    b && M && (Xe !== null && google.maps.event.removeListener(Xe), He(google.maps.event.addListener(b, "rightclick", M)));
  }, [M]), v(function() {
    b && E && (lt !== null && google.maps.event.removeListener(lt), mt(google.maps.event.addListener(b, "click", E)));
  }, [E]), v(function() {
    b && x && (sn !== null && google.maps.event.removeListener(sn), an(google.maps.event.addListener(b, "drag", x)));
  }, [x]), v(function() {
    b && V && (nt !== null && google.maps.event.removeListener(nt), Rt(google.maps.event.addListener(b, "clickable_changed", V)));
  }, [V]), v(function() {
    b && $ && (Bt !== null && google.maps.event.removeListener(Bt), un(google.maps.event.addListener(b, "cursor_changed", $)));
  }, [$]), v(function() {
    b && W && (cn !== null && google.maps.event.removeListener(cn), Nn(google.maps.event.addListener(b, "animation_changed", W)));
  }, [W]), v(function() {
    b && R && (zt !== null && google.maps.event.removeListener(zt), Fn(google.maps.event.addListener(b, "draggable_changed", R)));
  }, [R]), v(function() {
    b && H && (pn !== null && google.maps.event.removeListener(pn), Rn(google.maps.event.addListener(b, "flat_changed", H)));
  }, [H]), v(function() {
    b && X && (dn !== null && google.maps.event.removeListener(dn), cr(google.maps.event.addListener(b, "icon_changed", X)));
  }, [X]), v(function() {
    b && I && (fn !== null && google.maps.event.removeListener(fn), y(google.maps.event.addListener(b, "position_changed", I)));
  }, [I]), v(function() {
    b && J && (K !== null && google.maps.event.removeListener(K), ie(google.maps.event.addListener(b, "shape_changed", J)));
  }, [J]), v(function() {
    b && te && (we !== null && google.maps.event.removeListener(we), fe(google.maps.event.addListener(b, "title_changed", te)));
  }, [te]), v(function() {
    b && S && (Ie !== null && google.maps.event.removeListener(Ie), De(google.maps.event.addListener(b, "visible_changed", S)));
  }, [S]), v(function() {
    b && P && (ze !== null && google.maps.event.removeListener(ze), ct(google.maps.event.addListener(b, "zindex_changed", P)));
  }, [P]), v(function() {
    var je = Ze(Ze(Ze({}, n || mc), r ? mc : { map: Z }), { position: t }), le = new google.maps.Marker(je);
    return r ? r.addMarker(le, !!o) : le.setMap(Z), t && le.setPosition(t), typeof a < "u" && le.setVisible(a), typeof s < "u" && le.setDraggable(s), typeof u < "u" && le.setClickable(u), typeof c == "string" && le.setCursor(c), p && le.setIcon(p), typeof d < "u" && le.setLabel(d), typeof g < "u" && le.setOpacity(g), m && le.setShape(m), typeof f == "string" && le.setTitle(f), typeof h == "number" && le.setZIndex(h), L && Y(google.maps.event.addListener(le, "dblclick", L)), T && se(google.maps.event.addListener(le, "dragend", T)), w && de(google.maps.event.addListener(le, "dragstart", w)), U && me(google.maps.event.addListener(le, "mousedown", U)), C && re(google.maps.event.addListener(le, "mouseout", C)), k && Ee(google.maps.event.addListener(le, "mouseover", k)), O && Ue(google.maps.event.addListener(le, "mouseup", O)), M && He(google.maps.event.addListener(le, "rightclick", M)), E && mt(google.maps.event.addListener(le, "click", E)), x && an(google.maps.event.addListener(le, "drag", x)), V && Rt(google.maps.event.addListener(le, "clickable_changed", V)), $ && un(google.maps.event.addListener(le, "cursor_changed", $)), W && Nn(google.maps.event.addListener(le, "animation_changed", W)), R && Fn(google.maps.event.addListener(le, "draggable_changed", R)), H && Rn(google.maps.event.addListener(le, "flat_changed", H)), X && cr(google.maps.event.addListener(le, "icon_changed", X)), I && y(google.maps.event.addListener(le, "position_changed", I)), J && ie(google.maps.event.addListener(le, "shape_changed", J)), te && fe(google.maps.event.addListener(le, "title_changed", te)), S && De(google.maps.event.addListener(le, "visible_changed", S)), P && ct(google.maps.event.addListener(le, "zindex_changed", P)), F(le), q && q(le), function() {
      A !== null && google.maps.event.removeListener(A), B !== null && google.maps.event.removeListener(B), ce !== null && google.maps.event.removeListener(ce), ge !== null && google.maps.event.removeListener(ge), xe !== null && google.maps.event.removeListener(xe), ne !== null && google.maps.event.removeListener(ne), Fe !== null && google.maps.event.removeListener(Fe), Xe !== null && google.maps.event.removeListener(Xe), lt !== null && google.maps.event.removeListener(lt), nt !== null && google.maps.event.removeListener(nt), Bt !== null && google.maps.event.removeListener(Bt), cn !== null && google.maps.event.removeListener(cn), zt !== null && google.maps.event.removeListener(zt), pn !== null && google.maps.event.removeListener(pn), dn !== null && google.maps.event.removeListener(dn), fn !== null && google.maps.event.removeListener(fn), we !== null && google.maps.event.removeListener(we), Ie !== null && google.maps.event.removeListener(Ie), ze !== null && google.maps.event.removeListener(ze), j && j(le), r ? r.removeMarker(le, !!o) : le && le.setMap(null);
    };
  }, []);
  var pt = rr(function() {
    return i ? Mt.map(i, function(je) {
      if (!Li(je))
        return je;
      var le = je;
      return ki(le, { anchor: b });
    }) : null;
  }, [i, b]);
  return Q.jsx(Q.Fragment, { children: pt }) || null;
}
Re(YB);
var XB = (
  /** @class */
  function(e) {
    hn(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.registeredEvents = [], n;
    }
    return t.prototype.componentDidMount = function() {
      var n = Ze(Ze(Ze({}, this.props.options || mc), this.props.clusterer ? mc : { map: this.context }), { position: this.props.position });
      this.marker = new google.maps.Marker(n), this.props.clusterer ? this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw) : this.marker.setMap(this.context), this.registeredEvents = vt({
        updaterMap: Hy,
        eventMap: Wy,
        prevProps: {},
        nextProps: this.props,
        instance: this.marker
      }), this.props.onLoad && this.props.onLoad(this.marker);
    }, t.prototype.componentDidUpdate = function(n) {
      this.marker && (kt(this.registeredEvents), this.registeredEvents = vt({
        updaterMap: Hy,
        eventMap: Wy,
        prevProps: n,
        nextProps: this.props,
        instance: this.marker
      }));
    }, t.prototype.componentWillUnmount = function() {
      this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), kt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
    }, t.prototype.render = function() {
      var n = this, r = null;
      return this.props.children && (r = Mt.map(this.props.children, function(o) {
        if (!Li(o))
          return o;
        var i = o;
        return ki(i, { anchor: n.marker });
      })), r || null;
    }, t.contextType = ot, t;
  }(ke)
), QB = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), JB = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new QB(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function e_(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var t_ = 2e3, n_ = 500, r_ = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", o_ = "png", i_ = [53, 56, 66, 78, 90], s_ = "cluster", eS = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || r_, this.imageExtension = r.imageExtension || o_, this.imageSizes = r.imageSizes || i_, this.calculator = r.calculator || e_, this.batchSize = r.batchSize || t_, this.batchSizeIE = r.batchSizeIE || n_, this.clusterClass = r.clusterClass || s_, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [
        google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged),
        google.maps.event.addListener(t, "idle", this.onIdle)
      ]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = t; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new JB(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var s = i;
          this.prototype[s] = o.prototype[s];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), oo = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, _t = {
  averageCenter: function(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE: function(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator: function(e, t) {
    e.setCalculator(t);
  },
  clusterClass: function(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons: function(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize: function(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden: function(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension: function(e, t) {
    e.setImageExtension(t);
  },
  imagePath: function(e, t) {
    e.setImagePath(t);
  },
  imageSizes: function(e, t) {
    e.setImageSizes(t);
  },
  maxZoom: function(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize: function(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles: function(e, t) {
    e.setStyles(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  zoomOnClick: function(e, t) {
    e.setZoomOnClick(t);
  }
}, a_ = {};
function l_(e) {
  var t = e.children, n = e.options, r = e.averageCenter, o = e.batchSizeIE, i = e.calculator, s = e.clusterClass, a = e.enableRetinaIcons, l = e.gridSize, u = e.ignoreHidden, c = e.imageExtension, p = e.imagePath, d = e.imageSizes, g = e.maxZoom, m = e.minimumClusterSize, f = e.styles, h = e.title, E = e.zoomOnClick, L = e.onClick, x = e.onClusteringBegin, T = e.onClusteringEnd, w = e.onMouseOver, C = e.onMouseOut, k = e.onLoad, O = e.onUnmount, U = D(null), M = U[0], V = U[1], $ = _e(ot), W = D(null), R = W[0], H = W[1], X = D(null), I = X[0], J = X[1], te = D(null), S = te[0], P = te[1], q = D(null), j = q[0], Z = q[1], G = D(null), b = G[0], F = G[1];
  return v(function() {
    M && C && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(M, oo.onMouseOut, C)));
  }, [C]), v(function() {
    M && w && (b !== null && google.maps.event.removeListener(b), F(google.maps.event.addListener(M, oo.onMouseOver, w)));
  }, [w]), v(function() {
    M && L && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(M, oo.onClick, L)));
  }, [L]), v(function() {
    M && x && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(M, oo.onClusteringBegin, x)));
  }, [x]), v(function() {
    M && T && (S !== null && google.maps.event.removeListener(S), J(google.maps.event.addListener(M, oo.onClusteringEnd, T)));
  }, [T]), v(function() {
    typeof r < "u" && M !== null && _t.averageCenter(M, r);
  }, [M, r]), v(function() {
    typeof o < "u" && M !== null && _t.batchSizeIE(M, o);
  }, [M, o]), v(function() {
    typeof i < "u" && M !== null && _t.calculator(M, i);
  }, [M, i]), v(function() {
    typeof s < "u" && M !== null && _t.clusterClass(M, s);
  }, [M, s]), v(function() {
    typeof a < "u" && M !== null && _t.enableRetinaIcons(M, a);
  }, [M, a]), v(function() {
    typeof l < "u" && M !== null && _t.gridSize(M, l);
  }, [M, l]), v(function() {
    typeof u < "u" && M !== null && _t.ignoreHidden(M, u);
  }, [M, u]), v(function() {
    typeof c < "u" && M !== null && _t.imageExtension(M, c);
  }, [M, c]), v(function() {
    typeof p < "u" && M !== null && _t.imagePath(M, p);
  }, [M, p]), v(function() {
    typeof d < "u" && M !== null && _t.imageSizes(M, d);
  }, [M, d]), v(function() {
    typeof g < "u" && M !== null && _t.maxZoom(M, g);
  }, [M, g]), v(function() {
    typeof m < "u" && M !== null && _t.minimumClusterSize(M, m);
  }, [M, m]), v(function() {
    typeof f < "u" && M !== null && _t.styles(M, f);
  }, [M, f]), v(function() {
    typeof h < "u" && M !== null && _t.title(M, h);
  }, [M, h]), v(function() {
    typeof E < "u" && M !== null && _t.zoomOnClick(M, E);
  }, [M, E]), v(function() {
    if ($) {
      var z = Ze({}, n || a_), A = new eS($, [], z);
      return r && _t.averageCenter(A, r), o && _t.batchSizeIE(A, o), i && _t.calculator(A, i), s && _t.clusterClass(A, s), a && _t.enableRetinaIcons(A, a), l && _t.gridSize(A, l), u && _t.ignoreHidden(A, u), c && _t.imageExtension(A, c), p && _t.imagePath(A, p), d && _t.imageSizes(A, d), g && _t.maxZoom(A, g), m && _t.minimumClusterSize(A, m), f && _t.styles(A, f), h && _t.title(A, h), E && _t.zoomOnClick(A, E), C && Z(google.maps.event.addListener(A, oo.onMouseOut, C)), w && F(google.maps.event.addListener(A, oo.onMouseOver, w)), L && H(google.maps.event.addListener(A, oo.onClick, L)), x && J(google.maps.event.addListener(A, oo.onClusteringBegin, x)), T && P(google.maps.event.addListener(A, oo.onClusteringEnd, T)), V(A), k && k(A), function() {
        j !== null && google.maps.event.removeListener(j), b !== null && google.maps.event.removeListener(b), R !== null && google.maps.event.removeListener(R), I !== null && google.maps.event.removeListener(I), S !== null && google.maps.event.removeListener(S), O && O(A);
      };
    }
  }, []), M !== null && t(M) || null;
}
Re(l_);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      markerClusterer: null
    }, n.setClustererCallback = function() {
      n.state.markerClusterer !== null && n.props.onLoad && n.props.onLoad(n.state.markerClusterer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context) {
      var n = new eS(this.context, [], this.props.options);
      this.registeredEvents = vt({
        updaterMap: _t,
        eventMap: oo,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          markerClusterer: n
        };
      }, this.setClustererCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.markerClusterer && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: _t,
      eventMap: oo,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), kt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }, t.prototype.render = function() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }, t.contextType = ot, t;
})(ke);
function Vy(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var tS = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || Vy(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = [
            "mousedown",
            "mouseover",
            "mouseout",
            "mouseup",
            "click",
            "dblclick",
            "touchstart",
            "touchend",
            "touchmove"
          ], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, Vy));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, m = this.infoBoxClearance.height, f = this.getProjection(), h = f.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + p + u + g > a && (r = h.x + p + u + g - a), this.alignBottom ? h.y < -c + m + d ? o = h.y + c - m - d : h.y + c + m > l && (o = h.y + c + m - l) : h.y < -c + m ? o = h.y + c - m : h.y + d + c + m > l && (o = h.y + d + c + m - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = { top: 0, bottom: 0, left: 0, right: 0 };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Zy = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, qy = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, u_ = {};
function c_(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, g = _e(ot), m = D(null), f = m[0], h = m[1], E = D(null), L = E[0], x = E[1], T = D(null), w = T[0], C = T[1], k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = rt(null);
  return v(function() {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(function() {
    if (o && f !== null) {
      var I = o instanceof google.maps.LatLng ? o : new google.maps.LatLng(o.lat, o.lng);
      f.setPosition(I);
    }
  }, [o]), v(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(function() {
    f && a && (w !== null && google.maps.event.removeListener(w), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(function() {
    f && l && (O !== null && google.maps.event.removeListener(O), U(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(function() {
    f && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(function() {
    f && c && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(function() {
    if (g) {
      var I = r || u_, J = I.position, te = im(I, ["position"]), S = void 0;
      J && !(J instanceof google.maps.LatLng) && (S = new google.maps.LatLng(J.lat, J.lng));
      var P = new tS(Ze(Ze({}, te), S ? { position: S } : {}));
      X.current = document.createElement("div"), h(P), s && x(google.maps.event.addListener(P, "closeclick", s)), a && C(google.maps.event.addListener(P, "domready", a)), l && U(google.maps.event.addListener(P, "content_changed", l)), u && $(google.maps.event.addListener(P, "position_changed", u)), c && H(google.maps.event.addListener(P, "zindex_changed", c)), P.setContent(X.current), n ? P.open(g, n) : P.getPosition() ? P.open(g) : or(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(P);
    }
    return function() {
      f !== null && (L && google.maps.event.removeListener(L), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), V && google.maps.event.removeListener(V), R && google.maps.event.removeListener(R), d && d(f), f.close());
    };
  }, []), X.current ? Lr(Mt.only(t), X.current) : null;
}
Re(c_);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoBox: null
    }, n.open = function(r, o) {
      o ? n.context !== null && r.open(n.context, o) : r.getPosition() ? n.context !== null && r.open(n.context) : or(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }, n.setInfoBoxCallback = function() {
      n.state.infoBox !== null && n.containerElement !== null && (n.state.infoBox.setContent(n.containerElement), n.open(n.state.infoBox, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoBox));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.props.options || {}, r = n.position, o = im(n, ["position"]), i;
    r && !(r instanceof google.maps.LatLng) && (i = new google.maps.LatLng(r.lat, r.lng));
    var s = new tS(Ze(Ze({}, o), i ? { position: i } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = vt({
      updaterMap: qy,
      eventMap: Zy,
      prevProps: {},
      nextProps: this.props,
      instance: s
    }), this.setState({ infoBox: s }, this.setInfoBoxCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = this.state.infoBox;
    r !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: qy,
      eventMap: Zy,
      prevProps: n,
      nextProps: this.props,
      instance: r
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n = this.props.onUnmount, r = this.state.infoBox;
    r !== null && (n && n(r), kt(this.registeredEvents), r.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Lr(Mt.only(this.props.children), this.containerElement) : null;
  }, t.contextType = ot, t;
})(ke);
var p_ = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var s = i[o];
      if (!e(t[s], n[s])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
}, Gy = /* @__PURE__ */ KD(p_);
const Ky = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], Md = 1, Ys = 8;
class sm {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const o = r >> 4;
    if (o !== Md)
      throw new Error(`Got v${o} data when expected v${Md}.`);
    const i = Ky[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new sm(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, o) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = Ky.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Ys, t), this.coords = new this.ArrayType(this.data, Ys + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(Ys + s + a + l), this.ids = new this.IndexArrayType(this.data, Ys, t), this.coords = new this.ArrayType(this.data, Ys + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Md << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return Dh(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: s, nodeSize: a } = this, l = [0, i.length - 1, 0], u = [];
    for (; l.length; ) {
      const c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (let h = d; h <= p; h++) {
          const E = s[2 * h], L = s[2 * h + 1];
          E >= t && E <= r && L >= n && L <= o && u.push(i[h]);
        }
        continue;
      }
      const g = d + p >> 1, m = s[2 * g], f = s[2 * g + 1];
      m >= t && m <= r && f >= n && f <= o && u.push(i[g]), (c === 0 ? t <= m : n <= f) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= m : o >= f) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: s } = this, a = [0, o.length - 1, 0], l = [], u = r * r;
    for (; a.length; ) {
      const c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (let h = d; h <= p; h++)
          Yy(i[2 * h], i[2 * h + 1], t, n) <= u && l.push(o[h]);
        continue;
      }
      const g = d + p >> 1, m = i[2 * g], f = i[2 * g + 1];
      Yy(m, f, t, n) <= u && l.push(o[g]), (c === 0 ? t - r <= m : n - r <= f) && (a.push(d), a.push(g - 1), a.push(1 - c)), (c === 0 ? t + r >= m : n + r >= f) && (a.push(g + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function Dh(e, t, n, r, o, i) {
  if (o - r <= n) return;
  const s = r + o >> 1;
  nS(e, t, s, r, o, i), Dh(e, t, n, r, s - 1, 1 - i), Dh(e, t, n, s + 1, o, 1 - i);
}
function nS(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      const u = o - r + 1, c = n - r + 1, p = Math.log(u), d = 0.5 * Math.exp(2 * p / 3), g = 0.5 * Math.sqrt(p * d * (u - d) / u) * (c - u / 2 < 0 ? -1 : 1), m = Math.max(r, Math.floor(n - c * d / u + g)), f = Math.min(o, Math.floor(n + (u - c) * d / u + g));
      nS(e, t, n, m, f, i);
    }
    const s = t[2 * n + i];
    let a = r, l = o;
    for (Xs(e, t, r, n), t[2 * o + i] > s && Xs(e, t, r, o); a < l; ) {
      for (Xs(e, t, a, l), a++, l--; t[2 * a + i] < s; ) a++;
      for (; t[2 * l + i] > s; ) l--;
    }
    t[2 * r + i] === s ? Xs(e, t, r, l) : (l++, Xs(e, t, l, o)), l <= n && (r = l + 1), n <= l && (o = l - 1);
  }
}
function Xs(e, t, n, r) {
  Pd(e, n, r), Pd(t, 2 * n, 2 * r), Pd(t, 2 * n + 1, 2 * r + 1);
}
function Pd(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function Yy(e, t, n, r) {
  const o = e - n, i = t - r;
  return o * o + i * i;
}
const d_ = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, Xy = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), $i = 2, ci = 3, Td = 4, si = 5, rS = 6;
class f_ {
  constructor(t) {
    this.options = Object.assign(Object.create(d_), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    const { log: n, minZoom: r, maxZoom: o } = this.options;
    n && console.time("total time");
    const i = `prepare ${t.length} points`;
    n && console.time(i), this.points = t;
    const s = [];
    for (let l = 0; l < t.length; l++) {
      const u = t[l];
      if (!u.geometry) continue;
      const [c, p] = u.geometry.coordinates, d = Xy(Ul(c)), g = Xy($l(p));
      s.push(
        d,
        g,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        l,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && s.push(0);
    }
    let a = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (let l = o; l >= r; l--) {
      const u = +Date.now();
      a = this.trees[l] = this._createTree(this._cluster(a, l)), n && console.log("z%d: %d clusters in %dms", l, a.numItems, +Date.now() - u);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    let r = ((t[0] + 180) % 360 + 360) % 360 - 180;
    const o = Math.max(-90, Math.min(90, t[1]));
    let i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
    const s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      const p = this.getClusters([r, o, 180, s], n), d = this.getClusters([-180, o, i, s], n);
      return p.concat(d);
    }
    const a = this.trees[this._limitZoom(n)], l = a.range(Ul(r), $l(s), Ul(i), $l(o)), u = a.data, c = [];
    for (const p of l) {
      const d = this.stride * p;
      c.push(u[d + si] > 1 ? Qy(u, d, this.clusterProps) : this.points[u[d + ci]]);
    }
    return c;
  }
  getChildren(t) {
    const n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    const s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    const a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (const d of c) {
      const g = d * this.stride;
      s[g + Td] === t && p.push(s[g + si] > 1 ? Qy(s, g, this.clusterProps) : this.points[s[g + ci]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    const o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    const o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), { extent: s, radius: a } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(
      o.range((n - l) / i, u, (n + 1 + l) / i, c),
      o.data,
      n,
      r,
      i,
      p
    ), n === 0 && this._addTileFeatures(
      o.range(1 - l / i, u, 1, c),
      o.data,
      i,
      r,
      i,
      p
    ), n === i - 1 && this._addTileFeatures(
      o.range(0, u, l / i, c),
      o.data,
      -1,
      r,
      i,
      p
    ), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    let n = this._getOriginZoom(t) - 1;
    for (; n <= this.options.maxZoom; ) {
      const r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    const s = this.getChildren(n);
    for (const a of s) {
      const l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    const n = new sm(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (const a of t) {
      const l = a * this.stride, u = n[l + si] > 1;
      let c, p, d;
      if (u)
        c = oS(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        const f = this.points[n[l + ci]];
        c = f.properties;
        const [h, E] = f.geometry.coordinates;
        p = Ul(h), d = $l(E);
      }
      const g = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (p * i - r)),
          Math.round(this.options.extent * (d * i - o))
        ]],
        tags: c
      };
      let m;
      u || this.options.generateId ? m = n[l + ci] : m = this.points[n[l + ci]].id, m !== void 0 && (g.id = m), s.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    const { radius: r, extent: o, reduce: i, minPoints: s } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride;
    for (let p = 0; p < l.length; p += c) {
      if (l[p + $i] <= n) continue;
      l[p + $i] = n;
      const d = l[p], g = l[p + 1], m = t.within(l[p], l[p + 1], a), f = l[p + si];
      let h = f;
      for (const E of m) {
        const L = E * c;
        l[L + $i] > n && (h += l[L + si]);
      }
      if (h > f && h >= s) {
        let E = d * f, L = g * f, x, T = -1;
        const w = ((p / c | 0) << 5) + (n + 1) + this.points.length;
        for (const C of m) {
          const k = C * c;
          if (l[k + $i] <= n) continue;
          l[k + $i] = n;
          const O = l[k + si];
          E += l[k] * O, L += l[k + 1] * O, l[k + Td] = w, i && (x || (x = this._map(l, p, !0), T = this.clusterProps.length, this.clusterProps.push(x)), i(x, this._map(l, k)));
        }
        l[p + Td] = w, u.push(E / h, L / h, 1 / 0, w, -1, h), i && u.push(T);
      } else {
        for (let E = 0; E < c; E++) u.push(l[p + E]);
        if (h > 1)
          for (const E of m) {
            const L = E * c;
            if (!(l[L + $i] <= n)) {
              l[L + $i] = n;
              for (let x = 0; x < c; x++) u.push(l[L + x]);
            }
          }
      }
    }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + si] > 1) {
      const s = this.clusterProps[t[n + rS]];
      return r ? Object.assign({}, s) : s;
    }
    const o = this.points[t[n + ci]].properties, i = this.options.map(o);
    return r && i === o ? Object.assign({}, i) : i;
  }
}
function Qy(e, t, n) {
  return {
    type: "Feature",
    id: e[t + ci],
    properties: oS(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [h_(e[t]), g_(e[t + 1])]
    }
  };
}
function oS(e, t, n) {
  const r = e[t + si], o = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, i = e[t + rS], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + ci],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Ul(e) {
  return e / 360 + 0.5;
}
function $l(e) {
  const t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function h_(e) {
  return (e - 0.5) * 360;
}
function g_(e) {
  const t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function m_(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Hr {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Sh {
  constructor({ markers: t, position: n }) {
    this.markers = t, n && (n instanceof google.maps.LatLng ? this._position = n : this._position = new google.maps.LatLng(n));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const t = new google.maps.LatLngBounds(this._position, this._position);
    for (const n of this.markers)
      t.extend(Hr.getPosition(n));
    return t;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Hr.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Hr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class v_ {
  constructor({ maxZoom: t = 16 }) {
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: t }) {
    return y_(t);
  }
}
const y_ = (e) => e.map((n) => new Sh({
  position: Hr.getPosition(n),
  markers: [n]
}));
class b_ extends v_ {
  constructor(t) {
    var { maxZoom: n, radius: r = 60 } = t, o = m_(t, ["maxZoom", "radius"]);
    super({ maxZoom: n }), this.state = { zoom: -1 }, this.superCluster = new f_(Object.assign({ maxZoom: this.maxZoom, radius: r }, o));
  }
  calculate(t) {
    let n = !1;
    const r = { zoom: t.map.getZoom() };
    if (!Gy(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      const o = this.markers.map((i) => {
        const s = Hr.getPosition(i);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [s.lng(), s.lat()]
          },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !Gy(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), { clusters: this.clusters, changed: n };
  }
  cluster({ map: t }) {
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t.getZoom())).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [t, n] }, properties: r }) {
    if (r.cluster)
      return new Sh({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((i) => i.properties.marker),
        position: { lat: n, lng: t }
      });
    const o = r.marker;
    return new Sh({
      markers: [o],
      position: Hr.getPosition(o)
    });
  }
}
class w_ {
  constructor(t, n) {
    this.markers = { sum: t.length };
    const r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class C_ {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: t, position: n }, r, o) {
    const s = `<svg fill="${t > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>
</svg>`, a = `Cluster of ${t} markers`, l = Number(google.maps.Marker.MAX_ZINDEX) + t;
    if (Hr.isAdvancedMarkerAvailable(o)) {
      const p = new DOMParser().parseFromString(s, "image/svg+xml").documentElement;
      p.setAttribute("transform", "translate(0 25)");
      const d = {
        map: o,
        position: n,
        zIndex: l,
        title: a,
        content: p
      };
      return new google.maps.marker.AdvancedMarkerElement(d);
    }
    const u = {
      position: n,
      zIndex: l,
      title: a,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(s)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(u);
  }
}
function E_(e, t) {
  for (let n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class am {
  constructor() {
    E_(am, google.maps.OverlayView);
  }
}
var xa;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(xa || (xa = {}));
const x_ = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class L_ extends am {
  constructor({ map: t, markers: n = [], algorithmOptions: r = {}, algorithm: o = new b_(r), renderer: i = new C_(), onClusterClick: s = x_ }) {
    super(), this.markers = [...n], this.clusters = [], this.algorithm = o, this.renderer = i, this.onClusterClick = s, t && this.setMap(t);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    const r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Hr.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    let r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, xa.CLUSTERING_BEGIN, this);
      const { clusters: n, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const o = /* @__PURE__ */ new Set();
        for (const s of n)
          s.markers.length == 1 && o.add(s.markers[0]);
        const i = [];
        for (const s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Hr.setMap(s.marker, null) : i.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => i.forEach((s) => Hr.setMap(s, null)));
      }
      google.maps.event.trigger(this, xa.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Hr.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    const t = new w_(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Hr.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, xa.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Hr.setMap(r.marker, n);
    });
  }
}
function k_(e) {
  var t = _B(), n = D(null), r = n[0], o = n[1];
  return v(function() {
    if (t && r === null) {
      var i = new L_(Ze(Ze({}, e), { map: t }));
      o(i);
    }
  }, [t]), r;
}
function D_(e) {
  var t = e.children, n = e.options, r = k_(n);
  return r !== null ? t(r) : null;
}
Re(D_);
var Jy = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, e0 = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
function S_(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, g = _e(ot), m = D(null), f = m[0], h = m[1], E = D(null), L = E[0], x = E[1], T = D(null), w = T[0], C = T[1], k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = rt(null);
  return v(function() {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(function() {
    o && f !== null && f.setPosition(o);
  }, [o]), v(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(function() {
    f && a && (w !== null && google.maps.event.removeListener(w), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(function() {
    f && l && (O !== null && google.maps.event.removeListener(O), U(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(function() {
    f && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(function() {
    f && c && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(function() {
    var I = new google.maps.InfoWindow(Ze({}, r || {}));
    return h(I), X.current = document.createElement("div"), s && x(google.maps.event.addListener(I, "closeclick", s)), a && C(google.maps.event.addListener(I, "domready", a)), l && U(google.maps.event.addListener(I, "content_changed", l)), u && $(google.maps.event.addListener(I, "position_changed", u)), c && H(google.maps.event.addListener(I, "zindex_changed", c)), I.setContent(X.current), o && I.setPosition(o), i && I.setZIndex(i), n ? I.open(g, n) : I.getPosition() ? I.open(g) : or(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(I), function() {
      L && google.maps.event.removeListener(L), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), V && google.maps.event.removeListener(V), R && google.maps.event.removeListener(R), d && d(I), I.close();
    };
  }, []), X.current ? Lr(Mt.only(t), X.current) : null;
}
Re(S_);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoWindow: null
    }, n.open = function(r, o) {
      o ? r.open(n.context, o) : r.getPosition() ? r.open(n.context) : or(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }, n.setInfoWindowCallback = function() {
      n.state.infoWindow !== null && n.containerElement !== null && (n.state.infoWindow.setContent(n.containerElement), n.open(n.state.infoWindow, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoWindow));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.InfoWindow(Ze({}, this.props.options || {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = vt({
      updaterMap: e0,
      eventMap: Jy,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        infoWindow: n
      };
    }, this.setInfoWindowCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.infoWindow !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: e0,
      eventMap: Jy,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.infoWindow !== null && (kt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Lr(Mt.only(this.props.children), this.containerElement) : null;
  }, t.contextType = ot, t;
})(ke);
var t0 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, n0 = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, O_ = {};
function M_(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, g = e.onMouseUp, m = e.onRightClick, f = e.onClick, h = e.onDrag, E = e.onLoad, L = e.onUnmount, x = _e(ot), T = D(null), w = T[0], C = T[1], k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = D(null), I = X[0], J = X[1], te = D(null), S = te[0], P = te[1], q = D(null), j = q[0], Z = q[1], G = D(null), b = G[0], F = G[1], z = D(null), A = z[0], Y = z[1], ee = D(null), B = ee[0], se = ee[1], ue = D(null), ce = ue[0], de = ue[1], be = D(null), ge = be[0], me = be[1];
  return v(function() {
    w !== null && w.setMap(x);
  }, [x]), v(function() {
    typeof t < "u" && w !== null && w.setOptions(t);
  }, [w, t]), v(function() {
    typeof n < "u" && w !== null && w.setDraggable(n);
  }, [w, n]), v(function() {
    typeof r < "u" && w !== null && w.setEditable(r);
  }, [w, r]), v(function() {
    typeof o < "u" && w !== null && w.setVisible(o);
  }, [w, o]), v(function() {
    typeof i < "u" && w !== null && w.setPath(i);
  }, [w, i]), v(function() {
    w && s && (O !== null && google.maps.event.removeListener(O), U(google.maps.event.addListener(w, "dblclick", s)));
  }, [s]), v(function() {
    w && a && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "dragend", a)));
  }, [a]), v(function() {
    w && l && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(w, "dragstart", l)));
  }, [l]), v(function() {
    w && u && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(w, "mousedown", u)));
  }, [u]), v(function() {
    w && c && (S !== null && google.maps.event.removeListener(S), P(google.maps.event.addListener(w, "mousemove", c)));
  }, [c]), v(function() {
    w && p && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "mouseout", p)));
  }, [p]), v(function() {
    w && d && (b !== null && google.maps.event.removeListener(b), F(google.maps.event.addListener(w, "mouseover", d)));
  }, [d]), v(function() {
    w && g && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(w, "mouseup", g)));
  }, [g]), v(function() {
    w && m && (B !== null && google.maps.event.removeListener(B), se(google.maps.event.addListener(w, "rightclick", m)));
  }, [m]), v(function() {
    w && f && (ce !== null && google.maps.event.removeListener(ce), de(google.maps.event.addListener(w, "click", f)));
  }, [f]), v(function() {
    w && h && (ge !== null && google.maps.event.removeListener(ge), me(google.maps.event.addListener(w, "drag", h)));
  }, [h]), v(function() {
    var ae = new google.maps.Polyline(Ze(Ze({}, t || O_), { map: x }));
    return i && ae.setPath(i), typeof o < "u" && ae.setVisible(o), typeof r < "u" && ae.setEditable(r), typeof n < "u" && ae.setDraggable(n), s && U(google.maps.event.addListener(ae, "dblclick", s)), a && $(google.maps.event.addListener(ae, "dragend", a)), l && H(google.maps.event.addListener(ae, "dragstart", l)), u && J(google.maps.event.addListener(ae, "mousedown", u)), c && P(google.maps.event.addListener(ae, "mousemove", c)), p && Z(google.maps.event.addListener(ae, "mouseout", p)), d && F(google.maps.event.addListener(ae, "mouseover", d)), g && Y(google.maps.event.addListener(ae, "mouseup", g)), m && se(google.maps.event.addListener(ae, "rightclick", m)), f && de(google.maps.event.addListener(ae, "click", f)), h && me(google.maps.event.addListener(ae, "drag", h)), C(ae), E && E(ae), function() {
      O !== null && google.maps.event.removeListener(O), V !== null && google.maps.event.removeListener(V), R !== null && google.maps.event.removeListener(R), I !== null && google.maps.event.removeListener(I), S !== null && google.maps.event.removeListener(S), j !== null && google.maps.event.removeListener(j), b !== null && google.maps.event.removeListener(b), A !== null && google.maps.event.removeListener(A), B !== null && google.maps.event.removeListener(B), ce !== null && google.maps.event.removeListener(ce), L && L(ae), ae.setMap(null);
    };
  }, []), null;
}
Re(M_);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polyline: null
    }, n.setPolylineCallback = function() {
      n.state.polyline !== null && n.props.onLoad && n.props.onLoad(n.state.polyline);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polyline(Ze(Ze({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = vt({
      updaterMap: n0,
      eventMap: t0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polyline: n
      };
    }, this.setPolylineCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polyline !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: n0,
      eventMap: t0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), kt(this.registeredEvents), this.state.polyline.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
var r0 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, o0 = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  paths: function(e, t) {
    e.setPaths(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function P_(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.paths, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, g = e.onMouseOver, m = e.onMouseUp, f = e.onRightClick, h = e.onClick, E = e.onDrag, L = e.onLoad, x = e.onUnmount, T = e.onEdit, w = _e(ot), C = D(null), k = C[0], O = C[1], U = D(null), M = U[0], V = U[1], $ = D(null), W = $[0], R = $[1], H = D(null), X = H[0], I = H[1], J = D(null), te = J[0], S = J[1], P = D(null), q = P[0], j = P[1], Z = D(null), G = Z[0], b = Z[1], F = D(null), z = F[0], A = F[1], Y = D(null), ee = Y[0], B = Y[1], se = D(null), ue = se[0], ce = se[1], de = D(null), be = de[0], ge = de[1], me = D(null), ae = me[0], xe = me[1];
  return v(function() {
    k !== null && k.setMap(w);
  }, [w]), v(function() {
    typeof t < "u" && k !== null && k.setOptions(t);
  }, [k, t]), v(function() {
    typeof n < "u" && k !== null && k.setDraggable(n);
  }, [k, n]), v(function() {
    typeof r < "u" && k !== null && k.setEditable(r);
  }, [k, r]), v(function() {
    typeof o < "u" && k !== null && k.setVisible(o);
  }, [k, o]), v(function() {
    typeof i < "u" && k !== null && k.setPath(i);
  }, [k, i]), v(function() {
    typeof s < "u" && k !== null && k.setPaths(s);
  }, [k, s]), v(function() {
    k && a && (M !== null && google.maps.event.removeListener(M), V(google.maps.event.addListener(k, "dblclick", a)));
  }, [a]), v(function() {
    k && (google.maps.event.addListener(k.getPath(), "insert_at", function() {
      T == null || T(k);
    }), google.maps.event.addListener(k.getPath(), "set_at", function() {
      T == null || T(k);
    }));
  }, [k, T]), v(function() {
    k && l && (W !== null && google.maps.event.removeListener(W), R(google.maps.event.addListener(k, "dragend", l)));
  }, [l]), v(function() {
    k && u && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(k, "dragstart", u)));
  }, [u]), v(function() {
    k && c && (te !== null && google.maps.event.removeListener(te), S(google.maps.event.addListener(k, "mousedown", c)));
  }, [c]), v(function() {
    k && p && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(k, "mousemove", p)));
  }, [p]), v(function() {
    k && d && (G !== null && google.maps.event.removeListener(G), b(google.maps.event.addListener(k, "mouseout", d)));
  }, [d]), v(function() {
    k && g && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(k, "mouseover", g)));
  }, [g]), v(function() {
    k && m && (ee !== null && google.maps.event.removeListener(ee), B(google.maps.event.addListener(k, "mouseup", m)));
  }, [m]), v(function() {
    k && f && (ue !== null && google.maps.event.removeListener(ue), ce(google.maps.event.addListener(k, "rightclick", f)));
  }, [f]), v(function() {
    k && h && (be !== null && google.maps.event.removeListener(be), ge(google.maps.event.addListener(k, "click", h)));
  }, [h]), v(function() {
    k && E && (ae !== null && google.maps.event.removeListener(ae), xe(google.maps.event.addListener(k, "drag", E)));
  }, [E]), v(function() {
    var re = new google.maps.Polygon(Ze(Ze({}, t || {}), { map: w }));
    return i && re.setPath(i), s && re.setPaths(s), typeof o < "u" && re.setVisible(o), typeof r < "u" && re.setEditable(r), typeof n < "u" && re.setDraggable(n), a && V(google.maps.event.addListener(re, "dblclick", a)), l && R(google.maps.event.addListener(re, "dragend", l)), u && I(google.maps.event.addListener(re, "dragstart", u)), c && S(google.maps.event.addListener(re, "mousedown", c)), p && j(google.maps.event.addListener(re, "mousemove", p)), d && b(google.maps.event.addListener(re, "mouseout", d)), g && A(google.maps.event.addListener(re, "mouseover", g)), m && B(google.maps.event.addListener(re, "mouseup", m)), f && ce(google.maps.event.addListener(re, "rightclick", f)), h && ge(google.maps.event.addListener(re, "click", h)), E && xe(google.maps.event.addListener(re, "drag", E)), O(re), L && L(re), function() {
      M !== null && google.maps.event.removeListener(M), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), q !== null && google.maps.event.removeListener(q), G !== null && google.maps.event.removeListener(G), z !== null && google.maps.event.removeListener(z), ee !== null && google.maps.event.removeListener(ee), ue !== null && google.maps.event.removeListener(ue), be !== null && google.maps.event.removeListener(be), x && x(re), re.setMap(null);
    };
  }, []), null;
}
Re(P_);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polygon: null
    }, n.setPolygonCallback = function() {
      n.state.polygon !== null && n.props.onLoad && n.props.onLoad(n.state.polygon);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polygon(Ze(Ze({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = vt({
      updaterMap: o0,
      eventMap: r0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polygon: n
      };
    }, this.setPolygonCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polygon !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: o0,
      eventMap: r0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polygon
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polygon !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polygon), kt(this.registeredEvents), this.state.polygon && this.state.polygon.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
var i0 = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, s0 = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function T_(e) {
  var t = e.options, n = e.bounds, r = e.draggable, o = e.editable, i = e.visible, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, g = e.onMouseUp, m = e.onRightClick, f = e.onClick, h = e.onDrag, E = e.onBoundsChanged, L = e.onLoad, x = e.onUnmount, T = _e(ot), w = D(null), C = w[0], k = w[1], O = D(null), U = O[0], M = O[1], V = D(null), $ = V[0], W = V[1], R = D(null), H = R[0], X = R[1], I = D(null), J = I[0], te = I[1], S = D(null), P = S[0], q = S[1], j = D(null), Z = j[0], G = j[1], b = D(null), F = b[0], z = b[1], A = D(null), Y = A[0], ee = A[1], B = D(null), se = B[0], ue = B[1], ce = D(null), de = ce[0], be = ce[1], ge = D(null), me = ge[0], ae = ge[1], xe = D(null), re = xe[0], Te = xe[1];
  return v(function() {
    C !== null && C.setMap(T);
  }, [T]), v(function() {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(function() {
    typeof r < "u" && C !== null && C.setDraggable(r);
  }, [C, r]), v(function() {
    typeof o < "u" && C !== null && C.setEditable(o);
  }, [C, o]), v(function() {
    typeof i < "u" && C !== null && C.setVisible(i);
  }, [C, i]), v(function() {
    typeof n < "u" && C !== null && C.setBounds(n);
  }, [C, n]), v(function() {
    C && s && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(function() {
    C && a && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(C, "dragend", a)));
  }, [a]), v(function() {
    C && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "dragstart", l)));
  }, [l]), v(function() {
    C && u && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(C, "mousedown", u)));
  }, [u]), v(function() {
    C && c && (P !== null && google.maps.event.removeListener(P), q(google.maps.event.addListener(C, "mousemove", c)));
  }, [c]), v(function() {
    C && p && (Z !== null && google.maps.event.removeListener(Z), G(google.maps.event.addListener(C, "mouseout", p)));
  }, [p]), v(function() {
    C && d && (F !== null && google.maps.event.removeListener(F), z(google.maps.event.addListener(C, "mouseover", d)));
  }, [d]), v(function() {
    C && g && (Y !== null && google.maps.event.removeListener(Y), ee(google.maps.event.addListener(C, "mouseup", g)));
  }, [g]), v(function() {
    C && m && (se !== null && google.maps.event.removeListener(se), ue(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(function() {
    C && f && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(C, "click", f)));
  }, [f]), v(function() {
    C && h && (me !== null && google.maps.event.removeListener(me), ae(google.maps.event.addListener(C, "drag", h)));
  }, [h]), v(function() {
    C && E && (re !== null && google.maps.event.removeListener(re), Te(google.maps.event.addListener(C, "bounds_changed", E)));
  }, [E]), v(function() {
    var ne = new google.maps.Rectangle(Ze(Ze({}, t || {}), { map: T }));
    return typeof i < "u" && ne.setVisible(i), typeof o < "u" && ne.setEditable(o), typeof r < "u" && ne.setDraggable(r), typeof n < "u" && ne.setBounds(n), s && M(google.maps.event.addListener(ne, "dblclick", s)), a && W(google.maps.event.addListener(ne, "dragend", a)), l && X(google.maps.event.addListener(ne, "dragstart", l)), u && te(google.maps.event.addListener(ne, "mousedown", u)), c && q(google.maps.event.addListener(ne, "mousemove", c)), p && G(google.maps.event.addListener(ne, "mouseout", p)), d && z(google.maps.event.addListener(ne, "mouseover", d)), g && ee(google.maps.event.addListener(ne, "mouseup", g)), m && ue(google.maps.event.addListener(ne, "rightclick", m)), f && be(google.maps.event.addListener(ne, "click", f)), h && ae(google.maps.event.addListener(ne, "drag", h)), E && Te(google.maps.event.addListener(ne, "bounds_changed", E)), k(ne), L && L(ne), function() {
      U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), P !== null && google.maps.event.removeListener(P), Z !== null && google.maps.event.removeListener(Z), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), se !== null && google.maps.event.removeListener(se), de !== null && google.maps.event.removeListener(de), me !== null && google.maps.event.removeListener(me), re !== null && google.maps.event.removeListener(re), x && x(ne), ne.setMap(null);
    };
  }, []), null;
}
Re(T_);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      rectangle: null
    }, n.setRectangleCallback = function() {
      n.state.rectangle !== null && n.props.onLoad && n.props.onLoad(n.state.rectangle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Rectangle(Ze(Ze({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = vt({
      updaterMap: s0,
      eventMap: i0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        rectangle: n
      };
    }, this.setRectangleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.rectangle !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: s0,
      eventMap: i0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), kt(this.registeredEvents), this.state.rectangle.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
var a0 = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, l0 = {
  center: function(e, t) {
    e.setCenter(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  radius: function(e, t) {
    e.setRadius(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, A_ = {};
function B_(e) {
  var t = e.options, n = e.center, r = e.radius, o = e.draggable, i = e.editable, s = e.visible, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, g = e.onMouseOver, m = e.onMouseUp, f = e.onRightClick, h = e.onClick, E = e.onDrag, L = e.onCenterChanged, x = e.onRadiusChanged, T = e.onLoad, w = e.onUnmount, C = _e(ot), k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = D(null), I = X[0], J = X[1], te = D(null), S = te[0], P = te[1], q = D(null), j = q[0], Z = q[1], G = D(null), b = G[0], F = G[1], z = D(null), A = z[0], Y = z[1], ee = D(null), B = ee[0], se = ee[1], ue = D(null), ce = ue[0], de = ue[1], be = D(null), ge = be[0], me = be[1], ae = D(null), xe = ae[0], re = ae[1], Te = D(null), ne = Te[0], Ee = Te[1], Ne = D(null), Fe = Ne[0], Ue = Ne[1];
  return v(function() {
    O !== null && O.setMap(C);
  }, [C]), v(function() {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), v(function() {
    typeof o < "u" && O !== null && O.setDraggable(o);
  }, [O, o]), v(function() {
    typeof i < "u" && O !== null && O.setEditable(i);
  }, [O, i]), v(function() {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(function() {
    typeof r == "number" && O !== null && O.setRadius(r);
  }, [O, r]), v(function() {
    typeof n < "u" && O !== null && O.setCenter(n);
  }, [O, n]), v(function() {
    O && a && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), v(function() {
    O && l && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), v(function() {
    O && u && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), v(function() {
    O && c && (S !== null && google.maps.event.removeListener(S), P(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), v(function() {
    O && p && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(O, "mousemove", p)));
  }, [p]), v(function() {
    O && d && (b !== null && google.maps.event.removeListener(b), F(google.maps.event.addListener(O, "mouseout", d)));
  }, [d]), v(function() {
    O && g && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(O, "mouseover", g)));
  }, [g]), v(function() {
    O && m && (B !== null && google.maps.event.removeListener(B), se(google.maps.event.addListener(O, "mouseup", m)));
  }, [m]), v(function() {
    O && f && (ce !== null && google.maps.event.removeListener(ce), de(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), v(function() {
    O && h && (ge !== null && google.maps.event.removeListener(ge), me(google.maps.event.addListener(O, "click", h)));
  }, [h]), v(function() {
    O && E && (xe !== null && google.maps.event.removeListener(xe), re(google.maps.event.addListener(O, "drag", E)));
  }, [E]), v(function() {
    O && L && (ne !== null && google.maps.event.removeListener(ne), Ee(google.maps.event.addListener(O, "center_changed", L)));
  }, [h]), v(function() {
    O && x && (Fe !== null && google.maps.event.removeListener(Fe), Ue(google.maps.event.addListener(O, "radius_changed", x)));
  }, [x]), v(function() {
    var he = new google.maps.Circle(Ze(Ze({}, t || A_), { map: C }));
    return typeof r == "number" && he.setRadius(r), typeof n < "u" && he.setCenter(n), typeof r == "number" && he.setRadius(r), typeof s < "u" && he.setVisible(s), typeof i < "u" && he.setEditable(i), typeof o < "u" && he.setDraggable(o), a && $(google.maps.event.addListener(he, "dblclick", a)), l && H(google.maps.event.addListener(he, "dragend", l)), u && J(google.maps.event.addListener(he, "dragstart", u)), c && P(google.maps.event.addListener(he, "mousedown", c)), p && Z(google.maps.event.addListener(he, "mousemove", p)), d && F(google.maps.event.addListener(he, "mouseout", d)), g && Y(google.maps.event.addListener(he, "mouseover", g)), m && se(google.maps.event.addListener(he, "mouseup", m)), f && de(google.maps.event.addListener(he, "rightclick", f)), h && me(google.maps.event.addListener(he, "click", h)), E && re(google.maps.event.addListener(he, "drag", E)), L && Ee(google.maps.event.addListener(he, "center_changed", L)), x && Ue(google.maps.event.addListener(he, "radius_changed", x)), U(he), T && T(he), function() {
      V !== null && google.maps.event.removeListener(V), R !== null && google.maps.event.removeListener(R), I !== null && google.maps.event.removeListener(I), S !== null && google.maps.event.removeListener(S), j !== null && google.maps.event.removeListener(j), b !== null && google.maps.event.removeListener(b), A !== null && google.maps.event.removeListener(A), B !== null && google.maps.event.removeListener(B), ce !== null && google.maps.event.removeListener(ce), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), Fe !== null && google.maps.event.removeListener(Fe), w && w(he), he.setMap(null);
    };
  }, []), null;
}
Re(B_);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      circle: null
    }, n.setCircleCallback = function() {
      n.state.circle !== null && n.props.onLoad && n.props.onLoad(n.state.circle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Circle(Ze(Ze({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = vt({
      updaterMap: l0,
      eventMap: a0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        circle: n
      };
    }, this.setCircleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.circle !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: l0,
      eventMap: a0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n;
    this.state.circle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.circle), kt(this.registeredEvents), (n = this.state.circle) === null || n === void 0 || n.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
var u0 = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, c0 = {
  add: function(e, t) {
    e.add(t);
  },
  addgeojson: function(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains: function(e, t) {
    e.contains(t);
  },
  foreach: function(e, t) {
    e.forEach(t);
  },
  loadgeojson: function(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle: function(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove: function(e, t) {
    e.remove(t);
  },
  revertstyle: function(e, t) {
    e.revertStyle(t);
  },
  controlposition: function(e, t) {
    e.setControlPosition(t);
  },
  controls: function(e, t) {
    e.setControls(t);
  },
  drawingmode: function(e, t) {
    e.setDrawingMode(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  style: function(e, t) {
    e.setStyle(t);
  },
  togeojson: function(e, t) {
    e.toGeoJson(t);
  }
};
function __(e) {
  var t = e.options, n = e.onClick, r = e.onDblClick, o = e.onMouseDown, i = e.onMouseMove, s = e.onMouseOut, a = e.onMouseOver, l = e.onMouseUp, u = e.onRightClick, c = e.onAddFeature, p = e.onRemoveFeature, d = e.onRemoveProperty, g = e.onSetGeometry, m = e.onSetProperty, f = e.onLoad, h = e.onUnmount, E = _e(ot), L = D(null), x = L[0], T = L[1], w = D(null), C = w[0], k = w[1], O = D(null), U = O[0], M = O[1], V = D(null), $ = V[0], W = V[1], R = D(null), H = R[0], X = R[1], I = D(null), J = I[0], te = I[1], S = D(null), P = S[0], q = S[1], j = D(null), Z = j[0], G = j[1], b = D(null), F = b[0], z = b[1], A = D(null), Y = A[0], ee = A[1], B = D(null), se = B[0], ue = B[1], ce = D(null), de = ce[0], be = ce[1], ge = D(null), me = ge[0], ae = ge[1], xe = D(null), re = xe[0], Te = xe[1];
  return v(function() {
    x !== null && x.setMap(E);
  }, [E]), v(function() {
    x && r && (C !== null && google.maps.event.removeListener(C), k(google.maps.event.addListener(x, "dblclick", r)));
  }, [r]), v(function() {
    x && o && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(x, "mousedown", o)));
  }, [o]), v(function() {
    x && i && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(x, "mousemove", i)));
  }, [i]), v(function() {
    x && s && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mouseout", s)));
  }, [s]), v(function() {
    x && a && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(x, "mouseover", a)));
  }, [a]), v(function() {
    x && l && (P !== null && google.maps.event.removeListener(P), q(google.maps.event.addListener(x, "mouseup", l)));
  }, [l]), v(function() {
    x && u && (Z !== null && google.maps.event.removeListener(Z), G(google.maps.event.addListener(x, "rightclick", u)));
  }, [u]), v(function() {
    x && n && (F !== null && google.maps.event.removeListener(F), z(google.maps.event.addListener(x, "click", n)));
  }, [n]), v(function() {
    x && c && (Y !== null && google.maps.event.removeListener(Y), ee(google.maps.event.addListener(x, "addfeature", c)));
  }, [c]), v(function() {
    x && p && (se !== null && google.maps.event.removeListener(se), ue(google.maps.event.addListener(x, "removefeature", p)));
  }, [p]), v(function() {
    x && d && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(x, "removeproperty", d)));
  }, [d]), v(function() {
    x && g && (me !== null && google.maps.event.removeListener(me), ae(google.maps.event.addListener(x, "setgeometry", g)));
  }, [g]), v(function() {
    x && m && (re !== null && google.maps.event.removeListener(re), Te(google.maps.event.addListener(x, "setproperty", m)));
  }, [m]), v(function() {
    if (E !== null) {
      var ne = new google.maps.Data(Ze(Ze({}, t || {}), { map: E }));
      r && k(google.maps.event.addListener(ne, "dblclick", r)), o && M(google.maps.event.addListener(ne, "mousedown", o)), i && W(google.maps.event.addListener(ne, "mousemove", i)), s && X(google.maps.event.addListener(ne, "mouseout", s)), a && te(google.maps.event.addListener(ne, "mouseover", a)), l && q(google.maps.event.addListener(ne, "mouseup", l)), u && G(google.maps.event.addListener(ne, "rightclick", u)), n && z(google.maps.event.addListener(ne, "click", n)), c && ee(google.maps.event.addListener(ne, "addfeature", c)), p && ue(google.maps.event.addListener(ne, "removefeature", p)), d && be(google.maps.event.addListener(ne, "removeproperty", d)), g && ae(google.maps.event.addListener(ne, "setgeometry", g)), m && Te(google.maps.event.addListener(ne, "setproperty", m)), T(ne), f && f(ne);
    }
    return function() {
      x && (C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), P !== null && google.maps.event.removeListener(P), Z !== null && google.maps.event.removeListener(Z), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), se !== null && google.maps.event.removeListener(se), de !== null && google.maps.event.removeListener(de), me !== null && google.maps.event.removeListener(me), re !== null && google.maps.event.removeListener(re), h && h(x), x.setMap(null));
    };
  }, []), null;
}
Re(__);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      data: null
    }, n.setDataCallback = function() {
      n.state.data !== null && n.props.onLoad && n.props.onLoad(n.state.data);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context !== null) {
      var n = new google.maps.Data(Ze(Ze({}, this.props.options || {}), { map: this.context }));
      this.registeredEvents = vt({
        updaterMap: c0,
        eventMap: u0,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          data: n
        };
      }, this.setDataCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.data !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: c0,
      eventMap: u0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.data
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), kt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
var p0 = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, d0 = {
  options: function(e, t) {
    e.setOptions(t);
  },
  url: function(e, t) {
    e.setUrl(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      kmlLayer: null
    }, n.setKmlLayerCallback = function() {
      n.state.kmlLayer !== null && n.props.onLoad && n.props.onLoad(n.state.kmlLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.KmlLayer(Ze(Ze({}, this.props.options), { map: this.context }));
    this.registeredEvents = vt({
      updaterMap: d0,
      eventMap: p0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        kmlLayer: n
      };
    }, this.setKmlLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.kmlLayer !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: d0,
      eventMap: p0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), kt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
function iS(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function I_(e, t) {
  return new t(e.lat, e.lng);
}
function j_(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function N_(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function F_(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function R_(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function z_(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var o = r.x, i = r.y;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function sS(e, t, n, r) {
  return n !== void 0 ? R_(e, t, F_(n, google.maps.LatLngBounds, j_)) : z_(e, t, N_(r, google.maps.LatLng, I_));
}
function U_(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function $_(e, t, n, r, o) {
  var i = (
    /** @class */
    function(s) {
      hn(a, s);
      function a(l, u, c, p) {
        var d = s.call(this) || this;
        return d.container = l, d.pane = u, d.position = c, d.bounds = p, d;
      }
      return a.prototype.onAdd = function() {
        var l, u = (l = this.getPanes()) === null || l === void 0 ? void 0 : l[this.pane];
        u == null || u.appendChild(this.container);
      }, a.prototype.draw = function() {
        for (var l = this.getProjection(), u = Ze({}, this.container ? iS(this.container, o) : {
          x: 0,
          y: 0
        }), c = sS(l, u, this.bounds, this.position), p = 0, d = Object.entries(c); p < d.length; p++) {
          var g = d[p], m = g[0], f = g[1];
          this.container.style[m] = f;
        }
      }, a.prototype.onRemove = function() {
        this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
      }, a;
    }(google.maps.OverlayView)
  );
  return new i(e, t, n, r);
}
function f0(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function h0(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function W_(e) {
  var t = e.position, n = e.bounds, r = e.mapPaneName, o = e.zIndex, i = e.onLoad, s = e.onUnmount, a = e.getPixelPositionOffset, l = e.children, u = _e(ot), c = rr(function() {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = rr(function() {
    return $_(c, r, t, n, a);
  }, [c, r, t, n]);
  return v(function() {
    return i == null || i(p), p == null || p.setMap(u), function() {
      s == null || s(p), p == null || p.setMap(null);
    };
  }, [u, p]), v(function() {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Di.createPortal(l, c);
}
Re(W_);
(function(e) {
  hn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    r.state = {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }, r.updatePane = function() {
      var i = r.props.mapPaneName, s = r.overlayView.getPanes();
      or(!!i, "OverlayView requires props.mapPaneName but got %s", i), s ? r.setState({
        paneEl: s[i]
      }) : r.setState({
        paneEl: null
      });
    }, r.onAdd = function() {
      var i, s;
      r.updatePane(), (s = (i = r.props).onLoad) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.onPositionElement = function() {
      var i = r.overlayView.getProjection(), s = Ze({ x: 0, y: 0 }, r.containerRef.current ? iS(r.containerRef.current, r.props.getPixelPositionOffset) : {}), a = sS(i, s, r.props.bounds, r.props.position), l = r.state.containerStyle, u = l.left, c = l.top, p = l.width, d = l.height;
      U_(a, { left: u, top: c, width: p, height: d }) || r.setState({
        containerStyle: {
          top: a.top || 0,
          left: a.left || 0,
          width: a.width || 0,
          height: a.height || 0,
          position: "absolute"
        }
      });
    }, r.draw = function() {
      r.onPositionElement();
    }, r.onRemove = function() {
      var i, s;
      r.setState(function() {
        return {
          paneEl: null
        };
      }), (s = (i = r.props).onUnmount) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.containerRef = xr();
    var o = new google.maps.OverlayView();
    return o.onAdd = r.onAdd, o.draw = r.draw, o.onRemove = r.onRemove, r.overlayView = o, r;
  }
  return t.prototype.componentDidMount = function() {
    this.overlayView.setMap(this.context);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = f0(n.position), o = f0(this.props.position), i = h0(n.bounds), s = h0(this.props.bounds);
    (r !== o || i !== s) && this.overlayView.draw(), n.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }, t.prototype.componentWillUnmount = function() {
    this.overlayView.setMap(null);
  }, t.prototype.render = function() {
    var n = this.state.paneEl;
    return n ? Di.createPortal(Q.jsx("div", { ref: this.containerRef, style: this.state.containerStyle, children: Mt.only(this.props.children) }), n) : null;
  }, t.FLOAT_PANE = "floatPane", t.MAP_PANE = "mapPane", t.MARKER_LAYER = "markerLayer", t.OVERLAY_LAYER = "overlayLayer", t.OVERLAY_MOUSE_TARGET = "overlayMouseTarget", t.contextType = ot, t;
})(ke);
function H_() {
}
var g0 = {
  onDblClick: "dblclick",
  onClick: "click"
}, m0 = {
  opacity: function(e, t) {
    e.setOpacity(t);
  }
};
function V_(e) {
  var t = e.url, n = e.bounds, r = e.options, o = e.visible, i = _e(ot), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = rr(function() {
    var l = new google.maps.GroundOverlay(t, s, Ze({}, r));
    return l;
  }, []);
  return v(function() {
    a !== null && a.setMap(i);
  }, [i]), v(function() {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), v(function() {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), v(function() {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Re(V_);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      groundOverlay: null
    }, n.setGroundOverlayCallback = function() {
      n.state.groundOverlay !== null && n.props.onLoad && n.props.onLoad(n.state.groundOverlay);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    or(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var n = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Ze(Ze({}, this.props.options), { map: this.context }));
    this.registeredEvents = vt({
      updaterMap: m0,
      eventMap: g0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        groundOverlay: n
      };
    }, this.setGroundOverlayCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.groundOverlay !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: m0,
      eventMap: g0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.defaultProps = {
    onLoad: H_
  }, t.contextType = ot, t;
})(ke);
var v0 = {}, y0 = {
  data: function(e, t) {
    e.setData(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function Z_(e) {
  var t = e.data, n = e.onLoad, r = e.onUnmount, o = e.options, i = _e(ot), s = D(null), a = s[0], l = s[1];
  return v(function() {
    google.maps.visualization || or(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(function() {
    or(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(function() {
    a !== null && a.setMap(i);
  }, [i]), v(function() {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(function() {
    var u = new google.maps.visualization.HeatmapLayer(Ze(Ze({}, o || {}), { data: t, map: i }));
    return l(u), n && n(u), function() {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Re(Z_);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      heatmapLayer: null
    }, n.setHeatmapLayerCallback = function() {
      n.state.heatmapLayer !== null && n.props.onLoad && n.props.onLoad(n.state.heatmapLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    or(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), or(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var n = new google.maps.visualization.HeatmapLayer(Ze(Ze({}, this.props.options || {}), { data: this.props.data, map: this.context }));
    this.registeredEvents = vt({
      updaterMap: y0,
      eventMap: v0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        heatmapLayer: n
      };
    }, this.setHeatmapLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: y0,
      eventMap: v0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), kt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
var b0 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, w0 = {
  register: function(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links: function(e, t) {
    e.setLinks(t);
  },
  motionTracking: function(e, t) {
    e.setMotionTracking(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  pano: function(e, t) {
    e.setPano(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  pov: function(e, t) {
    e.setPov(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      streetViewPanorama: null
    }, n.setStreetViewPanoramaCallback = function() {
      n.state.streetViewPanorama !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewPanorama);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n, r, o = (r = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && r !== void 0 ? r : null;
    this.registeredEvents = vt({
      updaterMap: w0,
      eventMap: b0,
      prevProps: {},
      nextProps: this.props,
      instance: o
    }), this.setState(function() {
      return {
        streetViewPanorama: o
      };
    }, this.setStreetViewPanoramaCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.streetViewPanorama !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: w0,
      eventMap: b0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), kt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      streetViewService: null
    }, n.setStreetViewServiceCallback = function() {
      n.state.streetViewService !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: n
      };
    }, this.setStreetViewServiceCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = ot, t;
})(ke);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      directionsService: null
    }, n.setDirectionsServiceCallback = function() {
      n.state.directionsService !== null && n.props.onLoad && n.props.onLoad(n.state.directionsService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    or(!!this.props.options, "DirectionsService expected options object as parameter, but got %s", this.props.options);
    var n = new google.maps.DirectionsService();
    this.setState(function() {
      return {
        directionsService: n
      };
    }, this.setDirectionsServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.directionsService !== null && this.state.directionsService.route(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsService !== null && this.props.onUnmount && this.props.onUnmount(this.state.directionsService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(ke);
var C0 = {
  onDirectionsChanged: "directions_changed"
}, E0 = {
  directions: function(e, t) {
    e.setDirections(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  panel: function(e, t) {
    e.setPanel(t);
  },
  routeIndex: function(e, t) {
    e.setRouteIndex(t);
  }
};
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      directionsRenderer: null
    }, n.setDirectionsRendererCallback = function() {
      n.state.directionsRenderer !== null && (n.state.directionsRenderer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.directionsRenderer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = vt({
      updaterMap: E0,
      eventMap: C0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        directionsRenderer: n
      };
    }, this.setDirectionsRendererCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.directionsRenderer !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: E0,
      eventMap: C0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), kt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }, t.prototype.render = function() {
    return Q.jsx(Q.Fragment, {});
  }, t.contextType = ot, t;
})(ke);
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      distanceMatrixService: null
    }, n.setDistanceMatrixServiceCallback = function() {
      n.state.distanceMatrixService !== null && n.props.onLoad && n.props.onLoad(n.state.distanceMatrixService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    or(!!this.props.options, "DistanceMatrixService expected options object as parameter, but go %s", this.props.options);
    var n = new google.maps.DistanceMatrixService();
    this.setState(function() {
      return {
        distanceMatrixService: n
      };
    }, this.setDistanceMatrixServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.distanceMatrixService !== null && this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.distanceMatrixService !== null && this.props.onUnmount && this.props.onUnmount(this.state.distanceMatrixService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(ke);
var x0 = {
  onPlacesChanged: "places_changed"
}, L0 = {
  bounds: function(e, t) {
    e.setBounds(t);
  }
}, q_ = (
  /** @class */
  function(e) {
    hn(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.registeredEvents = [], n.containerElement = xr(), n.state = {
        searchBox: null
      }, n.setSearchBoxCallback = function() {
        n.state.searchBox !== null && n.props.onLoad && n.props.onLoad(n.state.searchBox);
      }, n;
    }
    return t.prototype.componentDidMount = function() {
      if (or(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
        var n = this.containerElement.current.querySelector("input");
        if (n !== null) {
          var r = new google.maps.places.SearchBox(n, this.props.options);
          this.registeredEvents = vt({
            updaterMap: L0,
            eventMap: x0,
            prevProps: {},
            nextProps: this.props,
            instance: r
          }), this.setState(function() {
            return {
              searchBox: r
            };
          }, this.setSearchBoxCallback);
        }
      }
    }, t.prototype.componentDidUpdate = function(n) {
      this.state.searchBox !== null && (kt(this.registeredEvents), this.registeredEvents = vt({
        updaterMap: L0,
        eventMap: x0,
        prevProps: n,
        nextProps: this.props,
        instance: this.state.searchBox
      }));
    }, t.prototype.componentWillUnmount = function() {
      this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), kt(this.registeredEvents));
    }, t.prototype.render = function() {
      return Q.jsx("div", { ref: this.containerElement, children: Mt.only(this.props.children) });
    }, t.contextType = ot, t;
  }(ke)
), k0 = {
  onPlaceChanged: "place_changed"
}, D0 = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  restrictions: function(e, t) {
    e.setComponentRestrictions(t);
  },
  fields: function(e, t) {
    e.setFields(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  types: function(e, t) {
    e.setTypes(t);
  }
};
(function(e) {
  hn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = xr(), n.state = {
      autocomplete: null
    }, n.setAutocompleteCallback = function() {
      n.state.autocomplete !== null && n.props.onLoad && n.props.onLoad(n.state.autocomplete);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n;
    or(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var r = (n = this.containerElement.current) === null || n === void 0 ? void 0 : n.querySelector("input");
    if (r) {
      var o = new google.maps.places.Autocomplete(r, this.props.options);
      this.registeredEvents = vt({
        updaterMap: D0,
        eventMap: k0,
        prevProps: {},
        nextProps: this.props,
        instance: o
      }), this.setState(function() {
        return {
          autocomplete: o
        };
      }, this.setAutocompleteCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    kt(this.registeredEvents), this.registeredEvents = vt({
      updaterMap: D0,
      eventMap: k0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.autocomplete !== null && kt(this.registeredEvents);
  }, t.prototype.render = function() {
    return Q.jsx("div", { ref: this.containerElement, className: this.props.className, children: Mt.only(this.props.children) });
  }, t.defaultProps = {
    className: ""
  }, t.contextType = ot, t;
})(ke);
function Wne({
  coordinates: e,
  zoom: t = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return e ? /* @__PURE__ */ Q.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ Q.jsx(
    UB,
    {
      zoom: t,
      center: e,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ Q.jsx(XB, { draggable: n, position: e })
    }
  ) }) : /* @__PURE__ */ Q.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ Q.jsx(oB, {}) });
}
function Hne(e) {
  const { className: t, ...n } = e, r = `arkynSkeleton ${t}`;
  return /* @__PURE__ */ Q.jsx("aside", { className: r.trim(), ...n });
}
function Vne(e) {
  const {
    emptyMessage: t = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = e, i = `arkynTableBody ${n}`, s = Mt.count(r) === 0;
  return /* @__PURE__ */ Q.jsx("tbody", { className: i.trim(), ...o, children: s ? /* @__PURE__ */ Q.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ Q.jsx("td", { colSpan: 100, children: /* @__PURE__ */ Q.jsx("div", { children: t }) }) }) : r });
}
function Zne(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableCaption ${t}`;
  return /* @__PURE__ */ Q.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ Q.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function qne(e) {
  const { children: t, className: n, ...r } = e, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ Q.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ Q.jsx("table", { children: t }) });
}
function Gne(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableFooter ${t}`;
  return /* @__PURE__ */ Q.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ Q.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ Q.jsx("tr", { children: /* @__PURE__ */ Q.jsx("th", { colSpan: 100, children: /* @__PURE__ */ Q.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function Kne(e) {
  const { className: t, children: n, ...r } = e, o = `arkynTableHeader ${t}`;
  return /* @__PURE__ */ Q.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ Q.jsx("tr", { children: n }),
    /* @__PURE__ */ Q.jsx("tr", { className: "spacingRow" })
  ] });
}
function Yne(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, g = { xs: 12, sm: 16, md: 20, lg: 24 }[i], h = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ Q.jsxs("button", { className: h, disabled: l || t, ...p, children: [
    /* @__PURE__ */ Q.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ Q.jsx(Zo, { size: g, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ Q.jsxs("div", { className: "arkynButtonContent", children: [
      gc(g, s),
      c,
      gc(g, a)
    ] })
  ] });
}
function G_() {
  const e = rm(), t = WD(), n = HD(), [r, o] = D(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function s() {
    r && o(null);
  }
  v(() => {
    var c, p;
    let u = ((p = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : p.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, e]), v(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && s();
  }, [n, t]);
  const a = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(a || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const aS = Ye({});
function Xne(e) {
  var p;
  const {
    children: t,
    className: n,
    id: r,
    ...o
  } = e, i = G_(), s = rt(null), a = ((p = s.current) == null ? void 0 : p.name) || "", l = (i == null ? void 0 : i[a]) || null, u = eB(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ Q.jsx(aS.Provider, { value: { error: l, id: u, inputRef: s }, children: /* @__PURE__ */ Q.jsx(
    "section",
    {
      id: r || a || void 0,
      className: c.trim(),
      ...o,
      children: t
    }
  ) });
}
function ro() {
  return _e(aS);
}
function Qne(e) {
  const {
    name: t,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: s = null,
    onCheck: a,
    value: l,
    ...u
  } = e, { id: c, inputRef: p, error: d } = ro(), g = o || !!d, [m, f] = D(i || !1), h = typeof s == "boolean" ? s : m, x = `arkynCheckbox ${r} ${g ? "errorTrue" : "errorFalse"} ${h ? "checkedTrue" : "checkedFalse"} ${n}`;
  function T() {
    const w = m;
    f(!w), a && a(w ? "" : l || "checked");
  }
  return /* @__PURE__ */ Q.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: x,
      onClick: T,
      ...u,
      children: [
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            type: "hidden",
            name: t,
            ref: p,
            value: h ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ Q.jsx(UD, {})
      ]
    }
  );
}
function Jne(e) {
  const { children: t, className: n, ...r } = e, o = `arkynFormError ${n}`, { error: i } = ro();
  return t ? /* @__PURE__ */ Q.jsx("strong", { className: o.trim(), ...r, children: t }) : i ? /* @__PURE__ */ Q.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function ere(e) {
  const {
    showAsterisk: t = !1,
    className: n = "",
    ...r
  } = e, { id: o } = ro(), s = `arkynFormLabel ${t ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ Q.jsx("label", { className: s.trim(), htmlFor: o, ...r });
}
function Ei(e, t, n) {
  if (!e) return /* @__PURE__ */ Q.jsx(Q.Fragment, {});
  if (typeof e == "string") return /* @__PURE__ */ Q.jsx("p", { className: n, children: e });
  const r = e;
  return /* @__PURE__ */ Q.jsx("p", { className: n, children: /* @__PURE__ */ Q.jsx(r, { color: "var(--secondary-600)", size: t, strokeWidth: 2.5 }) });
}
function lm(e) {
  return e && e.replace(/[^0-9]/g, "");
}
function lS(e, t) {
  let n = "", r = 0;
  return Array.from(e).forEach((o, i) => {
    t[i + r].match(/[0-9]/) || (n += t[i + r], r++), n += o;
  }), n;
}
function uS(e) {
  return e.length > 11 ? "CNPJ" : "CPF";
}
const um = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, cS = lm(um.CNPJ).length;
function K_(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    defaultValue: d,
    readOnly: g,
    onFocus: m,
    onBlur: f,
    title: h,
    style: E,
    onChange: L,
    ...x
  } = e;
  function T(R) {
    let H = lm(R);
    const X = uS(H);
    if (!(H.length > cS))
      return H = lS(H, um[X]), H;
  }
  const w = c ? "right" : "left", V = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || g || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, W = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: V,
    prefix: Ei(a, W, "prefix"),
    sufix: Ei(l, W, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: T(d || ""),
    disabled: p,
    readOnly: g,
    onFocus: m,
    onBlur: f,
    title: h,
    style: E,
    onChange: L,
    loadingPosition: w,
    iconSize: W,
    Spinner: /* @__PURE__ */ Q.jsx(Zo, { className: "spinner", size: W, strokeWidth: 2.5 }),
    ...x
  };
}
function Y_(e) {
  const [t, n] = D(!1), r = rt(null), { inputRef: o, id: i, error: s } = ro(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: m,
    iconSize: f,
    loadingPosition: h,
    isLoading: E,
    LeftIcon: L,
    readOnly: x,
    onFocus: T,
    onBlur: w,
    RightIcon: C,
    Spinner: k,
    onChange: O,
    value: U,
    defaultValue: M,
    ...V
  } = K_({ ...e, id: i, isError: l }, t), [$, W] = D(M), R = L && !E, H = C && !E, X = h === "left" && E, I = h === "right" && E;
  function J() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function te(q) {
    let j = lm(q.target.value);
    const Z = uS(j);
    j.length > cS || (j = lS(j, um[Z]), q.target.value = j, W(j), O && O(q));
  }
  function S(q) {
    n(!0), T && T(q);
  }
  function P(q) {
    n(!1), w && w(q);
  }
  return /* @__PURE__ */ Q.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: J,
      className: d,
      children: [
        g,
        X && k,
        R && /* @__PURE__ */ Q.jsx(L, { size: f, strokeWidth: 2.5 }),
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: x,
            ref: a,
            value: U || $,
            onFocus: S,
            onChange: te,
            onBlur: P,
            ...V
          }
        ),
        H && /* @__PURE__ */ Q.jsx(C, { size: f, strokeWidth: 2.5 }),
        I && k,
        m
      ]
    }
  );
}
const X_ = 3, Q_ = (e = "pt-BR", t, n = "BRL", r = !0) => new Intl.NumberFormat(e, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(t).slice(r ? X_ : 0), Wl = 2, S0 = (e) => typeof e == "number" ? e : Number(e.toString().replace(/[^0-9-]/g, "")), Oh = (e) => {
  let t = e;
  return typeof e == "string" ? (t = S0(e), t % 1 !== 0 && (t = t.toFixed(Wl))) : t = Number.isInteger(e) ? Number(e) * 10 ** Wl : e.toFixed(Wl), S0(t) / 10 ** Wl;
}, O0 = (e, t, n) => {
  if (!t) return [0, ""];
  const r = Oh(t), o = Q_(e, r, n);
  return [r, o];
};
function J_(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: m,
    title: f,
    style: h,
    // showCents = false,
    max: E = 1e9,
    locale: L = "pt-BR",
    currency: x = "BRL",
    ...T
  } = e, w = c ? "right" : "left", V = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, W = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: V,
    prefix: Ei(a, W, "prefix"),
    sufix: Ei(l, W, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    locale: L,
    currency: x,
    readOnly: d,
    onFocus: g,
    onBlur: m,
    title: f,
    style: h,
    max: E,
    // showCents,
    loadingPosition: w,
    iconSize: W,
    Spinner: /* @__PURE__ */ Q.jsx(Zo, { className: "spinner", size: W, strokeWidth: 2.5 }),
    ...T
  };
}
function eI(e) {
  const [t, n] = D(!1), [r, o] = D("0"), i = rt(null), { inputRef: s, id: a, error: l } = ro(), u = s || i, c = e.isError || !!l, {
    disabled: p,
    title: d,
    style: g,
    className: m,
    prefix: f,
    sufix: h,
    iconSize: E,
    loadingPosition: L,
    isLoading: x,
    LeftIcon: T,
    readOnly: w,
    onFocus: C,
    onBlur: k,
    RightIcon: O,
    Spinner: U,
    value: M,
    max: V,
    onChangeValue: $,
    onKeyPress: W,
    currency: R,
    locale: H,
    name: X,
    defaultValue: I,
    ...J
  } = J_({ ...e, id: a, isError: c }, t), te = T && !x, S = O && !x, P = L === "left" && x, q = L === "right" && x;
  function j() {
    p || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function Z(A) {
    n(!0), C && C(A);
  }
  function G(A) {
    n(!1), k && k(A);
  }
  const b = (A) => {
    const [Y, ee] = O0(
      H,
      A,
      R
    );
    return !V || Y <= V ? (o(ee), [Y, ee]) : [Oh(r), r];
  }, F = (A) => {
    A.preventDefault();
    const [Y, ee] = b(A.target.value);
    $(A, String(Y), String(ee));
  }, z = (A) => W && W(A, A.key, A.key);
  return v(() => {
    const A = M || +I || void 0, [, Y] = O0(H, A, R);
    o(Y);
  }, [R, I, M]), /* @__PURE__ */ Q.jsxs(
    "section",
    {
      title: d,
      style: g,
      onClick: j,
      className: m,
      children: [
        f,
        P && U,
        te && /* @__PURE__ */ Q.jsx(T, { size: E, strokeWidth: 2.5 }),
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            value: r,
            onChange: F,
            onBlur: G,
            onFocus: Z,
            onKeyUp: z,
            disabled: p || x,
            readOnly: w,
            ...J
          }
        ),
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: X,
            value: Oh(r)
          }
        ),
        q && U,
        S && /* @__PURE__ */ Q.jsx(O, { size: E, strokeWidth: 2.5 }),
        h
      ]
    }
  );
}
function tI(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: m,
    title: f,
    style: h,
    onChange: E,
    showMask: L = !1,
    type: x,
    ...T
  } = e, w = c ? "right" : "left", V = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, W = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: V,
    prefix: Ei(a, W, "prefix"),
    sufix: Ei(l, W, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: m,
    title: f,
    style: h,
    onChange: E,
    loadingPosition: w,
    iconSize: W,
    showMask: L,
    Spinner: /* @__PURE__ */ Q.jsx(Zo, { className: "spinner", size: W, strokeWidth: 2.5 }),
    ...T
  };
}
const nI = Fs((e, t) => /* @__PURE__ */ Q.jsx("input", { ref: t, ...e }));
function rI(e) {
  const [t, n] = D(!1), r = rt(null), { inputRef: o, id: i, error: s } = ro(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: m,
    iconSize: f,
    loadingPosition: h,
    isLoading: E,
    LeftIcon: L,
    readOnly: x,
    onFocus: T,
    onBlur: w,
    RightIcon: C,
    Spinner: k,
    ...O
  } = tI({ ...e, id: i, isError: l }, t), U = L && !E, M = C && !E, V = h === "left" && E, $ = h === "right" && E;
  function W() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function R(X) {
    n(!0), T && T(X);
  }
  function H(X) {
    n(!1), w && w(X);
  }
  return /* @__PURE__ */ Q.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: W,
      className: d,
      children: [
        g,
        V && k,
        U && /* @__PURE__ */ Q.jsx(L, { size: f, strokeWidth: 2.5 }),
        /* @__PURE__ */ Q.jsx(
          CB,
          {
            component: nI,
            ref: a,
            onFocus: R,
            onBlur: H,
            disabled: u,
            ...O
          }
        ),
        M && /* @__PURE__ */ Q.jsx(C, { size: f, strokeWidth: 2.5 }),
        $ && k,
        m
      ]
    }
  );
}
function oI(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: m,
    title: f,
    style: h,
    onChange: E,
    ...L
  } = e, x = c ? "right" : "left", U = `arkyn_input ${a ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${s} ${o} ${p || d || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, V = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: U,
    prefix: Ei(a, V, "prefix"),
    sufix: Ei(l, V, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: p,
    readOnly: d,
    onFocus: g,
    onBlur: m,
    title: f,
    style: h,
    onChange: E,
    loadingPosition: x,
    iconSize: V,
    Spinner: /* @__PURE__ */ Q.jsx(Zo, { className: "spinner", size: V, strokeWidth: 2.5 }),
    ...L
  };
}
function iI(e) {
  const [t, n] = D(!1), r = rt(null), { inputRef: o, id: i, error: s } = ro(), a = o || r, l = e.isError || !!s, {
    disabled: u,
    title: c,
    style: p,
    className: d,
    prefix: g,
    sufix: m,
    iconSize: f,
    loadingPosition: h,
    isLoading: E,
    LeftIcon: L,
    readOnly: x,
    onFocus: T,
    onBlur: w,
    RightIcon: C,
    type: k,
    Spinner: O,
    ...U
  } = oI({ ...e, id: i, isError: l }, t), M = L && !E, V = C && !E, $ = h === "left" && E, W = h === "right" && E;
  function R() {
    u || !(a != null && a.current) || (n(!0), a.current.focus());
  }
  function H(I) {
    n(!0), T && T(I);
  }
  function X(I) {
    n(!1), w && w(I);
  }
  return k === "hidden" ? /* @__PURE__ */ Q.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: a,
      ...U
    }
  ) : /* @__PURE__ */ Q.jsxs(
    "section",
    {
      title: c,
      style: p,
      onClick: R,
      className: d,
      children: [
        g,
        $ && O,
        M && /* @__PURE__ */ Q.jsx(L, { size: f, strokeWidth: 2.5 }),
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            disabled: u || E,
            readOnly: x,
            ref: a,
            onFocus: H,
            onBlur: X,
            type: k,
            ...U
          }
        ),
        V && /* @__PURE__ */ Q.jsx(C, { size: f, strokeWidth: 2.5 }),
        W && O,
        m
      ]
    }
  );
}
function pS(e) {
  return e.type === "currency" ? /* @__PURE__ */ Q.jsx(eI, { ...e }) : e.type === "masked" ? /* @__PURE__ */ Q.jsx(rI, { ...e }) : e.type === "cpf-cnpj" ? /* @__PURE__ */ Q.jsx(Y_, { ...e }) : /* @__PURE__ */ Q.jsx(iI, { ...e });
}
function tre({
  onChange: e,
  onPlaceChanged: t,
  options: n,
  ...r
}) {
  const [o, i] = D(null), s = (l) => i(l), a = () => {
    var g, m, f, h;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function p(E) {
      const L = c.find((x) => x.types[0] === E);
      return L ? L.long_name : "";
    }
    function d(E) {
      const L = c.find((x) => x.types[0] === E);
      return L ? L.short_name : "";
    }
    if (u) {
      const E = p("route"), L = p("street_number"), x = p("sublocality_level_1"), T = p("administrative_area_level_2"), w = p("administrative_area_level_1"), C = d("administrative_area_level_1"), k = p("postal_code"), O = (m = (g = u.geometry) == null ? void 0 : g.location) == null ? void 0 : m.lat(), U = (h = (f = u.geometry) == null ? void 0 : f.location) == null ? void 0 : h.lng();
      t && t({
        street: E,
        city: T,
        state: w,
        district: x,
        cep: k,
        streetNumber: L,
        stateShortName: C,
        coordinates: { lat: O, lng: U }
      });
    }
  };
  return /* @__PURE__ */ Q.jsx(
    q_,
    {
      onLoad: s,
      onPlacesChanged: a,
      options: n,
      children: /* @__PURE__ */ Q.jsx(pS, { type: "text", onChange: (l) => e(l.target.value), ...r })
    }
  );
}
function nre(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: s,
    className: a = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, p = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${a}`;
  return /* @__PURE__ */ Q.jsxs(
    "button",
    {
      disabled: s || t,
      className: p.trim(),
      ...l,
      children: [
        /* @__PURE__ */ Q.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ Q.jsx(Zo, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ Q.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ Q.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
var tn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function sI(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Mh = { exports: {} }, Qs = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var M0;
function aI() {
  if (M0) return Qs;
  M0 = 1;
  var e = Be, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: g, props: p, _owner: o.current };
  }
  return Qs.Fragment = n, Qs.jsx = s, Qs.jsxs = s, Qs;
}
var Hl = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var P0;
function lI() {
  return P0 || (P0 = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Be, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), m = Symbol.iterator, f = "@@iterator";
    function h(y) {
      if (y === null || typeof y != "object")
        return null;
      var _ = m && y[m] || y[f];
      return typeof _ == "function" ? _ : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function L(y) {
      {
        for (var _ = arguments.length, K = new Array(_ > 1 ? _ - 1 : 0), ie = 1; ie < _; ie++)
          K[ie - 1] = arguments[ie];
        x("error", y, K);
      }
    }
    function x(y, _, K) {
      {
        var ie = E.ReactDebugCurrentFrame, ve = ie.getStackAddendum();
        ve !== "" && (_ += "%s", K = K.concat([ve]));
        var we = K.map(function(fe) {
          return String(fe);
        });
        we.unshift("Warning: " + _), Function.prototype.apply.call(console[y], console, we);
      }
    }
    var T = !1, w = !1, C = !1, k = !1, O = !1, U;
    U = Symbol.for("react.module.reference");
    function M(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === i || O || y === o || y === u || y === c || k || y === g || T || w || C || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === p || y.$$typeof === s || y.$$typeof === a || y.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === U || y.getModuleId !== void 0));
    }
    function V(y, _, K) {
      var ie = y.displayName;
      if (ie)
        return ie;
      var ve = _.displayName || _.name || "";
      return ve !== "" ? K + "(" + ve + ")" : K;
    }
    function $(y) {
      return y.displayName || "Context";
    }
    function W(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && L("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case a:
            var _ = y;
            return $(_) + ".Consumer";
          case s:
            var K = y;
            return $(K._context) + ".Provider";
          case l:
            return V(y, y.render, "ForwardRef");
          case p:
            var ie = y.displayName || null;
            return ie !== null ? ie : W(y.type) || "Memo";
          case d: {
            var ve = y, we = ve._payload, fe = ve._init;
            try {
              return W(fe(we));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var R = Object.assign, H = 0, X, I, J, te, S, P, q;
    function j() {
    }
    j.__reactDisabledLog = !0;
    function Z() {
      {
        if (H === 0) {
          X = console.log, I = console.info, J = console.warn, te = console.error, S = console.group, P = console.groupCollapsed, q = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: j,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        H++;
      }
    }
    function G() {
      {
        if (H--, H === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: R({}, y, {
              value: X
            }),
            info: R({}, y, {
              value: I
            }),
            warn: R({}, y, {
              value: J
            }),
            error: R({}, y, {
              value: te
            }),
            group: R({}, y, {
              value: S
            }),
            groupCollapsed: R({}, y, {
              value: P
            }),
            groupEnd: R({}, y, {
              value: q
            })
          });
        }
        H < 0 && L("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var b = E.ReactCurrentDispatcher, F;
    function z(y, _, K) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ve) {
            var ie = ve.stack.trim().match(/\n( *(at )?)/);
            F = ie && ie[1] || "";
          }
        return `
` + F + y;
      }
    }
    var A = !1, Y;
    {
      var ee = typeof WeakMap == "function" ? WeakMap : Map;
      Y = new ee();
    }
    function B(y, _) {
      if (!y || A)
        return "";
      {
        var K = Y.get(y);
        if (K !== void 0)
          return K;
      }
      var ie;
      A = !0;
      var ve = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var we;
      we = b.current, b.current = null, Z();
      try {
        if (_) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (je) {
              ie = je;
            }
            Reflect.construct(y, [], fe);
          } else {
            try {
              fe.call();
            } catch (je) {
              ie = je;
            }
            y.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ie = je;
          }
          y();
        }
      } catch (je) {
        if (je && ie && typeof je.stack == "string") {
          for (var pe = je.stack.split(`
`), Ie = ie.stack.split(`
`), De = pe.length - 1, Se = Ie.length - 1; De >= 1 && Se >= 0 && pe[De] !== Ie[Se]; )
            Se--;
          for (; De >= 1 && Se >= 0; De--, Se--)
            if (pe[De] !== Ie[Se]) {
              if (De !== 1 || Se !== 1)
                do
                  if (De--, Se--, Se < 0 || pe[De] !== Ie[Se]) {
                    var ze = `
` + pe[De].replace(" at new ", " at ");
                    return y.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", y.displayName)), typeof y == "function" && Y.set(y, ze), ze;
                  }
                while (De >= 1 && Se >= 0);
              break;
            }
        }
      } finally {
        A = !1, b.current = we, G(), Error.prepareStackTrace = ve;
      }
      var ct = y ? y.displayName || y.name : "", pt = ct ? z(ct) : "";
      return typeof y == "function" && Y.set(y, pt), pt;
    }
    function se(y, _, K) {
      return B(y, !1);
    }
    function ue(y) {
      var _ = y.prototype;
      return !!(_ && _.isReactComponent);
    }
    function ce(y, _, K) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return B(y, ue(y));
      if (typeof y == "string")
        return z(y);
      switch (y) {
        case u:
          return z("Suspense");
        case c:
          return z("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case l:
            return se(y.render);
          case p:
            return ce(y.type, _, K);
          case d: {
            var ie = y, ve = ie._payload, we = ie._init;
            try {
              return ce(we(ve), _, K);
            } catch {
            }
          }
        }
      return "";
    }
    var de = Object.prototype.hasOwnProperty, be = {}, ge = E.ReactDebugCurrentFrame;
    function me(y) {
      if (y) {
        var _ = y._owner, K = ce(y.type, y._source, _ ? _.type : null);
        ge.setExtraStackFrame(K);
      } else
        ge.setExtraStackFrame(null);
    }
    function ae(y, _, K, ie, ve) {
      {
        var we = Function.call.bind(de);
        for (var fe in y)
          if (we(y, fe)) {
            var pe = void 0;
            try {
              if (typeof y[fe] != "function") {
                var Ie = Error((ie || "React class") + ": " + K + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ie.name = "Invariant Violation", Ie;
              }
              pe = y[fe](_, fe, ie, K, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (De) {
              pe = De;
            }
            pe && !(pe instanceof Error) && (me(ve), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ie || "React class", K, fe, typeof pe), me(null)), pe instanceof Error && !(pe.message in be) && (be[pe.message] = !0, me(ve), L("Failed %s type: %s", K, pe.message), me(null));
          }
      }
    }
    var xe = Array.isArray;
    function re(y) {
      return xe(y);
    }
    function Te(y) {
      {
        var _ = typeof Symbol == "function" && Symbol.toStringTag, K = _ && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return K;
      }
    }
    function ne(y) {
      try {
        return Ee(y), !1;
      } catch {
        return !0;
      }
    }
    function Ee(y) {
      return "" + y;
    }
    function Ne(y) {
      if (ne(y))
        return L("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Te(y)), Ee(y);
    }
    var Fe = E.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, he, Xe, He;
    He = {};
    function qt(y) {
      if (de.call(y, "ref")) {
        var _ = Object.getOwnPropertyDescriptor(y, "ref").get;
        if (_ && _.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function lt(y) {
      if (de.call(y, "key")) {
        var _ = Object.getOwnPropertyDescriptor(y, "key").get;
        if (_ && _.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function mt(y, _) {
      if (typeof y.ref == "string" && Fe.current && _ && Fe.current.stateNode !== _) {
        var K = W(Fe.current.type);
        He[K] || (L('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', W(Fe.current.type), y.ref), He[K] = !0);
      }
    }
    function on(y, _) {
      {
        var K = function() {
          he || (he = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _));
        };
        K.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: K,
          configurable: !0
        });
      }
    }
    function sn(y, _) {
      {
        var K = function() {
          Xe || (Xe = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _));
        };
        K.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: K,
          configurable: !0
        });
      }
    }
    var an = function(y, _, K, ie, ve, we, fe) {
      var pe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: _,
        ref: K,
        props: fe,
        // Record the component responsible for creating this element.
        _owner: we
      };
      return pe._store = {}, Object.defineProperty(pe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ie
      }), Object.defineProperty(pe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ve
      }), Object.freeze && (Object.freeze(pe.props), Object.freeze(pe)), pe;
    };
    function ln(y, _, K, ie, ve) {
      {
        var we, fe = {}, pe = null, Ie = null;
        K !== void 0 && (Ne(K), pe = "" + K), lt(_) && (Ne(_.key), pe = "" + _.key), qt(_) && (Ie = _.ref, mt(_, ve));
        for (we in _)
          de.call(_, we) && !Ue.hasOwnProperty(we) && (fe[we] = _[we]);
        if (y && y.defaultProps) {
          var De = y.defaultProps;
          for (we in De)
            fe[we] === void 0 && (fe[we] = De[we]);
        }
        if (pe || Ie) {
          var Se = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          pe && on(fe, Se), Ie && sn(fe, Se);
        }
        return an(y, pe, Ie, ve, ie, Fe.current, fe);
      }
    }
    var nt = E.ReactCurrentOwner, Rt = E.ReactDebugCurrentFrame;
    function ut(y) {
      if (y) {
        var _ = y._owner, K = ce(y.type, y._source, _ ? _.type : null);
        Rt.setExtraStackFrame(K);
      } else
        Rt.setExtraStackFrame(null);
    }
    var Bt;
    Bt = !1;
    function un(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function jn() {
      {
        if (nt.current) {
          var y = W(nt.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function cn(y) {
      {
        if (y !== void 0) {
          var _ = y.fileName.replace(/^.*[\\\/]/, ""), K = y.lineNumber;
          return `

Check your code at ` + _ + ":" + K + ".";
        }
        return "";
      }
    }
    var Nn = {};
    function lr(y) {
      {
        var _ = jn();
        if (!_) {
          var K = typeof y == "string" ? y : y.displayName || y.name;
          K && (_ = `

Check the top-level render call using <` + K + ">.");
        }
        return _;
      }
    }
    function zt(y, _) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var K = lr(_);
        if (Nn[K])
          return;
        Nn[K] = !0;
        var ie = "";
        y && y._owner && y._owner !== nt.current && (ie = " It was passed a child from " + W(y._owner.type) + "."), ut(y), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', K, ie), ut(null);
      }
    }
    function Fn(y, _) {
      {
        if (typeof y != "object")
          return;
        if (re(y))
          for (var K = 0; K < y.length; K++) {
            var ie = y[K];
            un(ie) && zt(ie, _);
          }
        else if (un(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var ve = h(y);
          if (typeof ve == "function" && ve !== y.entries)
            for (var we = ve.call(y), fe; !(fe = we.next()).done; )
              un(fe.value) && zt(fe.value, _);
        }
      }
    }
    function ur(y) {
      {
        var _ = y.type;
        if (_ == null || typeof _ == "string")
          return;
        var K;
        if (typeof _ == "function")
          K = _.propTypes;
        else if (typeof _ == "object" && (_.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        _.$$typeof === p))
          K = _.propTypes;
        else
          return;
        if (K) {
          var ie = W(_);
          ae(K, y.props, "prop", ie, y);
        } else if (_.PropTypes !== void 0 && !Bt) {
          Bt = !0;
          var ve = W(_);
          L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ve || "Unknown");
        }
        typeof _.getDefaultProps == "function" && !_.getDefaultProps.isReactClassApproved && L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function pn(y) {
      {
        for (var _ = Object.keys(y.props), K = 0; K < _.length; K++) {
          var ie = _[K];
          if (ie !== "children" && ie !== "key") {
            ut(y), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ie), ut(null);
            break;
          }
        }
        y.ref !== null && (ut(y), L("Invalid attribute `ref` supplied to `React.Fragment`."), ut(null));
      }
    }
    var Rn = {};
    function zn(y, _, K, ie, ve, we) {
      {
        var fe = M(y);
        if (!fe) {
          var pe = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ie = cn(ve);
          Ie ? pe += Ie : pe += jn();
          var De;
          y === null ? De = "null" : re(y) ? De = "array" : y !== void 0 && y.$$typeof === t ? (De = "<" + (W(y.type) || "Unknown") + " />", pe = " Did you accidentally export a JSX literal instead of a component?") : De = typeof y, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", De, pe);
        }
        var Se = ln(y, _, K, ve, we);
        if (Se == null)
          return Se;
        if (fe) {
          var ze = _.children;
          if (ze !== void 0)
            if (ie)
              if (re(ze)) {
                for (var ct = 0; ct < ze.length; ct++)
                  Fn(ze[ct], y);
                Object.freeze && Object.freeze(ze);
              } else
                L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Fn(ze, y);
        }
        if (de.call(_, "key")) {
          var pt = W(y), je = Object.keys(_).filter(function(Ui) {
            return Ui !== "key";
          }), le = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Rn[pt + le]) {
            var zi = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            L(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, le, pt, zi, pt), Rn[pt + le] = !0;
          }
        }
        return y === r ? pn(Se) : ur(Se), Se;
      }
    }
    function dn(y, _, K) {
      return zn(y, _, K, !0);
    }
    function cr(y, _, K) {
      return zn(y, _, K, !1);
    }
    var pr = cr, fn = dn;
    Hl.Fragment = r, Hl.jsx = pr, Hl.jsxs = fn;
  }()), Hl;
}
process.env.NODE_ENV === "production" ? Mh.exports = aI() : Mh.exports = lI();
var Ft = Mh.exports;
Ye({});
function T0(e, t) {
  return t ? /* @__PURE__ */ Ft.jsx(t, { size: e, strokeWidth: 2.5 }) : /* @__PURE__ */ Ft.jsx(Ft.Fragment, {});
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ph = function(e, t) {
  return Ph = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
  }, Ph(e, t);
};
function gn(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Ph(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var qe = function() {
  return qe = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, qe.apply(this, arguments);
};
function cm(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function uI(e, t, n, r) {
  function o(i) {
    return i instanceof n ? i : new n(function(s) {
      s(i);
    });
  }
  return new (n || (n = Promise))(function(i, s) {
    function a(c) {
      try {
        u(r.next(c));
      } catch (p) {
        s(p);
      }
    }
    function l(c) {
      try {
        u(r.throw(c));
      } catch (p) {
        s(p);
      }
    }
    function u(c) {
      c.done ? i(c.value) : o(c.value).then(a, l);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function cI(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(c) {
      return l([u, c]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, o && (i = u[0] & 2 ? o.return : u[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, u[1])).done) return i;
      switch (o = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
        case 0:
        case 1:
          i = u;
          break;
        case 4:
          return n.label++, { value: u[1], done: !1 };
        case 5:
          n.label++, o = u[1], u = [0];
          continue;
        case 7:
          u = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            n = 0;
            continue;
          }
          if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
            n.label = u[1];
            break;
          }
          if (u[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = u;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(u);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      u = t.call(e, n);
    } catch (c) {
      u = [6, c], o = 0;
    } finally {
      r = i = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function dS(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var pI = process.env.NODE_ENV, dI = function(e, t, n, r, o, i, s, a) {
  if (pI !== "production" && t === void 0)
    throw new Error("invariant requires an error message argument");
  if (!e) {
    var l;
    if (t === void 0)
      l = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var u = [n, r, o, i, s, a], c = 0;
      l = new Error(
        t.replace(/%s/g, function() {
          return u[c++];
        })
      ), l.name = "Invariant Violation";
    }
    throw l.framesToPop = 1, l;
  }
}, fI = dI, ir = /* @__PURE__ */ dS(fI), it = Ye(null);
function hI() {
  ir(!!_e, "useGoogleMap is React hook and requires React version 16.8+");
  var e = _e(it);
  return ir(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function gI(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function mI(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function vI(e, t, n, r) {
  var o = {}, i = function(s, a) {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return mI(e, i), o;
}
function yI(e, t, n) {
  var r = gI(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function bI(e) {
  google.maps.event.removeListener(e);
}
function Dt(e) {
  e === void 0 && (e = []), e.forEach(bI);
}
function yt(e) {
  var t = e.updaterMap, n = e.eventMap, r = e.prevProps, o = e.nextProps, i = e.instance, s = yI(o, i, n);
  return vI(t, r, o, i), s;
}
var A0 = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, B0 = {
  extraMapTypes: function(e, t) {
    t.forEach(function(n, r) {
      e.mapTypes.set(String(r), n);
    });
  },
  center: function(e, t) {
    e.setCenter(t);
  },
  clickableIcons: function(e, t) {
    e.setClickableIcons(t);
  },
  heading: function(e, t) {
    e.setHeading(t);
  },
  mapTypeId: function(e, t) {
    e.setMapTypeId(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  streetView: function(e, t) {
    e.setStreetView(t);
  },
  tilt: function(e, t) {
    e.setTilt(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
function wI(e) {
  var t = e.children, n = e.options, r = e.id, o = e.mapContainerStyle, i = e.mapContainerClassName, s = e.center, a = e.onClick, l = e.onDblClick, u = e.onDrag, c = e.onDragEnd, p = e.onDragStart, d = e.onMouseMove, g = e.onMouseOut, m = e.onMouseOver, f = e.onMouseDown, h = e.onMouseUp, E = e.onRightClick, L = e.onCenterChanged, x = e.onLoad, T = e.onUnmount, w = D(null), C = w[0], k = w[1], O = rt(null), U = D(null), M = U[0], V = U[1], $ = D(null), W = $[0], R = $[1], H = D(null), X = H[0], I = H[1], J = D(null), te = J[0], S = J[1], P = D(null), q = P[0], j = P[1], Z = D(null), G = Z[0], b = Z[1], F = D(null), z = F[0], A = F[1], Y = D(null), ee = Y[0], B = Y[1], se = D(null), ue = se[0], ce = se[1], de = D(null), be = de[0], ge = de[1], me = D(null), ae = me[0], xe = me[1], re = D(null), Te = re[0], ne = re[1];
  return v(function() {
    n && C !== null && C.setOptions(n);
  }, [C, n]), v(function() {
    C !== null && typeof s < "u" && C.setCenter(s);
  }, [C, s]), v(function() {
    C && l && (W !== null && google.maps.event.removeListener(W), R(google.maps.event.addListener(C, "dblclick", l)));
  }, [l]), v(function() {
    C && c && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(C, "dragend", c)));
  }, [c]), v(function() {
    C && p && (te !== null && google.maps.event.removeListener(te), S(google.maps.event.addListener(C, "dragstart", p)));
  }, [p]), v(function() {
    C && f && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "mousedown", f)));
  }, [f]), v(function() {
    C && d && (G !== null && google.maps.event.removeListener(G), b(google.maps.event.addListener(C, "mousemove", d)));
  }, [d]), v(function() {
    C && g && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(C, "mouseout", g)));
  }, [g]), v(function() {
    C && m && (ee !== null && google.maps.event.removeListener(ee), B(google.maps.event.addListener(C, "mouseover", m)));
  }, [m]), v(function() {
    C && h && (ue !== null && google.maps.event.removeListener(ue), ce(google.maps.event.addListener(C, "mouseup", h)));
  }, [h]), v(function() {
    C && E && (be !== null && google.maps.event.removeListener(be), ge(google.maps.event.addListener(C, "rightclick", E)));
  }, [E]), v(function() {
    C && a && (ae !== null && google.maps.event.removeListener(ae), xe(google.maps.event.addListener(C, "click", a)));
  }, [a]), v(function() {
    C && u && (Te !== null && google.maps.event.removeListener(Te), ne(google.maps.event.addListener(C, "drag", u)));
  }, [u]), v(function() {
    C && L && (M !== null && google.maps.event.removeListener(M), V(google.maps.event.addListener(C, "center_changed", L)));
  }, [a]), v(function() {
    var Ee = O.current === null ? null : new google.maps.Map(O.current, n);
    return k(Ee), Ee !== null && x && x(Ee), function() {
      Ee !== null && T && T(Ee);
    };
  }, []), Ft.jsx("div", { id: r, ref: O, style: o, className: i, children: Ft.jsx(it.Provider, { value: C, children: C !== null ? t : null }) });
}
Re(wI);
/** @class */
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      map: null
    }, n.registeredEvents = [], n.mapRef = null, n.getInstance = function() {
      return n.mapRef === null ? null : new google.maps.Map(n.mapRef, n.props.options);
    }, n.panTo = function(r) {
      var o = n.getInstance();
      o && o.panTo(r);
    }, n.setMapCallback = function() {
      n.state.map !== null && n.props.onLoad && n.props.onLoad(n.state.map);
    }, n.getRef = function(r) {
      n.mapRef = r;
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.getInstance();
    this.registeredEvents = yt({
      updaterMap: B0,
      eventMap: A0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        map: n
      };
    }, this.setMapCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.map !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: B0,
      eventMap: A0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.map
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), Dt(this.registeredEvents));
  }, t.prototype.render = function() {
    return Ft.jsx("div", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: Ft.jsx(it.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : null }) });
  }, t;
})(ke);
var as = typeof document < "u";
function fS(e) {
  var t = e.url, n = e.id, r = e.nonce;
  return as ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch(function(o) {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function _0(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function hS() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return _0(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return _0(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
function gS(e) {
  var t = e.googleMapsApiKey, n = e.googleMapsClientId, r = e.version, o = r === void 0 ? "weekly" : r, i = e.language, s = e.region, a = e.libraries, l = e.channel, u = e.mapIds, c = e.authReferrerPolicy, p = [];
  return ir(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? p.push("key=".concat(t)) : n && p.push("client=".concat(n)), o && p.push("v=".concat(o)), i && p.push("language=".concat(i)), s && p.push("region=".concat(s)), a && a.length && p.push("libraries=".concat(a.sort().join(","))), l && p.push("channel=".concat(l)), u && u.length && p.push("map_ids=".concat(u.join(","))), c && p.push("auth_referrer_policy=".concat(c)), p.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(p.join("&"));
}
var Js = !1;
function mS() {
  return Ft.jsx("div", { children: "Loading..." });
}
var Th = {
  id: "script-loader",
  version: "weekly"
};
/** @class */
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.check = xr(), n.state = {
      loaded: !1
    }, n.cleanupCallback = function() {
      delete window.google.maps, n.injectScript();
    }, n.isCleaningUp = function() {
      return uI(n, void 0, void 0, function() {
        function r(o) {
          if (!Js)
            o();
          else if (as)
            var i = window.setInterval(function() {
              Js || (window.clearInterval(i), o());
            }, 1);
        }
        return cI(this, function(o) {
          return [2, new Promise(r)];
        });
      });
    }, n.cleanup = function() {
      Js = !0;
      var r = document.getElementById(n.props.id);
      r && r.parentNode && r.parentNode.removeChild(r), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(o) {
        return typeof o.src == "string" && o.src.includes("maps.googleapis");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(o) {
        return o.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(o) {
        return o.innerText !== void 0 && o.innerText.length > 0 && o.innerText.includes(".gm-");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      });
    }, n.injectScript = function() {
      n.props.preventGoogleFontsLoading && hS(), ir(!!n.props.id, 'LoadScript requires "id" prop to be a string: %s', n.props.id);
      var r = {
        id: n.props.id,
        nonce: n.props.nonce,
        url: gS(n.props)
      };
      fS(r).then(function() {
        n.props.onLoad && n.props.onLoad(), n.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch(function(o) {
        n.props.onError && n.props.onError(o), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(n.props.googleMapsApiKey || "-", ") or Client ID (").concat(n.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (as) {
      if (window.google && window.google.maps && !Js) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.props.libraries !== n.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), as && n.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }, t.prototype.componentWillUnmount = function() {
    var n = this;
    if (as) {
      this.cleanup();
      var r = function() {
        n.check.current || (delete window.google, Js = !1);
      };
      window.setTimeout(r, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }, t.prototype.render = function() {
    return Ft.jsxs(Ft.Fragment, { children: [Ft.jsx("div", { ref: this.check }), this.state.loaded ? this.props.children : this.props.loadingElement || Ft.jsx(mS, {})] });
  }, t.defaultProps = Th, t;
})(ke);
var I0;
function CI(e) {
  var t = e.id, n = t === void 0 ? Th.id : t, r = e.version, o = r === void 0 ? Th.version : r, i = e.nonce, s = e.googleMapsApiKey, a = e.googleMapsClientId, l = e.language, u = e.region, c = e.libraries, p = e.preventGoogleFontsLoading, d = e.channel, g = e.mapIds, m = e.authReferrerPolicy, f = rt(!1), h = D(!1), E = h[0], L = h[1], x = D(void 0), T = x[0], w = x[1];
  v(function() {
    return f.current = !0, function() {
      f.current = !1;
    };
  }, []), v(function() {
    as && p && hS();
  }, [p]), v(function() {
    E && ir(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [E]);
  var C = gS({
    version: o,
    googleMapsApiKey: s,
    googleMapsClientId: a,
    language: l,
    region: u,
    libraries: c,
    channel: d,
    mapIds: g,
    authReferrerPolicy: m
  });
  v(function() {
    if (!as)
      return;
    function O() {
      f.current && (L(!0), I0 = C);
    }
    if (window.google && window.google.maps && I0 === C) {
      O();
      return;
    }
    fS({ id: n, url: C, nonce: i }).then(O).catch(function(U) {
      f.current && w(U), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(s || "-", ") or Client ID (").concat(a || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(U);
    });
  }, [n, C, i]);
  var k = rt();
  return v(function() {
    k.current && c !== k.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), k.current = c;
  }, [c]), { isLoaded: E, loadError: T, url: C };
}
var EI = Ft.jsx(mS, {});
function xI(e) {
  var t = e.loadingElement, n = e.onLoad, r = e.onError, o = e.onUnmount, i = e.children, s = cm(e, ["loadingElement", "onLoad", "onError", "onUnmount", "children"]), a = CI(s), l = a.isLoaded, u = a.loadError;
  return v(function() {
    l && typeof n == "function" && n();
  }, [l, n]), v(function() {
    u && typeof r == "function" && r(u);
  }, [u, r]), v(function() {
    return function() {
      o && o();
    };
  }, [o]), l ? i : t || EI;
}
Re(xI);
var j0;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(j0 || (j0 = {}));
var N0 = {}, F0 = {
  options: function(e, t) {
    e.setOptions(t);
  }
};
function LI(e) {
  var t = e.options, n = e.onLoad, r = e.onUnmount, o = _e(it), i = D(null), s = i[0], a = i[1];
  return v(function() {
    s !== null && s.setMap(o);
  }, [o]), v(function() {
    t && s !== null && s.setOptions(t);
  }, [s, t]), v(function() {
    var l = new google.maps.TrafficLayer(qe(qe({}, t || {}), { map: o }));
    return a(l), n && n(l), function() {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Re(LI);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      trafficLayer: null
    }, n.setTrafficLayerCallback = function() {
      n.state.trafficLayer !== null && n.props.onLoad && n.props.onLoad(n.state.trafficLayer);
    }, n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TrafficLayer(qe(qe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = yt({
      updaterMap: F0,
      eventMap: N0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        trafficLayer: n
      };
    }, this.setTrafficLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.trafficLayer !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: F0,
      eventMap: N0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Dt(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
function kI(e) {
  var t = e.onLoad, n = e.onUnmount, r = _e(it), o = D(null), i = o[0], s = o[1];
  return v(function() {
    i !== null && i.setMap(r);
  }, [r]), v(function() {
    var a = new google.maps.BicyclingLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Re(kI);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      bicyclingLayer: null
    }, n.setBicyclingLayerCallback = function() {
      n.state.bicyclingLayer !== null && (n.state.bicyclingLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.bicyclingLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.BicyclingLayer();
    this.setState(function() {
      return {
        bicyclingLayer: n
      };
    }, this.setBicyclingLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
function DI(e) {
  var t = e.onLoad, n = e.onUnmount, r = _e(it), o = D(null), i = o[0], s = o[1];
  return v(function() {
    i !== null && i.setMap(r);
  }, [r]), v(function() {
    var a = new google.maps.TransitLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      i !== null && (n && n(i), i.setMap(null));
    };
  }, []), null;
}
Re(DI);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      transitLayer: null
    }, n.setTransitLayerCallback = function() {
      n.state.transitLayer !== null && (n.state.transitLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.transitLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: n
      };
    }, this.setTransitLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
var R0 = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, z0 = {
  drawingMode: function(e, t) {
    e.setDrawingMode(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function SI(e) {
  var t = e.options, n = e.drawingMode, r = e.onCircleComplete, o = e.onMarkerComplete, i = e.onOverlayComplete, s = e.onPolygonComplete, a = e.onPolylineComplete, l = e.onRectangleComplete, u = e.onLoad, c = e.onUnmount, p = _e(it), d = D(null), g = d[0], m = d[1], f = D(null), h = f[0], E = f[1], L = D(null), x = L[0], T = L[1], w = D(null), C = w[0], k = w[1], O = D(null), U = O[0], M = O[1], V = D(null), $ = V[0], W = V[1], R = D(null), H = R[0], X = R[1];
  return v(function() {
    g !== null && g.setMap(p);
  }, [p]), v(function() {
    t && g !== null && g.setOptions(t);
  }, [g, t]), v(function() {
    g !== null && g.setDrawingMode(n ?? null);
  }, [g, n]), v(function() {
    g && r && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(g, "circlecomplete", r)));
  }, [g, r]), v(function() {
    g && o && (x !== null && google.maps.event.removeListener(x), T(google.maps.event.addListener(g, "markercomplete", o)));
  }, [g, o]), v(function() {
    g && i && (C !== null && google.maps.event.removeListener(C), k(google.maps.event.addListener(g, "overlaycomplete", i)));
  }, [g, i]), v(function() {
    g && s && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(g, "polygoncomplete", s)));
  }, [g, s]), v(function() {
    g && a && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(g, "polylinecomplete", a)));
  }, [g, a]), v(function() {
    g && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(g, "rectanglecomplete", l)));
  }, [g, l]), v(function() {
    ir(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var I = new google.maps.drawing.DrawingManager(qe(qe({}, t || {}), { map: p }));
    return n && I.setDrawingMode(n), r && E(google.maps.event.addListener(I, "circlecomplete", r)), o && T(google.maps.event.addListener(I, "markercomplete", o)), i && k(google.maps.event.addListener(I, "overlaycomplete", i)), s && M(google.maps.event.addListener(I, "polygoncomplete", s)), a && W(google.maps.event.addListener(I, "polylinecomplete", a)), l && X(google.maps.event.addListener(I, "rectanglecomplete", l)), m(I), u && u(I), function() {
      g !== null && (h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), $ && google.maps.event.removeListener($), H && google.maps.event.removeListener(H), c && c(g), g.setMap(null));
    };
  }, []), null;
}
Re(SI);
(function(e) {
  gn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    return r.registeredEvents = [], r.state = {
      drawingManager: null
    }, r.setDrawingManagerCallback = function() {
      r.state.drawingManager !== null && r.props.onLoad && r.props.onLoad(r.state.drawingManager);
    }, ir(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing), r;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.drawing.DrawingManager(qe(qe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = yt({
      updaterMap: z0,
      eventMap: R0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        drawingManager: n
      };
    }, this.setDrawingManagerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.drawingManager !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: z0,
      eventMap: R0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Dt(this.registeredEvents), this.state.drawingManager.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
var U0 = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, $0 = {
  animation: function(e, t) {
    e.setAnimation(t);
  },
  clickable: function(e, t) {
    e.setClickable(t);
  },
  cursor: function(e, t) {
    e.setCursor(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  icon: function(e, t) {
    e.setIcon(t);
  },
  label: function(e, t) {
    e.setLabel(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  opacity: function(e, t) {
    e.setOpacity(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  shape: function(e, t) {
    e.setShape(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, vc = {};
function OI(e) {
  var t = e.position, n = e.options, r = e.clusterer, o = e.noClustererRedraw, i = e.children, s = e.draggable, a = e.visible, l = e.animation, u = e.clickable, c = e.cursor, p = e.icon, d = e.label, g = e.opacity, m = e.shape, f = e.title, h = e.zIndex, E = e.onClick, L = e.onDblClick, x = e.onDrag, T = e.onDragEnd, w = e.onDragStart, C = e.onMouseOut, k = e.onMouseOver, O = e.onMouseUp, U = e.onMouseDown, M = e.onRightClick, V = e.onClickableChanged, $ = e.onCursorChanged, W = e.onAnimationChanged, R = e.onDraggableChanged, H = e.onFlatChanged, X = e.onIconChanged, I = e.onPositionChanged, J = e.onShapeChanged, te = e.onTitleChanged, S = e.onVisibleChanged, P = e.onZindexChanged, q = e.onLoad, j = e.onUnmount, Z = _e(it), G = D(null), b = G[0], F = G[1], z = D(null), A = z[0], Y = z[1], ee = D(null), B = ee[0], se = ee[1], ue = D(null), ce = ue[0], de = ue[1], be = D(null), ge = be[0], me = be[1], ae = D(null), xe = ae[0], re = ae[1], Te = D(null), ne = Te[0], Ee = Te[1], Ne = D(null), Fe = Ne[0], Ue = Ne[1], he = D(null), Xe = he[0], He = he[1], qt = D(null), lt = qt[0], mt = qt[1], on = D(null), sn = on[0], an = on[1], ln = D(null), nt = ln[0], Rt = ln[1], ut = D(null), Bt = ut[0], un = ut[1], jn = D(null), cn = jn[0], Nn = jn[1], lr = D(null), zt = lr[0], Fn = lr[1], ur = D(null), pn = ur[0], Rn = ur[1], zn = D(null), dn = zn[0], cr = zn[1], pr = D(null), fn = pr[0], y = pr[1], _ = D(null), K = _[0], ie = _[1], ve = D(null), we = ve[0], fe = ve[1], pe = D(null), Ie = pe[0], De = pe[1], Se = D(null), ze = Se[0], ct = Se[1];
  v(function() {
    b !== null && b.setMap(Z);
  }, [Z]), v(function() {
    typeof n < "u" && b !== null && b.setOptions(n);
  }, [b, n]), v(function() {
    typeof s < "u" && b !== null && b.setDraggable(s);
  }, [b, s]), v(function() {
    t && b !== null && b.setPosition(t);
  }, [b, t]), v(function() {
    typeof a < "u" && b !== null && b.setVisible(a);
  }, [b, a]), v(function() {
    b == null || b.setAnimation(l);
  }, [b, l]), v(function() {
    b && u !== void 0 && b.setClickable(u);
  }, [b, u]), v(function() {
    b && c !== void 0 && b.setCursor(c);
  }, [b, c]), v(function() {
    b && p !== void 0 && b.setIcon(p);
  }, [b, p]), v(function() {
    b && d !== void 0 && b.setLabel(d);
  }, [b, d]), v(function() {
    b && g !== void 0 && b.setOpacity(g);
  }, [b, g]), v(function() {
    b && m !== void 0 && b.setShape(m);
  }, [b, m]), v(function() {
    b && f !== void 0 && b.setTitle(f);
  }, [b, f]), v(function() {
    b && h !== void 0 && b.setZIndex(h);
  }, [b, h]), v(function() {
    b && L && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(b, "dblclick", L)));
  }, [L]), v(function() {
    b && T && (B !== null && google.maps.event.removeListener(B), se(google.maps.event.addListener(b, "dragend", T)));
  }, [T]), v(function() {
    b && w && (ce !== null && google.maps.event.removeListener(ce), de(google.maps.event.addListener(b, "dragstart", w)));
  }, [w]), v(function() {
    b && U && (ge !== null && google.maps.event.removeListener(ge), me(google.maps.event.addListener(b, "mousedown", U)));
  }, [U]), v(function() {
    b && C && (xe !== null && google.maps.event.removeListener(xe), re(google.maps.event.addListener(b, "mouseout", C)));
  }, [C]), v(function() {
    b && k && (ne !== null && google.maps.event.removeListener(ne), Ee(google.maps.event.addListener(b, "mouseover", k)));
  }, [k]), v(function() {
    b && O && (Fe !== null && google.maps.event.removeListener(Fe), Ue(google.maps.event.addListener(b, "mouseup", O)));
  }, [O]), v(function() {
    b && M && (Xe !== null && google.maps.event.removeListener(Xe), He(google.maps.event.addListener(b, "rightclick", M)));
  }, [M]), v(function() {
    b && E && (lt !== null && google.maps.event.removeListener(lt), mt(google.maps.event.addListener(b, "click", E)));
  }, [E]), v(function() {
    b && x && (sn !== null && google.maps.event.removeListener(sn), an(google.maps.event.addListener(b, "drag", x)));
  }, [x]), v(function() {
    b && V && (nt !== null && google.maps.event.removeListener(nt), Rt(google.maps.event.addListener(b, "clickable_changed", V)));
  }, [V]), v(function() {
    b && $ && (Bt !== null && google.maps.event.removeListener(Bt), un(google.maps.event.addListener(b, "cursor_changed", $)));
  }, [$]), v(function() {
    b && W && (cn !== null && google.maps.event.removeListener(cn), Nn(google.maps.event.addListener(b, "animation_changed", W)));
  }, [W]), v(function() {
    b && R && (zt !== null && google.maps.event.removeListener(zt), Fn(google.maps.event.addListener(b, "draggable_changed", R)));
  }, [R]), v(function() {
    b && H && (pn !== null && google.maps.event.removeListener(pn), Rn(google.maps.event.addListener(b, "flat_changed", H)));
  }, [H]), v(function() {
    b && X && (dn !== null && google.maps.event.removeListener(dn), cr(google.maps.event.addListener(b, "icon_changed", X)));
  }, [X]), v(function() {
    b && I && (fn !== null && google.maps.event.removeListener(fn), y(google.maps.event.addListener(b, "position_changed", I)));
  }, [I]), v(function() {
    b && J && (K !== null && google.maps.event.removeListener(K), ie(google.maps.event.addListener(b, "shape_changed", J)));
  }, [J]), v(function() {
    b && te && (we !== null && google.maps.event.removeListener(we), fe(google.maps.event.addListener(b, "title_changed", te)));
  }, [te]), v(function() {
    b && S && (Ie !== null && google.maps.event.removeListener(Ie), De(google.maps.event.addListener(b, "visible_changed", S)));
  }, [S]), v(function() {
    b && P && (ze !== null && google.maps.event.removeListener(ze), ct(google.maps.event.addListener(b, "zindex_changed", P)));
  }, [P]), v(function() {
    var je = qe(qe(qe({}, n || vc), r ? vc : { map: Z }), { position: t }), le = new google.maps.Marker(je);
    return r ? r.addMarker(le, !!o) : le.setMap(Z), t && le.setPosition(t), typeof a < "u" && le.setVisible(a), typeof s < "u" && le.setDraggable(s), typeof u < "u" && le.setClickable(u), typeof c == "string" && le.setCursor(c), p && le.setIcon(p), typeof d < "u" && le.setLabel(d), typeof g < "u" && le.setOpacity(g), m && le.setShape(m), typeof f == "string" && le.setTitle(f), typeof h == "number" && le.setZIndex(h), L && Y(google.maps.event.addListener(le, "dblclick", L)), T && se(google.maps.event.addListener(le, "dragend", T)), w && de(google.maps.event.addListener(le, "dragstart", w)), U && me(google.maps.event.addListener(le, "mousedown", U)), C && re(google.maps.event.addListener(le, "mouseout", C)), k && Ee(google.maps.event.addListener(le, "mouseover", k)), O && Ue(google.maps.event.addListener(le, "mouseup", O)), M && He(google.maps.event.addListener(le, "rightclick", M)), E && mt(google.maps.event.addListener(le, "click", E)), x && an(google.maps.event.addListener(le, "drag", x)), V && Rt(google.maps.event.addListener(le, "clickable_changed", V)), $ && un(google.maps.event.addListener(le, "cursor_changed", $)), W && Nn(google.maps.event.addListener(le, "animation_changed", W)), R && Fn(google.maps.event.addListener(le, "draggable_changed", R)), H && Rn(google.maps.event.addListener(le, "flat_changed", H)), X && cr(google.maps.event.addListener(le, "icon_changed", X)), I && y(google.maps.event.addListener(le, "position_changed", I)), J && ie(google.maps.event.addListener(le, "shape_changed", J)), te && fe(google.maps.event.addListener(le, "title_changed", te)), S && De(google.maps.event.addListener(le, "visible_changed", S)), P && ct(google.maps.event.addListener(le, "zindex_changed", P)), F(le), q && q(le), function() {
      A !== null && google.maps.event.removeListener(A), B !== null && google.maps.event.removeListener(B), ce !== null && google.maps.event.removeListener(ce), ge !== null && google.maps.event.removeListener(ge), xe !== null && google.maps.event.removeListener(xe), ne !== null && google.maps.event.removeListener(ne), Fe !== null && google.maps.event.removeListener(Fe), Xe !== null && google.maps.event.removeListener(Xe), lt !== null && google.maps.event.removeListener(lt), nt !== null && google.maps.event.removeListener(nt), Bt !== null && google.maps.event.removeListener(Bt), cn !== null && google.maps.event.removeListener(cn), zt !== null && google.maps.event.removeListener(zt), pn !== null && google.maps.event.removeListener(pn), dn !== null && google.maps.event.removeListener(dn), fn !== null && google.maps.event.removeListener(fn), we !== null && google.maps.event.removeListener(we), Ie !== null && google.maps.event.removeListener(Ie), ze !== null && google.maps.event.removeListener(ze), j && j(le), r ? r.removeMarker(le, !!o) : le && le.setMap(null);
    };
  }, []);
  var pt = rr(function() {
    return i ? Mt.map(i, function(je) {
      if (!Li(je))
        return je;
      var le = je;
      return ki(le, { anchor: b });
    }) : null;
  }, [i, b]);
  return Ft.jsx(Ft.Fragment, { children: pt }) || null;
}
Re(OI);
/** @class */
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = qe(qe(qe({}, this.props.options || vc), this.props.clusterer ? vc : { map: this.context }), { position: this.props.position });
    this.marker = new google.maps.Marker(n), this.props.clusterer ? this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw) : this.marker.setMap(this.context), this.registeredEvents = yt({
      updaterMap: $0,
      eventMap: U0,
      prevProps: {},
      nextProps: this.props,
      instance: this.marker
    }), this.props.onLoad && this.props.onLoad(this.marker);
  }, t.prototype.componentDidUpdate = function(n) {
    this.marker && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: $0,
      eventMap: U0,
      prevProps: n,
      nextProps: this.props,
      instance: this.marker
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Dt(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }, t.prototype.render = function() {
    var n = this, r = null;
    return this.props.children && (r = Mt.map(this.props.children, function(o) {
      if (!Li(o))
        return o;
      var i = o;
      return ki(i, { anchor: n.marker });
    })), r || null;
  }, t.contextType = it, t;
})(ke);
var MI = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), PI = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new MI(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function TI(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var AI = 2e3, BI = 500, _I = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", II = "png", jI = [53, 56, 66, 78, 90], NI = "cluster", vS = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || _I, this.imageExtension = r.imageExtension || II, this.imageSizes = r.imageSizes || jI, this.calculator = r.calculator || TI, this.batchSize = r.batchSize || AI, this.batchSizeIE = r.batchSizeIE || BI, this.clusterClass = r.clusterClass || NI, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [
        google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged),
        google.maps.event.addListener(t, "idle", this.onIdle)
      ]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new PI(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), io = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, It = {
  averageCenter: function(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE: function(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator: function(e, t) {
    e.setCalculator(t);
  },
  clusterClass: function(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons: function(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize: function(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden: function(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension: function(e, t) {
    e.setImageExtension(t);
  },
  imagePath: function(e, t) {
    e.setImagePath(t);
  },
  imageSizes: function(e, t) {
    e.setImageSizes(t);
  },
  maxZoom: function(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize: function(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles: function(e, t) {
    e.setStyles(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  zoomOnClick: function(e, t) {
    e.setZoomOnClick(t);
  }
}, FI = {};
function RI(e) {
  var t = e.children, n = e.options, r = e.averageCenter, o = e.batchSizeIE, i = e.calculator, s = e.clusterClass, a = e.enableRetinaIcons, l = e.gridSize, u = e.ignoreHidden, c = e.imageExtension, p = e.imagePath, d = e.imageSizes, g = e.maxZoom, m = e.minimumClusterSize, f = e.styles, h = e.title, E = e.zoomOnClick, L = e.onClick, x = e.onClusteringBegin, T = e.onClusteringEnd, w = e.onMouseOver, C = e.onMouseOut, k = e.onLoad, O = e.onUnmount, U = D(null), M = U[0], V = U[1], $ = _e(it), W = D(null), R = W[0], H = W[1], X = D(null), I = X[0], J = X[1], te = D(null), S = te[0], P = te[1], q = D(null), j = q[0], Z = q[1], G = D(null), b = G[0], F = G[1];
  return v(function() {
    M && C && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(M, io.onMouseOut, C)));
  }, [C]), v(function() {
    M && w && (b !== null && google.maps.event.removeListener(b), F(google.maps.event.addListener(M, io.onMouseOver, w)));
  }, [w]), v(function() {
    M && L && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(M, io.onClick, L)));
  }, [L]), v(function() {
    M && x && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(M, io.onClusteringBegin, x)));
  }, [x]), v(function() {
    M && T && (S !== null && google.maps.event.removeListener(S), J(google.maps.event.addListener(M, io.onClusteringEnd, T)));
  }, [T]), v(function() {
    typeof r < "u" && M !== null && It.averageCenter(M, r);
  }, [M, r]), v(function() {
    typeof o < "u" && M !== null && It.batchSizeIE(M, o);
  }, [M, o]), v(function() {
    typeof i < "u" && M !== null && It.calculator(M, i);
  }, [M, i]), v(function() {
    typeof s < "u" && M !== null && It.clusterClass(M, s);
  }, [M, s]), v(function() {
    typeof a < "u" && M !== null && It.enableRetinaIcons(M, a);
  }, [M, a]), v(function() {
    typeof l < "u" && M !== null && It.gridSize(M, l);
  }, [M, l]), v(function() {
    typeof u < "u" && M !== null && It.ignoreHidden(M, u);
  }, [M, u]), v(function() {
    typeof c < "u" && M !== null && It.imageExtension(M, c);
  }, [M, c]), v(function() {
    typeof p < "u" && M !== null && It.imagePath(M, p);
  }, [M, p]), v(function() {
    typeof d < "u" && M !== null && It.imageSizes(M, d);
  }, [M, d]), v(function() {
    typeof g < "u" && M !== null && It.maxZoom(M, g);
  }, [M, g]), v(function() {
    typeof m < "u" && M !== null && It.minimumClusterSize(M, m);
  }, [M, m]), v(function() {
    typeof f < "u" && M !== null && It.styles(M, f);
  }, [M, f]), v(function() {
    typeof h < "u" && M !== null && It.title(M, h);
  }, [M, h]), v(function() {
    typeof E < "u" && M !== null && It.zoomOnClick(M, E);
  }, [M, E]), v(function() {
    if ($) {
      var z = qe({}, n || FI), A = new vS($, [], z);
      return r && It.averageCenter(A, r), o && It.batchSizeIE(A, o), i && It.calculator(A, i), s && It.clusterClass(A, s), a && It.enableRetinaIcons(A, a), l && It.gridSize(A, l), u && It.ignoreHidden(A, u), c && It.imageExtension(A, c), p && It.imagePath(A, p), d && It.imageSizes(A, d), g && It.maxZoom(A, g), m && It.minimumClusterSize(A, m), f && It.styles(A, f), h && It.title(A, h), E && It.zoomOnClick(A, E), C && Z(google.maps.event.addListener(A, io.onMouseOut, C)), w && F(google.maps.event.addListener(A, io.onMouseOver, w)), L && H(google.maps.event.addListener(A, io.onClick, L)), x && J(google.maps.event.addListener(A, io.onClusteringBegin, x)), T && P(google.maps.event.addListener(A, io.onClusteringEnd, T)), V(A), k && k(A), function() {
        j !== null && google.maps.event.removeListener(j), b !== null && google.maps.event.removeListener(b), R !== null && google.maps.event.removeListener(R), I !== null && google.maps.event.removeListener(I), S !== null && google.maps.event.removeListener(S), O && O(A);
      };
    }
  }, []), M !== null && t(M) || null;
}
Re(RI);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      markerClusterer: null
    }, n.setClustererCallback = function() {
      n.state.markerClusterer !== null && n.props.onLoad && n.props.onLoad(n.state.markerClusterer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context) {
      var n = new vS(this.context, [], this.props.options);
      this.registeredEvents = yt({
        updaterMap: It,
        eventMap: io,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          markerClusterer: n
        };
      }, this.setClustererCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.markerClusterer && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: It,
      eventMap: io,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Dt(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }, t.prototype.render = function() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }, t.contextType = it, t;
})(ke);
function W0(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var yS = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || W0(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = [
            "mousedown",
            "mouseover",
            "mouseout",
            "mouseup",
            "click",
            "dblclick",
            "touchstart",
            "touchend",
            "touchmove"
          ], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, W0));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, m = this.infoBoxClearance.height, f = this.getProjection(), h = f.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + p + u + g > a && (r = h.x + p + u + g - a), this.alignBottom ? h.y < -c + m + d ? o = h.y + c - m - d : h.y + c + m > l && (o = h.y + c + m - l) : h.y < -c + m ? o = h.y + c - m : h.y + d + c + m > l && (o = h.y + d + c + m - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = { top: 0, bottom: 0, left: 0, right: 0 };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), H0 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, V0 = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, zI = {};
function UI(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, g = _e(it), m = D(null), f = m[0], h = m[1], E = D(null), L = E[0], x = E[1], T = D(null), w = T[0], C = T[1], k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = rt(null);
  return v(function() {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(function() {
    if (o && f !== null) {
      var I = o instanceof google.maps.LatLng ? o : new google.maps.LatLng(o.lat, o.lng);
      f.setPosition(I);
    }
  }, [o]), v(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(function() {
    f && a && (w !== null && google.maps.event.removeListener(w), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(function() {
    f && l && (O !== null && google.maps.event.removeListener(O), U(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(function() {
    f && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(function() {
    f && c && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(function() {
    if (g) {
      var I = r || zI, J = I.position, te = cm(I, ["position"]), S = void 0;
      J && !(J instanceof google.maps.LatLng) && (S = new google.maps.LatLng(J.lat, J.lng));
      var P = new yS(qe(qe({}, te), S ? { position: S } : {}));
      X.current = document.createElement("div"), h(P), s && x(google.maps.event.addListener(P, "closeclick", s)), a && C(google.maps.event.addListener(P, "domready", a)), l && U(google.maps.event.addListener(P, "content_changed", l)), u && $(google.maps.event.addListener(P, "position_changed", u)), c && H(google.maps.event.addListener(P, "zindex_changed", c)), P.setContent(X.current), n ? P.open(g, n) : P.getPosition() ? P.open(g) : ir(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(P);
    }
    return function() {
      f !== null && (L && google.maps.event.removeListener(L), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), V && google.maps.event.removeListener(V), R && google.maps.event.removeListener(R), d && d(f), f.close());
    };
  }, []), X.current ? Lr(Mt.only(t), X.current) : null;
}
Re(UI);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoBox: null
    }, n.open = function(r, o) {
      o ? n.context !== null && r.open(n.context, o) : r.getPosition() ? n.context !== null && r.open(n.context) : ir(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }, n.setInfoBoxCallback = function() {
      n.state.infoBox !== null && n.containerElement !== null && (n.state.infoBox.setContent(n.containerElement), n.open(n.state.infoBox, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoBox));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.props.options || {}, r = n.position, o = cm(n, ["position"]), i;
    r && !(r instanceof google.maps.LatLng) && (i = new google.maps.LatLng(r.lat, r.lng));
    var s = new yS(qe(qe({}, o), i ? { position: i } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = yt({
      updaterMap: V0,
      eventMap: H0,
      prevProps: {},
      nextProps: this.props,
      instance: s
    }), this.setState({ infoBox: s }, this.setInfoBoxCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = this.state.infoBox;
    r !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: V0,
      eventMap: H0,
      prevProps: n,
      nextProps: this.props,
      instance: r
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n = this.props.onUnmount, r = this.state.infoBox;
    r !== null && (n && n(r), Dt(this.registeredEvents), r.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Lr(Mt.only(this.props.children), this.containerElement) : null;
  }, t.contextType = it, t;
})(ke);
var $I = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var s = i[o];
      if (!e(t[s], n[s])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
}, Z0 = /* @__PURE__ */ dS($I);
const q0 = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], Ad = 1, ea = 8;
class pm {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const o = r >> 4;
    if (o !== Ad)
      throw new Error(`Got v${o} data when expected v${Ad}.`);
    const i = q0[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new pm(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, o) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = q0.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, ea, t), this.coords = new this.ArrayType(this.data, ea + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(ea + s + a + l), this.ids = new this.IndexArrayType(this.data, ea, t), this.coords = new this.ArrayType(this.data, ea + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Ad << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return Ah(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: s, nodeSize: a } = this, l = [0, i.length - 1, 0], u = [];
    for (; l.length; ) {
      const c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (let h = d; h <= p; h++) {
          const E = s[2 * h], L = s[2 * h + 1];
          E >= t && E <= r && L >= n && L <= o && u.push(i[h]);
        }
        continue;
      }
      const g = d + p >> 1, m = s[2 * g], f = s[2 * g + 1];
      m >= t && m <= r && f >= n && f <= o && u.push(i[g]), (c === 0 ? t <= m : n <= f) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= m : o >= f) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: s } = this, a = [0, o.length - 1, 0], l = [], u = r * r;
    for (; a.length; ) {
      const c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (let h = d; h <= p; h++)
          G0(i[2 * h], i[2 * h + 1], t, n) <= u && l.push(o[h]);
        continue;
      }
      const g = d + p >> 1, m = i[2 * g], f = i[2 * g + 1];
      G0(m, f, t, n) <= u && l.push(o[g]), (c === 0 ? t - r <= m : n - r <= f) && (a.push(d), a.push(g - 1), a.push(1 - c)), (c === 0 ? t + r >= m : n + r >= f) && (a.push(g + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function Ah(e, t, n, r, o, i) {
  if (o - r <= n) return;
  const s = r + o >> 1;
  bS(e, t, s, r, o, i), Ah(e, t, n, r, s - 1, 1 - i), Ah(e, t, n, s + 1, o, 1 - i);
}
function bS(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      const u = o - r + 1, c = n - r + 1, p = Math.log(u), d = 0.5 * Math.exp(2 * p / 3), g = 0.5 * Math.sqrt(p * d * (u - d) / u) * (c - u / 2 < 0 ? -1 : 1), m = Math.max(r, Math.floor(n - c * d / u + g)), f = Math.min(o, Math.floor(n + (u - c) * d / u + g));
      bS(e, t, n, m, f, i);
    }
    const s = t[2 * n + i];
    let a = r, l = o;
    for (ta(e, t, r, n), t[2 * o + i] > s && ta(e, t, r, o); a < l; ) {
      for (ta(e, t, a, l), a++, l--; t[2 * a + i] < s; ) a++;
      for (; t[2 * l + i] > s; ) l--;
    }
    t[2 * r + i] === s ? ta(e, t, r, l) : (l++, ta(e, t, l, o)), l <= n && (r = l + 1), n <= l && (o = l - 1);
  }
}
function ta(e, t, n, r) {
  Bd(e, n, r), Bd(t, 2 * n, 2 * r), Bd(t, 2 * n + 1, 2 * r + 1);
}
function Bd(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function G0(e, t, n, r) {
  const o = e - n, i = t - r;
  return o * o + i * i;
}
const WI = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, K0 = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Wi = 2, pi = 3, _d = 4, ai = 5, wS = 6;
class HI {
  constructor(t) {
    this.options = Object.assign(Object.create(WI), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    const { log: n, minZoom: r, maxZoom: o } = this.options;
    n && console.time("total time");
    const i = `prepare ${t.length} points`;
    n && console.time(i), this.points = t;
    const s = [];
    for (let l = 0; l < t.length; l++) {
      const u = t[l];
      if (!u.geometry) continue;
      const [c, p] = u.geometry.coordinates, d = K0(Vl(c)), g = K0(Zl(p));
      s.push(
        d,
        g,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        l,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && s.push(0);
    }
    let a = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (let l = o; l >= r; l--) {
      const u = +Date.now();
      a = this.trees[l] = this._createTree(this._cluster(a, l)), n && console.log("z%d: %d clusters in %dms", l, a.numItems, +Date.now() - u);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    let r = ((t[0] + 180) % 360 + 360) % 360 - 180;
    const o = Math.max(-90, Math.min(90, t[1]));
    let i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
    const s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      const p = this.getClusters([r, o, 180, s], n), d = this.getClusters([-180, o, i, s], n);
      return p.concat(d);
    }
    const a = this.trees[this._limitZoom(n)], l = a.range(Vl(r), Zl(s), Vl(i), Zl(o)), u = a.data, c = [];
    for (const p of l) {
      const d = this.stride * p;
      c.push(u[d + ai] > 1 ? Y0(u, d, this.clusterProps) : this.points[u[d + pi]]);
    }
    return c;
  }
  getChildren(t) {
    const n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    const s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    const a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (const d of c) {
      const g = d * this.stride;
      s[g + _d] === t && p.push(s[g + ai] > 1 ? Y0(s, g, this.clusterProps) : this.points[s[g + pi]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    const o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    const o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), { extent: s, radius: a } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(
      o.range((n - l) / i, u, (n + 1 + l) / i, c),
      o.data,
      n,
      r,
      i,
      p
    ), n === 0 && this._addTileFeatures(
      o.range(1 - l / i, u, 1, c),
      o.data,
      i,
      r,
      i,
      p
    ), n === i - 1 && this._addTileFeatures(
      o.range(0, u, l / i, c),
      o.data,
      -1,
      r,
      i,
      p
    ), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    let n = this._getOriginZoom(t) - 1;
    for (; n <= this.options.maxZoom; ) {
      const r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    const s = this.getChildren(n);
    for (const a of s) {
      const l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    const n = new pm(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (const a of t) {
      const l = a * this.stride, u = n[l + ai] > 1;
      let c, p, d;
      if (u)
        c = CS(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        const f = this.points[n[l + pi]];
        c = f.properties;
        const [h, E] = f.geometry.coordinates;
        p = Vl(h), d = Zl(E);
      }
      const g = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (p * i - r)),
          Math.round(this.options.extent * (d * i - o))
        ]],
        tags: c
      };
      let m;
      u || this.options.generateId ? m = n[l + pi] : m = this.points[n[l + pi]].id, m !== void 0 && (g.id = m), s.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    const { radius: r, extent: o, reduce: i, minPoints: s } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride;
    for (let p = 0; p < l.length; p += c) {
      if (l[p + Wi] <= n) continue;
      l[p + Wi] = n;
      const d = l[p], g = l[p + 1], m = t.within(l[p], l[p + 1], a), f = l[p + ai];
      let h = f;
      for (const E of m) {
        const L = E * c;
        l[L + Wi] > n && (h += l[L + ai]);
      }
      if (h > f && h >= s) {
        let E = d * f, L = g * f, x, T = -1;
        const w = ((p / c | 0) << 5) + (n + 1) + this.points.length;
        for (const C of m) {
          const k = C * c;
          if (l[k + Wi] <= n) continue;
          l[k + Wi] = n;
          const O = l[k + ai];
          E += l[k] * O, L += l[k + 1] * O, l[k + _d] = w, i && (x || (x = this._map(l, p, !0), T = this.clusterProps.length, this.clusterProps.push(x)), i(x, this._map(l, k)));
        }
        l[p + _d] = w, u.push(E / h, L / h, 1 / 0, w, -1, h), i && u.push(T);
      } else {
        for (let E = 0; E < c; E++) u.push(l[p + E]);
        if (h > 1)
          for (const E of m) {
            const L = E * c;
            if (!(l[L + Wi] <= n)) {
              l[L + Wi] = n;
              for (let x = 0; x < c; x++) u.push(l[L + x]);
            }
          }
      }
    }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ai] > 1) {
      const s = this.clusterProps[t[n + wS]];
      return r ? Object.assign({}, s) : s;
    }
    const o = this.points[t[n + pi]].properties, i = this.options.map(o);
    return r && i === o ? Object.assign({}, i) : i;
  }
}
function Y0(e, t, n) {
  return {
    type: "Feature",
    id: e[t + pi],
    properties: CS(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [VI(e[t]), ZI(e[t + 1])]
    }
  };
}
function CS(e, t, n) {
  const r = e[t + ai], o = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, i = e[t + wS], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + pi],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Vl(e) {
  return e / 360 + 0.5;
}
function Zl(e) {
  const t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function VI(e) {
  return (e - 0.5) * 360;
}
function ZI(e) {
  const t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function qI(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Vr {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Bh {
  constructor({ markers: t, position: n }) {
    this.markers = t, n && (n instanceof google.maps.LatLng ? this._position = n : this._position = new google.maps.LatLng(n));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const t = new google.maps.LatLngBounds(this._position, this._position);
    for (const n of this.markers)
      t.extend(Vr.getPosition(n));
    return t;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Vr.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Vr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class GI {
  constructor({ maxZoom: t = 16 }) {
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: t }) {
    return KI(t);
  }
}
const KI = (e) => e.map((t) => new Bh({
  position: Vr.getPosition(t),
  markers: [t]
}));
class YI extends GI {
  constructor(t) {
    var { maxZoom: n, radius: r = 60 } = t, o = qI(t, ["maxZoom", "radius"]);
    super({ maxZoom: n }), this.state = { zoom: -1 }, this.superCluster = new HI(Object.assign({ maxZoom: this.maxZoom, radius: r }, o));
  }
  calculate(t) {
    let n = !1;
    const r = { zoom: t.map.getZoom() };
    if (!Z0(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      const o = this.markers.map((i) => {
        const s = Vr.getPosition(i);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [s.lng(), s.lat()]
          },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !Z0(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), { clusters: this.clusters, changed: n };
  }
  cluster({ map: t }) {
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t.getZoom())).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [t, n] }, properties: r }) {
    if (r.cluster)
      return new Bh({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((i) => i.properties.marker),
        position: { lat: n, lng: t }
      });
    const o = r.marker;
    return new Bh({
      markers: [o],
      position: Vr.getPosition(o)
    });
  }
}
class XI {
  constructor(t, n) {
    this.markers = { sum: t.length };
    const r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class QI {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: t, position: n }, r, o) {
    const i = `<svg fill="${t > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>
</svg>`, s = `Cluster of ${t} markers`, a = Number(google.maps.Marker.MAX_ZINDEX) + t;
    if (Vr.isAdvancedMarkerAvailable(o)) {
      const u = new DOMParser().parseFromString(i, "image/svg+xml").documentElement;
      u.setAttribute("transform", "translate(0 25)");
      const c = {
        map: o,
        position: n,
        zIndex: a,
        title: s,
        content: u
      };
      return new google.maps.marker.AdvancedMarkerElement(c);
    }
    const l = {
      position: n,
      zIndex: a,
      title: s,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(i)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(l);
  }
}
function JI(e, t) {
  for (let n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class dm {
  constructor() {
    JI(dm, google.maps.OverlayView);
  }
}
var La;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(La || (La = {}));
const ej = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class tj extends dm {
  constructor({ map: t, markers: n = [], algorithmOptions: r = {}, algorithm: o = new YI(r), renderer: i = new QI(), onClusterClick: s = ej }) {
    super(), this.markers = [...n], this.clusters = [], this.algorithm = o, this.renderer = i, this.onClusterClick = s, t && this.setMap(t);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    const r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Vr.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    let r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, La.CLUSTERING_BEGIN, this);
      const { clusters: n, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const o = /* @__PURE__ */ new Set();
        for (const s of n)
          s.markers.length == 1 && o.add(s.markers[0]);
        const i = [];
        for (const s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Vr.setMap(s.marker, null) : i.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => i.forEach((s) => Vr.setMap(s, null)));
      }
      google.maps.event.trigger(this, La.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Vr.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    const t = new XI(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Vr.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, La.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Vr.setMap(r.marker, n);
    });
  }
}
function nj(e) {
  var t = hI(), n = D(null), r = n[0], o = n[1];
  return v(function() {
    if (t && r === null) {
      var i = new tj(qe(qe({}, e), { map: t }));
      o(i);
    }
  }, [t]), r;
}
function rj(e) {
  var t = e.children, n = e.options, r = nj(n);
  return r !== null ? t(r) : null;
}
Re(rj);
var X0 = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Q0 = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
function oj(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, g = _e(it), m = D(null), f = m[0], h = m[1], E = D(null), L = E[0], x = E[1], T = D(null), w = T[0], C = T[1], k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = rt(null);
  return v(function() {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(function() {
    o && f !== null && f.setPosition(o);
  }, [o]), v(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(function() {
    f && a && (w !== null && google.maps.event.removeListener(w), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(function() {
    f && l && (O !== null && google.maps.event.removeListener(O), U(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(function() {
    f && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(function() {
    f && c && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(function() {
    var I = new google.maps.InfoWindow(qe({}, r || {}));
    return h(I), X.current = document.createElement("div"), s && x(google.maps.event.addListener(I, "closeclick", s)), a && C(google.maps.event.addListener(I, "domready", a)), l && U(google.maps.event.addListener(I, "content_changed", l)), u && $(google.maps.event.addListener(I, "position_changed", u)), c && H(google.maps.event.addListener(I, "zindex_changed", c)), I.setContent(X.current), o && I.setPosition(o), i && I.setZIndex(i), n ? I.open(g, n) : I.getPosition() ? I.open(g) : ir(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(I), function() {
      L && google.maps.event.removeListener(L), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), V && google.maps.event.removeListener(V), R && google.maps.event.removeListener(R), d && d(I), I.close();
    };
  }, []), X.current ? Lr(Mt.only(t), X.current) : null;
}
Re(oj);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoWindow: null
    }, n.open = function(r, o) {
      o ? r.open(n.context, o) : r.getPosition() ? r.open(n.context) : ir(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }, n.setInfoWindowCallback = function() {
      n.state.infoWindow !== null && n.containerElement !== null && (n.state.infoWindow.setContent(n.containerElement), n.open(n.state.infoWindow, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoWindow));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.InfoWindow(qe({}, this.props.options || {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = yt({
      updaterMap: Q0,
      eventMap: X0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        infoWindow: n
      };
    }, this.setInfoWindowCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.infoWindow !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: Q0,
      eventMap: X0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.infoWindow !== null && (Dt(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Lr(Mt.only(this.props.children), this.containerElement) : null;
  }, t.contextType = it, t;
})(ke);
var J0 = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, eb = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, ij = {};
function sj(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, g = e.onMouseUp, m = e.onRightClick, f = e.onClick, h = e.onDrag, E = e.onLoad, L = e.onUnmount, x = _e(it), T = D(null), w = T[0], C = T[1], k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = D(null), I = X[0], J = X[1], te = D(null), S = te[0], P = te[1], q = D(null), j = q[0], Z = q[1], G = D(null), b = G[0], F = G[1], z = D(null), A = z[0], Y = z[1], ee = D(null), B = ee[0], se = ee[1], ue = D(null), ce = ue[0], de = ue[1], be = D(null), ge = be[0], me = be[1];
  return v(function() {
    w !== null && w.setMap(x);
  }, [x]), v(function() {
    typeof t < "u" && w !== null && w.setOptions(t);
  }, [w, t]), v(function() {
    typeof n < "u" && w !== null && w.setDraggable(n);
  }, [w, n]), v(function() {
    typeof r < "u" && w !== null && w.setEditable(r);
  }, [w, r]), v(function() {
    typeof o < "u" && w !== null && w.setVisible(o);
  }, [w, o]), v(function() {
    typeof i < "u" && w !== null && w.setPath(i);
  }, [w, i]), v(function() {
    w && s && (O !== null && google.maps.event.removeListener(O), U(google.maps.event.addListener(w, "dblclick", s)));
  }, [s]), v(function() {
    w && a && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "dragend", a)));
  }, [a]), v(function() {
    w && l && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(w, "dragstart", l)));
  }, [l]), v(function() {
    w && u && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(w, "mousedown", u)));
  }, [u]), v(function() {
    w && c && (S !== null && google.maps.event.removeListener(S), P(google.maps.event.addListener(w, "mousemove", c)));
  }, [c]), v(function() {
    w && p && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "mouseout", p)));
  }, [p]), v(function() {
    w && d && (b !== null && google.maps.event.removeListener(b), F(google.maps.event.addListener(w, "mouseover", d)));
  }, [d]), v(function() {
    w && g && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(w, "mouseup", g)));
  }, [g]), v(function() {
    w && m && (B !== null && google.maps.event.removeListener(B), se(google.maps.event.addListener(w, "rightclick", m)));
  }, [m]), v(function() {
    w && f && (ce !== null && google.maps.event.removeListener(ce), de(google.maps.event.addListener(w, "click", f)));
  }, [f]), v(function() {
    w && h && (ge !== null && google.maps.event.removeListener(ge), me(google.maps.event.addListener(w, "drag", h)));
  }, [h]), v(function() {
    var ae = new google.maps.Polyline(qe(qe({}, t || ij), { map: x }));
    return i && ae.setPath(i), typeof o < "u" && ae.setVisible(o), typeof r < "u" && ae.setEditable(r), typeof n < "u" && ae.setDraggable(n), s && U(google.maps.event.addListener(ae, "dblclick", s)), a && $(google.maps.event.addListener(ae, "dragend", a)), l && H(google.maps.event.addListener(ae, "dragstart", l)), u && J(google.maps.event.addListener(ae, "mousedown", u)), c && P(google.maps.event.addListener(ae, "mousemove", c)), p && Z(google.maps.event.addListener(ae, "mouseout", p)), d && F(google.maps.event.addListener(ae, "mouseover", d)), g && Y(google.maps.event.addListener(ae, "mouseup", g)), m && se(google.maps.event.addListener(ae, "rightclick", m)), f && de(google.maps.event.addListener(ae, "click", f)), h && me(google.maps.event.addListener(ae, "drag", h)), C(ae), E && E(ae), function() {
      O !== null && google.maps.event.removeListener(O), V !== null && google.maps.event.removeListener(V), R !== null && google.maps.event.removeListener(R), I !== null && google.maps.event.removeListener(I), S !== null && google.maps.event.removeListener(S), j !== null && google.maps.event.removeListener(j), b !== null && google.maps.event.removeListener(b), A !== null && google.maps.event.removeListener(A), B !== null && google.maps.event.removeListener(B), ce !== null && google.maps.event.removeListener(ce), L && L(ae), ae.setMap(null);
    };
  }, []), null;
}
Re(sj);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polyline: null
    }, n.setPolylineCallback = function() {
      n.state.polyline !== null && n.props.onLoad && n.props.onLoad(n.state.polyline);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polyline(qe(qe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = yt({
      updaterMap: eb,
      eventMap: J0,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polyline: n
      };
    }, this.setPolylineCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polyline !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: eb,
      eventMap: J0,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Dt(this.registeredEvents), this.state.polyline.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
var tb = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, nb = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  paths: function(e, t) {
    e.setPaths(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function aj(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.paths, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, g = e.onMouseOver, m = e.onMouseUp, f = e.onRightClick, h = e.onClick, E = e.onDrag, L = e.onLoad, x = e.onUnmount, T = e.onEdit, w = _e(it), C = D(null), k = C[0], O = C[1], U = D(null), M = U[0], V = U[1], $ = D(null), W = $[0], R = $[1], H = D(null), X = H[0], I = H[1], J = D(null), te = J[0], S = J[1], P = D(null), q = P[0], j = P[1], Z = D(null), G = Z[0], b = Z[1], F = D(null), z = F[0], A = F[1], Y = D(null), ee = Y[0], B = Y[1], se = D(null), ue = se[0], ce = se[1], de = D(null), be = de[0], ge = de[1], me = D(null), ae = me[0], xe = me[1];
  return v(function() {
    k !== null && k.setMap(w);
  }, [w]), v(function() {
    typeof t < "u" && k !== null && k.setOptions(t);
  }, [k, t]), v(function() {
    typeof n < "u" && k !== null && k.setDraggable(n);
  }, [k, n]), v(function() {
    typeof r < "u" && k !== null && k.setEditable(r);
  }, [k, r]), v(function() {
    typeof o < "u" && k !== null && k.setVisible(o);
  }, [k, o]), v(function() {
    typeof i < "u" && k !== null && k.setPath(i);
  }, [k, i]), v(function() {
    typeof s < "u" && k !== null && k.setPaths(s);
  }, [k, s]), v(function() {
    k && a && (M !== null && google.maps.event.removeListener(M), V(google.maps.event.addListener(k, "dblclick", a)));
  }, [a]), v(function() {
    k && (google.maps.event.addListener(k.getPath(), "insert_at", function() {
      T == null || T(k);
    }), google.maps.event.addListener(k.getPath(), "set_at", function() {
      T == null || T(k);
    }));
  }, [k, T]), v(function() {
    k && l && (W !== null && google.maps.event.removeListener(W), R(google.maps.event.addListener(k, "dragend", l)));
  }, [l]), v(function() {
    k && u && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(k, "dragstart", u)));
  }, [u]), v(function() {
    k && c && (te !== null && google.maps.event.removeListener(te), S(google.maps.event.addListener(k, "mousedown", c)));
  }, [c]), v(function() {
    k && p && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(k, "mousemove", p)));
  }, [p]), v(function() {
    k && d && (G !== null && google.maps.event.removeListener(G), b(google.maps.event.addListener(k, "mouseout", d)));
  }, [d]), v(function() {
    k && g && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(k, "mouseover", g)));
  }, [g]), v(function() {
    k && m && (ee !== null && google.maps.event.removeListener(ee), B(google.maps.event.addListener(k, "mouseup", m)));
  }, [m]), v(function() {
    k && f && (ue !== null && google.maps.event.removeListener(ue), ce(google.maps.event.addListener(k, "rightclick", f)));
  }, [f]), v(function() {
    k && h && (be !== null && google.maps.event.removeListener(be), ge(google.maps.event.addListener(k, "click", h)));
  }, [h]), v(function() {
    k && E && (ae !== null && google.maps.event.removeListener(ae), xe(google.maps.event.addListener(k, "drag", E)));
  }, [E]), v(function() {
    var re = new google.maps.Polygon(qe(qe({}, t || {}), { map: w }));
    return i && re.setPath(i), s && re.setPaths(s), typeof o < "u" && re.setVisible(o), typeof r < "u" && re.setEditable(r), typeof n < "u" && re.setDraggable(n), a && V(google.maps.event.addListener(re, "dblclick", a)), l && R(google.maps.event.addListener(re, "dragend", l)), u && I(google.maps.event.addListener(re, "dragstart", u)), c && S(google.maps.event.addListener(re, "mousedown", c)), p && j(google.maps.event.addListener(re, "mousemove", p)), d && b(google.maps.event.addListener(re, "mouseout", d)), g && A(google.maps.event.addListener(re, "mouseover", g)), m && B(google.maps.event.addListener(re, "mouseup", m)), f && ce(google.maps.event.addListener(re, "rightclick", f)), h && ge(google.maps.event.addListener(re, "click", h)), E && xe(google.maps.event.addListener(re, "drag", E)), O(re), L && L(re), function() {
      M !== null && google.maps.event.removeListener(M), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), q !== null && google.maps.event.removeListener(q), G !== null && google.maps.event.removeListener(G), z !== null && google.maps.event.removeListener(z), ee !== null && google.maps.event.removeListener(ee), ue !== null && google.maps.event.removeListener(ue), be !== null && google.maps.event.removeListener(be), x && x(re), re.setMap(null);
    };
  }, []), null;
}
Re(aj);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polygon: null
    }, n.setPolygonCallback = function() {
      n.state.polygon !== null && n.props.onLoad && n.props.onLoad(n.state.polygon);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polygon(qe(qe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = yt({
      updaterMap: nb,
      eventMap: tb,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polygon: n
      };
    }, this.setPolygonCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polygon !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: nb,
      eventMap: tb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polygon
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polygon !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polygon), Dt(this.registeredEvents), this.state.polygon && this.state.polygon.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
var rb = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, ob = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function lj(e) {
  var t = e.options, n = e.bounds, r = e.draggable, o = e.editable, i = e.visible, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, g = e.onMouseUp, m = e.onRightClick, f = e.onClick, h = e.onDrag, E = e.onBoundsChanged, L = e.onLoad, x = e.onUnmount, T = _e(it), w = D(null), C = w[0], k = w[1], O = D(null), U = O[0], M = O[1], V = D(null), $ = V[0], W = V[1], R = D(null), H = R[0], X = R[1], I = D(null), J = I[0], te = I[1], S = D(null), P = S[0], q = S[1], j = D(null), Z = j[0], G = j[1], b = D(null), F = b[0], z = b[1], A = D(null), Y = A[0], ee = A[1], B = D(null), se = B[0], ue = B[1], ce = D(null), de = ce[0], be = ce[1], ge = D(null), me = ge[0], ae = ge[1], xe = D(null), re = xe[0], Te = xe[1];
  return v(function() {
    C !== null && C.setMap(T);
  }, [T]), v(function() {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(function() {
    typeof r < "u" && C !== null && C.setDraggable(r);
  }, [C, r]), v(function() {
    typeof o < "u" && C !== null && C.setEditable(o);
  }, [C, o]), v(function() {
    typeof i < "u" && C !== null && C.setVisible(i);
  }, [C, i]), v(function() {
    typeof n < "u" && C !== null && C.setBounds(n);
  }, [C, n]), v(function() {
    C && s && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(function() {
    C && a && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(C, "dragend", a)));
  }, [a]), v(function() {
    C && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "dragstart", l)));
  }, [l]), v(function() {
    C && u && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(C, "mousedown", u)));
  }, [u]), v(function() {
    C && c && (P !== null && google.maps.event.removeListener(P), q(google.maps.event.addListener(C, "mousemove", c)));
  }, [c]), v(function() {
    C && p && (Z !== null && google.maps.event.removeListener(Z), G(google.maps.event.addListener(C, "mouseout", p)));
  }, [p]), v(function() {
    C && d && (F !== null && google.maps.event.removeListener(F), z(google.maps.event.addListener(C, "mouseover", d)));
  }, [d]), v(function() {
    C && g && (Y !== null && google.maps.event.removeListener(Y), ee(google.maps.event.addListener(C, "mouseup", g)));
  }, [g]), v(function() {
    C && m && (se !== null && google.maps.event.removeListener(se), ue(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(function() {
    C && f && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(C, "click", f)));
  }, [f]), v(function() {
    C && h && (me !== null && google.maps.event.removeListener(me), ae(google.maps.event.addListener(C, "drag", h)));
  }, [h]), v(function() {
    C && E && (re !== null && google.maps.event.removeListener(re), Te(google.maps.event.addListener(C, "bounds_changed", E)));
  }, [E]), v(function() {
    var ne = new google.maps.Rectangle(qe(qe({}, t || {}), { map: T }));
    return typeof i < "u" && ne.setVisible(i), typeof o < "u" && ne.setEditable(o), typeof r < "u" && ne.setDraggable(r), typeof n < "u" && ne.setBounds(n), s && M(google.maps.event.addListener(ne, "dblclick", s)), a && W(google.maps.event.addListener(ne, "dragend", a)), l && X(google.maps.event.addListener(ne, "dragstart", l)), u && te(google.maps.event.addListener(ne, "mousedown", u)), c && q(google.maps.event.addListener(ne, "mousemove", c)), p && G(google.maps.event.addListener(ne, "mouseout", p)), d && z(google.maps.event.addListener(ne, "mouseover", d)), g && ee(google.maps.event.addListener(ne, "mouseup", g)), m && ue(google.maps.event.addListener(ne, "rightclick", m)), f && be(google.maps.event.addListener(ne, "click", f)), h && ae(google.maps.event.addListener(ne, "drag", h)), E && Te(google.maps.event.addListener(ne, "bounds_changed", E)), k(ne), L && L(ne), function() {
      U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), P !== null && google.maps.event.removeListener(P), Z !== null && google.maps.event.removeListener(Z), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), se !== null && google.maps.event.removeListener(se), de !== null && google.maps.event.removeListener(de), me !== null && google.maps.event.removeListener(me), re !== null && google.maps.event.removeListener(re), x && x(ne), ne.setMap(null);
    };
  }, []), null;
}
Re(lj);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      rectangle: null
    }, n.setRectangleCallback = function() {
      n.state.rectangle !== null && n.props.onLoad && n.props.onLoad(n.state.rectangle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Rectangle(qe(qe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = yt({
      updaterMap: ob,
      eventMap: rb,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        rectangle: n
      };
    }, this.setRectangleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.rectangle !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: ob,
      eventMap: rb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Dt(this.registeredEvents), this.state.rectangle.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
var ib = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, sb = {
  center: function(e, t) {
    e.setCenter(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  radius: function(e, t) {
    e.setRadius(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, uj = {};
function cj(e) {
  var t = e.options, n = e.center, r = e.radius, o = e.draggable, i = e.editable, s = e.visible, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, g = e.onMouseOver, m = e.onMouseUp, f = e.onRightClick, h = e.onClick, E = e.onDrag, L = e.onCenterChanged, x = e.onRadiusChanged, T = e.onLoad, w = e.onUnmount, C = _e(it), k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = D(null), I = X[0], J = X[1], te = D(null), S = te[0], P = te[1], q = D(null), j = q[0], Z = q[1], G = D(null), b = G[0], F = G[1], z = D(null), A = z[0], Y = z[1], ee = D(null), B = ee[0], se = ee[1], ue = D(null), ce = ue[0], de = ue[1], be = D(null), ge = be[0], me = be[1], ae = D(null), xe = ae[0], re = ae[1], Te = D(null), ne = Te[0], Ee = Te[1], Ne = D(null), Fe = Ne[0], Ue = Ne[1];
  return v(function() {
    O !== null && O.setMap(C);
  }, [C]), v(function() {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), v(function() {
    typeof o < "u" && O !== null && O.setDraggable(o);
  }, [O, o]), v(function() {
    typeof i < "u" && O !== null && O.setEditable(i);
  }, [O, i]), v(function() {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(function() {
    typeof r == "number" && O !== null && O.setRadius(r);
  }, [O, r]), v(function() {
    typeof n < "u" && O !== null && O.setCenter(n);
  }, [O, n]), v(function() {
    O && a && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), v(function() {
    O && l && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), v(function() {
    O && u && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), v(function() {
    O && c && (S !== null && google.maps.event.removeListener(S), P(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), v(function() {
    O && p && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(O, "mousemove", p)));
  }, [p]), v(function() {
    O && d && (b !== null && google.maps.event.removeListener(b), F(google.maps.event.addListener(O, "mouseout", d)));
  }, [d]), v(function() {
    O && g && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(O, "mouseover", g)));
  }, [g]), v(function() {
    O && m && (B !== null && google.maps.event.removeListener(B), se(google.maps.event.addListener(O, "mouseup", m)));
  }, [m]), v(function() {
    O && f && (ce !== null && google.maps.event.removeListener(ce), de(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), v(function() {
    O && h && (ge !== null && google.maps.event.removeListener(ge), me(google.maps.event.addListener(O, "click", h)));
  }, [h]), v(function() {
    O && E && (xe !== null && google.maps.event.removeListener(xe), re(google.maps.event.addListener(O, "drag", E)));
  }, [E]), v(function() {
    O && L && (ne !== null && google.maps.event.removeListener(ne), Ee(google.maps.event.addListener(O, "center_changed", L)));
  }, [h]), v(function() {
    O && x && (Fe !== null && google.maps.event.removeListener(Fe), Ue(google.maps.event.addListener(O, "radius_changed", x)));
  }, [x]), v(function() {
    var he = new google.maps.Circle(qe(qe({}, t || uj), { map: C }));
    return typeof r == "number" && he.setRadius(r), typeof n < "u" && he.setCenter(n), typeof r == "number" && he.setRadius(r), typeof s < "u" && he.setVisible(s), typeof i < "u" && he.setEditable(i), typeof o < "u" && he.setDraggable(o), a && $(google.maps.event.addListener(he, "dblclick", a)), l && H(google.maps.event.addListener(he, "dragend", l)), u && J(google.maps.event.addListener(he, "dragstart", u)), c && P(google.maps.event.addListener(he, "mousedown", c)), p && Z(google.maps.event.addListener(he, "mousemove", p)), d && F(google.maps.event.addListener(he, "mouseout", d)), g && Y(google.maps.event.addListener(he, "mouseover", g)), m && se(google.maps.event.addListener(he, "mouseup", m)), f && de(google.maps.event.addListener(he, "rightclick", f)), h && me(google.maps.event.addListener(he, "click", h)), E && re(google.maps.event.addListener(he, "drag", E)), L && Ee(google.maps.event.addListener(he, "center_changed", L)), x && Ue(google.maps.event.addListener(he, "radius_changed", x)), U(he), T && T(he), function() {
      V !== null && google.maps.event.removeListener(V), R !== null && google.maps.event.removeListener(R), I !== null && google.maps.event.removeListener(I), S !== null && google.maps.event.removeListener(S), j !== null && google.maps.event.removeListener(j), b !== null && google.maps.event.removeListener(b), A !== null && google.maps.event.removeListener(A), B !== null && google.maps.event.removeListener(B), ce !== null && google.maps.event.removeListener(ce), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), Fe !== null && google.maps.event.removeListener(Fe), w && w(he), he.setMap(null);
    };
  }, []), null;
}
Re(cj);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      circle: null
    }, n.setCircleCallback = function() {
      n.state.circle !== null && n.props.onLoad && n.props.onLoad(n.state.circle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Circle(qe(qe({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = yt({
      updaterMap: sb,
      eventMap: ib,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        circle: n
      };
    }, this.setCircleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.circle !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: sb,
      eventMap: ib,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n;
    this.state.circle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.circle), Dt(this.registeredEvents), (n = this.state.circle) === null || n === void 0 || n.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
var ab = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, lb = {
  add: function(e, t) {
    e.add(t);
  },
  addgeojson: function(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains: function(e, t) {
    e.contains(t);
  },
  foreach: function(e, t) {
    e.forEach(t);
  },
  loadgeojson: function(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle: function(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove: function(e, t) {
    e.remove(t);
  },
  revertstyle: function(e, t) {
    e.revertStyle(t);
  },
  controlposition: function(e, t) {
    e.setControlPosition(t);
  },
  controls: function(e, t) {
    e.setControls(t);
  },
  drawingmode: function(e, t) {
    e.setDrawingMode(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  style: function(e, t) {
    e.setStyle(t);
  },
  togeojson: function(e, t) {
    e.toGeoJson(t);
  }
};
function pj(e) {
  var t = e.options, n = e.onClick, r = e.onDblClick, o = e.onMouseDown, i = e.onMouseMove, s = e.onMouseOut, a = e.onMouseOver, l = e.onMouseUp, u = e.onRightClick, c = e.onAddFeature, p = e.onRemoveFeature, d = e.onRemoveProperty, g = e.onSetGeometry, m = e.onSetProperty, f = e.onLoad, h = e.onUnmount, E = _e(it), L = D(null), x = L[0], T = L[1], w = D(null), C = w[0], k = w[1], O = D(null), U = O[0], M = O[1], V = D(null), $ = V[0], W = V[1], R = D(null), H = R[0], X = R[1], I = D(null), J = I[0], te = I[1], S = D(null), P = S[0], q = S[1], j = D(null), Z = j[0], G = j[1], b = D(null), F = b[0], z = b[1], A = D(null), Y = A[0], ee = A[1], B = D(null), se = B[0], ue = B[1], ce = D(null), de = ce[0], be = ce[1], ge = D(null), me = ge[0], ae = ge[1], xe = D(null), re = xe[0], Te = xe[1];
  return v(function() {
    x !== null && x.setMap(E);
  }, [E]), v(function() {
    x && r && (C !== null && google.maps.event.removeListener(C), k(google.maps.event.addListener(x, "dblclick", r)));
  }, [r]), v(function() {
    x && o && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(x, "mousedown", o)));
  }, [o]), v(function() {
    x && i && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(x, "mousemove", i)));
  }, [i]), v(function() {
    x && s && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mouseout", s)));
  }, [s]), v(function() {
    x && a && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(x, "mouseover", a)));
  }, [a]), v(function() {
    x && l && (P !== null && google.maps.event.removeListener(P), q(google.maps.event.addListener(x, "mouseup", l)));
  }, [l]), v(function() {
    x && u && (Z !== null && google.maps.event.removeListener(Z), G(google.maps.event.addListener(x, "rightclick", u)));
  }, [u]), v(function() {
    x && n && (F !== null && google.maps.event.removeListener(F), z(google.maps.event.addListener(x, "click", n)));
  }, [n]), v(function() {
    x && c && (Y !== null && google.maps.event.removeListener(Y), ee(google.maps.event.addListener(x, "addfeature", c)));
  }, [c]), v(function() {
    x && p && (se !== null && google.maps.event.removeListener(se), ue(google.maps.event.addListener(x, "removefeature", p)));
  }, [p]), v(function() {
    x && d && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(x, "removeproperty", d)));
  }, [d]), v(function() {
    x && g && (me !== null && google.maps.event.removeListener(me), ae(google.maps.event.addListener(x, "setgeometry", g)));
  }, [g]), v(function() {
    x && m && (re !== null && google.maps.event.removeListener(re), Te(google.maps.event.addListener(x, "setproperty", m)));
  }, [m]), v(function() {
    if (E !== null) {
      var ne = new google.maps.Data(qe(qe({}, t || {}), { map: E }));
      r && k(google.maps.event.addListener(ne, "dblclick", r)), o && M(google.maps.event.addListener(ne, "mousedown", o)), i && W(google.maps.event.addListener(ne, "mousemove", i)), s && X(google.maps.event.addListener(ne, "mouseout", s)), a && te(google.maps.event.addListener(ne, "mouseover", a)), l && q(google.maps.event.addListener(ne, "mouseup", l)), u && G(google.maps.event.addListener(ne, "rightclick", u)), n && z(google.maps.event.addListener(ne, "click", n)), c && ee(google.maps.event.addListener(ne, "addfeature", c)), p && ue(google.maps.event.addListener(ne, "removefeature", p)), d && be(google.maps.event.addListener(ne, "removeproperty", d)), g && ae(google.maps.event.addListener(ne, "setgeometry", g)), m && Te(google.maps.event.addListener(ne, "setproperty", m)), T(ne), f && f(ne);
    }
    return function() {
      x && (C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), P !== null && google.maps.event.removeListener(P), Z !== null && google.maps.event.removeListener(Z), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), se !== null && google.maps.event.removeListener(se), de !== null && google.maps.event.removeListener(de), me !== null && google.maps.event.removeListener(me), re !== null && google.maps.event.removeListener(re), h && h(x), x.setMap(null));
    };
  }, []), null;
}
Re(pj);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      data: null
    }, n.setDataCallback = function() {
      n.state.data !== null && n.props.onLoad && n.props.onLoad(n.state.data);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context !== null) {
      var n = new google.maps.Data(qe(qe({}, this.props.options || {}), { map: this.context }));
      this.registeredEvents = yt({
        updaterMap: lb,
        eventMap: ab,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          data: n
        };
      }, this.setDataCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.data !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: lb,
      eventMap: ab,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.data
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Dt(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
var ub = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, cb = {
  options: function(e, t) {
    e.setOptions(t);
  },
  url: function(e, t) {
    e.setUrl(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      kmlLayer: null
    }, n.setKmlLayerCallback = function() {
      n.state.kmlLayer !== null && n.props.onLoad && n.props.onLoad(n.state.kmlLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.KmlLayer(qe(qe({}, this.props.options), { map: this.context }));
    this.registeredEvents = yt({
      updaterMap: cb,
      eventMap: ub,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        kmlLayer: n
      };
    }, this.setKmlLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.kmlLayer !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: cb,
      eventMap: ub,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Dt(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
function ES(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function dj(e, t) {
  return new t(e.lat, e.lng);
}
function fj(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function hj(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function gj(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function mj(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function vj(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var o = r.x, i = r.y;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function xS(e, t, n, r) {
  return n !== void 0 ? mj(e, t, gj(n, google.maps.LatLngBounds, fj)) : vj(e, t, hj(r, google.maps.LatLng, dj));
}
function yj(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function bj(e, t, n, r, o) {
  var i = (
    /** @class */
    function(s) {
      gn(a, s);
      function a(l, u, c, p) {
        var d = s.call(this) || this;
        return d.container = l, d.pane = u, d.position = c, d.bounds = p, d;
      }
      return a.prototype.onAdd = function() {
        var l, u = (l = this.getPanes()) === null || l === void 0 ? void 0 : l[this.pane];
        u == null || u.appendChild(this.container);
      }, a.prototype.draw = function() {
        for (var l = this.getProjection(), u = qe({}, this.container ? ES(this.container, o) : {
          x: 0,
          y: 0
        }), c = xS(l, u, this.bounds, this.position), p = 0, d = Object.entries(c); p < d.length; p++) {
          var g = d[p], m = g[0], f = g[1];
          this.container.style[m] = f;
        }
      }, a.prototype.onRemove = function() {
        this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
      }, a;
    }(google.maps.OverlayView)
  );
  return new i(e, t, n, r);
}
function pb(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function db(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function wj(e) {
  var t = e.position, n = e.bounds, r = e.mapPaneName, o = e.zIndex, i = e.onLoad, s = e.onUnmount, a = e.getPixelPositionOffset, l = e.children, u = _e(it), c = rr(function() {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = rr(function() {
    return bj(c, r, t, n, a);
  }, [c, r, t, n]);
  return v(function() {
    return i == null || i(p), p == null || p.setMap(u), function() {
      s == null || s(p), p == null || p.setMap(null);
    };
  }, [u, p]), v(function() {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Di.createPortal(l, c);
}
Re(wj);
(function(e) {
  gn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    r.state = {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }, r.updatePane = function() {
      var i = r.props.mapPaneName, s = r.overlayView.getPanes();
      ir(!!i, "OverlayView requires props.mapPaneName but got %s", i), s ? r.setState({
        paneEl: s[i]
      }) : r.setState({
        paneEl: null
      });
    }, r.onAdd = function() {
      var i, s;
      r.updatePane(), (s = (i = r.props).onLoad) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.onPositionElement = function() {
      var i = r.overlayView.getProjection(), s = qe({ x: 0, y: 0 }, r.containerRef.current ? ES(r.containerRef.current, r.props.getPixelPositionOffset) : {}), a = xS(i, s, r.props.bounds, r.props.position), l = r.state.containerStyle, u = l.left, c = l.top, p = l.width, d = l.height;
      yj(a, { left: u, top: c, width: p, height: d }) || r.setState({
        containerStyle: {
          top: a.top || 0,
          left: a.left || 0,
          width: a.width || 0,
          height: a.height || 0,
          position: "absolute"
        }
      });
    }, r.draw = function() {
      r.onPositionElement();
    }, r.onRemove = function() {
      var i, s;
      r.setState(function() {
        return {
          paneEl: null
        };
      }), (s = (i = r.props).onUnmount) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.containerRef = xr();
    var o = new google.maps.OverlayView();
    return o.onAdd = r.onAdd, o.draw = r.draw, o.onRemove = r.onRemove, r.overlayView = o, r;
  }
  return t.prototype.componentDidMount = function() {
    this.overlayView.setMap(this.context);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = pb(n.position), o = pb(this.props.position), i = db(n.bounds), s = db(this.props.bounds);
    (r !== o || i !== s) && this.overlayView.draw(), n.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }, t.prototype.componentWillUnmount = function() {
    this.overlayView.setMap(null);
  }, t.prototype.render = function() {
    var n = this.state.paneEl;
    return n ? Di.createPortal(Ft.jsx("div", { ref: this.containerRef, style: this.state.containerStyle, children: Mt.only(this.props.children) }), n) : null;
  }, t.FLOAT_PANE = "floatPane", t.MAP_PANE = "mapPane", t.MARKER_LAYER = "markerLayer", t.OVERLAY_LAYER = "overlayLayer", t.OVERLAY_MOUSE_TARGET = "overlayMouseTarget", t.contextType = it, t;
})(ke);
function Cj() {
}
var fb = {
  onDblClick: "dblclick",
  onClick: "click"
}, hb = {
  opacity: function(e, t) {
    e.setOpacity(t);
  }
};
function Ej(e) {
  var t = e.url, n = e.bounds, r = e.options, o = e.visible, i = _e(it), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = rr(function() {
    var l = new google.maps.GroundOverlay(t, s, qe({}, r));
    return l;
  }, []);
  return v(function() {
    a !== null && a.setMap(i);
  }, [i]), v(function() {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), v(function() {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), v(function() {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Re(Ej);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      groundOverlay: null
    }, n.setGroundOverlayCallback = function() {
      n.state.groundOverlay !== null && n.props.onLoad && n.props.onLoad(n.state.groundOverlay);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    ir(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var n = new google.maps.GroundOverlay(this.props.url, this.props.bounds, qe(qe({}, this.props.options), { map: this.context }));
    this.registeredEvents = yt({
      updaterMap: hb,
      eventMap: fb,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        groundOverlay: n
      };
    }, this.setGroundOverlayCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.groundOverlay !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: hb,
      eventMap: fb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.defaultProps = {
    onLoad: Cj
  }, t.contextType = it, t;
})(ke);
var gb = {}, mb = {
  data: function(e, t) {
    e.setData(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function xj(e) {
  var t = e.data, n = e.onLoad, r = e.onUnmount, o = e.options, i = _e(it), s = D(null), a = s[0], l = s[1];
  return v(function() {
    google.maps.visualization || ir(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(function() {
    ir(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(function() {
    a !== null && a.setMap(i);
  }, [i]), v(function() {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(function() {
    var u = new google.maps.visualization.HeatmapLayer(qe(qe({}, o || {}), { data: t, map: i }));
    return l(u), n && n(u), function() {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Re(xj);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      heatmapLayer: null
    }, n.setHeatmapLayerCallback = function() {
      n.state.heatmapLayer !== null && n.props.onLoad && n.props.onLoad(n.state.heatmapLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    ir(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), ir(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var n = new google.maps.visualization.HeatmapLayer(qe(qe({}, this.props.options || {}), { data: this.props.data, map: this.context }));
    this.registeredEvents = yt({
      updaterMap: mb,
      eventMap: gb,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        heatmapLayer: n
      };
    }, this.setHeatmapLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: mb,
      eventMap: gb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Dt(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
var vb = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, yb = {
  register: function(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links: function(e, t) {
    e.setLinks(t);
  },
  motionTracking: function(e, t) {
    e.setMotionTracking(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  pano: function(e, t) {
    e.setPano(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  pov: function(e, t) {
    e.setPov(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      streetViewPanorama: null
    }, n.setStreetViewPanoramaCallback = function() {
      n.state.streetViewPanorama !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewPanorama);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n, r, o = (r = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && r !== void 0 ? r : null;
    this.registeredEvents = yt({
      updaterMap: yb,
      eventMap: vb,
      prevProps: {},
      nextProps: this.props,
      instance: o
    }), this.setState(function() {
      return {
        streetViewPanorama: o
      };
    }, this.setStreetViewPanoramaCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.streetViewPanorama !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: yb,
      eventMap: vb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Dt(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      streetViewService: null
    }, n.setStreetViewServiceCallback = function() {
      n.state.streetViewService !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: n
      };
    }, this.setStreetViewServiceCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = it, t;
})(ke);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      directionsService: null
    }, n.setDirectionsServiceCallback = function() {
      n.state.directionsService !== null && n.props.onLoad && n.props.onLoad(n.state.directionsService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    ir(!!this.props.options, "DirectionsService expected options object as parameter, but got %s", this.props.options);
    var n = new google.maps.DirectionsService();
    this.setState(function() {
      return {
        directionsService: n
      };
    }, this.setDirectionsServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.directionsService !== null && this.state.directionsService.route(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsService !== null && this.props.onUnmount && this.props.onUnmount(this.state.directionsService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(ke);
var bb = {
  onDirectionsChanged: "directions_changed"
}, wb = {
  directions: function(e, t) {
    e.setDirections(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  panel: function(e, t) {
    e.setPanel(t);
  },
  routeIndex: function(e, t) {
    e.setRouteIndex(t);
  }
};
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      directionsRenderer: null
    }, n.setDirectionsRendererCallback = function() {
      n.state.directionsRenderer !== null && (n.state.directionsRenderer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.directionsRenderer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = yt({
      updaterMap: wb,
      eventMap: bb,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        directionsRenderer: n
      };
    }, this.setDirectionsRendererCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.directionsRenderer !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: wb,
      eventMap: bb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Dt(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }, t.prototype.render = function() {
    return Ft.jsx(Ft.Fragment, {});
  }, t.contextType = it, t;
})(ke);
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      distanceMatrixService: null
    }, n.setDistanceMatrixServiceCallback = function() {
      n.state.distanceMatrixService !== null && n.props.onLoad && n.props.onLoad(n.state.distanceMatrixService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    ir(!!this.props.options, "DistanceMatrixService expected options object as parameter, but go %s", this.props.options);
    var n = new google.maps.DistanceMatrixService();
    this.setState(function() {
      return {
        distanceMatrixService: n
      };
    }, this.setDistanceMatrixServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.distanceMatrixService !== null && this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.distanceMatrixService !== null && this.props.onUnmount && this.props.onUnmount(this.state.distanceMatrixService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(ke);
var Cb = {
  onPlacesChanged: "places_changed"
}, Eb = {
  bounds: function(e, t) {
    e.setBounds(t);
  }
};
/** @class */
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = xr(), n.state = {
      searchBox: null
    }, n.setSearchBoxCallback = function() {
      n.state.searchBox !== null && n.props.onLoad && n.props.onLoad(n.state.searchBox);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (ir(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var n = this.containerElement.current.querySelector("input");
      if (n !== null) {
        var r = new google.maps.places.SearchBox(n, this.props.options);
        this.registeredEvents = yt({
          updaterMap: Eb,
          eventMap: Cb,
          prevProps: {},
          nextProps: this.props,
          instance: r
        }), this.setState(function() {
          return {
            searchBox: r
          };
        }, this.setSearchBoxCallback);
      }
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.searchBox !== null && (Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: Eb,
      eventMap: Cb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Dt(this.registeredEvents));
  }, t.prototype.render = function() {
    return Ft.jsx("div", { ref: this.containerElement, children: Mt.only(this.props.children) });
  }, t.contextType = it, t;
})(ke);
var xb = {
  onPlaceChanged: "place_changed"
}, Lb = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  restrictions: function(e, t) {
    e.setComponentRestrictions(t);
  },
  fields: function(e, t) {
    e.setFields(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  types: function(e, t) {
    e.setTypes(t);
  }
};
(function(e) {
  gn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = xr(), n.state = {
      autocomplete: null
    }, n.setAutocompleteCallback = function() {
      n.state.autocomplete !== null && n.props.onLoad && n.props.onLoad(n.state.autocomplete);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n;
    ir(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var r = (n = this.containerElement.current) === null || n === void 0 ? void 0 : n.querySelector("input");
    if (r) {
      var o = new google.maps.places.Autocomplete(r, this.props.options);
      this.registeredEvents = yt({
        updaterMap: Lb,
        eventMap: xb,
        prevProps: {},
        nextProps: this.props,
        instance: o
      }), this.setState(function() {
        return {
          autocomplete: o
        };
      }, this.setAutocompleteCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    Dt(this.registeredEvents), this.registeredEvents = yt({
      updaterMap: Lb,
      eventMap: xb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.autocomplete !== null && Dt(this.registeredEvents);
  }, t.prototype.render = function() {
    return Ft.jsx("div", { ref: this.containerElement, className: this.props.className, children: Mt.only(this.props.children) });
  }, t.defaultProps = {
    className: ""
  }, t.contextType = it, t;
})(ke);
function LS(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: s,
    rightIcon: a,
    disabled: l,
    className: u = "",
    children: c,
    ...p
  } = e, d = { xs: 12, sm: 16, md: 20, lg: 24 }[i], g = `arkynButton ${t ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ Ft.jsxs("button", { className: g, disabled: l || t, ...p, children: [
    /* @__PURE__ */ Ft.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ Ft.jsx(Zo, { size: d, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ Ft.jsxs("div", { className: "arkynButtonContent", children: [
      T0(d, s),
      c,
      T0(d, a)
    ] })
  ] });
}
function Lj() {
  const e = rm(), t = WD(), n = HD(), [r, o] = D(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function s() {
    r && o(null);
  }
  v(() => {
    var u, c;
    let p = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, p) || Object.entries(p).length !== 0 && o(p);
  }, [n, e]), v(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && s();
  }, [n, t]);
  const a = (e == null ? void 0 : e.fieldErrors) || r;
  let l = {};
  return Object.entries(a || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
Ye({});
function kj(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const Dj = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
kj(Dj.CNPJ).length;
Fs((e, t) => /* @__PURE__ */ Ft.jsx("input", { ref: t, ...e }));
function Sj(e) {
  const {
    isLoading: t = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: s,
    className: a = "",
    ...l
  } = e, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${t ? "loadingTrue" : "loadingFalse"} ${a}`;
  return /* @__PURE__ */ Ft.jsxs(
    "button",
    {
      disabled: s || t,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ Ft.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ Ft.jsx(Zo, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ Ft.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ Ft.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
var nn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function Oj(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var _h = { exports: {} }, na = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var kb;
function Mj() {
  if (kb) return na;
  kb = 1;
  var e = Be, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: g, props: p, _owner: o.current };
  }
  return na.Fragment = n, na.jsx = s, na.jsxs = s, na;
}
var ql = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Db;
function Pj() {
  return Db || (Db = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Be, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), m = Symbol.iterator, f = "@@iterator";
    function h(y) {
      if (y === null || typeof y != "object")
        return null;
      var _ = m && y[m] || y[f];
      return typeof _ == "function" ? _ : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function L(y) {
      {
        for (var _ = arguments.length, K = new Array(_ > 1 ? _ - 1 : 0), ie = 1; ie < _; ie++)
          K[ie - 1] = arguments[ie];
        x("error", y, K);
      }
    }
    function x(y, _, K) {
      {
        var ie = E.ReactDebugCurrentFrame, ve = ie.getStackAddendum();
        ve !== "" && (_ += "%s", K = K.concat([ve]));
        var we = K.map(function(fe) {
          return String(fe);
        });
        we.unshift("Warning: " + _), Function.prototype.apply.call(console[y], console, we);
      }
    }
    var T = !1, w = !1, C = !1, k = !1, O = !1, U;
    U = Symbol.for("react.module.reference");
    function M(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === i || O || y === o || y === u || y === c || k || y === g || T || w || C || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === p || y.$$typeof === s || y.$$typeof === a || y.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === U || y.getModuleId !== void 0));
    }
    function V(y, _, K) {
      var ie = y.displayName;
      if (ie)
        return ie;
      var ve = _.displayName || _.name || "";
      return ve !== "" ? K + "(" + ve + ")" : K;
    }
    function $(y) {
      return y.displayName || "Context";
    }
    function W(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && L("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case a:
            var _ = y;
            return $(_) + ".Consumer";
          case s:
            var K = y;
            return $(K._context) + ".Provider";
          case l:
            return V(y, y.render, "ForwardRef");
          case p:
            var ie = y.displayName || null;
            return ie !== null ? ie : W(y.type) || "Memo";
          case d: {
            var ve = y, we = ve._payload, fe = ve._init;
            try {
              return W(fe(we));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var R = Object.assign, H = 0, X, I, J, te, S, P, q;
    function j() {
    }
    j.__reactDisabledLog = !0;
    function Z() {
      {
        if (H === 0) {
          X = console.log, I = console.info, J = console.warn, te = console.error, S = console.group, P = console.groupCollapsed, q = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: j,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        H++;
      }
    }
    function G() {
      {
        if (H--, H === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: R({}, y, {
              value: X
            }),
            info: R({}, y, {
              value: I
            }),
            warn: R({}, y, {
              value: J
            }),
            error: R({}, y, {
              value: te
            }),
            group: R({}, y, {
              value: S
            }),
            groupCollapsed: R({}, y, {
              value: P
            }),
            groupEnd: R({}, y, {
              value: q
            })
          });
        }
        H < 0 && L("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var b = E.ReactCurrentDispatcher, F;
    function z(y, _, K) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ve) {
            var ie = ve.stack.trim().match(/\n( *(at )?)/);
            F = ie && ie[1] || "";
          }
        return `
` + F + y;
      }
    }
    var A = !1, Y;
    {
      var ee = typeof WeakMap == "function" ? WeakMap : Map;
      Y = new ee();
    }
    function B(y, _) {
      if (!y || A)
        return "";
      {
        var K = Y.get(y);
        if (K !== void 0)
          return K;
      }
      var ie;
      A = !0;
      var ve = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var we;
      we = b.current, b.current = null, Z();
      try {
        if (_) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (je) {
              ie = je;
            }
            Reflect.construct(y, [], fe);
          } else {
            try {
              fe.call();
            } catch (je) {
              ie = je;
            }
            y.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ie = je;
          }
          y();
        }
      } catch (je) {
        if (je && ie && typeof je.stack == "string") {
          for (var pe = je.stack.split(`
`), Ie = ie.stack.split(`
`), De = pe.length - 1, Se = Ie.length - 1; De >= 1 && Se >= 0 && pe[De] !== Ie[Se]; )
            Se--;
          for (; De >= 1 && Se >= 0; De--, Se--)
            if (pe[De] !== Ie[Se]) {
              if (De !== 1 || Se !== 1)
                do
                  if (De--, Se--, Se < 0 || pe[De] !== Ie[Se]) {
                    var ze = `
` + pe[De].replace(" at new ", " at ");
                    return y.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", y.displayName)), typeof y == "function" && Y.set(y, ze), ze;
                  }
                while (De >= 1 && Se >= 0);
              break;
            }
        }
      } finally {
        A = !1, b.current = we, G(), Error.prepareStackTrace = ve;
      }
      var ct = y ? y.displayName || y.name : "", pt = ct ? z(ct) : "";
      return typeof y == "function" && Y.set(y, pt), pt;
    }
    function se(y, _, K) {
      return B(y, !1);
    }
    function ue(y) {
      var _ = y.prototype;
      return !!(_ && _.isReactComponent);
    }
    function ce(y, _, K) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return B(y, ue(y));
      if (typeof y == "string")
        return z(y);
      switch (y) {
        case u:
          return z("Suspense");
        case c:
          return z("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case l:
            return se(y.render);
          case p:
            return ce(y.type, _, K);
          case d: {
            var ie = y, ve = ie._payload, we = ie._init;
            try {
              return ce(we(ve), _, K);
            } catch {
            }
          }
        }
      return "";
    }
    var de = Object.prototype.hasOwnProperty, be = {}, ge = E.ReactDebugCurrentFrame;
    function me(y) {
      if (y) {
        var _ = y._owner, K = ce(y.type, y._source, _ ? _.type : null);
        ge.setExtraStackFrame(K);
      } else
        ge.setExtraStackFrame(null);
    }
    function ae(y, _, K, ie, ve) {
      {
        var we = Function.call.bind(de);
        for (var fe in y)
          if (we(y, fe)) {
            var pe = void 0;
            try {
              if (typeof y[fe] != "function") {
                var Ie = Error((ie || "React class") + ": " + K + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ie.name = "Invariant Violation", Ie;
              }
              pe = y[fe](_, fe, ie, K, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (De) {
              pe = De;
            }
            pe && !(pe instanceof Error) && (me(ve), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ie || "React class", K, fe, typeof pe), me(null)), pe instanceof Error && !(pe.message in be) && (be[pe.message] = !0, me(ve), L("Failed %s type: %s", K, pe.message), me(null));
          }
      }
    }
    var xe = Array.isArray;
    function re(y) {
      return xe(y);
    }
    function Te(y) {
      {
        var _ = typeof Symbol == "function" && Symbol.toStringTag, K = _ && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return K;
      }
    }
    function ne(y) {
      try {
        return Ee(y), !1;
      } catch {
        return !0;
      }
    }
    function Ee(y) {
      return "" + y;
    }
    function Ne(y) {
      if (ne(y))
        return L("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Te(y)), Ee(y);
    }
    var Fe = E.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, he, Xe, He;
    He = {};
    function qt(y) {
      if (de.call(y, "ref")) {
        var _ = Object.getOwnPropertyDescriptor(y, "ref").get;
        if (_ && _.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function lt(y) {
      if (de.call(y, "key")) {
        var _ = Object.getOwnPropertyDescriptor(y, "key").get;
        if (_ && _.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function mt(y, _) {
      if (typeof y.ref == "string" && Fe.current && _ && Fe.current.stateNode !== _) {
        var K = W(Fe.current.type);
        He[K] || (L('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', W(Fe.current.type), y.ref), He[K] = !0);
      }
    }
    function on(y, _) {
      {
        var K = function() {
          he || (he = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _));
        };
        K.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: K,
          configurable: !0
        });
      }
    }
    function sn(y, _) {
      {
        var K = function() {
          Xe || (Xe = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _));
        };
        K.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: K,
          configurable: !0
        });
      }
    }
    var an = function(y, _, K, ie, ve, we, fe) {
      var pe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: _,
        ref: K,
        props: fe,
        // Record the component responsible for creating this element.
        _owner: we
      };
      return pe._store = {}, Object.defineProperty(pe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ie
      }), Object.defineProperty(pe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ve
      }), Object.freeze && (Object.freeze(pe.props), Object.freeze(pe)), pe;
    };
    function ln(y, _, K, ie, ve) {
      {
        var we, fe = {}, pe = null, Ie = null;
        K !== void 0 && (Ne(K), pe = "" + K), lt(_) && (Ne(_.key), pe = "" + _.key), qt(_) && (Ie = _.ref, mt(_, ve));
        for (we in _)
          de.call(_, we) && !Ue.hasOwnProperty(we) && (fe[we] = _[we]);
        if (y && y.defaultProps) {
          var De = y.defaultProps;
          for (we in De)
            fe[we] === void 0 && (fe[we] = De[we]);
        }
        if (pe || Ie) {
          var Se = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          pe && on(fe, Se), Ie && sn(fe, Se);
        }
        return an(y, pe, Ie, ve, ie, Fe.current, fe);
      }
    }
    var nt = E.ReactCurrentOwner, Rt = E.ReactDebugCurrentFrame;
    function ut(y) {
      if (y) {
        var _ = y._owner, K = ce(y.type, y._source, _ ? _.type : null);
        Rt.setExtraStackFrame(K);
      } else
        Rt.setExtraStackFrame(null);
    }
    var Bt;
    Bt = !1;
    function un(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function jn() {
      {
        if (nt.current) {
          var y = W(nt.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function cn(y) {
      {
        if (y !== void 0) {
          var _ = y.fileName.replace(/^.*[\\\/]/, ""), K = y.lineNumber;
          return `

Check your code at ` + _ + ":" + K + ".";
        }
        return "";
      }
    }
    var Nn = {};
    function lr(y) {
      {
        var _ = jn();
        if (!_) {
          var K = typeof y == "string" ? y : y.displayName || y.name;
          K && (_ = `

Check the top-level render call using <` + K + ">.");
        }
        return _;
      }
    }
    function zt(y, _) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var K = lr(_);
        if (Nn[K])
          return;
        Nn[K] = !0;
        var ie = "";
        y && y._owner && y._owner !== nt.current && (ie = " It was passed a child from " + W(y._owner.type) + "."), ut(y), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', K, ie), ut(null);
      }
    }
    function Fn(y, _) {
      {
        if (typeof y != "object")
          return;
        if (re(y))
          for (var K = 0; K < y.length; K++) {
            var ie = y[K];
            un(ie) && zt(ie, _);
          }
        else if (un(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var ve = h(y);
          if (typeof ve == "function" && ve !== y.entries)
            for (var we = ve.call(y), fe; !(fe = we.next()).done; )
              un(fe.value) && zt(fe.value, _);
        }
      }
    }
    function ur(y) {
      {
        var _ = y.type;
        if (_ == null || typeof _ == "string")
          return;
        var K;
        if (typeof _ == "function")
          K = _.propTypes;
        else if (typeof _ == "object" && (_.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        _.$$typeof === p))
          K = _.propTypes;
        else
          return;
        if (K) {
          var ie = W(_);
          ae(K, y.props, "prop", ie, y);
        } else if (_.PropTypes !== void 0 && !Bt) {
          Bt = !0;
          var ve = W(_);
          L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ve || "Unknown");
        }
        typeof _.getDefaultProps == "function" && !_.getDefaultProps.isReactClassApproved && L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function pn(y) {
      {
        for (var _ = Object.keys(y.props), K = 0; K < _.length; K++) {
          var ie = _[K];
          if (ie !== "children" && ie !== "key") {
            ut(y), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ie), ut(null);
            break;
          }
        }
        y.ref !== null && (ut(y), L("Invalid attribute `ref` supplied to `React.Fragment`."), ut(null));
      }
    }
    var Rn = {};
    function zn(y, _, K, ie, ve, we) {
      {
        var fe = M(y);
        if (!fe) {
          var pe = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ie = cn(ve);
          Ie ? pe += Ie : pe += jn();
          var De;
          y === null ? De = "null" : re(y) ? De = "array" : y !== void 0 && y.$$typeof === t ? (De = "<" + (W(y.type) || "Unknown") + " />", pe = " Did you accidentally export a JSX literal instead of a component?") : De = typeof y, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", De, pe);
        }
        var Se = ln(y, _, K, ve, we);
        if (Se == null)
          return Se;
        if (fe) {
          var ze = _.children;
          if (ze !== void 0)
            if (ie)
              if (re(ze)) {
                for (var ct = 0; ct < ze.length; ct++)
                  Fn(ze[ct], y);
                Object.freeze && Object.freeze(ze);
              } else
                L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Fn(ze, y);
        }
        if (de.call(_, "key")) {
          var pt = W(y), je = Object.keys(_).filter(function(Ui) {
            return Ui !== "key";
          }), le = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Rn[pt + le]) {
            var zi = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            L(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, le, pt, zi, pt), Rn[pt + le] = !0;
          }
        }
        return y === r ? pn(Se) : ur(Se), Se;
      }
    }
    function dn(y, _, K) {
      return zn(y, _, K, !0);
    }
    function cr(y, _, K) {
      return zn(y, _, K, !1);
    }
    var pr = cr, fn = dn;
    ql.Fragment = r, ql.jsx = pr, ql.jsxs = fn;
  }()), ql;
}
process.env.NODE_ENV === "production" ? _h.exports = Mj() : _h.exports = Pj();
var fr = _h.exports;
Ye({});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var Ih = function(e, t) {
  return Ih = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
  }, Ih(e, t);
};
function mn(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Ih(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Ge = function() {
  return Ge = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ge.apply(this, arguments);
};
function fm(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function Tj(e, t, n, r) {
  function o(i) {
    return i instanceof n ? i : new n(function(s) {
      s(i);
    });
  }
  return new (n || (n = Promise))(function(i, s) {
    function a(c) {
      try {
        u(r.next(c));
      } catch (p) {
        s(p);
      }
    }
    function l(c) {
      try {
        u(r.throw(c));
      } catch (p) {
        s(p);
      }
    }
    function u(c) {
      c.done ? i(c.value) : o(c.value).then(a, l);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function Aj(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(c) {
      return l([u, c]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, o && (i = u[0] & 2 ? o.return : u[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, u[1])).done) return i;
      switch (o = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
        case 0:
        case 1:
          i = u;
          break;
        case 4:
          return n.label++, { value: u[1], done: !1 };
        case 5:
          n.label++, o = u[1], u = [0];
          continue;
        case 7:
          u = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            n = 0;
            continue;
          }
          if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
            n.label = u[1];
            break;
          }
          if (u[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = u;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(u);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      u = t.call(e, n);
    } catch (c) {
      u = [6, c], o = 0;
    } finally {
      r = i = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function kS(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Bj = process.env.NODE_ENV, _j = function(e, t, n, r, o, i, s, a) {
  if (Bj !== "production" && t === void 0)
    throw new Error("invariant requires an error message argument");
  if (!e) {
    var l;
    if (t === void 0)
      l = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var u = [n, r, o, i, s, a], c = 0;
      l = new Error(
        t.replace(/%s/g, function() {
          return u[c++];
        })
      ), l.name = "Invariant Violation";
    }
    throw l.framesToPop = 1, l;
  }
}, Ij = _j, sr = /* @__PURE__ */ kS(Ij), st = Ye(null);
function jj() {
  sr(!!_e, "useGoogleMap is React hook and requires React version 16.8+");
  var e = _e(st);
  return sr(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function Nj(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function Fj(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function Rj(e, t, n, r) {
  var o = {}, i = function(s, a) {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return Fj(e, i), o;
}
function zj(e, t, n) {
  var r = Nj(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function Uj(e) {
  google.maps.event.removeListener(e);
}
function St(e) {
  e === void 0 && (e = []), e.forEach(Uj);
}
function bt(e) {
  var t = e.updaterMap, n = e.eventMap, r = e.prevProps, o = e.nextProps, i = e.instance, s = zj(o, i, n);
  return Rj(t, r, o, i), s;
}
var Sb = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, Ob = {
  extraMapTypes: function(e, t) {
    t.forEach(function(n, r) {
      e.mapTypes.set(String(r), n);
    });
  },
  center: function(e, t) {
    e.setCenter(t);
  },
  clickableIcons: function(e, t) {
    e.setClickableIcons(t);
  },
  heading: function(e, t) {
    e.setHeading(t);
  },
  mapTypeId: function(e, t) {
    e.setMapTypeId(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  streetView: function(e, t) {
    e.setStreetView(t);
  },
  tilt: function(e, t) {
    e.setTilt(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
function $j(e) {
  var t = e.children, n = e.options, r = e.id, o = e.mapContainerStyle, i = e.mapContainerClassName, s = e.center, a = e.onClick, l = e.onDblClick, u = e.onDrag, c = e.onDragEnd, p = e.onDragStart, d = e.onMouseMove, g = e.onMouseOut, m = e.onMouseOver, f = e.onMouseDown, h = e.onMouseUp, E = e.onRightClick, L = e.onCenterChanged, x = e.onLoad, T = e.onUnmount, w = D(null), C = w[0], k = w[1], O = rt(null), U = D(null), M = U[0], V = U[1], $ = D(null), W = $[0], R = $[1], H = D(null), X = H[0], I = H[1], J = D(null), te = J[0], S = J[1], P = D(null), q = P[0], j = P[1], Z = D(null), G = Z[0], b = Z[1], F = D(null), z = F[0], A = F[1], Y = D(null), ee = Y[0], B = Y[1], se = D(null), ue = se[0], ce = se[1], de = D(null), be = de[0], ge = de[1], me = D(null), ae = me[0], xe = me[1], re = D(null), Te = re[0], ne = re[1];
  return v(function() {
    n && C !== null && C.setOptions(n);
  }, [C, n]), v(function() {
    C !== null && typeof s < "u" && C.setCenter(s);
  }, [C, s]), v(function() {
    C && l && (W !== null && google.maps.event.removeListener(W), R(google.maps.event.addListener(C, "dblclick", l)));
  }, [l]), v(function() {
    C && c && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(C, "dragend", c)));
  }, [c]), v(function() {
    C && p && (te !== null && google.maps.event.removeListener(te), S(google.maps.event.addListener(C, "dragstart", p)));
  }, [p]), v(function() {
    C && f && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "mousedown", f)));
  }, [f]), v(function() {
    C && d && (G !== null && google.maps.event.removeListener(G), b(google.maps.event.addListener(C, "mousemove", d)));
  }, [d]), v(function() {
    C && g && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(C, "mouseout", g)));
  }, [g]), v(function() {
    C && m && (ee !== null && google.maps.event.removeListener(ee), B(google.maps.event.addListener(C, "mouseover", m)));
  }, [m]), v(function() {
    C && h && (ue !== null && google.maps.event.removeListener(ue), ce(google.maps.event.addListener(C, "mouseup", h)));
  }, [h]), v(function() {
    C && E && (be !== null && google.maps.event.removeListener(be), ge(google.maps.event.addListener(C, "rightclick", E)));
  }, [E]), v(function() {
    C && a && (ae !== null && google.maps.event.removeListener(ae), xe(google.maps.event.addListener(C, "click", a)));
  }, [a]), v(function() {
    C && u && (Te !== null && google.maps.event.removeListener(Te), ne(google.maps.event.addListener(C, "drag", u)));
  }, [u]), v(function() {
    C && L && (M !== null && google.maps.event.removeListener(M), V(google.maps.event.addListener(C, "center_changed", L)));
  }, [a]), v(function() {
    var Ee = O.current === null ? null : new google.maps.Map(O.current, n);
    return k(Ee), Ee !== null && x && x(Ee), function() {
      Ee !== null && T && T(Ee);
    };
  }, []), fr.jsx("div", { id: r, ref: O, style: o, className: i, children: fr.jsx(st.Provider, { value: C, children: C !== null ? t : null }) });
}
Re($j);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      map: null
    }, n.registeredEvents = [], n.mapRef = null, n.getInstance = function() {
      return n.mapRef === null ? null : new google.maps.Map(n.mapRef, n.props.options);
    }, n.panTo = function(r) {
      var o = n.getInstance();
      o && o.panTo(r);
    }, n.setMapCallback = function() {
      n.state.map !== null && n.props.onLoad && n.props.onLoad(n.state.map);
    }, n.getRef = function(r) {
      n.mapRef = r;
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.getInstance();
    this.registeredEvents = bt({
      updaterMap: Ob,
      eventMap: Sb,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        map: n
      };
    }, this.setMapCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.map !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: Ob,
      eventMap: Sb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.map
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), St(this.registeredEvents));
  }, t.prototype.render = function() {
    return fr.jsx("div", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: fr.jsx(st.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : null }) });
  }, t;
})(ke);
var ls = typeof document < "u";
function DS(e) {
  var t = e.url, n = e.id, r = e.nonce;
  return ls ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch(function(o) {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Mb(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function SS() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return Mb(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return Mb(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
function OS(e) {
  var t = e.googleMapsApiKey, n = e.googleMapsClientId, r = e.version, o = r === void 0 ? "weekly" : r, i = e.language, s = e.region, a = e.libraries, l = e.channel, u = e.mapIds, c = e.authReferrerPolicy, p = [];
  return sr(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? p.push("key=".concat(t)) : n && p.push("client=".concat(n)), o && p.push("v=".concat(o)), i && p.push("language=".concat(i)), s && p.push("region=".concat(s)), a && a.length && p.push("libraries=".concat(a.sort().join(","))), l && p.push("channel=".concat(l)), u && u.length && p.push("map_ids=".concat(u.join(","))), c && p.push("auth_referrer_policy=".concat(c)), p.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(p.join("&"));
}
var ra = !1;
function MS() {
  return fr.jsx("div", { children: "Loading..." });
}
var jh = {
  id: "script-loader",
  version: "weekly"
};
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.check = xr(), n.state = {
      loaded: !1
    }, n.cleanupCallback = function() {
      delete window.google.maps, n.injectScript();
    }, n.isCleaningUp = function() {
      return Tj(n, void 0, void 0, function() {
        function r(o) {
          if (!ra)
            o();
          else if (ls)
            var i = window.setInterval(function() {
              ra || (window.clearInterval(i), o());
            }, 1);
        }
        return Aj(this, function(o) {
          return [2, new Promise(r)];
        });
      });
    }, n.cleanup = function() {
      ra = !0;
      var r = document.getElementById(n.props.id);
      r && r.parentNode && r.parentNode.removeChild(r), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(o) {
        return typeof o.src == "string" && o.src.includes("maps.googleapis");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(o) {
        return o.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(o) {
        return o.innerText !== void 0 && o.innerText.length > 0 && o.innerText.includes(".gm-");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      });
    }, n.injectScript = function() {
      n.props.preventGoogleFontsLoading && SS(), sr(!!n.props.id, 'LoadScript requires "id" prop to be a string: %s', n.props.id);
      var r = {
        id: n.props.id,
        nonce: n.props.nonce,
        url: OS(n.props)
      };
      DS(r).then(function() {
        n.props.onLoad && n.props.onLoad(), n.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch(function(o) {
        n.props.onError && n.props.onError(o), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(n.props.googleMapsApiKey || "-", ") or Client ID (").concat(n.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (ls) {
      if (window.google && window.google.maps && !ra) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.props.libraries !== n.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), ls && n.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }, t.prototype.componentWillUnmount = function() {
    var n = this;
    if (ls) {
      this.cleanup();
      var r = function() {
        n.check.current || (delete window.google, ra = !1);
      };
      window.setTimeout(r, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }, t.prototype.render = function() {
    return fr.jsxs(fr.Fragment, { children: [fr.jsx("div", { ref: this.check }), this.state.loaded ? this.props.children : this.props.loadingElement || fr.jsx(MS, {})] });
  }, t.defaultProps = jh, t;
})(ke);
var Pb;
function Wj(e) {
  var t = e.id, n = t === void 0 ? jh.id : t, r = e.version, o = r === void 0 ? jh.version : r, i = e.nonce, s = e.googleMapsApiKey, a = e.googleMapsClientId, l = e.language, u = e.region, c = e.libraries, p = e.preventGoogleFontsLoading, d = e.channel, g = e.mapIds, m = e.authReferrerPolicy, f = rt(!1), h = D(!1), E = h[0], L = h[1], x = D(void 0), T = x[0], w = x[1];
  v(function() {
    return f.current = !0, function() {
      f.current = !1;
    };
  }, []), v(function() {
    ls && p && SS();
  }, [p]), v(function() {
    E && sr(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [E]);
  var C = OS({
    version: o,
    googleMapsApiKey: s,
    googleMapsClientId: a,
    language: l,
    region: u,
    libraries: c,
    channel: d,
    mapIds: g,
    authReferrerPolicy: m
  });
  v(function() {
    if (!ls)
      return;
    function O() {
      f.current && (L(!0), Pb = C);
    }
    if (window.google && window.google.maps && Pb === C) {
      O();
      return;
    }
    DS({ id: n, url: C, nonce: i }).then(O).catch(function(U) {
      f.current && w(U), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(s || "-", ") or Client ID (").concat(a || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(U);
    });
  }, [n, C, i]);
  var k = rt();
  return v(function() {
    k.current && c !== k.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), k.current = c;
  }, [c]), { isLoaded: E, loadError: T, url: C };
}
var Hj = fr.jsx(MS, {});
function Vj(e) {
  var t = e.loadingElement, n = e.onLoad, r = e.onError, o = e.onUnmount, i = e.children, s = fm(e, ["loadingElement", "onLoad", "onError", "onUnmount", "children"]), a = Wj(s), l = a.isLoaded, u = a.loadError;
  return v(function() {
    l && typeof n == "function" && n();
  }, [l, n]), v(function() {
    u && typeof r == "function" && r(u);
  }, [u, r]), v(function() {
    return function() {
      o && o();
    };
  }, [o]), l ? i : t || Hj;
}
Re(Vj);
var Tb;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Tb || (Tb = {}));
var Ab = {}, Bb = {
  options: function(e, t) {
    e.setOptions(t);
  }
};
function Zj(e) {
  var t = e.options, n = e.onLoad, r = e.onUnmount, o = _e(st), i = D(null), s = i[0], a = i[1];
  return v(function() {
    s !== null && s.setMap(o);
  }, [o]), v(function() {
    t && s !== null && s.setOptions(t);
  }, [s, t]), v(function() {
    var l = new google.maps.TrafficLayer(Ge(Ge({}, t || {}), { map: o }));
    return a(l), n && n(l), function() {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Re(Zj);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      trafficLayer: null
    }, n.setTrafficLayerCallback = function() {
      n.state.trafficLayer !== null && n.props.onLoad && n.props.onLoad(n.state.trafficLayer);
    }, n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TrafficLayer(Ge(Ge({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = bt({
      updaterMap: Bb,
      eventMap: Ab,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        trafficLayer: n
      };
    }, this.setTrafficLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.trafficLayer !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: Bb,
      eventMap: Ab,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), St(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
function qj(e) {
  var t = e.onLoad, n = e.onUnmount, r = _e(st), o = D(null), i = o[0], s = o[1];
  return v(function() {
    i !== null && i.setMap(r);
  }, [r]), v(function() {
    var a = new google.maps.BicyclingLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Re(qj);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      bicyclingLayer: null
    }, n.setBicyclingLayerCallback = function() {
      n.state.bicyclingLayer !== null && (n.state.bicyclingLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.bicyclingLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.BicyclingLayer();
    this.setState(function() {
      return {
        bicyclingLayer: n
      };
    }, this.setBicyclingLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
function Gj(e) {
  var t = e.onLoad, n = e.onUnmount, r = _e(st), o = D(null), i = o[0], s = o[1];
  return v(function() {
    i !== null && i.setMap(r);
  }, [r]), v(function() {
    var a = new google.maps.TransitLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      i !== null && (n && n(i), i.setMap(null));
    };
  }, []), null;
}
Re(Gj);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      transitLayer: null
    }, n.setTransitLayerCallback = function() {
      n.state.transitLayer !== null && (n.state.transitLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.transitLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: n
      };
    }, this.setTransitLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
var _b = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, Ib = {
  drawingMode: function(e, t) {
    e.setDrawingMode(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function Kj(e) {
  var t = e.options, n = e.drawingMode, r = e.onCircleComplete, o = e.onMarkerComplete, i = e.onOverlayComplete, s = e.onPolygonComplete, a = e.onPolylineComplete, l = e.onRectangleComplete, u = e.onLoad, c = e.onUnmount, p = _e(st), d = D(null), g = d[0], m = d[1], f = D(null), h = f[0], E = f[1], L = D(null), x = L[0], T = L[1], w = D(null), C = w[0], k = w[1], O = D(null), U = O[0], M = O[1], V = D(null), $ = V[0], W = V[1], R = D(null), H = R[0], X = R[1];
  return v(function() {
    g !== null && g.setMap(p);
  }, [p]), v(function() {
    t && g !== null && g.setOptions(t);
  }, [g, t]), v(function() {
    g !== null && g.setDrawingMode(n ?? null);
  }, [g, n]), v(function() {
    g && r && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(g, "circlecomplete", r)));
  }, [g, r]), v(function() {
    g && o && (x !== null && google.maps.event.removeListener(x), T(google.maps.event.addListener(g, "markercomplete", o)));
  }, [g, o]), v(function() {
    g && i && (C !== null && google.maps.event.removeListener(C), k(google.maps.event.addListener(g, "overlaycomplete", i)));
  }, [g, i]), v(function() {
    g && s && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(g, "polygoncomplete", s)));
  }, [g, s]), v(function() {
    g && a && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(g, "polylinecomplete", a)));
  }, [g, a]), v(function() {
    g && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(g, "rectanglecomplete", l)));
  }, [g, l]), v(function() {
    sr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var I = new google.maps.drawing.DrawingManager(Ge(Ge({}, t || {}), { map: p }));
    return n && I.setDrawingMode(n), r && E(google.maps.event.addListener(I, "circlecomplete", r)), o && T(google.maps.event.addListener(I, "markercomplete", o)), i && k(google.maps.event.addListener(I, "overlaycomplete", i)), s && M(google.maps.event.addListener(I, "polygoncomplete", s)), a && W(google.maps.event.addListener(I, "polylinecomplete", a)), l && X(google.maps.event.addListener(I, "rectanglecomplete", l)), m(I), u && u(I), function() {
      g !== null && (h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), $ && google.maps.event.removeListener($), H && google.maps.event.removeListener(H), c && c(g), g.setMap(null));
    };
  }, []), null;
}
Re(Kj);
(function(e) {
  mn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    return r.registeredEvents = [], r.state = {
      drawingManager: null
    }, r.setDrawingManagerCallback = function() {
      r.state.drawingManager !== null && r.props.onLoad && r.props.onLoad(r.state.drawingManager);
    }, sr(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing), r;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.drawing.DrawingManager(Ge(Ge({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = bt({
      updaterMap: Ib,
      eventMap: _b,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        drawingManager: n
      };
    }, this.setDrawingManagerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.drawingManager !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: Ib,
      eventMap: _b,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), St(this.registeredEvents), this.state.drawingManager.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
var jb = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, Nb = {
  animation: function(e, t) {
    e.setAnimation(t);
  },
  clickable: function(e, t) {
    e.setClickable(t);
  },
  cursor: function(e, t) {
    e.setCursor(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  icon: function(e, t) {
    e.setIcon(t);
  },
  label: function(e, t) {
    e.setLabel(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  opacity: function(e, t) {
    e.setOpacity(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  shape: function(e, t) {
    e.setShape(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, yc = {};
function Yj(e) {
  var t = e.position, n = e.options, r = e.clusterer, o = e.noClustererRedraw, i = e.children, s = e.draggable, a = e.visible, l = e.animation, u = e.clickable, c = e.cursor, p = e.icon, d = e.label, g = e.opacity, m = e.shape, f = e.title, h = e.zIndex, E = e.onClick, L = e.onDblClick, x = e.onDrag, T = e.onDragEnd, w = e.onDragStart, C = e.onMouseOut, k = e.onMouseOver, O = e.onMouseUp, U = e.onMouseDown, M = e.onRightClick, V = e.onClickableChanged, $ = e.onCursorChanged, W = e.onAnimationChanged, R = e.onDraggableChanged, H = e.onFlatChanged, X = e.onIconChanged, I = e.onPositionChanged, J = e.onShapeChanged, te = e.onTitleChanged, S = e.onVisibleChanged, P = e.onZindexChanged, q = e.onLoad, j = e.onUnmount, Z = _e(st), G = D(null), b = G[0], F = G[1], z = D(null), A = z[0], Y = z[1], ee = D(null), B = ee[0], se = ee[1], ue = D(null), ce = ue[0], de = ue[1], be = D(null), ge = be[0], me = be[1], ae = D(null), xe = ae[0], re = ae[1], Te = D(null), ne = Te[0], Ee = Te[1], Ne = D(null), Fe = Ne[0], Ue = Ne[1], he = D(null), Xe = he[0], He = he[1], qt = D(null), lt = qt[0], mt = qt[1], on = D(null), sn = on[0], an = on[1], ln = D(null), nt = ln[0], Rt = ln[1], ut = D(null), Bt = ut[0], un = ut[1], jn = D(null), cn = jn[0], Nn = jn[1], lr = D(null), zt = lr[0], Fn = lr[1], ur = D(null), pn = ur[0], Rn = ur[1], zn = D(null), dn = zn[0], cr = zn[1], pr = D(null), fn = pr[0], y = pr[1], _ = D(null), K = _[0], ie = _[1], ve = D(null), we = ve[0], fe = ve[1], pe = D(null), Ie = pe[0], De = pe[1], Se = D(null), ze = Se[0], ct = Se[1];
  v(function() {
    b !== null && b.setMap(Z);
  }, [Z]), v(function() {
    typeof n < "u" && b !== null && b.setOptions(n);
  }, [b, n]), v(function() {
    typeof s < "u" && b !== null && b.setDraggable(s);
  }, [b, s]), v(function() {
    t && b !== null && b.setPosition(t);
  }, [b, t]), v(function() {
    typeof a < "u" && b !== null && b.setVisible(a);
  }, [b, a]), v(function() {
    b == null || b.setAnimation(l);
  }, [b, l]), v(function() {
    b && u !== void 0 && b.setClickable(u);
  }, [b, u]), v(function() {
    b && c !== void 0 && b.setCursor(c);
  }, [b, c]), v(function() {
    b && p !== void 0 && b.setIcon(p);
  }, [b, p]), v(function() {
    b && d !== void 0 && b.setLabel(d);
  }, [b, d]), v(function() {
    b && g !== void 0 && b.setOpacity(g);
  }, [b, g]), v(function() {
    b && m !== void 0 && b.setShape(m);
  }, [b, m]), v(function() {
    b && f !== void 0 && b.setTitle(f);
  }, [b, f]), v(function() {
    b && h !== void 0 && b.setZIndex(h);
  }, [b, h]), v(function() {
    b && L && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(b, "dblclick", L)));
  }, [L]), v(function() {
    b && T && (B !== null && google.maps.event.removeListener(B), se(google.maps.event.addListener(b, "dragend", T)));
  }, [T]), v(function() {
    b && w && (ce !== null && google.maps.event.removeListener(ce), de(google.maps.event.addListener(b, "dragstart", w)));
  }, [w]), v(function() {
    b && U && (ge !== null && google.maps.event.removeListener(ge), me(google.maps.event.addListener(b, "mousedown", U)));
  }, [U]), v(function() {
    b && C && (xe !== null && google.maps.event.removeListener(xe), re(google.maps.event.addListener(b, "mouseout", C)));
  }, [C]), v(function() {
    b && k && (ne !== null && google.maps.event.removeListener(ne), Ee(google.maps.event.addListener(b, "mouseover", k)));
  }, [k]), v(function() {
    b && O && (Fe !== null && google.maps.event.removeListener(Fe), Ue(google.maps.event.addListener(b, "mouseup", O)));
  }, [O]), v(function() {
    b && M && (Xe !== null && google.maps.event.removeListener(Xe), He(google.maps.event.addListener(b, "rightclick", M)));
  }, [M]), v(function() {
    b && E && (lt !== null && google.maps.event.removeListener(lt), mt(google.maps.event.addListener(b, "click", E)));
  }, [E]), v(function() {
    b && x && (sn !== null && google.maps.event.removeListener(sn), an(google.maps.event.addListener(b, "drag", x)));
  }, [x]), v(function() {
    b && V && (nt !== null && google.maps.event.removeListener(nt), Rt(google.maps.event.addListener(b, "clickable_changed", V)));
  }, [V]), v(function() {
    b && $ && (Bt !== null && google.maps.event.removeListener(Bt), un(google.maps.event.addListener(b, "cursor_changed", $)));
  }, [$]), v(function() {
    b && W && (cn !== null && google.maps.event.removeListener(cn), Nn(google.maps.event.addListener(b, "animation_changed", W)));
  }, [W]), v(function() {
    b && R && (zt !== null && google.maps.event.removeListener(zt), Fn(google.maps.event.addListener(b, "draggable_changed", R)));
  }, [R]), v(function() {
    b && H && (pn !== null && google.maps.event.removeListener(pn), Rn(google.maps.event.addListener(b, "flat_changed", H)));
  }, [H]), v(function() {
    b && X && (dn !== null && google.maps.event.removeListener(dn), cr(google.maps.event.addListener(b, "icon_changed", X)));
  }, [X]), v(function() {
    b && I && (fn !== null && google.maps.event.removeListener(fn), y(google.maps.event.addListener(b, "position_changed", I)));
  }, [I]), v(function() {
    b && J && (K !== null && google.maps.event.removeListener(K), ie(google.maps.event.addListener(b, "shape_changed", J)));
  }, [J]), v(function() {
    b && te && (we !== null && google.maps.event.removeListener(we), fe(google.maps.event.addListener(b, "title_changed", te)));
  }, [te]), v(function() {
    b && S && (Ie !== null && google.maps.event.removeListener(Ie), De(google.maps.event.addListener(b, "visible_changed", S)));
  }, [S]), v(function() {
    b && P && (ze !== null && google.maps.event.removeListener(ze), ct(google.maps.event.addListener(b, "zindex_changed", P)));
  }, [P]), v(function() {
    var je = Ge(Ge(Ge({}, n || yc), r ? yc : { map: Z }), { position: t }), le = new google.maps.Marker(je);
    return r ? r.addMarker(le, !!o) : le.setMap(Z), t && le.setPosition(t), typeof a < "u" && le.setVisible(a), typeof s < "u" && le.setDraggable(s), typeof u < "u" && le.setClickable(u), typeof c == "string" && le.setCursor(c), p && le.setIcon(p), typeof d < "u" && le.setLabel(d), typeof g < "u" && le.setOpacity(g), m && le.setShape(m), typeof f == "string" && le.setTitle(f), typeof h == "number" && le.setZIndex(h), L && Y(google.maps.event.addListener(le, "dblclick", L)), T && se(google.maps.event.addListener(le, "dragend", T)), w && de(google.maps.event.addListener(le, "dragstart", w)), U && me(google.maps.event.addListener(le, "mousedown", U)), C && re(google.maps.event.addListener(le, "mouseout", C)), k && Ee(google.maps.event.addListener(le, "mouseover", k)), O && Ue(google.maps.event.addListener(le, "mouseup", O)), M && He(google.maps.event.addListener(le, "rightclick", M)), E && mt(google.maps.event.addListener(le, "click", E)), x && an(google.maps.event.addListener(le, "drag", x)), V && Rt(google.maps.event.addListener(le, "clickable_changed", V)), $ && un(google.maps.event.addListener(le, "cursor_changed", $)), W && Nn(google.maps.event.addListener(le, "animation_changed", W)), R && Fn(google.maps.event.addListener(le, "draggable_changed", R)), H && Rn(google.maps.event.addListener(le, "flat_changed", H)), X && cr(google.maps.event.addListener(le, "icon_changed", X)), I && y(google.maps.event.addListener(le, "position_changed", I)), J && ie(google.maps.event.addListener(le, "shape_changed", J)), te && fe(google.maps.event.addListener(le, "title_changed", te)), S && De(google.maps.event.addListener(le, "visible_changed", S)), P && ct(google.maps.event.addListener(le, "zindex_changed", P)), F(le), q && q(le), function() {
      A !== null && google.maps.event.removeListener(A), B !== null && google.maps.event.removeListener(B), ce !== null && google.maps.event.removeListener(ce), ge !== null && google.maps.event.removeListener(ge), xe !== null && google.maps.event.removeListener(xe), ne !== null && google.maps.event.removeListener(ne), Fe !== null && google.maps.event.removeListener(Fe), Xe !== null && google.maps.event.removeListener(Xe), lt !== null && google.maps.event.removeListener(lt), nt !== null && google.maps.event.removeListener(nt), Bt !== null && google.maps.event.removeListener(Bt), cn !== null && google.maps.event.removeListener(cn), zt !== null && google.maps.event.removeListener(zt), pn !== null && google.maps.event.removeListener(pn), dn !== null && google.maps.event.removeListener(dn), fn !== null && google.maps.event.removeListener(fn), we !== null && google.maps.event.removeListener(we), Ie !== null && google.maps.event.removeListener(Ie), ze !== null && google.maps.event.removeListener(ze), j && j(le), r ? r.removeMarker(le, !!o) : le && le.setMap(null);
    };
  }, []);
  var pt = rr(function() {
    return i ? Mt.map(i, function(je) {
      if (!Li(je))
        return je;
      var le = je;
      return ki(le, { anchor: b });
    }) : null;
  }, [i, b]);
  return fr.jsx(fr.Fragment, { children: pt }) || null;
}
Re(Yj);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = Ge(Ge(Ge({}, this.props.options || yc), this.props.clusterer ? yc : { map: this.context }), { position: this.props.position });
    this.marker = new google.maps.Marker(n), this.props.clusterer ? this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw) : this.marker.setMap(this.context), this.registeredEvents = bt({
      updaterMap: Nb,
      eventMap: jb,
      prevProps: {},
      nextProps: this.props,
      instance: this.marker
    }), this.props.onLoad && this.props.onLoad(this.marker);
  }, t.prototype.componentDidUpdate = function(n) {
    this.marker && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: Nb,
      eventMap: jb,
      prevProps: n,
      nextProps: this.props,
      instance: this.marker
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), St(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }, t.prototype.render = function() {
    var n = this, r = null;
    return this.props.children && (r = Mt.map(this.props.children, function(o) {
      if (!Li(o))
        return o;
      var i = o;
      return ki(i, { anchor: n.marker });
    })), r || null;
  }, t.contextType = st, t;
})(ke);
var Xj = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), Qj = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new Xj(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function Jj(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var eN = 2e3, tN = 500, nN = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", rN = "png", oN = [53, 56, 66, 78, 90], iN = "cluster", PS = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || nN, this.imageExtension = r.imageExtension || rN, this.imageSizes = r.imageSizes || oN, this.calculator = r.calculator || Jj, this.batchSize = r.batchSize || eN, this.batchSizeIE = r.batchSizeIE || tN, this.clusterClass = r.clusterClass || iN, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [
        google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged),
        google.maps.event.addListener(t, "idle", this.onIdle)
      ]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new Qj(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), so = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, jt = {
  averageCenter: function(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE: function(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator: function(e, t) {
    e.setCalculator(t);
  },
  clusterClass: function(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons: function(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize: function(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden: function(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension: function(e, t) {
    e.setImageExtension(t);
  },
  imagePath: function(e, t) {
    e.setImagePath(t);
  },
  imageSizes: function(e, t) {
    e.setImageSizes(t);
  },
  maxZoom: function(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize: function(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles: function(e, t) {
    e.setStyles(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  zoomOnClick: function(e, t) {
    e.setZoomOnClick(t);
  }
}, sN = {};
function aN(e) {
  var t = e.children, n = e.options, r = e.averageCenter, o = e.batchSizeIE, i = e.calculator, s = e.clusterClass, a = e.enableRetinaIcons, l = e.gridSize, u = e.ignoreHidden, c = e.imageExtension, p = e.imagePath, d = e.imageSizes, g = e.maxZoom, m = e.minimumClusterSize, f = e.styles, h = e.title, E = e.zoomOnClick, L = e.onClick, x = e.onClusteringBegin, T = e.onClusteringEnd, w = e.onMouseOver, C = e.onMouseOut, k = e.onLoad, O = e.onUnmount, U = D(null), M = U[0], V = U[1], $ = _e(st), W = D(null), R = W[0], H = W[1], X = D(null), I = X[0], J = X[1], te = D(null), S = te[0], P = te[1], q = D(null), j = q[0], Z = q[1], G = D(null), b = G[0], F = G[1];
  return v(function() {
    M && C && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(M, so.onMouseOut, C)));
  }, [C]), v(function() {
    M && w && (b !== null && google.maps.event.removeListener(b), F(google.maps.event.addListener(M, so.onMouseOver, w)));
  }, [w]), v(function() {
    M && L && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(M, so.onClick, L)));
  }, [L]), v(function() {
    M && x && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(M, so.onClusteringBegin, x)));
  }, [x]), v(function() {
    M && T && (S !== null && google.maps.event.removeListener(S), J(google.maps.event.addListener(M, so.onClusteringEnd, T)));
  }, [T]), v(function() {
    typeof r < "u" && M !== null && jt.averageCenter(M, r);
  }, [M, r]), v(function() {
    typeof o < "u" && M !== null && jt.batchSizeIE(M, o);
  }, [M, o]), v(function() {
    typeof i < "u" && M !== null && jt.calculator(M, i);
  }, [M, i]), v(function() {
    typeof s < "u" && M !== null && jt.clusterClass(M, s);
  }, [M, s]), v(function() {
    typeof a < "u" && M !== null && jt.enableRetinaIcons(M, a);
  }, [M, a]), v(function() {
    typeof l < "u" && M !== null && jt.gridSize(M, l);
  }, [M, l]), v(function() {
    typeof u < "u" && M !== null && jt.ignoreHidden(M, u);
  }, [M, u]), v(function() {
    typeof c < "u" && M !== null && jt.imageExtension(M, c);
  }, [M, c]), v(function() {
    typeof p < "u" && M !== null && jt.imagePath(M, p);
  }, [M, p]), v(function() {
    typeof d < "u" && M !== null && jt.imageSizes(M, d);
  }, [M, d]), v(function() {
    typeof g < "u" && M !== null && jt.maxZoom(M, g);
  }, [M, g]), v(function() {
    typeof m < "u" && M !== null && jt.minimumClusterSize(M, m);
  }, [M, m]), v(function() {
    typeof f < "u" && M !== null && jt.styles(M, f);
  }, [M, f]), v(function() {
    typeof h < "u" && M !== null && jt.title(M, h);
  }, [M, h]), v(function() {
    typeof E < "u" && M !== null && jt.zoomOnClick(M, E);
  }, [M, E]), v(function() {
    if ($) {
      var z = Ge({}, n || sN), A = new PS($, [], z);
      return r && jt.averageCenter(A, r), o && jt.batchSizeIE(A, o), i && jt.calculator(A, i), s && jt.clusterClass(A, s), a && jt.enableRetinaIcons(A, a), l && jt.gridSize(A, l), u && jt.ignoreHidden(A, u), c && jt.imageExtension(A, c), p && jt.imagePath(A, p), d && jt.imageSizes(A, d), g && jt.maxZoom(A, g), m && jt.minimumClusterSize(A, m), f && jt.styles(A, f), h && jt.title(A, h), E && jt.zoomOnClick(A, E), C && Z(google.maps.event.addListener(A, so.onMouseOut, C)), w && F(google.maps.event.addListener(A, so.onMouseOver, w)), L && H(google.maps.event.addListener(A, so.onClick, L)), x && J(google.maps.event.addListener(A, so.onClusteringBegin, x)), T && P(google.maps.event.addListener(A, so.onClusteringEnd, T)), V(A), k && k(A), function() {
        j !== null && google.maps.event.removeListener(j), b !== null && google.maps.event.removeListener(b), R !== null && google.maps.event.removeListener(R), I !== null && google.maps.event.removeListener(I), S !== null && google.maps.event.removeListener(S), O && O(A);
      };
    }
  }, []), M !== null && t(M) || null;
}
Re(aN);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      markerClusterer: null
    }, n.setClustererCallback = function() {
      n.state.markerClusterer !== null && n.props.onLoad && n.props.onLoad(n.state.markerClusterer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context) {
      var n = new PS(this.context, [], this.props.options);
      this.registeredEvents = bt({
        updaterMap: jt,
        eventMap: so,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          markerClusterer: n
        };
      }, this.setClustererCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.markerClusterer && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: jt,
      eventMap: so,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), St(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }, t.prototype.render = function() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }, t.contextType = st, t;
})(ke);
function Fb(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var TS = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || Fb(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = [
            "mousedown",
            "mouseover",
            "mouseout",
            "mouseup",
            "click",
            "dblclick",
            "touchstart",
            "touchend",
            "touchmove"
          ], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, Fb));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, m = this.infoBoxClearance.height, f = this.getProjection(), h = f.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + p + u + g > a && (r = h.x + p + u + g - a), this.alignBottom ? h.y < -c + m + d ? o = h.y + c - m - d : h.y + c + m > l && (o = h.y + c + m - l) : h.y < -c + m ? o = h.y + c - m : h.y + d + c + m > l && (o = h.y + d + c + m - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = { top: 0, bottom: 0, left: 0, right: 0 };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), Rb = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, zb = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, lN = {};
function uN(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, g = _e(st), m = D(null), f = m[0], h = m[1], E = D(null), L = E[0], x = E[1], T = D(null), w = T[0], C = T[1], k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = rt(null);
  return v(function() {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(function() {
    if (o && f !== null) {
      var I = o instanceof google.maps.LatLng ? o : new google.maps.LatLng(o.lat, o.lng);
      f.setPosition(I);
    }
  }, [o]), v(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(function() {
    f && a && (w !== null && google.maps.event.removeListener(w), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(function() {
    f && l && (O !== null && google.maps.event.removeListener(O), U(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(function() {
    f && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(function() {
    f && c && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(function() {
    if (g) {
      var I = r || lN, J = I.position, te = fm(I, ["position"]), S = void 0;
      J && !(J instanceof google.maps.LatLng) && (S = new google.maps.LatLng(J.lat, J.lng));
      var P = new TS(Ge(Ge({}, te), S ? { position: S } : {}));
      X.current = document.createElement("div"), h(P), s && x(google.maps.event.addListener(P, "closeclick", s)), a && C(google.maps.event.addListener(P, "domready", a)), l && U(google.maps.event.addListener(P, "content_changed", l)), u && $(google.maps.event.addListener(P, "position_changed", u)), c && H(google.maps.event.addListener(P, "zindex_changed", c)), P.setContent(X.current), n ? P.open(g, n) : P.getPosition() ? P.open(g) : sr(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(P);
    }
    return function() {
      f !== null && (L && google.maps.event.removeListener(L), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), V && google.maps.event.removeListener(V), R && google.maps.event.removeListener(R), d && d(f), f.close());
    };
  }, []), X.current ? Lr(Mt.only(t), X.current) : null;
}
Re(uN);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoBox: null
    }, n.open = function(r, o) {
      o ? n.context !== null && r.open(n.context, o) : r.getPosition() ? n.context !== null && r.open(n.context) : sr(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }, n.setInfoBoxCallback = function() {
      n.state.infoBox !== null && n.containerElement !== null && (n.state.infoBox.setContent(n.containerElement), n.open(n.state.infoBox, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoBox));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.props.options || {}, r = n.position, o = fm(n, ["position"]), i;
    r && !(r instanceof google.maps.LatLng) && (i = new google.maps.LatLng(r.lat, r.lng));
    var s = new TS(Ge(Ge({}, o), i ? { position: i } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = bt({
      updaterMap: zb,
      eventMap: Rb,
      prevProps: {},
      nextProps: this.props,
      instance: s
    }), this.setState({ infoBox: s }, this.setInfoBoxCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = this.state.infoBox;
    r !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: zb,
      eventMap: Rb,
      prevProps: n,
      nextProps: this.props,
      instance: r
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n = this.props.onUnmount, r = this.state.infoBox;
    r !== null && (n && n(r), St(this.registeredEvents), r.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Lr(Mt.only(this.props.children), this.containerElement) : null;
  }, t.contextType = st, t;
})(ke);
var cN = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var s = i[o];
      if (!e(t[s], n[s])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
}, Ub = /* @__PURE__ */ kS(cN);
const $b = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], Id = 1, oa = 8;
class hm {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const o = r >> 4;
    if (o !== Id)
      throw new Error(`Got v${o} data when expected v${Id}.`);
    const i = $b[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new hm(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, o) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = $b.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, oa, t), this.coords = new this.ArrayType(this.data, oa + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(oa + s + a + l), this.ids = new this.IndexArrayType(this.data, oa, t), this.coords = new this.ArrayType(this.data, oa + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Id << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return Nh(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: s, nodeSize: a } = this, l = [0, i.length - 1, 0], u = [];
    for (; l.length; ) {
      const c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (let h = d; h <= p; h++) {
          const E = s[2 * h], L = s[2 * h + 1];
          E >= t && E <= r && L >= n && L <= o && u.push(i[h]);
        }
        continue;
      }
      const g = d + p >> 1, m = s[2 * g], f = s[2 * g + 1];
      m >= t && m <= r && f >= n && f <= o && u.push(i[g]), (c === 0 ? t <= m : n <= f) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= m : o >= f) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: s } = this, a = [0, o.length - 1, 0], l = [], u = r * r;
    for (; a.length; ) {
      const c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (let h = d; h <= p; h++)
          Wb(i[2 * h], i[2 * h + 1], t, n) <= u && l.push(o[h]);
        continue;
      }
      const g = d + p >> 1, m = i[2 * g], f = i[2 * g + 1];
      Wb(m, f, t, n) <= u && l.push(o[g]), (c === 0 ? t - r <= m : n - r <= f) && (a.push(d), a.push(g - 1), a.push(1 - c)), (c === 0 ? t + r >= m : n + r >= f) && (a.push(g + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function Nh(e, t, n, r, o, i) {
  if (o - r <= n) return;
  const s = r + o >> 1;
  AS(e, t, s, r, o, i), Nh(e, t, n, r, s - 1, 1 - i), Nh(e, t, n, s + 1, o, 1 - i);
}
function AS(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      const u = o - r + 1, c = n - r + 1, p = Math.log(u), d = 0.5 * Math.exp(2 * p / 3), g = 0.5 * Math.sqrt(p * d * (u - d) / u) * (c - u / 2 < 0 ? -1 : 1), m = Math.max(r, Math.floor(n - c * d / u + g)), f = Math.min(o, Math.floor(n + (u - c) * d / u + g));
      AS(e, t, n, m, f, i);
    }
    const s = t[2 * n + i];
    let a = r, l = o;
    for (ia(e, t, r, n), t[2 * o + i] > s && ia(e, t, r, o); a < l; ) {
      for (ia(e, t, a, l), a++, l--; t[2 * a + i] < s; ) a++;
      for (; t[2 * l + i] > s; ) l--;
    }
    t[2 * r + i] === s ? ia(e, t, r, l) : (l++, ia(e, t, l, o)), l <= n && (r = l + 1), n <= l && (o = l - 1);
  }
}
function ia(e, t, n, r) {
  jd(e, n, r), jd(t, 2 * n, 2 * r), jd(t, 2 * n + 1, 2 * r + 1);
}
function jd(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function Wb(e, t, n, r) {
  const o = e - n, i = t - r;
  return o * o + i * i;
}
const pN = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, Hb = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Hi = 2, di = 3, Nd = 4, li = 5, BS = 6;
class dN {
  constructor(t) {
    this.options = Object.assign(Object.create(pN), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    const { log: n, minZoom: r, maxZoom: o } = this.options;
    n && console.time("total time");
    const i = `prepare ${t.length} points`;
    n && console.time(i), this.points = t;
    const s = [];
    for (let l = 0; l < t.length; l++) {
      const u = t[l];
      if (!u.geometry) continue;
      const [c, p] = u.geometry.coordinates, d = Hb(Gl(c)), g = Hb(Kl(p));
      s.push(
        d,
        g,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        l,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && s.push(0);
    }
    let a = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (let l = o; l >= r; l--) {
      const u = +Date.now();
      a = this.trees[l] = this._createTree(this._cluster(a, l)), n && console.log("z%d: %d clusters in %dms", l, a.numItems, +Date.now() - u);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    let r = ((t[0] + 180) % 360 + 360) % 360 - 180;
    const o = Math.max(-90, Math.min(90, t[1]));
    let i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
    const s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      const p = this.getClusters([r, o, 180, s], n), d = this.getClusters([-180, o, i, s], n);
      return p.concat(d);
    }
    const a = this.trees[this._limitZoom(n)], l = a.range(Gl(r), Kl(s), Gl(i), Kl(o)), u = a.data, c = [];
    for (const p of l) {
      const d = this.stride * p;
      c.push(u[d + li] > 1 ? Vb(u, d, this.clusterProps) : this.points[u[d + di]]);
    }
    return c;
  }
  getChildren(t) {
    const n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    const s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    const a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (const d of c) {
      const g = d * this.stride;
      s[g + Nd] === t && p.push(s[g + li] > 1 ? Vb(s, g, this.clusterProps) : this.points[s[g + di]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    const o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    const o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), { extent: s, radius: a } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(
      o.range((n - l) / i, u, (n + 1 + l) / i, c),
      o.data,
      n,
      r,
      i,
      p
    ), n === 0 && this._addTileFeatures(
      o.range(1 - l / i, u, 1, c),
      o.data,
      i,
      r,
      i,
      p
    ), n === i - 1 && this._addTileFeatures(
      o.range(0, u, l / i, c),
      o.data,
      -1,
      r,
      i,
      p
    ), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    let n = this._getOriginZoom(t) - 1;
    for (; n <= this.options.maxZoom; ) {
      const r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    const s = this.getChildren(n);
    for (const a of s) {
      const l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    const n = new hm(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (const a of t) {
      const l = a * this.stride, u = n[l + li] > 1;
      let c, p, d;
      if (u)
        c = _S(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        const f = this.points[n[l + di]];
        c = f.properties;
        const [h, E] = f.geometry.coordinates;
        p = Gl(h), d = Kl(E);
      }
      const g = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (p * i - r)),
          Math.round(this.options.extent * (d * i - o))
        ]],
        tags: c
      };
      let m;
      u || this.options.generateId ? m = n[l + di] : m = this.points[n[l + di]].id, m !== void 0 && (g.id = m), s.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    const { radius: r, extent: o, reduce: i, minPoints: s } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride;
    for (let p = 0; p < l.length; p += c) {
      if (l[p + Hi] <= n) continue;
      l[p + Hi] = n;
      const d = l[p], g = l[p + 1], m = t.within(l[p], l[p + 1], a), f = l[p + li];
      let h = f;
      for (const E of m) {
        const L = E * c;
        l[L + Hi] > n && (h += l[L + li]);
      }
      if (h > f && h >= s) {
        let E = d * f, L = g * f, x, T = -1;
        const w = ((p / c | 0) << 5) + (n + 1) + this.points.length;
        for (const C of m) {
          const k = C * c;
          if (l[k + Hi] <= n) continue;
          l[k + Hi] = n;
          const O = l[k + li];
          E += l[k] * O, L += l[k + 1] * O, l[k + Nd] = w, i && (x || (x = this._map(l, p, !0), T = this.clusterProps.length, this.clusterProps.push(x)), i(x, this._map(l, k)));
        }
        l[p + Nd] = w, u.push(E / h, L / h, 1 / 0, w, -1, h), i && u.push(T);
      } else {
        for (let E = 0; E < c; E++) u.push(l[p + E]);
        if (h > 1)
          for (const E of m) {
            const L = E * c;
            if (!(l[L + Hi] <= n)) {
              l[L + Hi] = n;
              for (let x = 0; x < c; x++) u.push(l[L + x]);
            }
          }
      }
    }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + li] > 1) {
      const s = this.clusterProps[t[n + BS]];
      return r ? Object.assign({}, s) : s;
    }
    const o = this.points[t[n + di]].properties, i = this.options.map(o);
    return r && i === o ? Object.assign({}, i) : i;
  }
}
function Vb(e, t, n) {
  return {
    type: "Feature",
    id: e[t + di],
    properties: _S(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [fN(e[t]), hN(e[t + 1])]
    }
  };
}
function _S(e, t, n) {
  const r = e[t + li], o = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, i = e[t + BS], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + di],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Gl(e) {
  return e / 360 + 0.5;
}
function Kl(e) {
  const t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function fN(e) {
  return (e - 0.5) * 360;
}
function hN(e) {
  const t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function gN(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class Zr {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Fh {
  constructor({ markers: t, position: n }) {
    this.markers = t, n && (n instanceof google.maps.LatLng ? this._position = n : this._position = new google.maps.LatLng(n));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const t = new google.maps.LatLngBounds(this._position, this._position);
    for (const n of this.markers)
      t.extend(Zr.getPosition(n));
    return t;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => Zr.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Zr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class mN {
  constructor({ maxZoom: t = 16 }) {
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: t }) {
    return vN(t);
  }
}
const vN = (e) => e.map((t) => new Fh({
  position: Zr.getPosition(t),
  markers: [t]
}));
class yN extends mN {
  constructor(t) {
    var { maxZoom: n, radius: r = 60 } = t, o = gN(t, ["maxZoom", "radius"]);
    super({ maxZoom: n }), this.state = { zoom: -1 }, this.superCluster = new dN(Object.assign({ maxZoom: this.maxZoom, radius: r }, o));
  }
  calculate(t) {
    let n = !1;
    const r = { zoom: t.map.getZoom() };
    if (!Ub(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      const o = this.markers.map((i) => {
        const s = Zr.getPosition(i);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [s.lng(), s.lat()]
          },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !Ub(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), { clusters: this.clusters, changed: n };
  }
  cluster({ map: t }) {
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t.getZoom())).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [t, n] }, properties: r }) {
    if (r.cluster)
      return new Fh({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((i) => i.properties.marker),
        position: { lat: n, lng: t }
      });
    const o = r.marker;
    return new Fh({
      markers: [o],
      position: Zr.getPosition(o)
    });
  }
}
class bN {
  constructor(t, n) {
    this.markers = { sum: t.length };
    const r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class wN {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: t, position: n }, r, o) {
    const i = `<svg fill="${t > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>
</svg>`, s = `Cluster of ${t} markers`, a = Number(google.maps.Marker.MAX_ZINDEX) + t;
    if (Zr.isAdvancedMarkerAvailable(o)) {
      const u = new DOMParser().parseFromString(i, "image/svg+xml").documentElement;
      u.setAttribute("transform", "translate(0 25)");
      const c = {
        map: o,
        position: n,
        zIndex: a,
        title: s,
        content: u
      };
      return new google.maps.marker.AdvancedMarkerElement(c);
    }
    const l = {
      position: n,
      zIndex: a,
      title: s,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(i)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(l);
  }
}
function CN(e, t) {
  for (let n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class gm {
  constructor() {
    CN(gm, google.maps.OverlayView);
  }
}
var ka;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(ka || (ka = {}));
const EN = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class xN extends gm {
  constructor({ map: t, markers: n = [], algorithmOptions: r = {}, algorithm: o = new yN(r), renderer: i = new wN(), onClusterClick: s = EN }) {
    super(), this.markers = [...n], this.clusters = [], this.algorithm = o, this.renderer = i, this.onClusterClick = s, t && this.setMap(t);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    const r = this.markers.indexOf(t);
    return r === -1 ? !1 : (Zr.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    let r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, ka.CLUSTERING_BEGIN, this);
      const { clusters: n, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const o = /* @__PURE__ */ new Set();
        for (const s of n)
          s.markers.length == 1 && o.add(s.markers[0]);
        const i = [];
        for (const s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Zr.setMap(s.marker, null) : i.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => i.forEach((s) => Zr.setMap(s, null)));
      }
      google.maps.event.trigger(this, ka.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => Zr.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    const t = new bN(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => Zr.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, ka.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Zr.setMap(r.marker, n);
    });
  }
}
function LN(e) {
  var t = jj(), n = D(null), r = n[0], o = n[1];
  return v(function() {
    if (t && r === null) {
      var i = new xN(Ge(Ge({}, e), { map: t }));
      o(i);
    }
  }, [t]), r;
}
function kN(e) {
  var t = e.children, n = e.options, r = LN(n);
  return r !== null ? t(r) : null;
}
Re(kN);
var Zb = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, qb = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
function DN(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, g = _e(st), m = D(null), f = m[0], h = m[1], E = D(null), L = E[0], x = E[1], T = D(null), w = T[0], C = T[1], k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = rt(null);
  return v(function() {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(function() {
    o && f !== null && f.setPosition(o);
  }, [o]), v(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(function() {
    f && a && (w !== null && google.maps.event.removeListener(w), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(function() {
    f && l && (O !== null && google.maps.event.removeListener(O), U(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(function() {
    f && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(function() {
    f && c && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(function() {
    var I = new google.maps.InfoWindow(Ge({}, r || {}));
    return h(I), X.current = document.createElement("div"), s && x(google.maps.event.addListener(I, "closeclick", s)), a && C(google.maps.event.addListener(I, "domready", a)), l && U(google.maps.event.addListener(I, "content_changed", l)), u && $(google.maps.event.addListener(I, "position_changed", u)), c && H(google.maps.event.addListener(I, "zindex_changed", c)), I.setContent(X.current), o && I.setPosition(o), i && I.setZIndex(i), n ? I.open(g, n) : I.getPosition() ? I.open(g) : sr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(I), function() {
      L && google.maps.event.removeListener(L), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), V && google.maps.event.removeListener(V), R && google.maps.event.removeListener(R), d && d(I), I.close();
    };
  }, []), X.current ? Lr(Mt.only(t), X.current) : null;
}
Re(DN);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoWindow: null
    }, n.open = function(r, o) {
      o ? r.open(n.context, o) : r.getPosition() ? r.open(n.context) : sr(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }, n.setInfoWindowCallback = function() {
      n.state.infoWindow !== null && n.containerElement !== null && (n.state.infoWindow.setContent(n.containerElement), n.open(n.state.infoWindow, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoWindow));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.InfoWindow(Ge({}, this.props.options || {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = bt({
      updaterMap: qb,
      eventMap: Zb,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        infoWindow: n
      };
    }, this.setInfoWindowCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.infoWindow !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: qb,
      eventMap: Zb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.infoWindow !== null && (St(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Lr(Mt.only(this.props.children), this.containerElement) : null;
  }, t.contextType = st, t;
})(ke);
var Gb = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Kb = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, SN = {};
function ON(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, g = e.onMouseUp, m = e.onRightClick, f = e.onClick, h = e.onDrag, E = e.onLoad, L = e.onUnmount, x = _e(st), T = D(null), w = T[0], C = T[1], k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = D(null), I = X[0], J = X[1], te = D(null), S = te[0], P = te[1], q = D(null), j = q[0], Z = q[1], G = D(null), b = G[0], F = G[1], z = D(null), A = z[0], Y = z[1], ee = D(null), B = ee[0], se = ee[1], ue = D(null), ce = ue[0], de = ue[1], be = D(null), ge = be[0], me = be[1];
  return v(function() {
    w !== null && w.setMap(x);
  }, [x]), v(function() {
    typeof t < "u" && w !== null && w.setOptions(t);
  }, [w, t]), v(function() {
    typeof n < "u" && w !== null && w.setDraggable(n);
  }, [w, n]), v(function() {
    typeof r < "u" && w !== null && w.setEditable(r);
  }, [w, r]), v(function() {
    typeof o < "u" && w !== null && w.setVisible(o);
  }, [w, o]), v(function() {
    typeof i < "u" && w !== null && w.setPath(i);
  }, [w, i]), v(function() {
    w && s && (O !== null && google.maps.event.removeListener(O), U(google.maps.event.addListener(w, "dblclick", s)));
  }, [s]), v(function() {
    w && a && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "dragend", a)));
  }, [a]), v(function() {
    w && l && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(w, "dragstart", l)));
  }, [l]), v(function() {
    w && u && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(w, "mousedown", u)));
  }, [u]), v(function() {
    w && c && (S !== null && google.maps.event.removeListener(S), P(google.maps.event.addListener(w, "mousemove", c)));
  }, [c]), v(function() {
    w && p && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "mouseout", p)));
  }, [p]), v(function() {
    w && d && (b !== null && google.maps.event.removeListener(b), F(google.maps.event.addListener(w, "mouseover", d)));
  }, [d]), v(function() {
    w && g && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(w, "mouseup", g)));
  }, [g]), v(function() {
    w && m && (B !== null && google.maps.event.removeListener(B), se(google.maps.event.addListener(w, "rightclick", m)));
  }, [m]), v(function() {
    w && f && (ce !== null && google.maps.event.removeListener(ce), de(google.maps.event.addListener(w, "click", f)));
  }, [f]), v(function() {
    w && h && (ge !== null && google.maps.event.removeListener(ge), me(google.maps.event.addListener(w, "drag", h)));
  }, [h]), v(function() {
    var ae = new google.maps.Polyline(Ge(Ge({}, t || SN), { map: x }));
    return i && ae.setPath(i), typeof o < "u" && ae.setVisible(o), typeof r < "u" && ae.setEditable(r), typeof n < "u" && ae.setDraggable(n), s && U(google.maps.event.addListener(ae, "dblclick", s)), a && $(google.maps.event.addListener(ae, "dragend", a)), l && H(google.maps.event.addListener(ae, "dragstart", l)), u && J(google.maps.event.addListener(ae, "mousedown", u)), c && P(google.maps.event.addListener(ae, "mousemove", c)), p && Z(google.maps.event.addListener(ae, "mouseout", p)), d && F(google.maps.event.addListener(ae, "mouseover", d)), g && Y(google.maps.event.addListener(ae, "mouseup", g)), m && se(google.maps.event.addListener(ae, "rightclick", m)), f && de(google.maps.event.addListener(ae, "click", f)), h && me(google.maps.event.addListener(ae, "drag", h)), C(ae), E && E(ae), function() {
      O !== null && google.maps.event.removeListener(O), V !== null && google.maps.event.removeListener(V), R !== null && google.maps.event.removeListener(R), I !== null && google.maps.event.removeListener(I), S !== null && google.maps.event.removeListener(S), j !== null && google.maps.event.removeListener(j), b !== null && google.maps.event.removeListener(b), A !== null && google.maps.event.removeListener(A), B !== null && google.maps.event.removeListener(B), ce !== null && google.maps.event.removeListener(ce), L && L(ae), ae.setMap(null);
    };
  }, []), null;
}
Re(ON);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polyline: null
    }, n.setPolylineCallback = function() {
      n.state.polyline !== null && n.props.onLoad && n.props.onLoad(n.state.polyline);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polyline(Ge(Ge({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = bt({
      updaterMap: Kb,
      eventMap: Gb,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polyline: n
      };
    }, this.setPolylineCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polyline !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: Kb,
      eventMap: Gb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), St(this.registeredEvents), this.state.polyline.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
var Yb = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Xb = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  paths: function(e, t) {
    e.setPaths(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function MN(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.paths, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, g = e.onMouseOver, m = e.onMouseUp, f = e.onRightClick, h = e.onClick, E = e.onDrag, L = e.onLoad, x = e.onUnmount, T = e.onEdit, w = _e(st), C = D(null), k = C[0], O = C[1], U = D(null), M = U[0], V = U[1], $ = D(null), W = $[0], R = $[1], H = D(null), X = H[0], I = H[1], J = D(null), te = J[0], S = J[1], P = D(null), q = P[0], j = P[1], Z = D(null), G = Z[0], b = Z[1], F = D(null), z = F[0], A = F[1], Y = D(null), ee = Y[0], B = Y[1], se = D(null), ue = se[0], ce = se[1], de = D(null), be = de[0], ge = de[1], me = D(null), ae = me[0], xe = me[1];
  return v(function() {
    k !== null && k.setMap(w);
  }, [w]), v(function() {
    typeof t < "u" && k !== null && k.setOptions(t);
  }, [k, t]), v(function() {
    typeof n < "u" && k !== null && k.setDraggable(n);
  }, [k, n]), v(function() {
    typeof r < "u" && k !== null && k.setEditable(r);
  }, [k, r]), v(function() {
    typeof o < "u" && k !== null && k.setVisible(o);
  }, [k, o]), v(function() {
    typeof i < "u" && k !== null && k.setPath(i);
  }, [k, i]), v(function() {
    typeof s < "u" && k !== null && k.setPaths(s);
  }, [k, s]), v(function() {
    k && a && (M !== null && google.maps.event.removeListener(M), V(google.maps.event.addListener(k, "dblclick", a)));
  }, [a]), v(function() {
    k && (google.maps.event.addListener(k.getPath(), "insert_at", function() {
      T == null || T(k);
    }), google.maps.event.addListener(k.getPath(), "set_at", function() {
      T == null || T(k);
    }));
  }, [k, T]), v(function() {
    k && l && (W !== null && google.maps.event.removeListener(W), R(google.maps.event.addListener(k, "dragend", l)));
  }, [l]), v(function() {
    k && u && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(k, "dragstart", u)));
  }, [u]), v(function() {
    k && c && (te !== null && google.maps.event.removeListener(te), S(google.maps.event.addListener(k, "mousedown", c)));
  }, [c]), v(function() {
    k && p && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(k, "mousemove", p)));
  }, [p]), v(function() {
    k && d && (G !== null && google.maps.event.removeListener(G), b(google.maps.event.addListener(k, "mouseout", d)));
  }, [d]), v(function() {
    k && g && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(k, "mouseover", g)));
  }, [g]), v(function() {
    k && m && (ee !== null && google.maps.event.removeListener(ee), B(google.maps.event.addListener(k, "mouseup", m)));
  }, [m]), v(function() {
    k && f && (ue !== null && google.maps.event.removeListener(ue), ce(google.maps.event.addListener(k, "rightclick", f)));
  }, [f]), v(function() {
    k && h && (be !== null && google.maps.event.removeListener(be), ge(google.maps.event.addListener(k, "click", h)));
  }, [h]), v(function() {
    k && E && (ae !== null && google.maps.event.removeListener(ae), xe(google.maps.event.addListener(k, "drag", E)));
  }, [E]), v(function() {
    var re = new google.maps.Polygon(Ge(Ge({}, t || {}), { map: w }));
    return i && re.setPath(i), s && re.setPaths(s), typeof o < "u" && re.setVisible(o), typeof r < "u" && re.setEditable(r), typeof n < "u" && re.setDraggable(n), a && V(google.maps.event.addListener(re, "dblclick", a)), l && R(google.maps.event.addListener(re, "dragend", l)), u && I(google.maps.event.addListener(re, "dragstart", u)), c && S(google.maps.event.addListener(re, "mousedown", c)), p && j(google.maps.event.addListener(re, "mousemove", p)), d && b(google.maps.event.addListener(re, "mouseout", d)), g && A(google.maps.event.addListener(re, "mouseover", g)), m && B(google.maps.event.addListener(re, "mouseup", m)), f && ce(google.maps.event.addListener(re, "rightclick", f)), h && ge(google.maps.event.addListener(re, "click", h)), E && xe(google.maps.event.addListener(re, "drag", E)), O(re), L && L(re), function() {
      M !== null && google.maps.event.removeListener(M), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), q !== null && google.maps.event.removeListener(q), G !== null && google.maps.event.removeListener(G), z !== null && google.maps.event.removeListener(z), ee !== null && google.maps.event.removeListener(ee), ue !== null && google.maps.event.removeListener(ue), be !== null && google.maps.event.removeListener(be), x && x(re), re.setMap(null);
    };
  }, []), null;
}
Re(MN);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polygon: null
    }, n.setPolygonCallback = function() {
      n.state.polygon !== null && n.props.onLoad && n.props.onLoad(n.state.polygon);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polygon(Ge(Ge({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = bt({
      updaterMap: Xb,
      eventMap: Yb,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polygon: n
      };
    }, this.setPolygonCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polygon !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: Xb,
      eventMap: Yb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polygon
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polygon !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polygon), St(this.registeredEvents), this.state.polygon && this.state.polygon.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
var Qb = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Jb = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function PN(e) {
  var t = e.options, n = e.bounds, r = e.draggable, o = e.editable, i = e.visible, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, g = e.onMouseUp, m = e.onRightClick, f = e.onClick, h = e.onDrag, E = e.onBoundsChanged, L = e.onLoad, x = e.onUnmount, T = _e(st), w = D(null), C = w[0], k = w[1], O = D(null), U = O[0], M = O[1], V = D(null), $ = V[0], W = V[1], R = D(null), H = R[0], X = R[1], I = D(null), J = I[0], te = I[1], S = D(null), P = S[0], q = S[1], j = D(null), Z = j[0], G = j[1], b = D(null), F = b[0], z = b[1], A = D(null), Y = A[0], ee = A[1], B = D(null), se = B[0], ue = B[1], ce = D(null), de = ce[0], be = ce[1], ge = D(null), me = ge[0], ae = ge[1], xe = D(null), re = xe[0], Te = xe[1];
  return v(function() {
    C !== null && C.setMap(T);
  }, [T]), v(function() {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(function() {
    typeof r < "u" && C !== null && C.setDraggable(r);
  }, [C, r]), v(function() {
    typeof o < "u" && C !== null && C.setEditable(o);
  }, [C, o]), v(function() {
    typeof i < "u" && C !== null && C.setVisible(i);
  }, [C, i]), v(function() {
    typeof n < "u" && C !== null && C.setBounds(n);
  }, [C, n]), v(function() {
    C && s && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(function() {
    C && a && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(C, "dragend", a)));
  }, [a]), v(function() {
    C && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "dragstart", l)));
  }, [l]), v(function() {
    C && u && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(C, "mousedown", u)));
  }, [u]), v(function() {
    C && c && (P !== null && google.maps.event.removeListener(P), q(google.maps.event.addListener(C, "mousemove", c)));
  }, [c]), v(function() {
    C && p && (Z !== null && google.maps.event.removeListener(Z), G(google.maps.event.addListener(C, "mouseout", p)));
  }, [p]), v(function() {
    C && d && (F !== null && google.maps.event.removeListener(F), z(google.maps.event.addListener(C, "mouseover", d)));
  }, [d]), v(function() {
    C && g && (Y !== null && google.maps.event.removeListener(Y), ee(google.maps.event.addListener(C, "mouseup", g)));
  }, [g]), v(function() {
    C && m && (se !== null && google.maps.event.removeListener(se), ue(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(function() {
    C && f && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(C, "click", f)));
  }, [f]), v(function() {
    C && h && (me !== null && google.maps.event.removeListener(me), ae(google.maps.event.addListener(C, "drag", h)));
  }, [h]), v(function() {
    C && E && (re !== null && google.maps.event.removeListener(re), Te(google.maps.event.addListener(C, "bounds_changed", E)));
  }, [E]), v(function() {
    var ne = new google.maps.Rectangle(Ge(Ge({}, t || {}), { map: T }));
    return typeof i < "u" && ne.setVisible(i), typeof o < "u" && ne.setEditable(o), typeof r < "u" && ne.setDraggable(r), typeof n < "u" && ne.setBounds(n), s && M(google.maps.event.addListener(ne, "dblclick", s)), a && W(google.maps.event.addListener(ne, "dragend", a)), l && X(google.maps.event.addListener(ne, "dragstart", l)), u && te(google.maps.event.addListener(ne, "mousedown", u)), c && q(google.maps.event.addListener(ne, "mousemove", c)), p && G(google.maps.event.addListener(ne, "mouseout", p)), d && z(google.maps.event.addListener(ne, "mouseover", d)), g && ee(google.maps.event.addListener(ne, "mouseup", g)), m && ue(google.maps.event.addListener(ne, "rightclick", m)), f && be(google.maps.event.addListener(ne, "click", f)), h && ae(google.maps.event.addListener(ne, "drag", h)), E && Te(google.maps.event.addListener(ne, "bounds_changed", E)), k(ne), L && L(ne), function() {
      U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), P !== null && google.maps.event.removeListener(P), Z !== null && google.maps.event.removeListener(Z), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), se !== null && google.maps.event.removeListener(se), de !== null && google.maps.event.removeListener(de), me !== null && google.maps.event.removeListener(me), re !== null && google.maps.event.removeListener(re), x && x(ne), ne.setMap(null);
    };
  }, []), null;
}
Re(PN);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      rectangle: null
    }, n.setRectangleCallback = function() {
      n.state.rectangle !== null && n.props.onLoad && n.props.onLoad(n.state.rectangle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Rectangle(Ge(Ge({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = bt({
      updaterMap: Jb,
      eventMap: Qb,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        rectangle: n
      };
    }, this.setRectangleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.rectangle !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: Jb,
      eventMap: Qb,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), St(this.registeredEvents), this.state.rectangle.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
var ew = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, tw = {
  center: function(e, t) {
    e.setCenter(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  radius: function(e, t) {
    e.setRadius(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, TN = {};
function AN(e) {
  var t = e.options, n = e.center, r = e.radius, o = e.draggable, i = e.editable, s = e.visible, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, g = e.onMouseOver, m = e.onMouseUp, f = e.onRightClick, h = e.onClick, E = e.onDrag, L = e.onCenterChanged, x = e.onRadiusChanged, T = e.onLoad, w = e.onUnmount, C = _e(st), k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = D(null), I = X[0], J = X[1], te = D(null), S = te[0], P = te[1], q = D(null), j = q[0], Z = q[1], G = D(null), b = G[0], F = G[1], z = D(null), A = z[0], Y = z[1], ee = D(null), B = ee[0], se = ee[1], ue = D(null), ce = ue[0], de = ue[1], be = D(null), ge = be[0], me = be[1], ae = D(null), xe = ae[0], re = ae[1], Te = D(null), ne = Te[0], Ee = Te[1], Ne = D(null), Fe = Ne[0], Ue = Ne[1];
  return v(function() {
    O !== null && O.setMap(C);
  }, [C]), v(function() {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), v(function() {
    typeof o < "u" && O !== null && O.setDraggable(o);
  }, [O, o]), v(function() {
    typeof i < "u" && O !== null && O.setEditable(i);
  }, [O, i]), v(function() {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(function() {
    typeof r == "number" && O !== null && O.setRadius(r);
  }, [O, r]), v(function() {
    typeof n < "u" && O !== null && O.setCenter(n);
  }, [O, n]), v(function() {
    O && a && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), v(function() {
    O && l && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), v(function() {
    O && u && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), v(function() {
    O && c && (S !== null && google.maps.event.removeListener(S), P(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), v(function() {
    O && p && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(O, "mousemove", p)));
  }, [p]), v(function() {
    O && d && (b !== null && google.maps.event.removeListener(b), F(google.maps.event.addListener(O, "mouseout", d)));
  }, [d]), v(function() {
    O && g && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(O, "mouseover", g)));
  }, [g]), v(function() {
    O && m && (B !== null && google.maps.event.removeListener(B), se(google.maps.event.addListener(O, "mouseup", m)));
  }, [m]), v(function() {
    O && f && (ce !== null && google.maps.event.removeListener(ce), de(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), v(function() {
    O && h && (ge !== null && google.maps.event.removeListener(ge), me(google.maps.event.addListener(O, "click", h)));
  }, [h]), v(function() {
    O && E && (xe !== null && google.maps.event.removeListener(xe), re(google.maps.event.addListener(O, "drag", E)));
  }, [E]), v(function() {
    O && L && (ne !== null && google.maps.event.removeListener(ne), Ee(google.maps.event.addListener(O, "center_changed", L)));
  }, [h]), v(function() {
    O && x && (Fe !== null && google.maps.event.removeListener(Fe), Ue(google.maps.event.addListener(O, "radius_changed", x)));
  }, [x]), v(function() {
    var he = new google.maps.Circle(Ge(Ge({}, t || TN), { map: C }));
    return typeof r == "number" && he.setRadius(r), typeof n < "u" && he.setCenter(n), typeof r == "number" && he.setRadius(r), typeof s < "u" && he.setVisible(s), typeof i < "u" && he.setEditable(i), typeof o < "u" && he.setDraggable(o), a && $(google.maps.event.addListener(he, "dblclick", a)), l && H(google.maps.event.addListener(he, "dragend", l)), u && J(google.maps.event.addListener(he, "dragstart", u)), c && P(google.maps.event.addListener(he, "mousedown", c)), p && Z(google.maps.event.addListener(he, "mousemove", p)), d && F(google.maps.event.addListener(he, "mouseout", d)), g && Y(google.maps.event.addListener(he, "mouseover", g)), m && se(google.maps.event.addListener(he, "mouseup", m)), f && de(google.maps.event.addListener(he, "rightclick", f)), h && me(google.maps.event.addListener(he, "click", h)), E && re(google.maps.event.addListener(he, "drag", E)), L && Ee(google.maps.event.addListener(he, "center_changed", L)), x && Ue(google.maps.event.addListener(he, "radius_changed", x)), U(he), T && T(he), function() {
      V !== null && google.maps.event.removeListener(V), R !== null && google.maps.event.removeListener(R), I !== null && google.maps.event.removeListener(I), S !== null && google.maps.event.removeListener(S), j !== null && google.maps.event.removeListener(j), b !== null && google.maps.event.removeListener(b), A !== null && google.maps.event.removeListener(A), B !== null && google.maps.event.removeListener(B), ce !== null && google.maps.event.removeListener(ce), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), Fe !== null && google.maps.event.removeListener(Fe), w && w(he), he.setMap(null);
    };
  }, []), null;
}
Re(AN);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      circle: null
    }, n.setCircleCallback = function() {
      n.state.circle !== null && n.props.onLoad && n.props.onLoad(n.state.circle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Circle(Ge(Ge({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = bt({
      updaterMap: tw,
      eventMap: ew,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        circle: n
      };
    }, this.setCircleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.circle !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: tw,
      eventMap: ew,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n;
    this.state.circle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.circle), St(this.registeredEvents), (n = this.state.circle) === null || n === void 0 || n.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
var nw = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, rw = {
  add: function(e, t) {
    e.add(t);
  },
  addgeojson: function(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains: function(e, t) {
    e.contains(t);
  },
  foreach: function(e, t) {
    e.forEach(t);
  },
  loadgeojson: function(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle: function(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove: function(e, t) {
    e.remove(t);
  },
  revertstyle: function(e, t) {
    e.revertStyle(t);
  },
  controlposition: function(e, t) {
    e.setControlPosition(t);
  },
  controls: function(e, t) {
    e.setControls(t);
  },
  drawingmode: function(e, t) {
    e.setDrawingMode(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  style: function(e, t) {
    e.setStyle(t);
  },
  togeojson: function(e, t) {
    e.toGeoJson(t);
  }
};
function BN(e) {
  var t = e.options, n = e.onClick, r = e.onDblClick, o = e.onMouseDown, i = e.onMouseMove, s = e.onMouseOut, a = e.onMouseOver, l = e.onMouseUp, u = e.onRightClick, c = e.onAddFeature, p = e.onRemoveFeature, d = e.onRemoveProperty, g = e.onSetGeometry, m = e.onSetProperty, f = e.onLoad, h = e.onUnmount, E = _e(st), L = D(null), x = L[0], T = L[1], w = D(null), C = w[0], k = w[1], O = D(null), U = O[0], M = O[1], V = D(null), $ = V[0], W = V[1], R = D(null), H = R[0], X = R[1], I = D(null), J = I[0], te = I[1], S = D(null), P = S[0], q = S[1], j = D(null), Z = j[0], G = j[1], b = D(null), F = b[0], z = b[1], A = D(null), Y = A[0], ee = A[1], B = D(null), se = B[0], ue = B[1], ce = D(null), de = ce[0], be = ce[1], ge = D(null), me = ge[0], ae = ge[1], xe = D(null), re = xe[0], Te = xe[1];
  return v(function() {
    x !== null && x.setMap(E);
  }, [E]), v(function() {
    x && r && (C !== null && google.maps.event.removeListener(C), k(google.maps.event.addListener(x, "dblclick", r)));
  }, [r]), v(function() {
    x && o && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(x, "mousedown", o)));
  }, [o]), v(function() {
    x && i && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(x, "mousemove", i)));
  }, [i]), v(function() {
    x && s && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mouseout", s)));
  }, [s]), v(function() {
    x && a && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(x, "mouseover", a)));
  }, [a]), v(function() {
    x && l && (P !== null && google.maps.event.removeListener(P), q(google.maps.event.addListener(x, "mouseup", l)));
  }, [l]), v(function() {
    x && u && (Z !== null && google.maps.event.removeListener(Z), G(google.maps.event.addListener(x, "rightclick", u)));
  }, [u]), v(function() {
    x && n && (F !== null && google.maps.event.removeListener(F), z(google.maps.event.addListener(x, "click", n)));
  }, [n]), v(function() {
    x && c && (Y !== null && google.maps.event.removeListener(Y), ee(google.maps.event.addListener(x, "addfeature", c)));
  }, [c]), v(function() {
    x && p && (se !== null && google.maps.event.removeListener(se), ue(google.maps.event.addListener(x, "removefeature", p)));
  }, [p]), v(function() {
    x && d && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(x, "removeproperty", d)));
  }, [d]), v(function() {
    x && g && (me !== null && google.maps.event.removeListener(me), ae(google.maps.event.addListener(x, "setgeometry", g)));
  }, [g]), v(function() {
    x && m && (re !== null && google.maps.event.removeListener(re), Te(google.maps.event.addListener(x, "setproperty", m)));
  }, [m]), v(function() {
    if (E !== null) {
      var ne = new google.maps.Data(Ge(Ge({}, t || {}), { map: E }));
      r && k(google.maps.event.addListener(ne, "dblclick", r)), o && M(google.maps.event.addListener(ne, "mousedown", o)), i && W(google.maps.event.addListener(ne, "mousemove", i)), s && X(google.maps.event.addListener(ne, "mouseout", s)), a && te(google.maps.event.addListener(ne, "mouseover", a)), l && q(google.maps.event.addListener(ne, "mouseup", l)), u && G(google.maps.event.addListener(ne, "rightclick", u)), n && z(google.maps.event.addListener(ne, "click", n)), c && ee(google.maps.event.addListener(ne, "addfeature", c)), p && ue(google.maps.event.addListener(ne, "removefeature", p)), d && be(google.maps.event.addListener(ne, "removeproperty", d)), g && ae(google.maps.event.addListener(ne, "setgeometry", g)), m && Te(google.maps.event.addListener(ne, "setproperty", m)), T(ne), f && f(ne);
    }
    return function() {
      x && (C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), P !== null && google.maps.event.removeListener(P), Z !== null && google.maps.event.removeListener(Z), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), se !== null && google.maps.event.removeListener(se), de !== null && google.maps.event.removeListener(de), me !== null && google.maps.event.removeListener(me), re !== null && google.maps.event.removeListener(re), h && h(x), x.setMap(null));
    };
  }, []), null;
}
Re(BN);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      data: null
    }, n.setDataCallback = function() {
      n.state.data !== null && n.props.onLoad && n.props.onLoad(n.state.data);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context !== null) {
      var n = new google.maps.Data(Ge(Ge({}, this.props.options || {}), { map: this.context }));
      this.registeredEvents = bt({
        updaterMap: rw,
        eventMap: nw,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          data: n
        };
      }, this.setDataCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.data !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: rw,
      eventMap: nw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.data
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), St(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
var ow = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, iw = {
  options: function(e, t) {
    e.setOptions(t);
  },
  url: function(e, t) {
    e.setUrl(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      kmlLayer: null
    }, n.setKmlLayerCallback = function() {
      n.state.kmlLayer !== null && n.props.onLoad && n.props.onLoad(n.state.kmlLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.KmlLayer(Ge(Ge({}, this.props.options), { map: this.context }));
    this.registeredEvents = bt({
      updaterMap: iw,
      eventMap: ow,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        kmlLayer: n
      };
    }, this.setKmlLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.kmlLayer !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: iw,
      eventMap: ow,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), St(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
function IS(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function _N(e, t) {
  return new t(e.lat, e.lng);
}
function IN(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function jN(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function NN(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function FN(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function RN(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var o = r.x, i = r.y;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function jS(e, t, n, r) {
  return n !== void 0 ? FN(e, t, NN(n, google.maps.LatLngBounds, IN)) : RN(e, t, jN(r, google.maps.LatLng, _N));
}
function zN(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function UN(e, t, n, r, o) {
  var i = (
    /** @class */
    function(s) {
      mn(a, s);
      function a(l, u, c, p) {
        var d = s.call(this) || this;
        return d.container = l, d.pane = u, d.position = c, d.bounds = p, d;
      }
      return a.prototype.onAdd = function() {
        var l, u = (l = this.getPanes()) === null || l === void 0 ? void 0 : l[this.pane];
        u == null || u.appendChild(this.container);
      }, a.prototype.draw = function() {
        for (var l = this.getProjection(), u = Ge({}, this.container ? IS(this.container, o) : {
          x: 0,
          y: 0
        }), c = jS(l, u, this.bounds, this.position), p = 0, d = Object.entries(c); p < d.length; p++) {
          var g = d[p], m = g[0], f = g[1];
          this.container.style[m] = f;
        }
      }, a.prototype.onRemove = function() {
        this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
      }, a;
    }(google.maps.OverlayView)
  );
  return new i(e, t, n, r);
}
function sw(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function aw(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function $N(e) {
  var t = e.position, n = e.bounds, r = e.mapPaneName, o = e.zIndex, i = e.onLoad, s = e.onUnmount, a = e.getPixelPositionOffset, l = e.children, u = _e(st), c = rr(function() {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = rr(function() {
    return UN(c, r, t, n, a);
  }, [c, r, t, n]);
  return v(function() {
    return i == null || i(p), p == null || p.setMap(u), function() {
      s == null || s(p), p == null || p.setMap(null);
    };
  }, [u, p]), v(function() {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Di.createPortal(l, c);
}
Re($N);
(function(e) {
  mn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    r.state = {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }, r.updatePane = function() {
      var i = r.props.mapPaneName, s = r.overlayView.getPanes();
      sr(!!i, "OverlayView requires props.mapPaneName but got %s", i), s ? r.setState({
        paneEl: s[i]
      }) : r.setState({
        paneEl: null
      });
    }, r.onAdd = function() {
      var i, s;
      r.updatePane(), (s = (i = r.props).onLoad) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.onPositionElement = function() {
      var i = r.overlayView.getProjection(), s = Ge({ x: 0, y: 0 }, r.containerRef.current ? IS(r.containerRef.current, r.props.getPixelPositionOffset) : {}), a = jS(i, s, r.props.bounds, r.props.position), l = r.state.containerStyle, u = l.left, c = l.top, p = l.width, d = l.height;
      zN(a, { left: u, top: c, width: p, height: d }) || r.setState({
        containerStyle: {
          top: a.top || 0,
          left: a.left || 0,
          width: a.width || 0,
          height: a.height || 0,
          position: "absolute"
        }
      });
    }, r.draw = function() {
      r.onPositionElement();
    }, r.onRemove = function() {
      var i, s;
      r.setState(function() {
        return {
          paneEl: null
        };
      }), (s = (i = r.props).onUnmount) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.containerRef = xr();
    var o = new google.maps.OverlayView();
    return o.onAdd = r.onAdd, o.draw = r.draw, o.onRemove = r.onRemove, r.overlayView = o, r;
  }
  return t.prototype.componentDidMount = function() {
    this.overlayView.setMap(this.context);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = sw(n.position), o = sw(this.props.position), i = aw(n.bounds), s = aw(this.props.bounds);
    (r !== o || i !== s) && this.overlayView.draw(), n.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }, t.prototype.componentWillUnmount = function() {
    this.overlayView.setMap(null);
  }, t.prototype.render = function() {
    var n = this.state.paneEl;
    return n ? Di.createPortal(fr.jsx("div", { ref: this.containerRef, style: this.state.containerStyle, children: Mt.only(this.props.children) }), n) : null;
  }, t.FLOAT_PANE = "floatPane", t.MAP_PANE = "mapPane", t.MARKER_LAYER = "markerLayer", t.OVERLAY_LAYER = "overlayLayer", t.OVERLAY_MOUSE_TARGET = "overlayMouseTarget", t.contextType = st, t;
})(ke);
function WN() {
}
var lw = {
  onDblClick: "dblclick",
  onClick: "click"
}, uw = {
  opacity: function(e, t) {
    e.setOpacity(t);
  }
};
function HN(e) {
  var t = e.url, n = e.bounds, r = e.options, o = e.visible, i = _e(st), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = rr(function() {
    var l = new google.maps.GroundOverlay(t, s, Ge({}, r));
    return l;
  }, []);
  return v(function() {
    a !== null && a.setMap(i);
  }, [i]), v(function() {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), v(function() {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), v(function() {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Re(HN);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      groundOverlay: null
    }, n.setGroundOverlayCallback = function() {
      n.state.groundOverlay !== null && n.props.onLoad && n.props.onLoad(n.state.groundOverlay);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    sr(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var n = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Ge(Ge({}, this.props.options), { map: this.context }));
    this.registeredEvents = bt({
      updaterMap: uw,
      eventMap: lw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        groundOverlay: n
      };
    }, this.setGroundOverlayCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.groundOverlay !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: uw,
      eventMap: lw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.defaultProps = {
    onLoad: WN
  }, t.contextType = st, t;
})(ke);
var cw = {}, pw = {
  data: function(e, t) {
    e.setData(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function VN(e) {
  var t = e.data, n = e.onLoad, r = e.onUnmount, o = e.options, i = _e(st), s = D(null), a = s[0], l = s[1];
  return v(function() {
    google.maps.visualization || sr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(function() {
    sr(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(function() {
    a !== null && a.setMap(i);
  }, [i]), v(function() {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(function() {
    var u = new google.maps.visualization.HeatmapLayer(Ge(Ge({}, o || {}), { data: t, map: i }));
    return l(u), n && n(u), function() {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Re(VN);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      heatmapLayer: null
    }, n.setHeatmapLayerCallback = function() {
      n.state.heatmapLayer !== null && n.props.onLoad && n.props.onLoad(n.state.heatmapLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    sr(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), sr(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var n = new google.maps.visualization.HeatmapLayer(Ge(Ge({}, this.props.options || {}), { data: this.props.data, map: this.context }));
    this.registeredEvents = bt({
      updaterMap: pw,
      eventMap: cw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        heatmapLayer: n
      };
    }, this.setHeatmapLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: pw,
      eventMap: cw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), St(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
var dw = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, fw = {
  register: function(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links: function(e, t) {
    e.setLinks(t);
  },
  motionTracking: function(e, t) {
    e.setMotionTracking(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  pano: function(e, t) {
    e.setPano(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  pov: function(e, t) {
    e.setPov(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      streetViewPanorama: null
    }, n.setStreetViewPanoramaCallback = function() {
      n.state.streetViewPanorama !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewPanorama);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n, r, o = (r = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && r !== void 0 ? r : null;
    this.registeredEvents = bt({
      updaterMap: fw,
      eventMap: dw,
      prevProps: {},
      nextProps: this.props,
      instance: o
    }), this.setState(function() {
      return {
        streetViewPanorama: o
      };
    }, this.setStreetViewPanoramaCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.streetViewPanorama !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: fw,
      eventMap: dw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), St(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      streetViewService: null
    }, n.setStreetViewServiceCallback = function() {
      n.state.streetViewService !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: n
      };
    }, this.setStreetViewServiceCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = st, t;
})(ke);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      directionsService: null
    }, n.setDirectionsServiceCallback = function() {
      n.state.directionsService !== null && n.props.onLoad && n.props.onLoad(n.state.directionsService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    sr(!!this.props.options, "DirectionsService expected options object as parameter, but got %s", this.props.options);
    var n = new google.maps.DirectionsService();
    this.setState(function() {
      return {
        directionsService: n
      };
    }, this.setDirectionsServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.directionsService !== null && this.state.directionsService.route(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsService !== null && this.props.onUnmount && this.props.onUnmount(this.state.directionsService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(ke);
var hw = {
  onDirectionsChanged: "directions_changed"
}, gw = {
  directions: function(e, t) {
    e.setDirections(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  panel: function(e, t) {
    e.setPanel(t);
  },
  routeIndex: function(e, t) {
    e.setRouteIndex(t);
  }
};
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      directionsRenderer: null
    }, n.setDirectionsRendererCallback = function() {
      n.state.directionsRenderer !== null && (n.state.directionsRenderer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.directionsRenderer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = bt({
      updaterMap: gw,
      eventMap: hw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        directionsRenderer: n
      };
    }, this.setDirectionsRendererCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.directionsRenderer !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: gw,
      eventMap: hw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), St(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }, t.prototype.render = function() {
    return fr.jsx(fr.Fragment, {});
  }, t.contextType = st, t;
})(ke);
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      distanceMatrixService: null
    }, n.setDistanceMatrixServiceCallback = function() {
      n.state.distanceMatrixService !== null && n.props.onLoad && n.props.onLoad(n.state.distanceMatrixService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    sr(!!this.props.options, "DistanceMatrixService expected options object as parameter, but go %s", this.props.options);
    var n = new google.maps.DistanceMatrixService();
    this.setState(function() {
      return {
        distanceMatrixService: n
      };
    }, this.setDistanceMatrixServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.distanceMatrixService !== null && this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.distanceMatrixService !== null && this.props.onUnmount && this.props.onUnmount(this.state.distanceMatrixService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(ke);
var mw = {
  onPlacesChanged: "places_changed"
}, vw = {
  bounds: function(e, t) {
    e.setBounds(t);
  }
};
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = xr(), n.state = {
      searchBox: null
    }, n.setSearchBoxCallback = function() {
      n.state.searchBox !== null && n.props.onLoad && n.props.onLoad(n.state.searchBox);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (sr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var n = this.containerElement.current.querySelector("input");
      if (n !== null) {
        var r = new google.maps.places.SearchBox(n, this.props.options);
        this.registeredEvents = bt({
          updaterMap: vw,
          eventMap: mw,
          prevProps: {},
          nextProps: this.props,
          instance: r
        }), this.setState(function() {
          return {
            searchBox: r
          };
        }, this.setSearchBoxCallback);
      }
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.searchBox !== null && (St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: vw,
      eventMap: mw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), St(this.registeredEvents));
  }, t.prototype.render = function() {
    return fr.jsx("div", { ref: this.containerElement, children: Mt.only(this.props.children) });
  }, t.contextType = st, t;
})(ke);
var yw = {
  onPlaceChanged: "place_changed"
}, bw = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  restrictions: function(e, t) {
    e.setComponentRestrictions(t);
  },
  fields: function(e, t) {
    e.setFields(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  types: function(e, t) {
    e.setTypes(t);
  }
};
(function(e) {
  mn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = xr(), n.state = {
      autocomplete: null
    }, n.setAutocompleteCallback = function() {
      n.state.autocomplete !== null && n.props.onLoad && n.props.onLoad(n.state.autocomplete);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n;
    sr(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var r = (n = this.containerElement.current) === null || n === void 0 ? void 0 : n.querySelector("input");
    if (r) {
      var o = new google.maps.places.Autocomplete(r, this.props.options);
      this.registeredEvents = bt({
        updaterMap: bw,
        eventMap: yw,
        prevProps: {},
        nextProps: this.props,
        instance: o
      }), this.setState(function() {
        return {
          autocomplete: o
        };
      }, this.setAutocompleteCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    St(this.registeredEvents), this.registeredEvents = bt({
      updaterMap: bw,
      eventMap: yw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.autocomplete !== null && St(this.registeredEvents);
  }, t.prototype.render = function() {
    return fr.jsx("div", { ref: this.containerElement, className: this.props.className, children: Mt.only(this.props.children) });
  }, t.defaultProps = {
    className: ""
  }, t.contextType = st, t;
})(ke);
Ye({});
function ZN(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const qN = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
ZN(qN.CNPJ).length;
Fs((e, t) => /* @__PURE__ */ fr.jsx("input", { ref: t, ...e }));
var rn = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function GN(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var Rh = { exports: {} }, sa = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ww;
function KN() {
  if (ww) return sa;
  ww = 1;
  var e = Be, t = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function s(a, l, u) {
    var c, p = {}, d = null, g = null;
    u !== void 0 && (d = "" + u), l.key !== void 0 && (d = "" + l.key), l.ref !== void 0 && (g = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (p[c] = l[c]);
    if (a && a.defaultProps) for (c in l = a.defaultProps, l) p[c] === void 0 && (p[c] = l[c]);
    return { $$typeof: t, type: a, key: d, ref: g, props: p, _owner: o.current };
  }
  return sa.Fragment = n, sa.jsx = s, sa.jsxs = s, sa;
}
var Yl = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Cw;
function YN() {
  return Cw || (Cw = 1, process.env.NODE_ENV !== "production" && function() {
    var e = Be, t = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), s = Symbol.for("react.provider"), a = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), p = Symbol.for("react.memo"), d = Symbol.for("react.lazy"), g = Symbol.for("react.offscreen"), m = Symbol.iterator, f = "@@iterator";
    function h(y) {
      if (y === null || typeof y != "object")
        return null;
      var _ = m && y[m] || y[f];
      return typeof _ == "function" ? _ : null;
    }
    var E = e.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function L(y) {
      {
        for (var _ = arguments.length, K = new Array(_ > 1 ? _ - 1 : 0), ie = 1; ie < _; ie++)
          K[ie - 1] = arguments[ie];
        x("error", y, K);
      }
    }
    function x(y, _, K) {
      {
        var ie = E.ReactDebugCurrentFrame, ve = ie.getStackAddendum();
        ve !== "" && (_ += "%s", K = K.concat([ve]));
        var we = K.map(function(fe) {
          return String(fe);
        });
        we.unshift("Warning: " + _), Function.prototype.apply.call(console[y], console, we);
      }
    }
    var T = !1, w = !1, C = !1, k = !1, O = !1, U;
    U = Symbol.for("react.module.reference");
    function M(y) {
      return !!(typeof y == "string" || typeof y == "function" || y === r || y === i || O || y === o || y === u || y === c || k || y === g || T || w || C || typeof y == "object" && y !== null && (y.$$typeof === d || y.$$typeof === p || y.$$typeof === s || y.$$typeof === a || y.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      y.$$typeof === U || y.getModuleId !== void 0));
    }
    function V(y, _, K) {
      var ie = y.displayName;
      if (ie)
        return ie;
      var ve = _.displayName || _.name || "";
      return ve !== "" ? K + "(" + ve + ")" : K;
    }
    function $(y) {
      return y.displayName || "Context";
    }
    function W(y) {
      if (y == null)
        return null;
      if (typeof y.tag == "number" && L("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof y == "function")
        return y.displayName || y.name || null;
      if (typeof y == "string")
        return y;
      switch (y) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case a:
            var _ = y;
            return $(_) + ".Consumer";
          case s:
            var K = y;
            return $(K._context) + ".Provider";
          case l:
            return V(y, y.render, "ForwardRef");
          case p:
            var ie = y.displayName || null;
            return ie !== null ? ie : W(y.type) || "Memo";
          case d: {
            var ve = y, we = ve._payload, fe = ve._init;
            try {
              return W(fe(we));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var R = Object.assign, H = 0, X, I, J, te, S, P, q;
    function j() {
    }
    j.__reactDisabledLog = !0;
    function Z() {
      {
        if (H === 0) {
          X = console.log, I = console.info, J = console.warn, te = console.error, S = console.group, P = console.groupCollapsed, q = console.groupEnd;
          var y = {
            configurable: !0,
            enumerable: !0,
            value: j,
            writable: !0
          };
          Object.defineProperties(console, {
            info: y,
            log: y,
            warn: y,
            error: y,
            group: y,
            groupCollapsed: y,
            groupEnd: y
          });
        }
        H++;
      }
    }
    function G() {
      {
        if (H--, H === 0) {
          var y = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: R({}, y, {
              value: X
            }),
            info: R({}, y, {
              value: I
            }),
            warn: R({}, y, {
              value: J
            }),
            error: R({}, y, {
              value: te
            }),
            group: R({}, y, {
              value: S
            }),
            groupCollapsed: R({}, y, {
              value: P
            }),
            groupEnd: R({}, y, {
              value: q
            })
          });
        }
        H < 0 && L("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var b = E.ReactCurrentDispatcher, F;
    function z(y, _, K) {
      {
        if (F === void 0)
          try {
            throw Error();
          } catch (ve) {
            var ie = ve.stack.trim().match(/\n( *(at )?)/);
            F = ie && ie[1] || "";
          }
        return `
` + F + y;
      }
    }
    var A = !1, Y;
    {
      var ee = typeof WeakMap == "function" ? WeakMap : Map;
      Y = new ee();
    }
    function B(y, _) {
      if (!y || A)
        return "";
      {
        var K = Y.get(y);
        if (K !== void 0)
          return K;
      }
      var ie;
      A = !0;
      var ve = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var we;
      we = b.current, b.current = null, Z();
      try {
        if (_) {
          var fe = function() {
            throw Error();
          };
          if (Object.defineProperty(fe.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(fe, []);
            } catch (je) {
              ie = je;
            }
            Reflect.construct(y, [], fe);
          } else {
            try {
              fe.call();
            } catch (je) {
              ie = je;
            }
            y.call(fe.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (je) {
            ie = je;
          }
          y();
        }
      } catch (je) {
        if (je && ie && typeof je.stack == "string") {
          for (var pe = je.stack.split(`
`), Ie = ie.stack.split(`
`), De = pe.length - 1, Se = Ie.length - 1; De >= 1 && Se >= 0 && pe[De] !== Ie[Se]; )
            Se--;
          for (; De >= 1 && Se >= 0; De--, Se--)
            if (pe[De] !== Ie[Se]) {
              if (De !== 1 || Se !== 1)
                do
                  if (De--, Se--, Se < 0 || pe[De] !== Ie[Se]) {
                    var ze = `
` + pe[De].replace(" at new ", " at ");
                    return y.displayName && ze.includes("<anonymous>") && (ze = ze.replace("<anonymous>", y.displayName)), typeof y == "function" && Y.set(y, ze), ze;
                  }
                while (De >= 1 && Se >= 0);
              break;
            }
        }
      } finally {
        A = !1, b.current = we, G(), Error.prepareStackTrace = ve;
      }
      var ct = y ? y.displayName || y.name : "", pt = ct ? z(ct) : "";
      return typeof y == "function" && Y.set(y, pt), pt;
    }
    function se(y, _, K) {
      return B(y, !1);
    }
    function ue(y) {
      var _ = y.prototype;
      return !!(_ && _.isReactComponent);
    }
    function ce(y, _, K) {
      if (y == null)
        return "";
      if (typeof y == "function")
        return B(y, ue(y));
      if (typeof y == "string")
        return z(y);
      switch (y) {
        case u:
          return z("Suspense");
        case c:
          return z("SuspenseList");
      }
      if (typeof y == "object")
        switch (y.$$typeof) {
          case l:
            return se(y.render);
          case p:
            return ce(y.type, _, K);
          case d: {
            var ie = y, ve = ie._payload, we = ie._init;
            try {
              return ce(we(ve), _, K);
            } catch {
            }
          }
        }
      return "";
    }
    var de = Object.prototype.hasOwnProperty, be = {}, ge = E.ReactDebugCurrentFrame;
    function me(y) {
      if (y) {
        var _ = y._owner, K = ce(y.type, y._source, _ ? _.type : null);
        ge.setExtraStackFrame(K);
      } else
        ge.setExtraStackFrame(null);
    }
    function ae(y, _, K, ie, ve) {
      {
        var we = Function.call.bind(de);
        for (var fe in y)
          if (we(y, fe)) {
            var pe = void 0;
            try {
              if (typeof y[fe] != "function") {
                var Ie = Error((ie || "React class") + ": " + K + " type `" + fe + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof y[fe] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Ie.name = "Invariant Violation", Ie;
              }
              pe = y[fe](_, fe, ie, K, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (De) {
              pe = De;
            }
            pe && !(pe instanceof Error) && (me(ve), L("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ie || "React class", K, fe, typeof pe), me(null)), pe instanceof Error && !(pe.message in be) && (be[pe.message] = !0, me(ve), L("Failed %s type: %s", K, pe.message), me(null));
          }
      }
    }
    var xe = Array.isArray;
    function re(y) {
      return xe(y);
    }
    function Te(y) {
      {
        var _ = typeof Symbol == "function" && Symbol.toStringTag, K = _ && y[Symbol.toStringTag] || y.constructor.name || "Object";
        return K;
      }
    }
    function ne(y) {
      try {
        return Ee(y), !1;
      } catch {
        return !0;
      }
    }
    function Ee(y) {
      return "" + y;
    }
    function Ne(y) {
      if (ne(y))
        return L("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", Te(y)), Ee(y);
    }
    var Fe = E.ReactCurrentOwner, Ue = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, he, Xe, He;
    He = {};
    function qt(y) {
      if (de.call(y, "ref")) {
        var _ = Object.getOwnPropertyDescriptor(y, "ref").get;
        if (_ && _.isReactWarning)
          return !1;
      }
      return y.ref !== void 0;
    }
    function lt(y) {
      if (de.call(y, "key")) {
        var _ = Object.getOwnPropertyDescriptor(y, "key").get;
        if (_ && _.isReactWarning)
          return !1;
      }
      return y.key !== void 0;
    }
    function mt(y, _) {
      if (typeof y.ref == "string" && Fe.current && _ && Fe.current.stateNode !== _) {
        var K = W(Fe.current.type);
        He[K] || (L('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', W(Fe.current.type), y.ref), He[K] = !0);
      }
    }
    function on(y, _) {
      {
        var K = function() {
          he || (he = !0, L("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _));
        };
        K.isReactWarning = !0, Object.defineProperty(y, "key", {
          get: K,
          configurable: !0
        });
      }
    }
    function sn(y, _) {
      {
        var K = function() {
          Xe || (Xe = !0, L("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", _));
        };
        K.isReactWarning = !0, Object.defineProperty(y, "ref", {
          get: K,
          configurable: !0
        });
      }
    }
    var an = function(y, _, K, ie, ve, we, fe) {
      var pe = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t,
        // Built-in properties that belong on the element
        type: y,
        key: _,
        ref: K,
        props: fe,
        // Record the component responsible for creating this element.
        _owner: we
      };
      return pe._store = {}, Object.defineProperty(pe._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(pe, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ie
      }), Object.defineProperty(pe, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ve
      }), Object.freeze && (Object.freeze(pe.props), Object.freeze(pe)), pe;
    };
    function ln(y, _, K, ie, ve) {
      {
        var we, fe = {}, pe = null, Ie = null;
        K !== void 0 && (Ne(K), pe = "" + K), lt(_) && (Ne(_.key), pe = "" + _.key), qt(_) && (Ie = _.ref, mt(_, ve));
        for (we in _)
          de.call(_, we) && !Ue.hasOwnProperty(we) && (fe[we] = _[we]);
        if (y && y.defaultProps) {
          var De = y.defaultProps;
          for (we in De)
            fe[we] === void 0 && (fe[we] = De[we]);
        }
        if (pe || Ie) {
          var Se = typeof y == "function" ? y.displayName || y.name || "Unknown" : y;
          pe && on(fe, Se), Ie && sn(fe, Se);
        }
        return an(y, pe, Ie, ve, ie, Fe.current, fe);
      }
    }
    var nt = E.ReactCurrentOwner, Rt = E.ReactDebugCurrentFrame;
    function ut(y) {
      if (y) {
        var _ = y._owner, K = ce(y.type, y._source, _ ? _.type : null);
        Rt.setExtraStackFrame(K);
      } else
        Rt.setExtraStackFrame(null);
    }
    var Bt;
    Bt = !1;
    function un(y) {
      return typeof y == "object" && y !== null && y.$$typeof === t;
    }
    function jn() {
      {
        if (nt.current) {
          var y = W(nt.current.type);
          if (y)
            return `

Check the render method of \`` + y + "`.";
        }
        return "";
      }
    }
    function cn(y) {
      {
        if (y !== void 0) {
          var _ = y.fileName.replace(/^.*[\\\/]/, ""), K = y.lineNumber;
          return `

Check your code at ` + _ + ":" + K + ".";
        }
        return "";
      }
    }
    var Nn = {};
    function lr(y) {
      {
        var _ = jn();
        if (!_) {
          var K = typeof y == "string" ? y : y.displayName || y.name;
          K && (_ = `

Check the top-level render call using <` + K + ">.");
        }
        return _;
      }
    }
    function zt(y, _) {
      {
        if (!y._store || y._store.validated || y.key != null)
          return;
        y._store.validated = !0;
        var K = lr(_);
        if (Nn[K])
          return;
        Nn[K] = !0;
        var ie = "";
        y && y._owner && y._owner !== nt.current && (ie = " It was passed a child from " + W(y._owner.type) + "."), ut(y), L('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', K, ie), ut(null);
      }
    }
    function Fn(y, _) {
      {
        if (typeof y != "object")
          return;
        if (re(y))
          for (var K = 0; K < y.length; K++) {
            var ie = y[K];
            un(ie) && zt(ie, _);
          }
        else if (un(y))
          y._store && (y._store.validated = !0);
        else if (y) {
          var ve = h(y);
          if (typeof ve == "function" && ve !== y.entries)
            for (var we = ve.call(y), fe; !(fe = we.next()).done; )
              un(fe.value) && zt(fe.value, _);
        }
      }
    }
    function ur(y) {
      {
        var _ = y.type;
        if (_ == null || typeof _ == "string")
          return;
        var K;
        if (typeof _ == "function")
          K = _.propTypes;
        else if (typeof _ == "object" && (_.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        _.$$typeof === p))
          K = _.propTypes;
        else
          return;
        if (K) {
          var ie = W(_);
          ae(K, y.props, "prop", ie, y);
        } else if (_.PropTypes !== void 0 && !Bt) {
          Bt = !0;
          var ve = W(_);
          L("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", ve || "Unknown");
        }
        typeof _.getDefaultProps == "function" && !_.getDefaultProps.isReactClassApproved && L("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function pn(y) {
      {
        for (var _ = Object.keys(y.props), K = 0; K < _.length; K++) {
          var ie = _[K];
          if (ie !== "children" && ie !== "key") {
            ut(y), L("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ie), ut(null);
            break;
          }
        }
        y.ref !== null && (ut(y), L("Invalid attribute `ref` supplied to `React.Fragment`."), ut(null));
      }
    }
    var Rn = {};
    function zn(y, _, K, ie, ve, we) {
      {
        var fe = M(y);
        if (!fe) {
          var pe = "";
          (y === void 0 || typeof y == "object" && y !== null && Object.keys(y).length === 0) && (pe += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Ie = cn(ve);
          Ie ? pe += Ie : pe += jn();
          var De;
          y === null ? De = "null" : re(y) ? De = "array" : y !== void 0 && y.$$typeof === t ? (De = "<" + (W(y.type) || "Unknown") + " />", pe = " Did you accidentally export a JSX literal instead of a component?") : De = typeof y, L("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", De, pe);
        }
        var Se = ln(y, _, K, ve, we);
        if (Se == null)
          return Se;
        if (fe) {
          var ze = _.children;
          if (ze !== void 0)
            if (ie)
              if (re(ze)) {
                for (var ct = 0; ct < ze.length; ct++)
                  Fn(ze[ct], y);
                Object.freeze && Object.freeze(ze);
              } else
                L("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Fn(ze, y);
        }
        if (de.call(_, "key")) {
          var pt = W(y), je = Object.keys(_).filter(function(Ui) {
            return Ui !== "key";
          }), le = je.length > 0 ? "{key: someKey, " + je.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Rn[pt + le]) {
            var zi = je.length > 0 ? "{" + je.join(": ..., ") + ": ...}" : "{}";
            L(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, le, pt, zi, pt), Rn[pt + le] = !0;
          }
        }
        return y === r ? pn(Se) : ur(Se), Se;
      }
    }
    function dn(y, _, K) {
      return zn(y, _, K, !0);
    }
    function cr(y, _, K) {
      return zn(y, _, K, !1);
    }
    var pr = cr, fn = dn;
    Yl.Fragment = r, Yl.jsx = pr, Yl.jsxs = fn;
  }()), Yl;
}
process.env.NODE_ENV === "production" ? Rh.exports = KN() : Rh.exports = YN();
var hr = Rh.exports;
Ye({});
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var zh = function(e, t) {
  return zh = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, r) {
    n.__proto__ = r;
  } || function(n, r) {
    for (var o in r) Object.prototype.hasOwnProperty.call(r, o) && (n[o] = r[o]);
  }, zh(e, t);
};
function vn(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  zh(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var Ke = function() {
  return Ke = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ke.apply(this, arguments);
};
function mm(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
function XN(e, t, n, r) {
  function o(i) {
    return i instanceof n ? i : new n(function(s) {
      s(i);
    });
  }
  return new (n || (n = Promise))(function(i, s) {
    function a(c) {
      try {
        u(r.next(c));
      } catch (p) {
        s(p);
      }
    }
    function l(c) {
      try {
        u(r.throw(c));
      } catch (p) {
        s(p);
      }
    }
    function u(c) {
      c.done ? i(c.value) : o(c.value).then(a, l);
    }
    u((r = r.apply(e, t || [])).next());
  });
}
function QN(e, t) {
  var n = { label: 0, sent: function() {
    if (i[0] & 1) throw i[1];
    return i[1];
  }, trys: [], ops: [] }, r, o, i, s;
  return s = { next: a(0), throw: a(1), return: a(2) }, typeof Symbol == "function" && (s[Symbol.iterator] = function() {
    return this;
  }), s;
  function a(u) {
    return function(c) {
      return l([u, c]);
    };
  }
  function l(u) {
    if (r) throw new TypeError("Generator is already executing.");
    for (; n; ) try {
      if (r = 1, o && (i = u[0] & 2 ? o.return : u[0] ? o.throw || ((i = o.return) && i.call(o), 0) : o.next) && !(i = i.call(o, u[1])).done) return i;
      switch (o = 0, i && (u = [u[0] & 2, i.value]), u[0]) {
        case 0:
        case 1:
          i = u;
          break;
        case 4:
          return n.label++, { value: u[1], done: !1 };
        case 5:
          n.label++, o = u[1], u = [0];
          continue;
        case 7:
          u = n.ops.pop(), n.trys.pop();
          continue;
        default:
          if (i = n.trys, !(i = i.length > 0 && i[i.length - 1]) && (u[0] === 6 || u[0] === 2)) {
            n = 0;
            continue;
          }
          if (u[0] === 3 && (!i || u[1] > i[0] && u[1] < i[3])) {
            n.label = u[1];
            break;
          }
          if (u[0] === 6 && n.label < i[1]) {
            n.label = i[1], i = u;
            break;
          }
          if (i && n.label < i[2]) {
            n.label = i[2], n.ops.push(u);
            break;
          }
          i[2] && n.ops.pop(), n.trys.pop();
          continue;
      }
      u = t.call(e, n);
    } catch (c) {
      u = [6, c], o = 0;
    } finally {
      r = i = 0;
    }
    if (u[0] & 5) throw u[1];
    return { value: u[0] ? u[1] : void 0, done: !0 };
  }
}
function NS(e) {
  return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e;
}
var JN = process.env.NODE_ENV, eF = function(e, t, n, r, o, i, s, a) {
  if (JN !== "production" && t === void 0)
    throw new Error("invariant requires an error message argument");
  if (!e) {
    var l;
    if (t === void 0)
      l = new Error(
        "Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings."
      );
    else {
      var u = [n, r, o, i, s, a], c = 0;
      l = new Error(
        t.replace(/%s/g, function() {
          return u[c++];
        })
      ), l.name = "Invariant Violation";
    }
    throw l.framesToPop = 1, l;
  }
}, tF = eF, ar = /* @__PURE__ */ NS(tF), at = Ye(null);
function nF() {
  ar(!!_e, "useGoogleMap is React hook and requires React version 16.8+");
  var e = _e(at);
  return ar(!!e, "useGoogleMap needs a GoogleMap available up in the tree"), e;
}
function rF(e, t, n) {
  return Object.keys(e).reduce(function(r, o) {
    return t(r, e[o], o);
  }, n);
}
function oF(e, t) {
  Object.keys(e).forEach(function(n) {
    return t(e[n], n);
  });
}
function iF(e, t, n, r) {
  var o = {}, i = function(s, a) {
    var l = n[a];
    l !== t[a] && (o[a] = l, s(r, l));
  };
  return oF(e, i), o;
}
function sF(e, t, n) {
  var r = rF(n, function(o, i, s) {
    return typeof e[s] == "function" && o.push(google.maps.event.addListener(t, i, e[s])), o;
  }, []);
  return r;
}
function aF(e) {
  google.maps.event.removeListener(e);
}
function Ot(e) {
  e === void 0 && (e = []), e.forEach(aF);
}
function wt(e) {
  var t = e.updaterMap, n = e.eventMap, r = e.prevProps, o = e.nextProps, i = e.instance, s = sF(o, i, n);
  return iF(t, r, o, i), s;
}
var Ew = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, xw = {
  extraMapTypes: function(e, t) {
    t.forEach(function(n, r) {
      e.mapTypes.set(String(r), n);
    });
  },
  center: function(e, t) {
    e.setCenter(t);
  },
  clickableIcons: function(e, t) {
    e.setClickableIcons(t);
  },
  heading: function(e, t) {
    e.setHeading(t);
  },
  mapTypeId: function(e, t) {
    e.setMapTypeId(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  streetView: function(e, t) {
    e.setStreetView(t);
  },
  tilt: function(e, t) {
    e.setTilt(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
function lF(e) {
  var t = e.children, n = e.options, r = e.id, o = e.mapContainerStyle, i = e.mapContainerClassName, s = e.center, a = e.onClick, l = e.onDblClick, u = e.onDrag, c = e.onDragEnd, p = e.onDragStart, d = e.onMouseMove, g = e.onMouseOut, m = e.onMouseOver, f = e.onMouseDown, h = e.onMouseUp, E = e.onRightClick, L = e.onCenterChanged, x = e.onLoad, T = e.onUnmount, w = D(null), C = w[0], k = w[1], O = rt(null), U = D(null), M = U[0], V = U[1], $ = D(null), W = $[0], R = $[1], H = D(null), X = H[0], I = H[1], J = D(null), te = J[0], S = J[1], P = D(null), q = P[0], j = P[1], Z = D(null), G = Z[0], b = Z[1], F = D(null), z = F[0], A = F[1], Y = D(null), ee = Y[0], B = Y[1], se = D(null), ue = se[0], ce = se[1], de = D(null), be = de[0], ge = de[1], me = D(null), ae = me[0], xe = me[1], re = D(null), Te = re[0], ne = re[1];
  return v(function() {
    n && C !== null && C.setOptions(n);
  }, [C, n]), v(function() {
    C !== null && typeof s < "u" && C.setCenter(s);
  }, [C, s]), v(function() {
    C && l && (W !== null && google.maps.event.removeListener(W), R(google.maps.event.addListener(C, "dblclick", l)));
  }, [l]), v(function() {
    C && c && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(C, "dragend", c)));
  }, [c]), v(function() {
    C && p && (te !== null && google.maps.event.removeListener(te), S(google.maps.event.addListener(C, "dragstart", p)));
  }, [p]), v(function() {
    C && f && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(C, "mousedown", f)));
  }, [f]), v(function() {
    C && d && (G !== null && google.maps.event.removeListener(G), b(google.maps.event.addListener(C, "mousemove", d)));
  }, [d]), v(function() {
    C && g && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(C, "mouseout", g)));
  }, [g]), v(function() {
    C && m && (ee !== null && google.maps.event.removeListener(ee), B(google.maps.event.addListener(C, "mouseover", m)));
  }, [m]), v(function() {
    C && h && (ue !== null && google.maps.event.removeListener(ue), ce(google.maps.event.addListener(C, "mouseup", h)));
  }, [h]), v(function() {
    C && E && (be !== null && google.maps.event.removeListener(be), ge(google.maps.event.addListener(C, "rightclick", E)));
  }, [E]), v(function() {
    C && a && (ae !== null && google.maps.event.removeListener(ae), xe(google.maps.event.addListener(C, "click", a)));
  }, [a]), v(function() {
    C && u && (Te !== null && google.maps.event.removeListener(Te), ne(google.maps.event.addListener(C, "drag", u)));
  }, [u]), v(function() {
    C && L && (M !== null && google.maps.event.removeListener(M), V(google.maps.event.addListener(C, "center_changed", L)));
  }, [a]), v(function() {
    var Ee = O.current === null ? null : new google.maps.Map(O.current, n);
    return k(Ee), Ee !== null && x && x(Ee), function() {
      Ee !== null && T && T(Ee);
    };
  }, []), hr.jsx("div", { id: r, ref: O, style: o, className: i, children: hr.jsx(at.Provider, { value: C, children: C !== null ? t : null }) });
}
Re(lF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      map: null
    }, n.registeredEvents = [], n.mapRef = null, n.getInstance = function() {
      return n.mapRef === null ? null : new google.maps.Map(n.mapRef, n.props.options);
    }, n.panTo = function(r) {
      var o = n.getInstance();
      o && o.panTo(r);
    }, n.setMapCallback = function() {
      n.state.map !== null && n.props.onLoad && n.props.onLoad(n.state.map);
    }, n.getRef = function(r) {
      n.mapRef = r;
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.getInstance();
    this.registeredEvents = wt({
      updaterMap: xw,
      eventMap: Ew,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        map: n
      };
    }, this.setMapCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.map !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: xw,
      eventMap: Ew,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.map
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), Ot(this.registeredEvents));
  }, t.prototype.render = function() {
    return hr.jsx("div", { id: this.props.id, ref: this.getRef, style: this.props.mapContainerStyle, className: this.props.mapContainerClassName, children: hr.jsx(at.Provider, { value: this.state.map, children: this.state.map !== null ? this.props.children : null }) });
  }, t;
})(ke);
var us = typeof document < "u";
function FS(e) {
  var t = e.url, n = e.id, r = e.nonce;
  return us ? new Promise(function(o, i) {
    var s = document.getElementById(n), a = window;
    if (s) {
      var l = s.getAttribute("data-state");
      if (s.src === t && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = a.initMap, c = s.onerror;
        a.initMap = function() {
          u && u(), o(n);
        }, s.onerror = function(d) {
          c && c(d), i(d);
        };
        return;
      } else
        s.remove();
    }
    var p = document.createElement("script");
    p.type = "text/javascript", p.src = t, p.id = n, p.async = !0, p.nonce = r || "", p.onerror = function(d) {
      p.setAttribute("data-state", "error"), i(d);
    }, a.initMap = function() {
      p.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(p);
  }).catch(function(o) {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Lw(e) {
  var t = e.href;
  return t && (t.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || t.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    e.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      e.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (e.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        e.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !e.innerHTML
      )
    )
  );
}
function RS() {
  var e = document.getElementsByTagName("head")[0];
  if (e) {
    var t = e.insertBefore.bind(e);
    e.insertBefore = function(r, o) {
      return Lw(r) || Reflect.apply(t, e, [r, o]), r;
    };
    var n = e.appendChild.bind(e);
    e.appendChild = function(r) {
      return Lw(r) || Reflect.apply(n, e, [r]), r;
    };
  }
}
function zS(e) {
  var t = e.googleMapsApiKey, n = e.googleMapsClientId, r = e.version, o = r === void 0 ? "weekly" : r, i = e.language, s = e.region, a = e.libraries, l = e.channel, u = e.mapIds, c = e.authReferrerPolicy, p = [];
  return ar(t && n || !(t && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), t ? p.push("key=".concat(t)) : n && p.push("client=".concat(n)), o && p.push("v=".concat(o)), i && p.push("language=".concat(i)), s && p.push("region=".concat(s)), a && a.length && p.push("libraries=".concat(a.sort().join(","))), l && p.push("channel=".concat(l)), u && u.length && p.push("map_ids=".concat(u.join(","))), c && p.push("auth_referrer_policy=".concat(c)), p.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(p.join("&"));
}
var aa = !1;
function US() {
  return hr.jsx("div", { children: "Loading..." });
}
var Uh = {
  id: "script-loader",
  version: "weekly"
};
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.check = xr(), n.state = {
      loaded: !1
    }, n.cleanupCallback = function() {
      delete window.google.maps, n.injectScript();
    }, n.isCleaningUp = function() {
      return XN(n, void 0, void 0, function() {
        function r(o) {
          if (!aa)
            o();
          else if (us)
            var i = window.setInterval(function() {
              aa || (window.clearInterval(i), o());
            }, 1);
        }
        return QN(this, function(o) {
          return [2, new Promise(r)];
        });
      });
    }, n.cleanup = function() {
      aa = !0;
      var r = document.getElementById(n.props.id);
      r && r.parentNode && r.parentNode.removeChild(r), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(o) {
        return typeof o.src == "string" && o.src.includes("maps.googleapis");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(o) {
        return o.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(o) {
        return o.innerText !== void 0 && o.innerText.length > 0 && o.innerText.includes(".gm-");
      }).forEach(function(o) {
        o.parentNode && o.parentNode.removeChild(o);
      });
    }, n.injectScript = function() {
      n.props.preventGoogleFontsLoading && RS(), ar(!!n.props.id, 'LoadScript requires "id" prop to be a string: %s', n.props.id);
      var r = {
        id: n.props.id,
        nonce: n.props.nonce,
        url: zS(n.props)
      };
      FS(r).then(function() {
        n.props.onLoad && n.props.onLoad(), n.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch(function(o) {
        n.props.onError && n.props.onError(o), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(n.props.googleMapsApiKey || "-", ") or Client ID (").concat(n.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (us) {
      if (window.google && window.google.maps && !aa) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.props.libraries !== n.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), us && n.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }, t.prototype.componentWillUnmount = function() {
    var n = this;
    if (us) {
      this.cleanup();
      var r = function() {
        n.check.current || (delete window.google, aa = !1);
      };
      window.setTimeout(r, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }, t.prototype.render = function() {
    return hr.jsxs(hr.Fragment, { children: [hr.jsx("div", { ref: this.check }), this.state.loaded ? this.props.children : this.props.loadingElement || hr.jsx(US, {})] });
  }, t.defaultProps = Uh, t;
})(ke);
var kw;
function uF(e) {
  var t = e.id, n = t === void 0 ? Uh.id : t, r = e.version, o = r === void 0 ? Uh.version : r, i = e.nonce, s = e.googleMapsApiKey, a = e.googleMapsClientId, l = e.language, u = e.region, c = e.libraries, p = e.preventGoogleFontsLoading, d = e.channel, g = e.mapIds, m = e.authReferrerPolicy, f = rt(!1), h = D(!1), E = h[0], L = h[1], x = D(void 0), T = x[0], w = x[1];
  v(function() {
    return f.current = !0, function() {
      f.current = !1;
    };
  }, []), v(function() {
    us && p && RS();
  }, [p]), v(function() {
    E && ar(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [E]);
  var C = zS({
    version: o,
    googleMapsApiKey: s,
    googleMapsClientId: a,
    language: l,
    region: u,
    libraries: c,
    channel: d,
    mapIds: g,
    authReferrerPolicy: m
  });
  v(function() {
    if (!us)
      return;
    function O() {
      f.current && (L(!0), kw = C);
    }
    if (window.google && window.google.maps && kw === C) {
      O();
      return;
    }
    FS({ id: n, url: C, nonce: i }).then(O).catch(function(U) {
      f.current && w(U), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(s || "-", ") or Client ID (").concat(a || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(U);
    });
  }, [n, C, i]);
  var k = rt();
  return v(function() {
    k.current && c !== k.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), k.current = c;
  }, [c]), { isLoaded: E, loadError: T, url: C };
}
var cF = hr.jsx(US, {});
function pF(e) {
  var t = e.loadingElement, n = e.onLoad, r = e.onError, o = e.onUnmount, i = e.children, s = mm(e, ["loadingElement", "onLoad", "onError", "onUnmount", "children"]), a = uF(s), l = a.isLoaded, u = a.loadError;
  return v(function() {
    l && typeof n == "function" && n();
  }, [l, n]), v(function() {
    u && typeof r == "function" && r(u);
  }, [u, r]), v(function() {
    return function() {
      o && o();
    };
  }, [o]), l ? i : t || cF;
}
Re(pF);
var Dw;
(function(e) {
  e[e.INITIALIZED = 0] = "INITIALIZED", e[e.LOADING = 1] = "LOADING", e[e.SUCCESS = 2] = "SUCCESS", e[e.FAILURE = 3] = "FAILURE";
})(Dw || (Dw = {}));
var Sw = {}, Ow = {
  options: function(e, t) {
    e.setOptions(t);
  }
};
function dF(e) {
  var t = e.options, n = e.onLoad, r = e.onUnmount, o = _e(at), i = D(null), s = i[0], a = i[1];
  return v(function() {
    s !== null && s.setMap(o);
  }, [o]), v(function() {
    t && s !== null && s.setOptions(t);
  }, [s, t]), v(function() {
    var l = new google.maps.TrafficLayer(Ke(Ke({}, t || {}), { map: o }));
    return a(l), n && n(l), function() {
      s !== null && (r && r(s), s.setMap(null));
    };
  }, []), null;
}
Re(dF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      trafficLayer: null
    }, n.setTrafficLayerCallback = function() {
      n.state.trafficLayer !== null && n.props.onLoad && n.props.onLoad(n.state.trafficLayer);
    }, n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TrafficLayer(Ke(Ke({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = wt({
      updaterMap: Ow,
      eventMap: Sw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        trafficLayer: n
      };
    }, this.setTrafficLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.trafficLayer !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: Ow,
      eventMap: Sw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Ot(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
function fF(e) {
  var t = e.onLoad, n = e.onUnmount, r = _e(at), o = D(null), i = o[0], s = o[1];
  return v(function() {
    i !== null && i.setMap(r);
  }, [r]), v(function() {
    var a = new google.maps.BicyclingLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Re(fF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      bicyclingLayer: null
    }, n.setBicyclingLayerCallback = function() {
      n.state.bicyclingLayer !== null && (n.state.bicyclingLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.bicyclingLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.BicyclingLayer();
    this.setState(function() {
      return {
        bicyclingLayer: n
      };
    }, this.setBicyclingLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
function hF(e) {
  var t = e.onLoad, n = e.onUnmount, r = _e(at), o = D(null), i = o[0], s = o[1];
  return v(function() {
    i !== null && i.setMap(r);
  }, [r]), v(function() {
    var a = new google.maps.TransitLayer();
    return s(a), a.setMap(r), t && t(a), function() {
      i !== null && (n && n(i), i.setMap(null));
    };
  }, []), null;
}
Re(hF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      transitLayer: null
    }, n.setTransitLayerCallback = function() {
      n.state.transitLayer !== null && (n.state.transitLayer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.transitLayer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: n
      };
    }, this.setTransitLayerCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
var Mw = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, Pw = {
  drawingMode: function(e, t) {
    e.setDrawingMode(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function gF(e) {
  var t = e.options, n = e.drawingMode, r = e.onCircleComplete, o = e.onMarkerComplete, i = e.onOverlayComplete, s = e.onPolygonComplete, a = e.onPolylineComplete, l = e.onRectangleComplete, u = e.onLoad, c = e.onUnmount, p = _e(at), d = D(null), g = d[0], m = d[1], f = D(null), h = f[0], E = f[1], L = D(null), x = L[0], T = L[1], w = D(null), C = w[0], k = w[1], O = D(null), U = O[0], M = O[1], V = D(null), $ = V[0], W = V[1], R = D(null), H = R[0], X = R[1];
  return v(function() {
    g !== null && g.setMap(p);
  }, [p]), v(function() {
    t && g !== null && g.setOptions(t);
  }, [g, t]), v(function() {
    g !== null && g.setDrawingMode(n ?? null);
  }, [g, n]), v(function() {
    g && r && (h !== null && google.maps.event.removeListener(h), E(google.maps.event.addListener(g, "circlecomplete", r)));
  }, [g, r]), v(function() {
    g && o && (x !== null && google.maps.event.removeListener(x), T(google.maps.event.addListener(g, "markercomplete", o)));
  }, [g, o]), v(function() {
    g && i && (C !== null && google.maps.event.removeListener(C), k(google.maps.event.addListener(g, "overlaycomplete", i)));
  }, [g, i]), v(function() {
    g && s && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(g, "polygoncomplete", s)));
  }, [g, s]), v(function() {
    g && a && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(g, "polylinecomplete", a)));
  }, [g, a]), v(function() {
    g && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(g, "rectanglecomplete", l)));
  }, [g, l]), v(function() {
    ar(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var I = new google.maps.drawing.DrawingManager(Ke(Ke({}, t || {}), { map: p }));
    return n && I.setDrawingMode(n), r && E(google.maps.event.addListener(I, "circlecomplete", r)), o && T(google.maps.event.addListener(I, "markercomplete", o)), i && k(google.maps.event.addListener(I, "overlaycomplete", i)), s && M(google.maps.event.addListener(I, "polygoncomplete", s)), a && W(google.maps.event.addListener(I, "polylinecomplete", a)), l && X(google.maps.event.addListener(I, "rectanglecomplete", l)), m(I), u && u(I), function() {
      g !== null && (h && google.maps.event.removeListener(h), x && google.maps.event.removeListener(x), C && google.maps.event.removeListener(C), U && google.maps.event.removeListener(U), $ && google.maps.event.removeListener($), H && google.maps.event.removeListener(H), c && c(g), g.setMap(null));
    };
  }, []), null;
}
Re(gF);
(function(e) {
  vn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    return r.registeredEvents = [], r.state = {
      drawingManager: null
    }, r.setDrawingManagerCallback = function() {
      r.state.drawingManager !== null && r.props.onLoad && r.props.onLoad(r.state.drawingManager);
    }, ar(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing), r;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.drawing.DrawingManager(Ke(Ke({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = wt({
      updaterMap: Pw,
      eventMap: Mw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        drawingManager: n
      };
    }, this.setDrawingManagerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.drawingManager !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: Pw,
      eventMap: Mw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Ot(this.registeredEvents), this.state.drawingManager.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
var Tw = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, Aw = {
  animation: function(e, t) {
    e.setAnimation(t);
  },
  clickable: function(e, t) {
    e.setClickable(t);
  },
  cursor: function(e, t) {
    e.setCursor(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  icon: function(e, t) {
    e.setIcon(t);
  },
  label: function(e, t) {
    e.setLabel(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  opacity: function(e, t) {
    e.setOpacity(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  shape: function(e, t) {
    e.setShape(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, bc = {};
function mF(e) {
  var t = e.position, n = e.options, r = e.clusterer, o = e.noClustererRedraw, i = e.children, s = e.draggable, a = e.visible, l = e.animation, u = e.clickable, c = e.cursor, p = e.icon, d = e.label, g = e.opacity, m = e.shape, f = e.title, h = e.zIndex, E = e.onClick, L = e.onDblClick, x = e.onDrag, T = e.onDragEnd, w = e.onDragStart, C = e.onMouseOut, k = e.onMouseOver, O = e.onMouseUp, U = e.onMouseDown, M = e.onRightClick, V = e.onClickableChanged, $ = e.onCursorChanged, W = e.onAnimationChanged, R = e.onDraggableChanged, H = e.onFlatChanged, X = e.onIconChanged, I = e.onPositionChanged, J = e.onShapeChanged, te = e.onTitleChanged, S = e.onVisibleChanged, P = e.onZindexChanged, q = e.onLoad, j = e.onUnmount, Z = _e(at), G = D(null), b = G[0], F = G[1], z = D(null), A = z[0], Y = z[1], ee = D(null), B = ee[0], se = ee[1], ue = D(null), ce = ue[0], de = ue[1], be = D(null), ge = be[0], me = be[1], ae = D(null), xe = ae[0], re = ae[1], Te = D(null), ne = Te[0], Ee = Te[1], Ne = D(null), Fe = Ne[0], Ue = Ne[1], he = D(null), Xe = he[0], He = he[1], qt = D(null), lt = qt[0], mt = qt[1], on = D(null), sn = on[0], an = on[1], ln = D(null), nt = ln[0], Rt = ln[1], ut = D(null), Bt = ut[0], un = ut[1], jn = D(null), cn = jn[0], Nn = jn[1], lr = D(null), zt = lr[0], Fn = lr[1], ur = D(null), pn = ur[0], Rn = ur[1], zn = D(null), dn = zn[0], cr = zn[1], pr = D(null), fn = pr[0], y = pr[1], _ = D(null), K = _[0], ie = _[1], ve = D(null), we = ve[0], fe = ve[1], pe = D(null), Ie = pe[0], De = pe[1], Se = D(null), ze = Se[0], ct = Se[1];
  v(function() {
    b !== null && b.setMap(Z);
  }, [Z]), v(function() {
    typeof n < "u" && b !== null && b.setOptions(n);
  }, [b, n]), v(function() {
    typeof s < "u" && b !== null && b.setDraggable(s);
  }, [b, s]), v(function() {
    t && b !== null && b.setPosition(t);
  }, [b, t]), v(function() {
    typeof a < "u" && b !== null && b.setVisible(a);
  }, [b, a]), v(function() {
    b == null || b.setAnimation(l);
  }, [b, l]), v(function() {
    b && u !== void 0 && b.setClickable(u);
  }, [b, u]), v(function() {
    b && c !== void 0 && b.setCursor(c);
  }, [b, c]), v(function() {
    b && p !== void 0 && b.setIcon(p);
  }, [b, p]), v(function() {
    b && d !== void 0 && b.setLabel(d);
  }, [b, d]), v(function() {
    b && g !== void 0 && b.setOpacity(g);
  }, [b, g]), v(function() {
    b && m !== void 0 && b.setShape(m);
  }, [b, m]), v(function() {
    b && f !== void 0 && b.setTitle(f);
  }, [b, f]), v(function() {
    b && h !== void 0 && b.setZIndex(h);
  }, [b, h]), v(function() {
    b && L && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(b, "dblclick", L)));
  }, [L]), v(function() {
    b && T && (B !== null && google.maps.event.removeListener(B), se(google.maps.event.addListener(b, "dragend", T)));
  }, [T]), v(function() {
    b && w && (ce !== null && google.maps.event.removeListener(ce), de(google.maps.event.addListener(b, "dragstart", w)));
  }, [w]), v(function() {
    b && U && (ge !== null && google.maps.event.removeListener(ge), me(google.maps.event.addListener(b, "mousedown", U)));
  }, [U]), v(function() {
    b && C && (xe !== null && google.maps.event.removeListener(xe), re(google.maps.event.addListener(b, "mouseout", C)));
  }, [C]), v(function() {
    b && k && (ne !== null && google.maps.event.removeListener(ne), Ee(google.maps.event.addListener(b, "mouseover", k)));
  }, [k]), v(function() {
    b && O && (Fe !== null && google.maps.event.removeListener(Fe), Ue(google.maps.event.addListener(b, "mouseup", O)));
  }, [O]), v(function() {
    b && M && (Xe !== null && google.maps.event.removeListener(Xe), He(google.maps.event.addListener(b, "rightclick", M)));
  }, [M]), v(function() {
    b && E && (lt !== null && google.maps.event.removeListener(lt), mt(google.maps.event.addListener(b, "click", E)));
  }, [E]), v(function() {
    b && x && (sn !== null && google.maps.event.removeListener(sn), an(google.maps.event.addListener(b, "drag", x)));
  }, [x]), v(function() {
    b && V && (nt !== null && google.maps.event.removeListener(nt), Rt(google.maps.event.addListener(b, "clickable_changed", V)));
  }, [V]), v(function() {
    b && $ && (Bt !== null && google.maps.event.removeListener(Bt), un(google.maps.event.addListener(b, "cursor_changed", $)));
  }, [$]), v(function() {
    b && W && (cn !== null && google.maps.event.removeListener(cn), Nn(google.maps.event.addListener(b, "animation_changed", W)));
  }, [W]), v(function() {
    b && R && (zt !== null && google.maps.event.removeListener(zt), Fn(google.maps.event.addListener(b, "draggable_changed", R)));
  }, [R]), v(function() {
    b && H && (pn !== null && google.maps.event.removeListener(pn), Rn(google.maps.event.addListener(b, "flat_changed", H)));
  }, [H]), v(function() {
    b && X && (dn !== null && google.maps.event.removeListener(dn), cr(google.maps.event.addListener(b, "icon_changed", X)));
  }, [X]), v(function() {
    b && I && (fn !== null && google.maps.event.removeListener(fn), y(google.maps.event.addListener(b, "position_changed", I)));
  }, [I]), v(function() {
    b && J && (K !== null && google.maps.event.removeListener(K), ie(google.maps.event.addListener(b, "shape_changed", J)));
  }, [J]), v(function() {
    b && te && (we !== null && google.maps.event.removeListener(we), fe(google.maps.event.addListener(b, "title_changed", te)));
  }, [te]), v(function() {
    b && S && (Ie !== null && google.maps.event.removeListener(Ie), De(google.maps.event.addListener(b, "visible_changed", S)));
  }, [S]), v(function() {
    b && P && (ze !== null && google.maps.event.removeListener(ze), ct(google.maps.event.addListener(b, "zindex_changed", P)));
  }, [P]), v(function() {
    var je = Ke(Ke(Ke({}, n || bc), r ? bc : { map: Z }), { position: t }), le = new google.maps.Marker(je);
    return r ? r.addMarker(le, !!o) : le.setMap(Z), t && le.setPosition(t), typeof a < "u" && le.setVisible(a), typeof s < "u" && le.setDraggable(s), typeof u < "u" && le.setClickable(u), typeof c == "string" && le.setCursor(c), p && le.setIcon(p), typeof d < "u" && le.setLabel(d), typeof g < "u" && le.setOpacity(g), m && le.setShape(m), typeof f == "string" && le.setTitle(f), typeof h == "number" && le.setZIndex(h), L && Y(google.maps.event.addListener(le, "dblclick", L)), T && se(google.maps.event.addListener(le, "dragend", T)), w && de(google.maps.event.addListener(le, "dragstart", w)), U && me(google.maps.event.addListener(le, "mousedown", U)), C && re(google.maps.event.addListener(le, "mouseout", C)), k && Ee(google.maps.event.addListener(le, "mouseover", k)), O && Ue(google.maps.event.addListener(le, "mouseup", O)), M && He(google.maps.event.addListener(le, "rightclick", M)), E && mt(google.maps.event.addListener(le, "click", E)), x && an(google.maps.event.addListener(le, "drag", x)), V && Rt(google.maps.event.addListener(le, "clickable_changed", V)), $ && un(google.maps.event.addListener(le, "cursor_changed", $)), W && Nn(google.maps.event.addListener(le, "animation_changed", W)), R && Fn(google.maps.event.addListener(le, "draggable_changed", R)), H && Rn(google.maps.event.addListener(le, "flat_changed", H)), X && cr(google.maps.event.addListener(le, "icon_changed", X)), I && y(google.maps.event.addListener(le, "position_changed", I)), J && ie(google.maps.event.addListener(le, "shape_changed", J)), te && fe(google.maps.event.addListener(le, "title_changed", te)), S && De(google.maps.event.addListener(le, "visible_changed", S)), P && ct(google.maps.event.addListener(le, "zindex_changed", P)), F(le), q && q(le), function() {
      A !== null && google.maps.event.removeListener(A), B !== null && google.maps.event.removeListener(B), ce !== null && google.maps.event.removeListener(ce), ge !== null && google.maps.event.removeListener(ge), xe !== null && google.maps.event.removeListener(xe), ne !== null && google.maps.event.removeListener(ne), Fe !== null && google.maps.event.removeListener(Fe), Xe !== null && google.maps.event.removeListener(Xe), lt !== null && google.maps.event.removeListener(lt), nt !== null && google.maps.event.removeListener(nt), Bt !== null && google.maps.event.removeListener(Bt), cn !== null && google.maps.event.removeListener(cn), zt !== null && google.maps.event.removeListener(zt), pn !== null && google.maps.event.removeListener(pn), dn !== null && google.maps.event.removeListener(dn), fn !== null && google.maps.event.removeListener(fn), we !== null && google.maps.event.removeListener(we), Ie !== null && google.maps.event.removeListener(Ie), ze !== null && google.maps.event.removeListener(ze), j && j(le), r ? r.removeMarker(le, !!o) : le && le.setMap(null);
    };
  }, []);
  var pt = rr(function() {
    return i ? Mt.map(i, function(je) {
      if (!Li(je))
        return je;
      var le = je;
      return ki(le, { anchor: b });
    }) : null;
  }, [i, b]);
  return hr.jsx(hr.Fragment, { children: pt }) || null;
}
Re(mF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n;
  }
  return t.prototype.componentDidMount = function() {
    var n = Ke(Ke(Ke({}, this.props.options || bc), this.props.clusterer ? bc : { map: this.context }), { position: this.props.position });
    this.marker = new google.maps.Marker(n), this.props.clusterer ? this.props.clusterer.addMarker(this.marker, !!this.props.noClustererRedraw) : this.marker.setMap(this.context), this.registeredEvents = wt({
      updaterMap: Aw,
      eventMap: Tw,
      prevProps: {},
      nextProps: this.props,
      instance: this.marker
    }), this.props.onLoad && this.props.onLoad(this.marker);
  }, t.prototype.componentDidUpdate = function(n) {
    this.marker && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: Aw,
      eventMap: Tw,
      prevProps: n,
      nextProps: this.props,
      instance: this.marker
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Ot(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }, t.prototype.render = function() {
    var n = this, r = null;
    return this.props.children && (r = Mt.map(this.props.children, function(o) {
      if (!Li(o))
        return o;
      var i = o;
      return ki(i, { anchor: n.marker });
    })), r || null;
  }, t.contextType = at, t;
})(ke);
var vF = (
  /** @class */
  function() {
    function e(t, n) {
      t.getClusterer().extend(e, google.maps.OverlayView), this.cluster = t, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(t.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return e.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, e.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, e.prototype.onClick = function(t) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var s = n.getMap();
            if (s !== null) {
              "fitBounds" in s && s.fitBounds(o);
              var a = s.getZoom() || 0;
              r !== null && a > r && s.setZoom(r + 1);
            }
          }, 100);
        }
        t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
      }
    }, e.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, e.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, e.prototype.onAdd = function() {
      var t;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (t = this.getPanes()) === null || t === void 0 || t.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, e.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var t = this.getPosFromLatLng(this.center);
        this.div.style.top = t !== null ? "".concat(t.y, "px") : "0", this.div.style.left = t !== null ? "".concat(t.x, "px") : "0";
      }
    }, e.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, e.prototype.show = function() {
      var t, n, r, o, i, s;
      if (this.div && this.center) {
        var a = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((t = l[0]) === null || t === void 0 ? void 0 : t.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), p = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(p !== null ? "".concat(p.y, "px") : "0", "; left: ").concat(p !== null ? "".concat(p.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var d = document.createElement("img");
        d.alt = a, d.src = this.url, d.width = this.width, d.height = this.height, d.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (d.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var g = document.createElement("div");
        g.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (g.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (g.innerHTML = "".concat((s = this.sums) === null || s === void 0 ? void 0 : s.html)), this.div.innerHTML = "", this.div.appendChild(d), this.div.appendChild(g), this.div.title = a, this.div.style.display = "";
      }
      this.visible = !0;
    }, e.prototype.useStyle = function(t) {
      this.sums = t;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, t.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, e.prototype.setCenter = function(t) {
      this.center = t;
    }, e.prototype.getPosFromLatLng = function(t) {
      var n = this.getProjection().fromLatLngToDivPixel(t);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, e;
  }()
), yF = (
  /** @class */
  function() {
    function e(t) {
      this.markerClusterer = t, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new vF(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return e.prototype.getSize = function() {
      return this.markers.length;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getCenter = function() {
      return this.center;
    }, e.prototype.getMap = function() {
      return this.map;
    }, e.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, e.prototype.getBounds = function() {
      for (var t = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && t.extend(s);
      }
      return t;
    }, e.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, e.prototype.addMarker = function(t) {
      var n;
      if (this.isMarkerAlreadyAdded(t))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = t.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = t.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      t.isAdded = !0, this.markers.push(t);
      var i = this.markers.length, s = this.markerClusterer.getMaxZoom(), a = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (s !== null && typeof a < "u" && a > s)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i < this.minClusterSize)
        t.getMap() !== this.map && t.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        t.setMap(null);
      return !0;
    }, e.prototype.isMarkerInClusterBounds = function(t) {
      if (this.bounds !== null) {
        var n = t.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, e.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, e.prototype.updateIcon = function() {
      var t, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (t = this.map) === null || t === void 0 ? void 0 : t.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, e.prototype.isMarkerAlreadyAdded = function(t) {
      if (this.markers.includes)
        return this.markers.includes(t);
      for (var n = 0; n < this.markers.length; n++)
        if (t === this.markers[n])
          return !0;
      return !1;
    }, e;
  }()
);
function bF(e, t) {
  var n = e.length, r = n.toString().length, o = Math.min(r, t);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var wF = 2e3, CF = 500, EF = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", xF = "png", LF = [53, 56, 66, 78, 90], kF = "cluster", $S = (
  /** @class */
  function() {
    function e(t, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(e, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || EF, this.imageExtension = r.imageExtension || xF, this.imageSizes = r.imageSizes || LF, this.calculator = r.calculator || bF, this.batchSize = r.batchSize || wF, this.batchSizeIE = r.batchSizeIE || CF, this.clusterClass = r.clusterClass || kF, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(t);
    }
    return e.prototype.onZoomChanged = function() {
      var t, n;
      this.resetViewport(!1), (((t = this.getMap()) === null || t === void 0 ? void 0 : t.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, e.prototype.onIdle = function() {
      this.redraw();
    }, e.prototype.onAdd = function() {
      var t = this.getMap();
      this.activeMap = t, this.ready = !0, this.repaint(), t !== null && (this.listeners = [
        google.maps.event.addListener(t, "zoom_changed", this.onZoomChanged),
        google.maps.event.addListener(t, "idle", this.onIdle)
      ]);
    }, e.prototype.onRemove = function() {
      for (var t = 0, n = this.markers; t < n.length; t++) {
        var r = n[t];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var s = i[o];
        s.remove();
      }
      this.clusters = [];
      for (var a = 0, l = this.listeners; a < l.length; a++) {
        var u = l[a];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, e.prototype.draw = function() {
    }, e.prototype.getMap = function() {
      return null;
    }, e.prototype.getPanes = function() {
      return null;
    }, e.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, e.prototype.setMap = function() {
    }, e.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, e.prototype.bindTo = function() {
    }, e.prototype.get = function() {
    }, e.prototype.notify = function() {
    }, e.prototype.set = function() {
    }, e.prototype.setValues = function() {
    }, e.prototype.unbind = function() {
    }, e.prototype.unbindAll = function() {
    }, e.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var t = 0; t < this.imageSizes.length; t++)
          this.styles.push({
            url: "".concat(this.imagePath + (t + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[t] || 0,
            width: this.imageSizes[t] || 0
          });
    }, e.prototype.fitMapToMarkers = function() {
      for (var t = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = t; r < o.length; r++) {
        var i = o[r], s = i.getPosition();
        s && n.extend(s);
      }
      var a = this.getMap();
      a !== null && "fitBounds" in a && a.fitBounds(n);
    }, e.prototype.getGridSize = function() {
      return this.gridSize;
    }, e.prototype.setGridSize = function(t) {
      this.gridSize = t;
    }, e.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, e.prototype.setMinimumClusterSize = function(t) {
      this.minClusterSize = t;
    }, e.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, e.prototype.setMaxZoom = function(t) {
      this.maxZoom = t;
    }, e.prototype.getStyles = function() {
      return this.styles;
    }, e.prototype.setStyles = function(t) {
      this.styles = t;
    }, e.prototype.getTitle = function() {
      return this.title;
    }, e.prototype.setTitle = function(t) {
      this.title = t;
    }, e.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, e.prototype.setZoomOnClick = function(t) {
      this.zoomOnClick = t;
    }, e.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, e.prototype.setAverageCenter = function(t) {
      this.averageCenter = t;
    }, e.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, e.prototype.setIgnoreHidden = function(t) {
      this.ignoreHidden = t;
    }, e.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, e.prototype.setEnableRetinaIcons = function(t) {
      this.enableRetinaIcons = t;
    }, e.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, e.prototype.setImageExtension = function(t) {
      this.imageExtension = t;
    }, e.prototype.getImagePath = function() {
      return this.imagePath;
    }, e.prototype.setImagePath = function(t) {
      this.imagePath = t;
    }, e.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, e.prototype.setImageSizes = function(t) {
      this.imageSizes = t;
    }, e.prototype.getCalculator = function() {
      return this.calculator;
    }, e.prototype.setCalculator = function(t) {
      this.calculator = t;
    }, e.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, e.prototype.setBatchSizeIE = function(t) {
      this.batchSizeIE = t;
    }, e.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, e.prototype.setClusterClass = function(t) {
      this.clusterClass = t;
    }, e.prototype.getMarkers = function() {
      return this.markers;
    }, e.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, e.prototype.getClusters = function() {
      return this.clusters;
    }, e.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, e.prototype.addMarker = function(t, n) {
      this.pushMarkerTo(t), n || this.redraw();
    }, e.prototype.addMarkers = function(t, n) {
      for (var r in t)
        if (Object.prototype.hasOwnProperty.call(t, r)) {
          var o = t[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, e.prototype.pushMarkerTo = function(t) {
      var n = this;
      t.getDraggable() && google.maps.event.addListener(t, "dragend", function() {
        n.ready && (t.isAdded = !1, n.repaint());
      }), t.isAdded = !1, this.markers.push(t);
    }, e.prototype.removeMarker_ = function(t) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(t);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (t === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (t.setMap(null), this.markers.splice(n, 1), !0);
    }, e.prototype.removeMarker = function(t, n) {
      var r = this.removeMarker_(t);
      return !n && r && this.repaint(), r;
    }, e.prototype.removeMarkers = function(t, n) {
      for (var r = !1, o = 0, i = t; o < i.length; o++) {
        var s = i[o];
        r = r || this.removeMarker_(s);
      }
      return !n && r && this.repaint(), r;
    }, e.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, e.prototype.repaint = function() {
      var t = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = t; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, e.prototype.getExtendedBounds = function(t) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getNorthEast().lat(), t.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(t.getSouthWest().lat(), t.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && t.extend(i);
      }
      if (o !== null) {
        var s = n.fromDivPixelToLatLng(o);
        s !== null && t.extend(s);
      }
      return t;
    }, e.prototype.redraw = function() {
      this.createClusters(0);
    }, e.prototype.resetViewport = function(t) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, s = this.markers; i < s.length; i++) {
        var a = s[i];
        a.isAdded = !1, t && a.setMap(null);
      }
    }, e.prototype.distanceBetweenPoints = function(t, n) {
      var r = 6371, o = (n.lat() - t.lat()) * Math.PI / 180, i = (n.lng() - t.lng()) * Math.PI / 180, s = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(t.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(s), Math.sqrt(1 - s)));
    }, e.prototype.isMarkerInBounds = function(t, n) {
      var r = t.getPosition();
      return r ? n.contains(r) : !1;
    }, e.prototype.addToClosestCluster = function(t) {
      for (var n, r = 4e4, o = null, i = 0, s = this.clusters; i < s.length; i++) {
        var a = s[i];
        n = a;
        var l = n.getCenter(), u = t.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(t) ? o.addMarker(t) : (n = new yF(this), n.addMarker(t), this.clusters.push(n));
    }, e.prototype.createClusters = function(t) {
      var n = this;
      if (this.ready) {
        t === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, s = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), a = this.getExtendedBounds(s), l = Math.min(t + this.batchSize, this.markers.length), u = t; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, a) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var p = 0, d = this.clusters; p < d.length; p++) {
            var g = d[p];
            g.updateIcon();
          }
        }
      }
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), ao = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Nt = {
  averageCenter: function(e, t) {
    e.setAverageCenter(t);
  },
  batchSizeIE: function(e, t) {
    e.setBatchSizeIE(t);
  },
  calculator: function(e, t) {
    e.setCalculator(t);
  },
  clusterClass: function(e, t) {
    e.setClusterClass(t);
  },
  enableRetinaIcons: function(e, t) {
    e.setEnableRetinaIcons(t);
  },
  gridSize: function(e, t) {
    e.setGridSize(t);
  },
  ignoreHidden: function(e, t) {
    e.setIgnoreHidden(t);
  },
  imageExtension: function(e, t) {
    e.setImageExtension(t);
  },
  imagePath: function(e, t) {
    e.setImagePath(t);
  },
  imageSizes: function(e, t) {
    e.setImageSizes(t);
  },
  maxZoom: function(e, t) {
    e.setMaxZoom(t);
  },
  minimumClusterSize: function(e, t) {
    e.setMinimumClusterSize(t);
  },
  styles: function(e, t) {
    e.setStyles(t);
  },
  title: function(e, t) {
    e.setTitle(t);
  },
  zoomOnClick: function(e, t) {
    e.setZoomOnClick(t);
  }
}, DF = {};
function SF(e) {
  var t = e.children, n = e.options, r = e.averageCenter, o = e.batchSizeIE, i = e.calculator, s = e.clusterClass, a = e.enableRetinaIcons, l = e.gridSize, u = e.ignoreHidden, c = e.imageExtension, p = e.imagePath, d = e.imageSizes, g = e.maxZoom, m = e.minimumClusterSize, f = e.styles, h = e.title, E = e.zoomOnClick, L = e.onClick, x = e.onClusteringBegin, T = e.onClusteringEnd, w = e.onMouseOver, C = e.onMouseOut, k = e.onLoad, O = e.onUnmount, U = D(null), M = U[0], V = U[1], $ = _e(at), W = D(null), R = W[0], H = W[1], X = D(null), I = X[0], J = X[1], te = D(null), S = te[0], P = te[1], q = D(null), j = q[0], Z = q[1], G = D(null), b = G[0], F = G[1];
  return v(function() {
    M && C && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(M, ao.onMouseOut, C)));
  }, [C]), v(function() {
    M && w && (b !== null && google.maps.event.removeListener(b), F(google.maps.event.addListener(M, ao.onMouseOver, w)));
  }, [w]), v(function() {
    M && L && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(M, ao.onClick, L)));
  }, [L]), v(function() {
    M && x && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(M, ao.onClusteringBegin, x)));
  }, [x]), v(function() {
    M && T && (S !== null && google.maps.event.removeListener(S), J(google.maps.event.addListener(M, ao.onClusteringEnd, T)));
  }, [T]), v(function() {
    typeof r < "u" && M !== null && Nt.averageCenter(M, r);
  }, [M, r]), v(function() {
    typeof o < "u" && M !== null && Nt.batchSizeIE(M, o);
  }, [M, o]), v(function() {
    typeof i < "u" && M !== null && Nt.calculator(M, i);
  }, [M, i]), v(function() {
    typeof s < "u" && M !== null && Nt.clusterClass(M, s);
  }, [M, s]), v(function() {
    typeof a < "u" && M !== null && Nt.enableRetinaIcons(M, a);
  }, [M, a]), v(function() {
    typeof l < "u" && M !== null && Nt.gridSize(M, l);
  }, [M, l]), v(function() {
    typeof u < "u" && M !== null && Nt.ignoreHidden(M, u);
  }, [M, u]), v(function() {
    typeof c < "u" && M !== null && Nt.imageExtension(M, c);
  }, [M, c]), v(function() {
    typeof p < "u" && M !== null && Nt.imagePath(M, p);
  }, [M, p]), v(function() {
    typeof d < "u" && M !== null && Nt.imageSizes(M, d);
  }, [M, d]), v(function() {
    typeof g < "u" && M !== null && Nt.maxZoom(M, g);
  }, [M, g]), v(function() {
    typeof m < "u" && M !== null && Nt.minimumClusterSize(M, m);
  }, [M, m]), v(function() {
    typeof f < "u" && M !== null && Nt.styles(M, f);
  }, [M, f]), v(function() {
    typeof h < "u" && M !== null && Nt.title(M, h);
  }, [M, h]), v(function() {
    typeof E < "u" && M !== null && Nt.zoomOnClick(M, E);
  }, [M, E]), v(function() {
    if ($) {
      var z = Ke({}, n || DF), A = new $S($, [], z);
      return r && Nt.averageCenter(A, r), o && Nt.batchSizeIE(A, o), i && Nt.calculator(A, i), s && Nt.clusterClass(A, s), a && Nt.enableRetinaIcons(A, a), l && Nt.gridSize(A, l), u && Nt.ignoreHidden(A, u), c && Nt.imageExtension(A, c), p && Nt.imagePath(A, p), d && Nt.imageSizes(A, d), g && Nt.maxZoom(A, g), m && Nt.minimumClusterSize(A, m), f && Nt.styles(A, f), h && Nt.title(A, h), E && Nt.zoomOnClick(A, E), C && Z(google.maps.event.addListener(A, ao.onMouseOut, C)), w && F(google.maps.event.addListener(A, ao.onMouseOver, w)), L && H(google.maps.event.addListener(A, ao.onClick, L)), x && J(google.maps.event.addListener(A, ao.onClusteringBegin, x)), T && P(google.maps.event.addListener(A, ao.onClusteringEnd, T)), V(A), k && k(A), function() {
        j !== null && google.maps.event.removeListener(j), b !== null && google.maps.event.removeListener(b), R !== null && google.maps.event.removeListener(R), I !== null && google.maps.event.removeListener(I), S !== null && google.maps.event.removeListener(S), O && O(A);
      };
    }
  }, []), M !== null && t(M) || null;
}
Re(SF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      markerClusterer: null
    }, n.setClustererCallback = function() {
      n.state.markerClusterer !== null && n.props.onLoad && n.props.onLoad(n.state.markerClusterer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context) {
      var n = new $S(this.context, [], this.props.options);
      this.registeredEvents = wt({
        updaterMap: Nt,
        eventMap: ao,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          markerClusterer: n
        };
      }, this.setClustererCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.markerClusterer && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: Nt,
      eventMap: ao,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Ot(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }, t.prototype.render = function() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }, t.contextType = at, t;
})(ke);
function Bw(e) {
  e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
}
var WS = (
  /** @class */
  function() {
    function e(t) {
      t === void 0 && (t = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(e, google.maps.OverlayView), this.content = t.content || "", this.disableAutoPan = t.disableAutoPan || !1, this.maxWidth = t.maxWidth || 0, this.pixelOffset = t.pixelOffset || new google.maps.Size(0, 0), this.position = t.position || new google.maps.LatLng(0, 0), this.zIndex = t.zIndex || null, this.boxClass = t.boxClass || "infoBox", this.boxStyle = t.boxStyle || {}, this.closeBoxMargin = t.closeBoxMargin || "2px", this.closeBoxURL = t.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", t.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = t.infoBoxClearance || new google.maps.Size(1, 1), typeof t.visible > "u" && (typeof t.isHidden > "u" ? t.visible = !0 : t.visible = !t.isHidden), this.isHidden = !t.visible, this.alignBottom = t.alignBottom || !1, this.pane = t.pane || "floatPane", this.enableEventPropagation = t.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return e.prototype.createInfoBoxDiv = function() {
      var t = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), t.enableEventPropagation || Bw(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = [
            "mousedown",
            "mouseover",
            "mouseout",
            "mouseup",
            "click",
            "dblclick",
            "touchstart",
            "touchend",
            "touchmove"
          ], s = 0, a = i; s < a.length; s++) {
            var l = a[s];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, Bw));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            t.div && (t.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, e.prototype.getCloseBoxImg = function() {
      var t = "";
      return this.closeBoxURL !== "" && (t = '<img alt=""', t += ' aria-hidden="true"', t += " src='" + this.closeBoxURL + "'", t += " align=right", t += " style='", t += " position: relative;", t += " cursor: pointer;", t += " margin: " + this.closeBoxMargin + ";", t += "'>"), t;
    }, e.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, e.prototype.closeClickHandler = function(t) {
      t.cancelBubble = !0, t.stopPropagation && t.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, e.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, e.prototype.panBox = function(t) {
      if (this.div && !t) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var s = n.getDiv(), a = s.offsetWidth, l = s.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, p = this.div.offsetWidth, d = this.div.offsetHeight, g = this.infoBoxClearance.width, m = this.infoBoxClearance.height, f = this.getProjection(), h = f.fromLatLngToContainerPixel(this.position);
          h !== null && (h.x < -u + g ? r = h.x + u - g : h.x + p + u + g > a && (r = h.x + p + u + g - a), this.alignBottom ? h.y < -c + m + d ? o = h.y + c - m - d : h.y + c + m > l && (o = h.y + c + m - l) : h.y < -c + m ? o = h.y + c - m : h.y + d + c + m > l && (o = h.y + d + c + m - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, e.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var t = this.boxStyle;
        for (var n in t)
          Object.prototype.hasOwnProperty.call(t, n) && (this.div.style[n] = t[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, e.prototype.getBoxWidths = function() {
      var t = { top: 0, bottom: 0, left: 0, right: 0 };
      if (!this.div)
        return t;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (t.top = parseInt(r.borderTopWidth || "", 10) || 0, t.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, t.left = parseInt(r.borderLeftWidth || "", 10) || 0, t.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (t.top = parseInt(o.borderTopWidth || "", 10) || 0, t.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, t.left = parseInt(o.borderLeftWidth || "", 10) || 0, t.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return t;
    }, e.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, e.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var t = this.getProjection(), n = t.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, e.prototype.setOptions = function(t) {
      t === void 0 && (t = {}), typeof t.boxClass < "u" && (this.boxClass = t.boxClass, this.setBoxStyle()), typeof t.boxStyle < "u" && (this.boxStyle = t.boxStyle, this.setBoxStyle()), typeof t.content < "u" && this.setContent(t.content), typeof t.disableAutoPan < "u" && (this.disableAutoPan = t.disableAutoPan), typeof t.maxWidth < "u" && (this.maxWidth = t.maxWidth), typeof t.pixelOffset < "u" && (this.pixelOffset = t.pixelOffset), typeof t.alignBottom < "u" && (this.alignBottom = t.alignBottom), typeof t.position < "u" && this.setPosition(t.position), typeof t.zIndex < "u" && this.setZIndex(t.zIndex), typeof t.closeBoxMargin < "u" && (this.closeBoxMargin = t.closeBoxMargin), typeof t.closeBoxURL < "u" && (this.closeBoxURL = t.closeBoxURL), typeof t.infoBoxClearance < "u" && (this.infoBoxClearance = t.infoBoxClearance), typeof t.isHidden < "u" && (this.isHidden = t.isHidden), typeof t.visible < "u" && (this.isHidden = !t.visible), typeof t.enableEventPropagation < "u" && (this.enableEventPropagation = t.enableEventPropagation), this.div && this.draw();
    }, e.prototype.setContent = function(t) {
      this.content = t, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof t == "string" ? this.div.innerHTML = this.getCloseBoxImg() + t : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(t))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, e.prototype.setPosition = function(t) {
      this.position = t, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, e.prototype.setVisible = function(t) {
      this.isHidden = !t, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, e.prototype.setZIndex = function(t) {
      this.zIndex = t, this.div && (this.div.style.zIndex = t + ""), google.maps.event.trigger(this, "zindex_changed");
    }, e.prototype.getContent = function() {
      return this.content;
    }, e.prototype.getPosition = function() {
      return this.position;
    }, e.prototype.getZIndex = function() {
      return this.zIndex;
    }, e.prototype.getVisible = function() {
      var t = this.getMap();
      return typeof t > "u" || t === null ? !1 : !this.isHidden;
    }, e.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, e.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, e.prototype.open = function(t, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(t), this.div && this.panBox();
    }, e.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var t = 0, n = this.eventListeners; t < n.length; t++) {
          var r = n[t];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, e.prototype.extend = function(t, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(t, [n]);
    }, e;
  }()
), _w = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Iw = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    t instanceof google.maps.LatLng ? e.setPosition(t) : e.setPosition(new google.maps.LatLng(t.lat, t.lng));
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
}, OF = {};
function MF(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, g = _e(at), m = D(null), f = m[0], h = m[1], E = D(null), L = E[0], x = E[1], T = D(null), w = T[0], C = T[1], k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = rt(null);
  return v(function() {
    g && f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(function() {
    if (o && f !== null) {
      var I = o instanceof google.maps.LatLng ? o : new google.maps.LatLng(o.lat, o.lng);
      f.setPosition(I);
    }
  }, [o]), v(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(function() {
    f && a && (w !== null && google.maps.event.removeListener(w), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(function() {
    f && l && (O !== null && google.maps.event.removeListener(O), U(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(function() {
    f && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(function() {
    f && c && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(function() {
    if (g) {
      var I = r || OF, J = I.position, te = mm(I, ["position"]), S = void 0;
      J && !(J instanceof google.maps.LatLng) && (S = new google.maps.LatLng(J.lat, J.lng));
      var P = new WS(Ke(Ke({}, te), S ? { position: S } : {}));
      X.current = document.createElement("div"), h(P), s && x(google.maps.event.addListener(P, "closeclick", s)), a && C(google.maps.event.addListener(P, "domready", a)), l && U(google.maps.event.addListener(P, "content_changed", l)), u && $(google.maps.event.addListener(P, "position_changed", u)), c && H(google.maps.event.addListener(P, "zindex_changed", c)), P.setContent(X.current), n ? P.open(g, n) : P.getPosition() ? P.open(g) : ar(!1, "You must provide either an anchor or a position prop for <InfoBox>."), p && p(P);
    }
    return function() {
      f !== null && (L && google.maps.event.removeListener(L), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), V && google.maps.event.removeListener(V), R && google.maps.event.removeListener(R), d && d(f), f.close());
    };
  }, []), X.current ? Lr(Mt.only(t), X.current) : null;
}
Re(MF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoBox: null
    }, n.open = function(r, o) {
      o ? n.context !== null && r.open(n.context, o) : r.getPosition() ? n.context !== null && r.open(n.context) : ar(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }, n.setInfoBoxCallback = function() {
      n.state.infoBox !== null && n.containerElement !== null && (n.state.infoBox.setContent(n.containerElement), n.open(n.state.infoBox, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoBox));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = this.props.options || {}, r = n.position, o = mm(n, ["position"]), i;
    r && !(r instanceof google.maps.LatLng) && (i = new google.maps.LatLng(r.lat, r.lng));
    var s = new WS(Ke(Ke({}, o), i ? { position: i } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = wt({
      updaterMap: Iw,
      eventMap: _w,
      prevProps: {},
      nextProps: this.props,
      instance: s
    }), this.setState({ infoBox: s }, this.setInfoBoxCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = this.state.infoBox;
    r !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: Iw,
      eventMap: _w,
      prevProps: n,
      nextProps: this.props,
      instance: r
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n = this.props.onUnmount, r = this.state.infoBox;
    r !== null && (n && n(r), Ot(this.registeredEvents), r.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Lr(Mt.only(this.props.children), this.containerElement) : null;
  }, t.contextType = at, t;
})(ke);
var PF = function e(t, n) {
  if (t === n) return !0;
  if (t && n && typeof t == "object" && typeof n == "object") {
    if (t.constructor !== n.constructor) return !1;
    var r, o, i;
    if (Array.isArray(t)) {
      if (r = t.length, r != n.length) return !1;
      for (o = r; o-- !== 0; )
        if (!e(t[o], n[o])) return !1;
      return !0;
    }
    if (t.constructor === RegExp) return t.source === n.source && t.flags === n.flags;
    if (t.valueOf !== Object.prototype.valueOf) return t.valueOf() === n.valueOf();
    if (t.toString !== Object.prototype.toString) return t.toString() === n.toString();
    if (i = Object.keys(t), r = i.length, r !== Object.keys(n).length) return !1;
    for (o = r; o-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
    for (o = r; o-- !== 0; ) {
      var s = i[o];
      if (!e(t[s], n[s])) return !1;
    }
    return !0;
  }
  return t !== t && n !== n;
}, jw = /* @__PURE__ */ NS(PF);
const Nw = [
  Int8Array,
  Uint8Array,
  Uint8ClampedArray,
  Int16Array,
  Uint16Array,
  Int32Array,
  Uint32Array,
  Float32Array,
  Float64Array
], Fd = 1, la = 8;
class vm {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(t) {
    if (!(t instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    const [n, r] = new Uint8Array(t, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    const o = r >> 4;
    if (o !== Fd)
      throw new Error(`Got v${o} data when expected v${Fd}.`);
    const i = Nw[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    const [s] = new Uint16Array(t, 2, 1), [a] = new Uint32Array(t, 4, 1);
    return new vm(a, s, i, t);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(t, n = 64, r = Float64Array, o) {
    if (isNaN(t) || t < 0) throw new Error(`Unpexpected numItems value: ${t}.`);
    this.numItems = +t, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
    const i = Nw.indexOf(this.ArrayType), s = t * 2 * this.ArrayType.BYTES_PER_ELEMENT, a = t * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - a % 8) % 8;
    if (i < 0)
      throw new Error(`Unexpected typed array class: ${r}.`);
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, la, t), this.coords = new this.ArrayType(this.data, la + a + l, t * 2), this._pos = t * 2, this._finished = !0) : (this.data = new ArrayBuffer(la + s + a + l), this.ids = new this.IndexArrayType(this.data, la, t), this.coords = new this.ArrayType(this.data, la + a + l, t * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Fd << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = t);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(t, n) {
    const r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = t, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    const t = this._pos >> 1;
    if (t !== this.numItems)
      throw new Error(`Added ${t} items when expected ${this.numItems}.`);
    return $h(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(t, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: i, coords: s, nodeSize: a } = this, l = [0, i.length - 1, 0], u = [];
    for (; l.length; ) {
      const c = l.pop() || 0, p = l.pop() || 0, d = l.pop() || 0;
      if (p - d <= a) {
        for (let h = d; h <= p; h++) {
          const E = s[2 * h], L = s[2 * h + 1];
          E >= t && E <= r && L >= n && L <= o && u.push(i[h]);
        }
        continue;
      }
      const g = d + p >> 1, m = s[2 * g], f = s[2 * g + 1];
      m >= t && m <= r && f >= n && f <= o && u.push(i[g]), (c === 0 ? t <= m : n <= f) && (l.push(d), l.push(g - 1), l.push(1 - c)), (c === 0 ? r >= m : o >= f) && (l.push(g + 1), l.push(p), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(t, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    const { ids: o, coords: i, nodeSize: s } = this, a = [0, o.length - 1, 0], l = [], u = r * r;
    for (; a.length; ) {
      const c = a.pop() || 0, p = a.pop() || 0, d = a.pop() || 0;
      if (p - d <= s) {
        for (let h = d; h <= p; h++)
          Fw(i[2 * h], i[2 * h + 1], t, n) <= u && l.push(o[h]);
        continue;
      }
      const g = d + p >> 1, m = i[2 * g], f = i[2 * g + 1];
      Fw(m, f, t, n) <= u && l.push(o[g]), (c === 0 ? t - r <= m : n - r <= f) && (a.push(d), a.push(g - 1), a.push(1 - c)), (c === 0 ? t + r >= m : n + r >= f) && (a.push(g + 1), a.push(p), a.push(1 - c));
    }
    return l;
  }
}
function $h(e, t, n, r, o, i) {
  if (o - r <= n) return;
  const s = r + o >> 1;
  HS(e, t, s, r, o, i), $h(e, t, n, r, s - 1, 1 - i), $h(e, t, n, s + 1, o, 1 - i);
}
function HS(e, t, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      const u = o - r + 1, c = n - r + 1, p = Math.log(u), d = 0.5 * Math.exp(2 * p / 3), g = 0.5 * Math.sqrt(p * d * (u - d) / u) * (c - u / 2 < 0 ? -1 : 1), m = Math.max(r, Math.floor(n - c * d / u + g)), f = Math.min(o, Math.floor(n + (u - c) * d / u + g));
      HS(e, t, n, m, f, i);
    }
    const s = t[2 * n + i];
    let a = r, l = o;
    for (ua(e, t, r, n), t[2 * o + i] > s && ua(e, t, r, o); a < l; ) {
      for (ua(e, t, a, l), a++, l--; t[2 * a + i] < s; ) a++;
      for (; t[2 * l + i] > s; ) l--;
    }
    t[2 * r + i] === s ? ua(e, t, r, l) : (l++, ua(e, t, l, o)), l <= n && (r = l + 1), n <= l && (o = l - 1);
  }
}
function ua(e, t, n, r) {
  Rd(e, n, r), Rd(t, 2 * n, 2 * r), Rd(t, 2 * n + 1, 2 * r + 1);
}
function Rd(e, t, n) {
  const r = e[t];
  e[t] = e[n], e[n] = r;
}
function Fw(e, t, n, r) {
  const o = e - n, i = t - r;
  return o * o + i * i;
}
const TF = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (e) => e
  // props => ({sum: props.my_value})
}, Rw = Math.fround || /* @__PURE__ */ ((e) => (t) => (e[0] = +t, e[0]))(new Float32Array(1)), Vi = 2, fi = 3, zd = 4, ui = 5, VS = 6;
class AF {
  constructor(t) {
    this.options = Object.assign(Object.create(TF), t), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(t) {
    const { log: n, minZoom: r, maxZoom: o } = this.options;
    n && console.time("total time");
    const i = `prepare ${t.length} points`;
    n && console.time(i), this.points = t;
    const s = [];
    for (let l = 0; l < t.length; l++) {
      const u = t[l];
      if (!u.geometry) continue;
      const [c, p] = u.geometry.coordinates, d = Rw(Xl(c)), g = Rw(Ql(p));
      s.push(
        d,
        g,
        // projected point coordinates
        1 / 0,
        // the last zoom the point was processed at
        l,
        // index of the source feature in the original input array
        -1,
        // parent cluster id
        1
        // number of points in a cluster
      ), this.options.reduce && s.push(0);
    }
    let a = this.trees[o + 1] = this._createTree(s);
    n && console.timeEnd(i);
    for (let l = o; l >= r; l--) {
      const u = +Date.now();
      a = this.trees[l] = this._createTree(this._cluster(a, l)), n && console.log("z%d: %d clusters in %dms", l, a.numItems, +Date.now() - u);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(t, n) {
    let r = ((t[0] + 180) % 360 + 360) % 360 - 180;
    const o = Math.max(-90, Math.min(90, t[1]));
    let i = t[2] === 180 ? 180 : ((t[2] + 180) % 360 + 360) % 360 - 180;
    const s = Math.max(-90, Math.min(90, t[3]));
    if (t[2] - t[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      const p = this.getClusters([r, o, 180, s], n), d = this.getClusters([-180, o, i, s], n);
      return p.concat(d);
    }
    const a = this.trees[this._limitZoom(n)], l = a.range(Xl(r), Ql(s), Xl(i), Ql(o)), u = a.data, c = [];
    for (const p of l) {
      const d = this.stride * p;
      c.push(u[d + ui] > 1 ? zw(u, d, this.clusterProps) : this.points[u[d + fi]]);
    }
    return c;
  }
  getChildren(t) {
    const n = this._getOriginId(t), r = this._getOriginZoom(t), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    const s = i.data;
    if (n * this.stride >= s.length) throw new Error(o);
    const a = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = s[n * this.stride], u = s[n * this.stride + 1], c = i.within(l, u, a), p = [];
    for (const d of c) {
      const g = d * this.stride;
      s[g + zd] === t && p.push(s[g + ui] > 1 ? zw(s, g, this.clusterProps) : this.points[s[g + fi]]);
    }
    if (p.length === 0) throw new Error(o);
    return p;
  }
  getLeaves(t, n, r) {
    n = n || 10, r = r || 0;
    const o = [];
    return this._appendLeaves(o, t, n, r, 0), o;
  }
  getTile(t, n, r) {
    const o = this.trees[this._limitZoom(t)], i = Math.pow(2, t), { extent: s, radius: a } = this.options, l = a / s, u = (r - l) / i, c = (r + 1 + l) / i, p = {
      features: []
    };
    return this._addTileFeatures(
      o.range((n - l) / i, u, (n + 1 + l) / i, c),
      o.data,
      n,
      r,
      i,
      p
    ), n === 0 && this._addTileFeatures(
      o.range(1 - l / i, u, 1, c),
      o.data,
      i,
      r,
      i,
      p
    ), n === i - 1 && this._addTileFeatures(
      o.range(0, u, l / i, c),
      o.data,
      -1,
      r,
      i,
      p
    ), p.features.length ? p : null;
  }
  getClusterExpansionZoom(t) {
    let n = this._getOriginZoom(t) - 1;
    for (; n <= this.options.maxZoom; ) {
      const r = this.getChildren(t);
      if (n++, r.length !== 1) break;
      t = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(t, n, r, o, i) {
    const s = this.getChildren(n);
    for (const a of s) {
      const l = a.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(t, l.cluster_id, r, o, i) : i < o ? i++ : t.push(a), t.length === r) break;
    }
    return i;
  }
  _createTree(t) {
    const n = new vm(t.length / this.stride | 0, this.options.nodeSize, Float32Array);
    for (let r = 0; r < t.length; r += this.stride) n.add(t[r], t[r + 1]);
    return n.finish(), n.data = t, n;
  }
  _addTileFeatures(t, n, r, o, i, s) {
    for (const a of t) {
      const l = a * this.stride, u = n[l + ui] > 1;
      let c, p, d;
      if (u)
        c = ZS(n, l, this.clusterProps), p = n[l], d = n[l + 1];
      else {
        const f = this.points[n[l + fi]];
        c = f.properties;
        const [h, E] = f.geometry.coordinates;
        p = Xl(h), d = Ql(E);
      }
      const g = {
        type: 1,
        geometry: [[
          Math.round(this.options.extent * (p * i - r)),
          Math.round(this.options.extent * (d * i - o))
        ]],
        tags: c
      };
      let m;
      u || this.options.generateId ? m = n[l + fi] : m = this.points[n[l + fi]].id, m !== void 0 && (g.id = m), s.features.push(g);
    }
  }
  _limitZoom(t) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+t), this.options.maxZoom + 1));
  }
  _cluster(t, n) {
    const { radius: r, extent: o, reduce: i, minPoints: s } = this.options, a = r / (o * Math.pow(2, n)), l = t.data, u = [], c = this.stride;
    for (let p = 0; p < l.length; p += c) {
      if (l[p + Vi] <= n) continue;
      l[p + Vi] = n;
      const d = l[p], g = l[p + 1], m = t.within(l[p], l[p + 1], a), f = l[p + ui];
      let h = f;
      for (const E of m) {
        const L = E * c;
        l[L + Vi] > n && (h += l[L + ui]);
      }
      if (h > f && h >= s) {
        let E = d * f, L = g * f, x, T = -1;
        const w = ((p / c | 0) << 5) + (n + 1) + this.points.length;
        for (const C of m) {
          const k = C * c;
          if (l[k + Vi] <= n) continue;
          l[k + Vi] = n;
          const O = l[k + ui];
          E += l[k] * O, L += l[k + 1] * O, l[k + zd] = w, i && (x || (x = this._map(l, p, !0), T = this.clusterProps.length, this.clusterProps.push(x)), i(x, this._map(l, k)));
        }
        l[p + zd] = w, u.push(E / h, L / h, 1 / 0, w, -1, h), i && u.push(T);
      } else {
        for (let E = 0; E < c; E++) u.push(l[p + E]);
        if (h > 1)
          for (const E of m) {
            const L = E * c;
            if (!(l[L + Vi] <= n)) {
              l[L + Vi] = n;
              for (let x = 0; x < c; x++) u.push(l[L + x]);
            }
          }
      }
    }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(t) {
    return t - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(t) {
    return (t - this.points.length) % 32;
  }
  _map(t, n, r) {
    if (t[n + ui] > 1) {
      const s = this.clusterProps[t[n + VS]];
      return r ? Object.assign({}, s) : s;
    }
    const o = this.points[t[n + fi]].properties, i = this.options.map(o);
    return r && i === o ? Object.assign({}, i) : i;
  }
}
function zw(e, t, n) {
  return {
    type: "Feature",
    id: e[t + fi],
    properties: ZS(e, t, n),
    geometry: {
      type: "Point",
      coordinates: [BF(e[t]), _F(e[t + 1])]
    }
  };
}
function ZS(e, t, n) {
  const r = e[t + ui], o = r >= 1e4 ? `${Math.round(r / 1e3)}k` : r >= 1e3 ? `${Math.round(r / 100) / 10}k` : r, i = e[t + VS], s = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(s, {
    cluster: !0,
    cluster_id: e[t + fi],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Xl(e) {
  return e / 360 + 0.5;
}
function Ql(e) {
  const t = Math.sin(e * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + t) / (1 - t)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function BF(e) {
  return (e - 0.5) * 360;
}
function _F(e) {
  const t = (180 - e * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(t)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function IF(e, t) {
  var n = {};
  for (var r in e) Object.prototype.hasOwnProperty.call(e, r) && t.indexOf(r) < 0 && (n[r] = e[r]);
  if (e != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o = 0, r = Object.getOwnPropertySymbols(e); o < r.length; o++)
      t.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(e, r[o]) && (n[r[o]] = e[r[o]]);
  return n;
}
class qr {
  static isAdvancedMarkerAvailable(t) {
    return google.maps.marker && t.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(t) {
    return google.maps.marker && t instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(t, n) {
    this.isAdvancedMarker(t) ? t.map = n : t.setMap(n);
  }
  static getPosition(t) {
    if (this.isAdvancedMarker(t)) {
      if (t.position) {
        if (t.position instanceof google.maps.LatLng)
          return t.position;
        if (t.position.lat && t.position.lng)
          return new google.maps.LatLng(t.position.lat, t.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return t.getPosition();
  }
  static getVisible(t) {
    return this.isAdvancedMarker(t) ? !0 : t.getVisible();
  }
}
class Wh {
  constructor({ markers: t, position: n }) {
    this.markers = t, n && (n instanceof google.maps.LatLng ? this._position = n : this._position = new google.maps.LatLng(n));
  }
  get bounds() {
    if (this.markers.length === 0 && !this._position)
      return;
    const t = new google.maps.LatLngBounds(this._position, this._position);
    for (const n of this.markers)
      t.extend(qr.getPosition(n));
    return t;
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((t) => qr.getVisible(t)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(t) {
    this.markers.push(t);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (qr.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class jF {
  constructor({ maxZoom: t = 16 }) {
    this.maxZoom = t;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop({ markers: t }) {
    return NF(t);
  }
}
const NF = (e) => e.map((t) => new Wh({
  position: qr.getPosition(t),
  markers: [t]
}));
class FF extends jF {
  constructor(t) {
    var { maxZoom: n, radius: r = 60 } = t, o = IF(t, ["maxZoom", "radius"]);
    super({ maxZoom: n }), this.state = { zoom: -1 }, this.superCluster = new AF(Object.assign({ maxZoom: this.maxZoom, radius: r }, o));
  }
  calculate(t) {
    let n = !1;
    const r = { zoom: t.map.getZoom() };
    if (!jw(t.markers, this.markers)) {
      n = !0, this.markers = [...t.markers];
      const o = this.markers.map((i) => {
        const s = qr.getPosition(i);
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: [s.lng(), s.lat()]
          },
          properties: { marker: i }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !jw(this.state, r)), this.state = r, n && (this.clusters = this.cluster(t)), { clusters: this.clusters, changed: n };
  }
  cluster({ map: t }) {
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(t.getZoom())).map((n) => this.transformCluster(n));
  }
  transformCluster({ geometry: { coordinates: [t, n] }, properties: r }) {
    if (r.cluster)
      return new Wh({
        markers: this.superCluster.getLeaves(r.cluster_id, 1 / 0).map((i) => i.properties.marker),
        position: { lat: n, lng: t }
      });
    const o = r.marker;
    return new Wh({
      markers: [o],
      position: qr.getPosition(o)
    });
  }
}
class RF {
  constructor(t, n) {
    this.markers = { sum: t.length };
    const r = n.map((i) => i.count), o = r.reduce((i, s) => i + s, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class zF {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render({ count: t, position: n }, r, o) {
    const i = `<svg fill="${t > Math.max(10, r.clusters.markers.mean) ? "#ff0000" : "#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${t}</text>
</svg>`, s = `Cluster of ${t} markers`, a = Number(google.maps.Marker.MAX_ZINDEX) + t;
    if (qr.isAdvancedMarkerAvailable(o)) {
      const u = new DOMParser().parseFromString(i, "image/svg+xml").documentElement;
      u.setAttribute("transform", "translate(0 25)");
      const c = {
        map: o,
        position: n,
        zIndex: a,
        title: s,
        content: u
      };
      return new google.maps.marker.AdvancedMarkerElement(c);
    }
    const l = {
      position: n,
      zIndex: a,
      title: s,
      icon: {
        url: `data:image/svg+xml;base64,${btoa(i)}`,
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(l);
  }
}
function UF(e, t) {
  for (let n in t.prototype)
    e.prototype[n] = t.prototype[n];
}
class ym {
  constructor() {
    UF(ym, google.maps.OverlayView);
  }
}
var Da;
(function(e) {
  e.CLUSTERING_BEGIN = "clusteringbegin", e.CLUSTERING_END = "clusteringend", e.CLUSTER_CLICK = "click";
})(Da || (Da = {}));
const $F = (e, t, n) => {
  n.fitBounds(t.bounds);
};
class WF extends ym {
  constructor({ map: t, markers: n = [], algorithmOptions: r = {}, algorithm: o = new FF(r), renderer: i = new zF(), onClusterClick: s = $F }) {
    super(), this.markers = [...n], this.clusters = [], this.algorithm = o, this.renderer = i, this.onClusterClick = s, t && this.setMap(t);
  }
  addMarker(t, n) {
    this.markers.includes(t) || (this.markers.push(t), n || this.render());
  }
  addMarkers(t, n) {
    t.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(t, n) {
    const r = this.markers.indexOf(t);
    return r === -1 ? !1 : (qr.setMap(t, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(t, n) {
    let r = !1;
    return t.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(t) {
    this.markers.length = 0, t || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    const t = this.getMap();
    if (t instanceof google.maps.Map && t.getProjection()) {
      google.maps.event.trigger(this, Da.CLUSTERING_BEGIN, this);
      const { clusters: n, changed: r } = this.algorithm.calculate({
        markers: this.markers,
        map: t,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        const o = /* @__PURE__ */ new Set();
        for (const s of n)
          s.markers.length == 1 && o.add(s.markers[0]);
        const i = [];
        for (const s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || qr.setMap(s.marker, null) : i.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => i.forEach((s) => qr.setMap(s, null)));
      }
      google.maps.event.trigger(this, Da.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((t) => qr.setMap(t, null)), this.clusters.forEach((t) => t.delete()), this.clusters = [];
  }
  renderClusters() {
    const t = new RF(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, t, n), r.markers.forEach((o) => qr.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Da.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), qr.setMap(r.marker, n);
    });
  }
}
function HF(e) {
  var t = nF(), n = D(null), r = n[0], o = n[1];
  return v(function() {
    if (t && r === null) {
      var i = new WF(Ke(Ke({}, e), { map: t }));
      o(i);
    }
  }, [t]), r;
}
function VF(e) {
  var t = e.children, n = e.options, r = HF(n);
  return r !== null ? t(r) : null;
}
Re(VF);
var Uw = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, $w = {
  options: function(e, t) {
    e.setOptions(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
function ZF(e) {
  var t = e.children, n = e.anchor, r = e.options, o = e.position, i = e.zIndex, s = e.onCloseClick, a = e.onDomReady, l = e.onContentChanged, u = e.onPositionChanged, c = e.onZindexChanged, p = e.onLoad, d = e.onUnmount, g = _e(at), m = D(null), f = m[0], h = m[1], E = D(null), L = E[0], x = E[1], T = D(null), w = T[0], C = T[1], k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = rt(null);
  return v(function() {
    f !== null && (f.close(), n ? f.open(g, n) : f.getPosition() && f.open(g));
  }, [g, f, n]), v(function() {
    r && f !== null && f.setOptions(r);
  }, [f, r]), v(function() {
    o && f !== null && f.setPosition(o);
  }, [o]), v(function() {
    typeof i == "number" && f !== null && f.setZIndex(i);
  }, [i]), v(function() {
    f && s && (L !== null && google.maps.event.removeListener(L), x(google.maps.event.addListener(f, "closeclick", s)));
  }, [s]), v(function() {
    f && a && (w !== null && google.maps.event.removeListener(w), C(google.maps.event.addListener(f, "domready", a)));
  }, [a]), v(function() {
    f && l && (O !== null && google.maps.event.removeListener(O), U(google.maps.event.addListener(f, "content_changed", l)));
  }, [l]), v(function() {
    f && u && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(f, "position_changed", u)));
  }, [u]), v(function() {
    f && c && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(f, "zindex_changed", c)));
  }, [c]), v(function() {
    var I = new google.maps.InfoWindow(Ke({}, r || {}));
    return h(I), X.current = document.createElement("div"), s && x(google.maps.event.addListener(I, "closeclick", s)), a && C(google.maps.event.addListener(I, "domready", a)), l && U(google.maps.event.addListener(I, "content_changed", l)), u && $(google.maps.event.addListener(I, "position_changed", u)), c && H(google.maps.event.addListener(I, "zindex_changed", c)), I.setContent(X.current), o && I.setPosition(o), i && I.setZIndex(i), n ? I.open(g, n) : I.getPosition() ? I.open(g) : ar(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), p && p(I), function() {
      L && google.maps.event.removeListener(L), O && google.maps.event.removeListener(O), w && google.maps.event.removeListener(w), V && google.maps.event.removeListener(V), R && google.maps.event.removeListener(R), d && d(I), I.close();
    };
  }, []), X.current ? Lr(Mt.only(t), X.current) : null;
}
Re(ZF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = null, n.state = {
      infoWindow: null
    }, n.open = function(r, o) {
      o ? r.open(n.context, o) : r.getPosition() ? r.open(n.context) : ar(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }, n.setInfoWindowCallback = function() {
      n.state.infoWindow !== null && n.containerElement !== null && (n.state.infoWindow.setContent(n.containerElement), n.open(n.state.infoWindow, n.props.anchor), n.props.onLoad && n.props.onLoad(n.state.infoWindow));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.InfoWindow(Ke({}, this.props.options || {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = wt({
      updaterMap: $w,
      eventMap: Uw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        infoWindow: n
      };
    }, this.setInfoWindowCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.infoWindow !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: $w,
      eventMap: Uw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.infoWindow !== null && (Ot(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }, t.prototype.render = function() {
    return this.containerElement ? Lr(Mt.only(this.props.children), this.containerElement) : null;
  }, t.contextType = at, t;
})(ke);
var Ww = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Hw = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, qF = {};
function GF(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, g = e.onMouseUp, m = e.onRightClick, f = e.onClick, h = e.onDrag, E = e.onLoad, L = e.onUnmount, x = _e(at), T = D(null), w = T[0], C = T[1], k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = D(null), I = X[0], J = X[1], te = D(null), S = te[0], P = te[1], q = D(null), j = q[0], Z = q[1], G = D(null), b = G[0], F = G[1], z = D(null), A = z[0], Y = z[1], ee = D(null), B = ee[0], se = ee[1], ue = D(null), ce = ue[0], de = ue[1], be = D(null), ge = be[0], me = be[1];
  return v(function() {
    w !== null && w.setMap(x);
  }, [x]), v(function() {
    typeof t < "u" && w !== null && w.setOptions(t);
  }, [w, t]), v(function() {
    typeof n < "u" && w !== null && w.setDraggable(n);
  }, [w, n]), v(function() {
    typeof r < "u" && w !== null && w.setEditable(r);
  }, [w, r]), v(function() {
    typeof o < "u" && w !== null && w.setVisible(o);
  }, [w, o]), v(function() {
    typeof i < "u" && w !== null && w.setPath(i);
  }, [w, i]), v(function() {
    w && s && (O !== null && google.maps.event.removeListener(O), U(google.maps.event.addListener(w, "dblclick", s)));
  }, [s]), v(function() {
    w && a && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(w, "dragend", a)));
  }, [a]), v(function() {
    w && l && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(w, "dragstart", l)));
  }, [l]), v(function() {
    w && u && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(w, "mousedown", u)));
  }, [u]), v(function() {
    w && c && (S !== null && google.maps.event.removeListener(S), P(google.maps.event.addListener(w, "mousemove", c)));
  }, [c]), v(function() {
    w && p && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(w, "mouseout", p)));
  }, [p]), v(function() {
    w && d && (b !== null && google.maps.event.removeListener(b), F(google.maps.event.addListener(w, "mouseover", d)));
  }, [d]), v(function() {
    w && g && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(w, "mouseup", g)));
  }, [g]), v(function() {
    w && m && (B !== null && google.maps.event.removeListener(B), se(google.maps.event.addListener(w, "rightclick", m)));
  }, [m]), v(function() {
    w && f && (ce !== null && google.maps.event.removeListener(ce), de(google.maps.event.addListener(w, "click", f)));
  }, [f]), v(function() {
    w && h && (ge !== null && google.maps.event.removeListener(ge), me(google.maps.event.addListener(w, "drag", h)));
  }, [h]), v(function() {
    var ae = new google.maps.Polyline(Ke(Ke({}, t || qF), { map: x }));
    return i && ae.setPath(i), typeof o < "u" && ae.setVisible(o), typeof r < "u" && ae.setEditable(r), typeof n < "u" && ae.setDraggable(n), s && U(google.maps.event.addListener(ae, "dblclick", s)), a && $(google.maps.event.addListener(ae, "dragend", a)), l && H(google.maps.event.addListener(ae, "dragstart", l)), u && J(google.maps.event.addListener(ae, "mousedown", u)), c && P(google.maps.event.addListener(ae, "mousemove", c)), p && Z(google.maps.event.addListener(ae, "mouseout", p)), d && F(google.maps.event.addListener(ae, "mouseover", d)), g && Y(google.maps.event.addListener(ae, "mouseup", g)), m && se(google.maps.event.addListener(ae, "rightclick", m)), f && de(google.maps.event.addListener(ae, "click", f)), h && me(google.maps.event.addListener(ae, "drag", h)), C(ae), E && E(ae), function() {
      O !== null && google.maps.event.removeListener(O), V !== null && google.maps.event.removeListener(V), R !== null && google.maps.event.removeListener(R), I !== null && google.maps.event.removeListener(I), S !== null && google.maps.event.removeListener(S), j !== null && google.maps.event.removeListener(j), b !== null && google.maps.event.removeListener(b), A !== null && google.maps.event.removeListener(A), B !== null && google.maps.event.removeListener(B), ce !== null && google.maps.event.removeListener(ce), L && L(ae), ae.setMap(null);
    };
  }, []), null;
}
Re(GF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polyline: null
    }, n.setPolylineCallback = function() {
      n.state.polyline !== null && n.props.onLoad && n.props.onLoad(n.state.polyline);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polyline(Ke(Ke({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = wt({
      updaterMap: Hw,
      eventMap: Ww,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polyline: n
      };
    }, this.setPolylineCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polyline !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: Hw,
      eventMap: Ww,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Ot(this.registeredEvents), this.state.polyline.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
var Vw = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Zw = {
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  path: function(e, t) {
    e.setPath(t);
  },
  paths: function(e, t) {
    e.setPaths(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function KF(e) {
  var t = e.options, n = e.draggable, r = e.editable, o = e.visible, i = e.path, s = e.paths, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, g = e.onMouseOver, m = e.onMouseUp, f = e.onRightClick, h = e.onClick, E = e.onDrag, L = e.onLoad, x = e.onUnmount, T = e.onEdit, w = _e(at), C = D(null), k = C[0], O = C[1], U = D(null), M = U[0], V = U[1], $ = D(null), W = $[0], R = $[1], H = D(null), X = H[0], I = H[1], J = D(null), te = J[0], S = J[1], P = D(null), q = P[0], j = P[1], Z = D(null), G = Z[0], b = Z[1], F = D(null), z = F[0], A = F[1], Y = D(null), ee = Y[0], B = Y[1], se = D(null), ue = se[0], ce = se[1], de = D(null), be = de[0], ge = de[1], me = D(null), ae = me[0], xe = me[1];
  return v(function() {
    k !== null && k.setMap(w);
  }, [w]), v(function() {
    typeof t < "u" && k !== null && k.setOptions(t);
  }, [k, t]), v(function() {
    typeof n < "u" && k !== null && k.setDraggable(n);
  }, [k, n]), v(function() {
    typeof r < "u" && k !== null && k.setEditable(r);
  }, [k, r]), v(function() {
    typeof o < "u" && k !== null && k.setVisible(o);
  }, [k, o]), v(function() {
    typeof i < "u" && k !== null && k.setPath(i);
  }, [k, i]), v(function() {
    typeof s < "u" && k !== null && k.setPaths(s);
  }, [k, s]), v(function() {
    k && a && (M !== null && google.maps.event.removeListener(M), V(google.maps.event.addListener(k, "dblclick", a)));
  }, [a]), v(function() {
    k && (google.maps.event.addListener(k.getPath(), "insert_at", function() {
      T == null || T(k);
    }), google.maps.event.addListener(k.getPath(), "set_at", function() {
      T == null || T(k);
    }));
  }, [k, T]), v(function() {
    k && l && (W !== null && google.maps.event.removeListener(W), R(google.maps.event.addListener(k, "dragend", l)));
  }, [l]), v(function() {
    k && u && (X !== null && google.maps.event.removeListener(X), I(google.maps.event.addListener(k, "dragstart", u)));
  }, [u]), v(function() {
    k && c && (te !== null && google.maps.event.removeListener(te), S(google.maps.event.addListener(k, "mousedown", c)));
  }, [c]), v(function() {
    k && p && (q !== null && google.maps.event.removeListener(q), j(google.maps.event.addListener(k, "mousemove", p)));
  }, [p]), v(function() {
    k && d && (G !== null && google.maps.event.removeListener(G), b(google.maps.event.addListener(k, "mouseout", d)));
  }, [d]), v(function() {
    k && g && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(k, "mouseover", g)));
  }, [g]), v(function() {
    k && m && (ee !== null && google.maps.event.removeListener(ee), B(google.maps.event.addListener(k, "mouseup", m)));
  }, [m]), v(function() {
    k && f && (ue !== null && google.maps.event.removeListener(ue), ce(google.maps.event.addListener(k, "rightclick", f)));
  }, [f]), v(function() {
    k && h && (be !== null && google.maps.event.removeListener(be), ge(google.maps.event.addListener(k, "click", h)));
  }, [h]), v(function() {
    k && E && (ae !== null && google.maps.event.removeListener(ae), xe(google.maps.event.addListener(k, "drag", E)));
  }, [E]), v(function() {
    var re = new google.maps.Polygon(Ke(Ke({}, t || {}), { map: w }));
    return i && re.setPath(i), s && re.setPaths(s), typeof o < "u" && re.setVisible(o), typeof r < "u" && re.setEditable(r), typeof n < "u" && re.setDraggable(n), a && V(google.maps.event.addListener(re, "dblclick", a)), l && R(google.maps.event.addListener(re, "dragend", l)), u && I(google.maps.event.addListener(re, "dragstart", u)), c && S(google.maps.event.addListener(re, "mousedown", c)), p && j(google.maps.event.addListener(re, "mousemove", p)), d && b(google.maps.event.addListener(re, "mouseout", d)), g && A(google.maps.event.addListener(re, "mouseover", g)), m && B(google.maps.event.addListener(re, "mouseup", m)), f && ce(google.maps.event.addListener(re, "rightclick", f)), h && ge(google.maps.event.addListener(re, "click", h)), E && xe(google.maps.event.addListener(re, "drag", E)), O(re), L && L(re), function() {
      M !== null && google.maps.event.removeListener(M), W !== null && google.maps.event.removeListener(W), X !== null && google.maps.event.removeListener(X), te !== null && google.maps.event.removeListener(te), q !== null && google.maps.event.removeListener(q), G !== null && google.maps.event.removeListener(G), z !== null && google.maps.event.removeListener(z), ee !== null && google.maps.event.removeListener(ee), ue !== null && google.maps.event.removeListener(ue), be !== null && google.maps.event.removeListener(be), x && x(re), re.setMap(null);
    };
  }, []), null;
}
Re(KF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      polygon: null
    }, n.setPolygonCallback = function() {
      n.state.polygon !== null && n.props.onLoad && n.props.onLoad(n.state.polygon);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Polygon(Ke(Ke({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = wt({
      updaterMap: Zw,
      eventMap: Vw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        polygon: n
      };
    }, this.setPolygonCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.polygon !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: Zw,
      eventMap: Vw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.polygon
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.polygon !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polygon), Ot(this.registeredEvents), this.state.polygon && this.state.polygon.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
var qw = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Gw = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
};
function YF(e) {
  var t = e.options, n = e.bounds, r = e.draggable, o = e.editable, i = e.visible, s = e.onDblClick, a = e.onDragEnd, l = e.onDragStart, u = e.onMouseDown, c = e.onMouseMove, p = e.onMouseOut, d = e.onMouseOver, g = e.onMouseUp, m = e.onRightClick, f = e.onClick, h = e.onDrag, E = e.onBoundsChanged, L = e.onLoad, x = e.onUnmount, T = _e(at), w = D(null), C = w[0], k = w[1], O = D(null), U = O[0], M = O[1], V = D(null), $ = V[0], W = V[1], R = D(null), H = R[0], X = R[1], I = D(null), J = I[0], te = I[1], S = D(null), P = S[0], q = S[1], j = D(null), Z = j[0], G = j[1], b = D(null), F = b[0], z = b[1], A = D(null), Y = A[0], ee = A[1], B = D(null), se = B[0], ue = B[1], ce = D(null), de = ce[0], be = ce[1], ge = D(null), me = ge[0], ae = ge[1], xe = D(null), re = xe[0], Te = xe[1];
  return v(function() {
    C !== null && C.setMap(T);
  }, [T]), v(function() {
    typeof t < "u" && C !== null && C.setOptions(t);
  }, [C, t]), v(function() {
    typeof r < "u" && C !== null && C.setDraggable(r);
  }, [C, r]), v(function() {
    typeof o < "u" && C !== null && C.setEditable(o);
  }, [C, o]), v(function() {
    typeof i < "u" && C !== null && C.setVisible(i);
  }, [C, i]), v(function() {
    typeof n < "u" && C !== null && C.setBounds(n);
  }, [C, n]), v(function() {
    C && s && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(C, "dblclick", s)));
  }, [s]), v(function() {
    C && a && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(C, "dragend", a)));
  }, [a]), v(function() {
    C && l && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(C, "dragstart", l)));
  }, [l]), v(function() {
    C && u && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(C, "mousedown", u)));
  }, [u]), v(function() {
    C && c && (P !== null && google.maps.event.removeListener(P), q(google.maps.event.addListener(C, "mousemove", c)));
  }, [c]), v(function() {
    C && p && (Z !== null && google.maps.event.removeListener(Z), G(google.maps.event.addListener(C, "mouseout", p)));
  }, [p]), v(function() {
    C && d && (F !== null && google.maps.event.removeListener(F), z(google.maps.event.addListener(C, "mouseover", d)));
  }, [d]), v(function() {
    C && g && (Y !== null && google.maps.event.removeListener(Y), ee(google.maps.event.addListener(C, "mouseup", g)));
  }, [g]), v(function() {
    C && m && (se !== null && google.maps.event.removeListener(se), ue(google.maps.event.addListener(C, "rightclick", m)));
  }, [m]), v(function() {
    C && f && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(C, "click", f)));
  }, [f]), v(function() {
    C && h && (me !== null && google.maps.event.removeListener(me), ae(google.maps.event.addListener(C, "drag", h)));
  }, [h]), v(function() {
    C && E && (re !== null && google.maps.event.removeListener(re), Te(google.maps.event.addListener(C, "bounds_changed", E)));
  }, [E]), v(function() {
    var ne = new google.maps.Rectangle(Ke(Ke({}, t || {}), { map: T }));
    return typeof i < "u" && ne.setVisible(i), typeof o < "u" && ne.setEditable(o), typeof r < "u" && ne.setDraggable(r), typeof n < "u" && ne.setBounds(n), s && M(google.maps.event.addListener(ne, "dblclick", s)), a && W(google.maps.event.addListener(ne, "dragend", a)), l && X(google.maps.event.addListener(ne, "dragstart", l)), u && te(google.maps.event.addListener(ne, "mousedown", u)), c && q(google.maps.event.addListener(ne, "mousemove", c)), p && G(google.maps.event.addListener(ne, "mouseout", p)), d && z(google.maps.event.addListener(ne, "mouseover", d)), g && ee(google.maps.event.addListener(ne, "mouseup", g)), m && ue(google.maps.event.addListener(ne, "rightclick", m)), f && be(google.maps.event.addListener(ne, "click", f)), h && ae(google.maps.event.addListener(ne, "drag", h)), E && Te(google.maps.event.addListener(ne, "bounds_changed", E)), k(ne), L && L(ne), function() {
      U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), P !== null && google.maps.event.removeListener(P), Z !== null && google.maps.event.removeListener(Z), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), se !== null && google.maps.event.removeListener(se), de !== null && google.maps.event.removeListener(de), me !== null && google.maps.event.removeListener(me), re !== null && google.maps.event.removeListener(re), x && x(ne), ne.setMap(null);
    };
  }, []), null;
}
Re(YF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      rectangle: null
    }, n.setRectangleCallback = function() {
      n.state.rectangle !== null && n.props.onLoad && n.props.onLoad(n.state.rectangle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Rectangle(Ke(Ke({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = wt({
      updaterMap: Gw,
      eventMap: qw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        rectangle: n
      };
    }, this.setRectangleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.rectangle !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: Gw,
      eventMap: qw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Ot(this.registeredEvents), this.state.rectangle.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
var Kw = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Yw = {
  center: function(e, t) {
    e.setCenter(t);
  },
  draggable: function(e, t) {
    e.setDraggable(t);
  },
  editable: function(e, t) {
    e.setEditable(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  radius: function(e, t) {
    e.setRadius(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  }
}, XF = {};
function QF(e) {
  var t = e.options, n = e.center, r = e.radius, o = e.draggable, i = e.editable, s = e.visible, a = e.onDblClick, l = e.onDragEnd, u = e.onDragStart, c = e.onMouseDown, p = e.onMouseMove, d = e.onMouseOut, g = e.onMouseOver, m = e.onMouseUp, f = e.onRightClick, h = e.onClick, E = e.onDrag, L = e.onCenterChanged, x = e.onRadiusChanged, T = e.onLoad, w = e.onUnmount, C = _e(at), k = D(null), O = k[0], U = k[1], M = D(null), V = M[0], $ = M[1], W = D(null), R = W[0], H = W[1], X = D(null), I = X[0], J = X[1], te = D(null), S = te[0], P = te[1], q = D(null), j = q[0], Z = q[1], G = D(null), b = G[0], F = G[1], z = D(null), A = z[0], Y = z[1], ee = D(null), B = ee[0], se = ee[1], ue = D(null), ce = ue[0], de = ue[1], be = D(null), ge = be[0], me = be[1], ae = D(null), xe = ae[0], re = ae[1], Te = D(null), ne = Te[0], Ee = Te[1], Ne = D(null), Fe = Ne[0], Ue = Ne[1];
  return v(function() {
    O !== null && O.setMap(C);
  }, [C]), v(function() {
    typeof t < "u" && O !== null && O.setOptions(t);
  }, [O, t]), v(function() {
    typeof o < "u" && O !== null && O.setDraggable(o);
  }, [O, o]), v(function() {
    typeof i < "u" && O !== null && O.setEditable(i);
  }, [O, i]), v(function() {
    typeof s < "u" && O !== null && O.setVisible(s);
  }, [O, s]), v(function() {
    typeof r == "number" && O !== null && O.setRadius(r);
  }, [O, r]), v(function() {
    typeof n < "u" && O !== null && O.setCenter(n);
  }, [O, n]), v(function() {
    O && a && (V !== null && google.maps.event.removeListener(V), $(google.maps.event.addListener(O, "dblclick", a)));
  }, [a]), v(function() {
    O && l && (R !== null && google.maps.event.removeListener(R), H(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), v(function() {
    O && u && (I !== null && google.maps.event.removeListener(I), J(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), v(function() {
    O && c && (S !== null && google.maps.event.removeListener(S), P(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), v(function() {
    O && p && (j !== null && google.maps.event.removeListener(j), Z(google.maps.event.addListener(O, "mousemove", p)));
  }, [p]), v(function() {
    O && d && (b !== null && google.maps.event.removeListener(b), F(google.maps.event.addListener(O, "mouseout", d)));
  }, [d]), v(function() {
    O && g && (A !== null && google.maps.event.removeListener(A), Y(google.maps.event.addListener(O, "mouseover", g)));
  }, [g]), v(function() {
    O && m && (B !== null && google.maps.event.removeListener(B), se(google.maps.event.addListener(O, "mouseup", m)));
  }, [m]), v(function() {
    O && f && (ce !== null && google.maps.event.removeListener(ce), de(google.maps.event.addListener(O, "rightclick", f)));
  }, [f]), v(function() {
    O && h && (ge !== null && google.maps.event.removeListener(ge), me(google.maps.event.addListener(O, "click", h)));
  }, [h]), v(function() {
    O && E && (xe !== null && google.maps.event.removeListener(xe), re(google.maps.event.addListener(O, "drag", E)));
  }, [E]), v(function() {
    O && L && (ne !== null && google.maps.event.removeListener(ne), Ee(google.maps.event.addListener(O, "center_changed", L)));
  }, [h]), v(function() {
    O && x && (Fe !== null && google.maps.event.removeListener(Fe), Ue(google.maps.event.addListener(O, "radius_changed", x)));
  }, [x]), v(function() {
    var he = new google.maps.Circle(Ke(Ke({}, t || XF), { map: C }));
    return typeof r == "number" && he.setRadius(r), typeof n < "u" && he.setCenter(n), typeof r == "number" && he.setRadius(r), typeof s < "u" && he.setVisible(s), typeof i < "u" && he.setEditable(i), typeof o < "u" && he.setDraggable(o), a && $(google.maps.event.addListener(he, "dblclick", a)), l && H(google.maps.event.addListener(he, "dragend", l)), u && J(google.maps.event.addListener(he, "dragstart", u)), c && P(google.maps.event.addListener(he, "mousedown", c)), p && Z(google.maps.event.addListener(he, "mousemove", p)), d && F(google.maps.event.addListener(he, "mouseout", d)), g && Y(google.maps.event.addListener(he, "mouseover", g)), m && se(google.maps.event.addListener(he, "mouseup", m)), f && de(google.maps.event.addListener(he, "rightclick", f)), h && me(google.maps.event.addListener(he, "click", h)), E && re(google.maps.event.addListener(he, "drag", E)), L && Ee(google.maps.event.addListener(he, "center_changed", L)), x && Ue(google.maps.event.addListener(he, "radius_changed", x)), U(he), T && T(he), function() {
      V !== null && google.maps.event.removeListener(V), R !== null && google.maps.event.removeListener(R), I !== null && google.maps.event.removeListener(I), S !== null && google.maps.event.removeListener(S), j !== null && google.maps.event.removeListener(j), b !== null && google.maps.event.removeListener(b), A !== null && google.maps.event.removeListener(A), B !== null && google.maps.event.removeListener(B), ce !== null && google.maps.event.removeListener(ce), ge !== null && google.maps.event.removeListener(ge), ne !== null && google.maps.event.removeListener(ne), Fe !== null && google.maps.event.removeListener(Fe), w && w(he), he.setMap(null);
    };
  }, []), null;
}
Re(QF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      circle: null
    }, n.setCircleCallback = function() {
      n.state.circle !== null && n.props.onLoad && n.props.onLoad(n.state.circle);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.Circle(Ke(Ke({}, this.props.options || {}), { map: this.context }));
    this.registeredEvents = wt({
      updaterMap: Yw,
      eventMap: Kw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        circle: n
      };
    }, this.setCircleCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.circle !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: Yw,
      eventMap: Kw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }, t.prototype.componentWillUnmount = function() {
    var n;
    this.state.circle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.circle), Ot(this.registeredEvents), (n = this.state.circle) === null || n === void 0 || n.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
var Xw = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, Qw = {
  add: function(e, t) {
    e.add(t);
  },
  addgeojson: function(e, t, n) {
    e.addGeoJson(t, n);
  },
  contains: function(e, t) {
    e.contains(t);
  },
  foreach: function(e, t) {
    e.forEach(t);
  },
  loadgeojson: function(e, t, n, r) {
    e.loadGeoJson(t, n, r);
  },
  overridestyle: function(e, t, n) {
    e.overrideStyle(t, n);
  },
  remove: function(e, t) {
    e.remove(t);
  },
  revertstyle: function(e, t) {
    e.revertStyle(t);
  },
  controlposition: function(e, t) {
    e.setControlPosition(t);
  },
  controls: function(e, t) {
    e.setControls(t);
  },
  drawingmode: function(e, t) {
    e.setDrawingMode(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  style: function(e, t) {
    e.setStyle(t);
  },
  togeojson: function(e, t) {
    e.toGeoJson(t);
  }
};
function JF(e) {
  var t = e.options, n = e.onClick, r = e.onDblClick, o = e.onMouseDown, i = e.onMouseMove, s = e.onMouseOut, a = e.onMouseOver, l = e.onMouseUp, u = e.onRightClick, c = e.onAddFeature, p = e.onRemoveFeature, d = e.onRemoveProperty, g = e.onSetGeometry, m = e.onSetProperty, f = e.onLoad, h = e.onUnmount, E = _e(at), L = D(null), x = L[0], T = L[1], w = D(null), C = w[0], k = w[1], O = D(null), U = O[0], M = O[1], V = D(null), $ = V[0], W = V[1], R = D(null), H = R[0], X = R[1], I = D(null), J = I[0], te = I[1], S = D(null), P = S[0], q = S[1], j = D(null), Z = j[0], G = j[1], b = D(null), F = b[0], z = b[1], A = D(null), Y = A[0], ee = A[1], B = D(null), se = B[0], ue = B[1], ce = D(null), de = ce[0], be = ce[1], ge = D(null), me = ge[0], ae = ge[1], xe = D(null), re = xe[0], Te = xe[1];
  return v(function() {
    x !== null && x.setMap(E);
  }, [E]), v(function() {
    x && r && (C !== null && google.maps.event.removeListener(C), k(google.maps.event.addListener(x, "dblclick", r)));
  }, [r]), v(function() {
    x && o && (U !== null && google.maps.event.removeListener(U), M(google.maps.event.addListener(x, "mousedown", o)));
  }, [o]), v(function() {
    x && i && ($ !== null && google.maps.event.removeListener($), W(google.maps.event.addListener(x, "mousemove", i)));
  }, [i]), v(function() {
    x && s && (H !== null && google.maps.event.removeListener(H), X(google.maps.event.addListener(x, "mouseout", s)));
  }, [s]), v(function() {
    x && a && (J !== null && google.maps.event.removeListener(J), te(google.maps.event.addListener(x, "mouseover", a)));
  }, [a]), v(function() {
    x && l && (P !== null && google.maps.event.removeListener(P), q(google.maps.event.addListener(x, "mouseup", l)));
  }, [l]), v(function() {
    x && u && (Z !== null && google.maps.event.removeListener(Z), G(google.maps.event.addListener(x, "rightclick", u)));
  }, [u]), v(function() {
    x && n && (F !== null && google.maps.event.removeListener(F), z(google.maps.event.addListener(x, "click", n)));
  }, [n]), v(function() {
    x && c && (Y !== null && google.maps.event.removeListener(Y), ee(google.maps.event.addListener(x, "addfeature", c)));
  }, [c]), v(function() {
    x && p && (se !== null && google.maps.event.removeListener(se), ue(google.maps.event.addListener(x, "removefeature", p)));
  }, [p]), v(function() {
    x && d && (de !== null && google.maps.event.removeListener(de), be(google.maps.event.addListener(x, "removeproperty", d)));
  }, [d]), v(function() {
    x && g && (me !== null && google.maps.event.removeListener(me), ae(google.maps.event.addListener(x, "setgeometry", g)));
  }, [g]), v(function() {
    x && m && (re !== null && google.maps.event.removeListener(re), Te(google.maps.event.addListener(x, "setproperty", m)));
  }, [m]), v(function() {
    if (E !== null) {
      var ne = new google.maps.Data(Ke(Ke({}, t || {}), { map: E }));
      r && k(google.maps.event.addListener(ne, "dblclick", r)), o && M(google.maps.event.addListener(ne, "mousedown", o)), i && W(google.maps.event.addListener(ne, "mousemove", i)), s && X(google.maps.event.addListener(ne, "mouseout", s)), a && te(google.maps.event.addListener(ne, "mouseover", a)), l && q(google.maps.event.addListener(ne, "mouseup", l)), u && G(google.maps.event.addListener(ne, "rightclick", u)), n && z(google.maps.event.addListener(ne, "click", n)), c && ee(google.maps.event.addListener(ne, "addfeature", c)), p && ue(google.maps.event.addListener(ne, "removefeature", p)), d && be(google.maps.event.addListener(ne, "removeproperty", d)), g && ae(google.maps.event.addListener(ne, "setgeometry", g)), m && Te(google.maps.event.addListener(ne, "setproperty", m)), T(ne), f && f(ne);
    }
    return function() {
      x && (C !== null && google.maps.event.removeListener(C), U !== null && google.maps.event.removeListener(U), $ !== null && google.maps.event.removeListener($), H !== null && google.maps.event.removeListener(H), J !== null && google.maps.event.removeListener(J), P !== null && google.maps.event.removeListener(P), Z !== null && google.maps.event.removeListener(Z), F !== null && google.maps.event.removeListener(F), Y !== null && google.maps.event.removeListener(Y), se !== null && google.maps.event.removeListener(se), de !== null && google.maps.event.removeListener(de), me !== null && google.maps.event.removeListener(me), re !== null && google.maps.event.removeListener(re), h && h(x), x.setMap(null));
    };
  }, []), null;
}
Re(JF);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      data: null
    }, n.setDataCallback = function() {
      n.state.data !== null && n.props.onLoad && n.props.onLoad(n.state.data);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (this.context !== null) {
      var n = new google.maps.Data(Ke(Ke({}, this.props.options || {}), { map: this.context }));
      this.registeredEvents = wt({
        updaterMap: Qw,
        eventMap: Xw,
        prevProps: {},
        nextProps: this.props,
        instance: n
      }), this.setState(function() {
        return {
          data: n
        };
      }, this.setDataCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.data !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: Qw,
      eventMap: Xw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.data
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Ot(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
var Jw = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, e1 = {
  options: function(e, t) {
    e.setOptions(t);
  },
  url: function(e, t) {
    e.setUrl(t);
  },
  zIndex: function(e, t) {
    e.setZIndex(t);
  }
};
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      kmlLayer: null
    }, n.setKmlLayerCallback = function() {
      n.state.kmlLayer !== null && n.props.onLoad && n.props.onLoad(n.state.kmlLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.KmlLayer(Ke(Ke({}, this.props.options), { map: this.context }));
    this.registeredEvents = wt({
      updaterMap: e1,
      eventMap: Jw,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        kmlLayer: n
      };
    }, this.setKmlLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.kmlLayer !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: e1,
      eventMap: Jw,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Ot(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
function qS(e, t) {
  return typeof t == "function" ? t(e.offsetWidth, e.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function eR(e, t) {
  return new t(e.lat, e.lng);
}
function tR(e, t) {
  return new t(new google.maps.LatLng(e.ne.lat, e.ne.lng), new google.maps.LatLng(e.sw.lat, e.sw.lng));
}
function nR(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function rR(e, t, n) {
  return e instanceof t ? e : n(e, t);
}
function oR(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n.getNorthEast()), o = e && e.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + t.x, "px"),
    top: "".concat(r.y + t.y, "px"),
    width: "".concat(r.x - o.x - t.x, "px"),
    height: "".concat(o.y - r.y - t.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function iR(e, t, n) {
  var r = e && e.fromLatLngToDivPixel(n);
  if (r) {
    var o = r.x, i = r.y;
    return {
      left: "".concat(o + t.x, "px"),
      top: "".concat(i + t.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function GS(e, t, n, r) {
  return n !== void 0 ? oR(e, t, rR(n, google.maps.LatLngBounds, tR)) : iR(e, t, nR(r, google.maps.LatLng, eR));
}
function sR(e, t) {
  return e.left === t.left && e.top === t.top && e.width === t.height && e.height === t.height;
}
function aR(e, t, n, r, o) {
  var i = (
    /** @class */
    function(s) {
      vn(a, s);
      function a(l, u, c, p) {
        var d = s.call(this) || this;
        return d.container = l, d.pane = u, d.position = c, d.bounds = p, d;
      }
      return a.prototype.onAdd = function() {
        var l, u = (l = this.getPanes()) === null || l === void 0 ? void 0 : l[this.pane];
        u == null || u.appendChild(this.container);
      }, a.prototype.draw = function() {
        for (var l = this.getProjection(), u = Ke({}, this.container ? qS(this.container, o) : {
          x: 0,
          y: 0
        }), c = GS(l, u, this.bounds, this.position), p = 0, d = Object.entries(c); p < d.length; p++) {
          var g = d[p], m = g[0], f = g[1];
          this.container.style[m] = f;
        }
      }, a.prototype.onRemove = function() {
        this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
      }, a;
    }(google.maps.OverlayView)
  );
  return new i(e, t, n, r);
}
function t1(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLng ? e : new google.maps.LatLng(e.lat, e.lng);
  return t + "";
}
function n1(e) {
  if (!e)
    return "";
  var t = e instanceof google.maps.LatLngBounds ? e : new google.maps.LatLngBounds(new google.maps.LatLng(e.south, e.east), new google.maps.LatLng(e.north, e.west));
  return t + "";
}
function lR(e) {
  var t = e.position, n = e.bounds, r = e.mapPaneName, o = e.zIndex, i = e.onLoad, s = e.onUnmount, a = e.getPixelPositionOffset, l = e.children, u = _e(at), c = rr(function() {
    var d = document.createElement("div");
    return d.style.position = "absolute", d;
  }, []), p = rr(function() {
    return aR(c, r, t, n, a);
  }, [c, r, t, n]);
  return v(function() {
    return i == null || i(p), p == null || p.setMap(u), function() {
      s == null || s(p), p == null || p.setMap(null);
    };
  }, [u, p]), v(function() {
    c.style.zIndex = "".concat(o);
  }, [o, c]), Di.createPortal(l, c);
}
Re(lR);
(function(e) {
  vn(t, e);
  function t(n) {
    var r = e.call(this, n) || this;
    r.state = {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }, r.updatePane = function() {
      var i = r.props.mapPaneName, s = r.overlayView.getPanes();
      ar(!!i, "OverlayView requires props.mapPaneName but got %s", i), s ? r.setState({
        paneEl: s[i]
      }) : r.setState({
        paneEl: null
      });
    }, r.onAdd = function() {
      var i, s;
      r.updatePane(), (s = (i = r.props).onLoad) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.onPositionElement = function() {
      var i = r.overlayView.getProjection(), s = Ke({ x: 0, y: 0 }, r.containerRef.current ? qS(r.containerRef.current, r.props.getPixelPositionOffset) : {}), a = GS(i, s, r.props.bounds, r.props.position), l = r.state.containerStyle, u = l.left, c = l.top, p = l.width, d = l.height;
      sR(a, { left: u, top: c, width: p, height: d }) || r.setState({
        containerStyle: {
          top: a.top || 0,
          left: a.left || 0,
          width: a.width || 0,
          height: a.height || 0,
          position: "absolute"
        }
      });
    }, r.draw = function() {
      r.onPositionElement();
    }, r.onRemove = function() {
      var i, s;
      r.setState(function() {
        return {
          paneEl: null
        };
      }), (s = (i = r.props).onUnmount) === null || s === void 0 || s.call(i, r.overlayView);
    }, r.containerRef = xr();
    var o = new google.maps.OverlayView();
    return o.onAdd = r.onAdd, o.draw = r.draw, o.onRemove = r.onRemove, r.overlayView = o, r;
  }
  return t.prototype.componentDidMount = function() {
    this.overlayView.setMap(this.context);
  }, t.prototype.componentDidUpdate = function(n) {
    var r = t1(n.position), o = t1(this.props.position), i = n1(n.bounds), s = n1(this.props.bounds);
    (r !== o || i !== s) && this.overlayView.draw(), n.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }, t.prototype.componentWillUnmount = function() {
    this.overlayView.setMap(null);
  }, t.prototype.render = function() {
    var n = this.state.paneEl;
    return n ? Di.createPortal(hr.jsx("div", { ref: this.containerRef, style: this.state.containerStyle, children: Mt.only(this.props.children) }), n) : null;
  }, t.FLOAT_PANE = "floatPane", t.MAP_PANE = "mapPane", t.MARKER_LAYER = "markerLayer", t.OVERLAY_LAYER = "overlayLayer", t.OVERLAY_MOUSE_TARGET = "overlayMouseTarget", t.contextType = at, t;
})(ke);
function uR() {
}
var r1 = {
  onDblClick: "dblclick",
  onClick: "click"
}, o1 = {
  opacity: function(e, t) {
    e.setOpacity(t);
  }
};
function cR(e) {
  var t = e.url, n = e.bounds, r = e.options, o = e.visible, i = _e(at), s = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), a = rr(function() {
    var l = new google.maps.GroundOverlay(t, s, Ke({}, r));
    return l;
  }, []);
  return v(function() {
    a !== null && a.setMap(i);
  }, [i]), v(function() {
    typeof t < "u" && a !== null && (a.set("url", t), a.setMap(i));
  }, [a, t]), v(function() {
    typeof o < "u" && a !== null && a.setOpacity(o ? 1 : 0);
  }, [a, o]), v(function() {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && a !== null && (a.set("bounds", l), a.setMap(i));
  }, [a, n]), null;
}
Re(cR);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      groundOverlay: null
    }, n.setGroundOverlayCallback = function() {
      n.state.groundOverlay !== null && n.props.onLoad && n.props.onLoad(n.state.groundOverlay);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    ar(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var n = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Ke(Ke({}, this.props.options), { map: this.context }));
    this.registeredEvents = wt({
      updaterMap: o1,
      eventMap: r1,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        groundOverlay: n
      };
    }, this.setGroundOverlayCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.groundOverlay !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: o1,
      eventMap: r1,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.defaultProps = {
    onLoad: uR
  }, t.contextType = at, t;
})(ke);
var i1 = {}, s1 = {
  data: function(e, t) {
    e.setData(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  }
};
function pR(e) {
  var t = e.data, n = e.onLoad, r = e.onUnmount, o = e.options, i = _e(at), s = D(null), a = s[0], l = s[1];
  return v(function() {
    google.maps.visualization || ar(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), v(function() {
    ar(!!t, "data property is required in HeatmapLayer %s", t);
  }, [t]), v(function() {
    a !== null && a.setMap(i);
  }, [i]), v(function() {
    o && a !== null && a.setOptions(o);
  }, [a, o]), v(function() {
    var u = new google.maps.visualization.HeatmapLayer(Ke(Ke({}, o || {}), { data: t, map: i }));
    return l(u), n && n(u), function() {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Re(pR);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      heatmapLayer: null
    }, n.setHeatmapLayerCallback = function() {
      n.state.heatmapLayer !== null && n.props.onLoad && n.props.onLoad(n.state.heatmapLayer);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    ar(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), ar(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var n = new google.maps.visualization.HeatmapLayer(Ke(Ke({}, this.props.options || {}), { data: this.props.data, map: this.context }));
    this.registeredEvents = wt({
      updaterMap: s1,
      eventMap: i1,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        heatmapLayer: n
      };
    }, this.setHeatmapLayerCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: s1,
      eventMap: i1,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Ot(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
var a1 = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, l1 = {
  register: function(e, t, n) {
    e.registerPanoProvider(t, n);
  },
  links: function(e, t) {
    e.setLinks(t);
  },
  motionTracking: function(e, t) {
    e.setMotionTracking(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  pano: function(e, t) {
    e.setPano(t);
  },
  position: function(e, t) {
    e.setPosition(t);
  },
  pov: function(e, t) {
    e.setPov(t);
  },
  visible: function(e, t) {
    e.setVisible(t);
  },
  zoom: function(e, t) {
    e.setZoom(t);
  }
};
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      streetViewPanorama: null
    }, n.setStreetViewPanoramaCallback = function() {
      n.state.streetViewPanorama !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewPanorama);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n, r, o = (r = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && r !== void 0 ? r : null;
    this.registeredEvents = wt({
      updaterMap: l1,
      eventMap: a1,
      prevProps: {},
      nextProps: this.props,
      instance: o
    }), this.setState(function() {
      return {
        streetViewPanorama: o
      };
    }, this.setStreetViewPanoramaCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.streetViewPanorama !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: l1,
      eventMap: a1,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Ot(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      streetViewService: null
    }, n.setStreetViewServiceCallback = function() {
      n.state.streetViewService !== null && n.props.onLoad && n.props.onLoad(n.state.streetViewService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: n
      };
    }, this.setStreetViewServiceCallback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }, t.prototype.render = function() {
    return null;
  }, t.contextType = at, t;
})(ke);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      directionsService: null
    }, n.setDirectionsServiceCallback = function() {
      n.state.directionsService !== null && n.props.onLoad && n.props.onLoad(n.state.directionsService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    ar(!!this.props.options, "DirectionsService expected options object as parameter, but got %s", this.props.options);
    var n = new google.maps.DirectionsService();
    this.setState(function() {
      return {
        directionsService: n
      };
    }, this.setDirectionsServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.directionsService !== null && this.state.directionsService.route(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsService !== null && this.props.onUnmount && this.props.onUnmount(this.state.directionsService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(ke);
var u1 = {
  onDirectionsChanged: "directions_changed"
}, c1 = {
  directions: function(e, t) {
    e.setDirections(t);
  },
  map: function(e, t) {
    e.setMap(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  panel: function(e, t) {
    e.setPanel(t);
  },
  routeIndex: function(e, t) {
    e.setRouteIndex(t);
  }
};
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.state = {
      directionsRenderer: null
    }, n.setDirectionsRendererCallback = function() {
      n.state.directionsRenderer !== null && (n.state.directionsRenderer.setMap(n.context), n.props.onLoad && n.props.onLoad(n.state.directionsRenderer));
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = wt({
      updaterMap: c1,
      eventMap: u1,
      prevProps: {},
      nextProps: this.props,
      instance: n
    }), this.setState(function() {
      return {
        directionsRenderer: n
      };
    }, this.setDirectionsRendererCallback);
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.directionsRenderer !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: c1,
      eventMap: u1,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Ot(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }, t.prototype.render = function() {
    return hr.jsx(hr.Fragment, {});
  }, t.contextType = at, t;
})(ke);
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.state = {
      distanceMatrixService: null
    }, n.setDistanceMatrixServiceCallback = function() {
      n.state.distanceMatrixService !== null && n.props.onLoad && n.props.onLoad(n.state.distanceMatrixService);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    ar(!!this.props.options, "DistanceMatrixService expected options object as parameter, but go %s", this.props.options);
    var n = new google.maps.DistanceMatrixService();
    this.setState(function() {
      return {
        distanceMatrixService: n
      };
    }, this.setDistanceMatrixServiceCallback);
  }, t.prototype.componentDidUpdate = function() {
    this.state.distanceMatrixService !== null && this.state.distanceMatrixService.getDistanceMatrix(this.props.options, this.props.callback);
  }, t.prototype.componentWillUnmount = function() {
    this.state.distanceMatrixService !== null && this.props.onUnmount && this.props.onUnmount(this.state.distanceMatrixService);
  }, t.prototype.render = function() {
    return null;
  }, t;
})(ke);
var p1 = {
  onPlacesChanged: "places_changed"
}, d1 = {
  bounds: function(e, t) {
    e.setBounds(t);
  }
};
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = xr(), n.state = {
      searchBox: null
    }, n.setSearchBoxCallback = function() {
      n.state.searchBox !== null && n.props.onLoad && n.props.onLoad(n.state.searchBox);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    if (ar(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var n = this.containerElement.current.querySelector("input");
      if (n !== null) {
        var r = new google.maps.places.SearchBox(n, this.props.options);
        this.registeredEvents = wt({
          updaterMap: d1,
          eventMap: p1,
          prevProps: {},
          nextProps: this.props,
          instance: r
        }), this.setState(function() {
          return {
            searchBox: r
          };
        }, this.setSearchBoxCallback);
      }
    }
  }, t.prototype.componentDidUpdate = function(n) {
    this.state.searchBox !== null && (Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: d1,
      eventMap: p1,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }, t.prototype.componentWillUnmount = function() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Ot(this.registeredEvents));
  }, t.prototype.render = function() {
    return hr.jsx("div", { ref: this.containerElement, children: Mt.only(this.props.children) });
  }, t.contextType = at, t;
})(ke);
var f1 = {
  onPlaceChanged: "place_changed"
}, h1 = {
  bounds: function(e, t) {
    e.setBounds(t);
  },
  restrictions: function(e, t) {
    e.setComponentRestrictions(t);
  },
  fields: function(e, t) {
    e.setFields(t);
  },
  options: function(e, t) {
    e.setOptions(t);
  },
  types: function(e, t) {
    e.setTypes(t);
  }
};
(function(e) {
  vn(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.registeredEvents = [], n.containerElement = xr(), n.state = {
      autocomplete: null
    }, n.setAutocompleteCallback = function() {
      n.state.autocomplete !== null && n.props.onLoad && n.props.onLoad(n.state.autocomplete);
    }, n;
  }
  return t.prototype.componentDidMount = function() {
    var n;
    ar(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var r = (n = this.containerElement.current) === null || n === void 0 ? void 0 : n.querySelector("input");
    if (r) {
      var o = new google.maps.places.Autocomplete(r, this.props.options);
      this.registeredEvents = wt({
        updaterMap: h1,
        eventMap: f1,
        prevProps: {},
        nextProps: this.props,
        instance: o
      }), this.setState(function() {
        return {
          autocomplete: o
        };
      }, this.setAutocompleteCallback);
    }
  }, t.prototype.componentDidUpdate = function(n) {
    Ot(this.registeredEvents), this.registeredEvents = wt({
      updaterMap: h1,
      eventMap: f1,
      prevProps: n,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }, t.prototype.componentWillUnmount = function() {
    this.state.autocomplete !== null && Ot(this.registeredEvents);
  }, t.prototype.render = function() {
    return hr.jsx("div", { ref: this.containerElement, className: this.props.className, children: Mt.only(this.props.children) });
  }, t.defaultProps = {
    className: ""
  }, t.contextType = at, t;
})(ke);
Ye({});
function dR(e) {
  return e && e.replace(/[^0-9]/g, "");
}
const fR = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
dR(fR.CNPJ).length;
Fs((e, t) => /* @__PURE__ */ hr.jsx("input", { ref: t, ...e }));
Ye({});
var qo = {};
Object.defineProperty(qo, "__esModule", {
  value: !0
});
var hR = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Ud = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, KS = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: hR ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, bm = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Jl = 1; Jl < 20; Jl++)
  bm["f" + Jl] = 111 + Jl;
function Qc(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return YS(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return XS(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function gR(e, t) {
  return Qc(e, t);
}
function mR(e, t) {
  return Qc(e, { byKey: !0 }, t);
}
function YS(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Ud)
    r[Ud[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var m = wm(d), f = Ud[m];
      if (d.length > 1 && !f && !KS[d] && !bm[m])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !f) && (n ? r.key = m : r.which = QS(d)), f && (r[f] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function XS(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function QS(e) {
  e = wm(e);
  var t = bm[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function wm(e) {
  return e = e.toLowerCase(), e = KS[e] || e, e;
}
qo.default = Qc;
var $d = qo.isHotkey = Qc;
qo.isCodeHotkey = gR;
qo.isKeyHotkey = mR;
qo.parseHotkey = YS;
qo.compareHotkey = XS;
qo.toKeyCode = QS;
qo.toKeyName = wm;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function g1(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function br(e) {
  var t, n;
  return g1(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(g1(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var JS = Symbol.for("immer-nothing"), m1 = Symbol.for("immer-draftable"), Kr = Symbol.for("immer-state"), vR = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Br(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = vR[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var As = Object.getPrototypeOf;
function gs(e) {
  return !!e && !!e[Kr];
}
function ms(e) {
  var t;
  return e ? eO(e) || Array.isArray(e) || !!e[m1] || !!((t = e.constructor) != null && t[m1]) || ep(e) || tp(e) : !1;
}
var yR = Object.prototype.constructor.toString();
function eO(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = As(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === yR;
}
function wc(e, t) {
  Jc(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Jc(e) {
  const t = e[Kr];
  return t ? t.type_ : Array.isArray(e) ? 1 : ep(e) ? 2 : tp(e) ? 3 : 0;
}
function Hh(e, t) {
  return Jc(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function tO(e, t, n) {
  const r = Jc(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function bR(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function ep(e) {
  return e instanceof Map;
}
function tp(e) {
  return e instanceof Set;
}
function Xi(e) {
  return e.copy_ || e.base_;
}
function Vh(e, t) {
  if (ep(e))
    return new Map(e);
  if (tp(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = eO(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Kr];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(As(e), r);
  } else {
    const r = As(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Cm(e, t = !1) {
  return np(e) || gs(e) || !ms(e) || (Jc(e) > 1 && (e.set = e.add = e.clear = e.delete = wR), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Cm(r, !0))), e;
}
function wR() {
  Br(2);
}
function np(e) {
  return Object.isFrozen(e);
}
var CR = {};
function vs(e) {
  const t = CR[e];
  return t || Br(0, e), t;
}
var Wa;
function nO() {
  return Wa;
}
function ER(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function v1(e, t) {
  t && (vs("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function Zh(e) {
  qh(e), e.drafts_.forEach(xR), e.drafts_ = null;
}
function qh(e) {
  e === Wa && (Wa = e.parent_);
}
function y1(e) {
  return Wa = ER(Wa, e);
}
function xR(e) {
  const t = e[Kr];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function b1(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Kr].modified_ && (Zh(t), Br(4)), ms(e) && (e = Cc(t, e), t.parent_ || Ec(t, e)), t.patches_ && vs("Patches").generateReplacementPatches_(
    n[Kr].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Cc(t, n, []), Zh(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== JS ? e : void 0;
}
function Cc(e, t, n) {
  if (np(t))
    return t;
  const r = t[Kr];
  if (!r)
    return wc(
      t,
      (o, i) => w1(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Ec(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), wc(
      i,
      (a, l) => w1(e, r, o, a, l, n, s)
    ), Ec(e, o, !1), n && e.patches_ && vs("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function w1(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Br(5), gs(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Hh(t.assigned_, r) ? i.concat(r) : void 0, l = Cc(e, o, a);
    if (tO(n, r, l), gs(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (ms(o) && !np(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Cc(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Ec(e, o);
  }
}
function Ec(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Cm(t, n);
}
function LR(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : nO(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Em;
  n && (o = [r], i = Ha);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var Em = {
  get(e, t) {
    if (t === Kr)
      return e;
    const n = Xi(e);
    if (!Hh(n, t))
      return kR(e, n, t);
    const r = n[t];
    return e.finalized_ || !ms(r) ? r : r === Wd(e.base_, t) ? (Hd(e), e.copy_[t] = Kh(r, e)) : r;
  },
  has(e, t) {
    return t in Xi(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Xi(e));
  },
  set(e, t, n) {
    const r = rO(Xi(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Wd(Xi(e), t), i = o == null ? void 0 : o[Kr];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (bR(n, o) && (n !== void 0 || Hh(e.base_, t)))
        return !0;
      Hd(e), Gh(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Wd(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Hd(e), Gh(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Xi(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Br(11);
  },
  getPrototypeOf(e) {
    return As(e.base_);
  },
  setPrototypeOf() {
    Br(12);
  }
}, Ha = {};
wc(Em, (e, t) => {
  Ha[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Ha.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Br(13), Ha.set.call(this, e, t, void 0);
};
Ha.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Br(14), Em.set.call(this, e[0], t, n, e[0]);
};
function Wd(e, t) {
  const n = e[Kr];
  return (n ? Xi(n) : e)[t];
}
function kR(e, t, n) {
  var r;
  const o = rO(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function rO(e, t) {
  if (!(t in e))
    return;
  let n = As(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = As(n);
  }
}
function Gh(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Gh(e.parent_));
}
function Hd(e) {
  e.copy_ || (e.copy_ = Vh(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var DR = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Br(6), r !== void 0 && typeof r != "function" && Br(7);
      let o;
      if (ms(t)) {
        const i = y1(this), s = Kh(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? Zh(i) : qh(i);
        }
        return v1(i, r), b1(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === JS && (o = void 0), this.autoFreeze_ && Cm(o, !0), r) {
          const i = [], s = [];
          vs("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Br(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ms(e) || Br(8), gs(e) && (e = SR(e));
    const t = y1(this), n = Kh(e, void 0);
    return n[Kr].isManual_ = !0, qh(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Kr];
    (!n || !n.isManual_) && Br(9);
    const { scope_: r } = n;
    return v1(r, t), b1(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = vs("Patches").applyPatches_;
    return gs(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Kh(e, t) {
  const n = ep(e) ? vs("MapSet").proxyMap_(e, t) : tp(e) ? vs("MapSet").proxySet_(e, t) : LR(e, t);
  return (t ? t.scope_ : nO()).drafts_.push(n), n;
}
function SR(e) {
  return gs(e) || Br(10, e), oO(e);
}
function oO(e) {
  if (!ms(e) || np(e))
    return e;
  const t = e[Kr];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Vh(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Vh(e, !0);
  return wc(n, (r, o) => {
    tO(n, r, oO(o));
  }), t && (t.finalized_ = !1), n;
}
var Yr = new DR(), xm = Yr.produce;
Yr.produceWithPatches.bind(
  Yr
);
Yr.setAutoFreeze.bind(Yr);
Yr.setUseStrictShallowCopy.bind(Yr);
Yr.applyPatches.bind(Yr);
var C1 = Yr.createDraft.bind(Yr), E1 = Yr.finishDraft.bind(Yr), Oe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Oe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Oe.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Oe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Oe.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Oe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Oe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Oe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Oe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Oe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Oe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Oe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Oe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Oe.isAncestor(t, e) && !Oe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Oe.equals(i, r) || Oe.endsBefore(i, r) || Oe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (Oe.equals(s, r) || Oe.isAncestor(s, r))
          return null;
        Oe.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        Oe.equals(a, r) || Oe.endsBefore(a, r) ? r[a.length - 1] -= 1 : Oe.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Oe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Oe.endsBefore(u, r) ? r[u.length - 1] += 1 : Oe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Oe.equals(p, d))
          return r;
        if (Oe.isAncestor(p, r) || Oe.equals(p, r)) {
          var g = d.slice();
          return Oe.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Oe.isSibling(p, d) && (Oe.isAncestor(d, r) || Oe.equals(d, r)) ? Oe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Oe.endsBefore(d, r) || Oe.equals(d, r) || Oe.isAncestor(d, r) ? (Oe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Oe.endsBefore(p, r) && (Oe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Va(e) {
  "@babel/helpers - typeof";
  return Va = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Va(e);
}
function OR(e, t) {
  if (Va(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Va(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function MR(e) {
  var t = OR(e, "string");
  return Va(t) === "symbol" ? t : String(t);
}
function Rs(e, t, n) {
  return t = MR(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function x1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ca(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? x1(Object(n), !0).forEach(function(r) {
      Rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : x1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var PR = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Je.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of dt.points(t))
          t[l] = Cn.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Je.leaf(e, u), g = d.text.slice(0, c), m = d.text.slice(c);
      if (d.text = g + p + m, t)
        for (var [f, h] of dt.points(t))
          t[h] = Cn.transform(f, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, L = Je.get(e, E), x = Oe.previous(E), T = Je.get(e, x), w = Je.parent(e, E), C = E[E.length - 1];
      if (Yn.isText(L) && Yn.isText(T))
        T.text += L.text;
      else if (!Yn.isText(L) && !Yn.isText(T))
        T.children.push(...L.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Ur.stringify(L), " ").concat(Ur.stringify(T)));
      if (w.children.splice(C, 1), t)
        for (var [k, O] of dt.points(t))
          t[O] = Cn.transform(k, n);
      break;
    }
    case "move_node": {
      var {
        path: U,
        newPath: M
      } = n;
      if (Oe.isAncestor(U, M))
        throw new Error("Cannot move a path [".concat(U, "] to new path [").concat(M, "] because the destination is inside itself."));
      var V = Je.get(e, U), $ = Je.parent(e, U), W = U[U.length - 1];
      $.children.splice(W, 1);
      var R = Oe.transform(U, n), H = Je.get(e, Oe.parent(R)), X = R[R.length - 1];
      if (H.children.splice(X, 0, V), t)
        for (var [I, J] of dt.points(t))
          t[J] = Cn.transform(I, n);
      break;
    }
    case "remove_node": {
      var {
        path: te
      } = n, S = te[te.length - 1], P = Je.parent(e, te);
      if (P.children.splice(S, 1), t)
        for (var [q, j] of dt.points(t)) {
          var Z = Cn.transform(q, n);
          if (t != null && Z != null)
            t[j] = Z;
          else {
            var G = void 0, b = void 0;
            for (var [F, z] of Je.texts(e))
              if (Oe.compare(z, te) === -1)
                G = [F, z];
              else {
                b = [F, z];
                break;
              }
            var A = !1;
            G && b && (Oe.equals(b[1], te) ? A = !Oe.hasPrevious(b[1]) : A = Oe.common(G[1], te).length < Oe.common(b[1], te).length), G && !A ? (q.path = G[1], q.offset = G[0].text.length) : b ? (q.path = b[1], q.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: Y,
        offset: ee,
        text: B
      } = n;
      if (B.length === 0) break;
      var se = Je.leaf(e, Y), ue = se.text.slice(0, ee), ce = se.text.slice(ee + B.length);
      if (se.text = ue + ce, t)
        for (var [de, be] of dt.points(t))
          t[be] = Cn.transform(de, n);
      break;
    }
    case "set_node": {
      var {
        path: ge,
        properties: me,
        newProperties: ae
      } = n;
      if (ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var xe = Je.get(e, ge);
      for (var re in ae) {
        if (re === "children" || re === "text")
          throw new Error('Cannot set the "'.concat(re, '" property of nodes!'));
        var Te = ae[re];
        Te == null ? delete xe[re] : xe[re] = Te;
      }
      for (var ne in me)
        ae.hasOwnProperty(ne) || delete xe[ne];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Ee
      } = n;
      if (Ee == null)
        t = Ee;
      else {
        if (t == null) {
          if (!dt.isRange(Ee))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Ur.stringify(Ee), " when there is no current selection."));
          t = ca({}, Ee);
        }
        for (var Ne in Ee) {
          var Fe = Ee[Ne];
          if (Fe == null) {
            if (Ne === "anchor" || Ne === "focus")
              throw new Error('Cannot remove the "'.concat(Ne, '" selection property'));
            delete t[Ne];
          } else
            t[Ne] = Fe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: he,
        properties: Xe
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var He = Je.get(e, Ue), qt = Je.parent(e, Ue), lt = Ue[Ue.length - 1], mt;
      if (Yn.isText(He)) {
        var on = He.text.slice(0, he), sn = He.text.slice(he);
        He.text = on, mt = ca(ca({}, Xe), {}, {
          text: sn
        });
      } else {
        var an = He.children.slice(0, he), ln = He.children.slice(he);
        He.children = an, mt = ca(ca({}, Xe), {}, {
          children: ln
        });
      }
      if (qt.children.splice(lt + 1, 0, mt), t)
        for (var [nt, Rt] of dt.points(t))
          t[Rt] = Cn.transform(nt, n);
      break;
    }
  }
  return t;
}, TR = {
  transform(e, t) {
    e.children = C1(e.children);
    var n = e.selection && C1(e.selection);
    try {
      n = PR(e, n, t);
    } finally {
      e.children = E1(e.children), n ? e.selection = gs(n) ? E1(n) : n : e.selection = null;
    }
  }
}, AR = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, BR = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, iO = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (br(r) && br(o)) {
      if (!iO(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function _R(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Za(e, t) {
  if (e == null) return {};
  var n = _R(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var IR = ["anchor", "focus"];
function L1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function jR(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? L1(Object(n), !0).forEach(function(r) {
      Rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : L1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var dt = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return dt.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = dt.edges(e);
    return t;
  },
  equals(e, t) {
    return Cn.equals(e.anchor, t.anchor) && Cn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (dt.isRange(t)) {
      if (dt.includes(e, t.anchor) || dt.includes(e, t.focus))
        return !0;
      var [n, r] = dt.edges(e), [o, i] = dt.edges(t);
      return Cn.isBefore(n, o) && Cn.isAfter(r, i);
    }
    var [s, a] = dt.edges(e), l = !1, u = !1;
    return Cn.isPoint(t) ? (l = Cn.compare(t, s) >= 0, u = Cn.compare(t, a) <= 0) : (l = Oe.compare(t, s.path) >= 0, u = Oe.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Za(e, IR), [r, o] = dt.edges(e), [i, s] = dt.edges(t), a = Cn.isBefore(r, i) ? i : r, l = Cn.isBefore(o, s) ? o : s;
    return Cn.isBefore(l, a) ? null : jR({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Cn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return Cn.equals(t, n);
  },
  isExpanded(e) {
    return !dt.isCollapsed(e);
  },
  isForward(e) {
    return !dt.isBackward(e);
  },
  isRange(e) {
    return br(e) && Cn.isPoint(e.anchor) && Cn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = dt.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return xm(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = dt.isCollapsed(r);
        dt.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? dt.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = Cn.transform(r.anchor, t, {
        affinity: i
      }), u = Cn.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, k1 = (e) => br(e) && Je.isNodeList(e.children) && !Xt.isEditor(e), No = {
  isAncestor(e) {
    return br(e) && Je.isNodeList(e.children);
  },
  isElement: k1,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => No.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return k1(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, NR = ["children"], FR = ["text"], D1 = /* @__PURE__ */ new WeakMap(), Je = {
  ancestor(e, t) {
    var n = Je.get(e, t);
    if (Yn.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Ur.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Oe.ancestors(t, n)) {
        var o = Je.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Yn.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Ur.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Ur.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Je.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = Je.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Oe.common(t, n), o = Je.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Je.get(e, t);
    if (Xt.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Ur.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Je.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Je.nodes(e, t))
        No.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (No.isAncestor(e)) {
      var t = Za(e, NR);
      return t;
    } else {
      var t = Za(e, FR);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Je.get(e, n); r && !(Yn.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Yn.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Ur.stringify(e)));
    var n = xm({
      children: e.children
    }, (r) => {
      var [o, i] = dt.edges(t), s = Je.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !dt.includes(t, g);
        }
      });
      for (var [, a] of s) {
        if (!dt.includes(t, a)) {
          var l = Je.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (Oe.equals(a, i.path)) {
          var c = Je.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (Oe.equals(a, o.path)) {
          var p = Je.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      Xt.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Yn.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Ur.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Yn.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Yn.isText(e) || No.isElement(e) || Xt.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = D1.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Je.isNode(r));
    return D1.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Je.get(e, n); r && !(Yn.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Je.get(e, t);
    if (!Yn.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Ur.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Oe.levels(t, n)) {
        var o = Je.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return No.isElement(e) && No.isElementProps(t) && No.matches(e, t) || Yn.isText(e) && Yn.isTextProps(t) && Yn.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? Oe.isBefore(a, i) : Oe.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Yn.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          Oe.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = Je.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = Oe.next(a);
          if (Je.has(e, c)) {
            a = c, l = Je.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = Oe.previous(a);
          a = p, l = Je.get(e, a);
          continue;
        }
        a = Oe.parent(a), l = Je.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Oe.parent(t), r = Je.get(e, n);
    if (Yn.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Yn.isText(e) ? e.text : e.children.map(Je.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Je.nodes(e, t))
        Yn.isText(n) && (yield [n, r]);
    }();
  }
};
function S1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ln(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? S1(Object(n), !0).forEach(function(r) {
      Rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : S1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ma = {
  isNodeOperation(e) {
    return ma.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!br(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Oe.isPath(e.path) && Je.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Oe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Oe.isPath(e.path) && br(e.properties);
      case "move_node":
        return Oe.isPath(e.path) && Oe.isPath(e.newPath);
      case "remove_node":
        return Oe.isPath(e.path) && Je.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Oe.isPath(e.path);
      case "set_node":
        return Oe.isPath(e.path) && br(e.properties) && br(e.newProperties);
      case "set_selection":
        return e.properties === null && dt.isRange(e.newProperties) || e.newProperties === null && dt.isRange(e.properties) || br(e.properties) && br(e.newProperties);
      case "split_node":
        return Oe.isPath(e.path) && typeof e.position == "number" && br(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => ma.isOperation(t));
  },
  isSelectionOperation(e) {
    return ma.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return ma.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Ln(Ln({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Ln(Ln({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Ln(Ln({}, e), {}, {
          type: "split_node",
          path: Oe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Oe.equals(t, n))
          return e;
        if (Oe.isSibling(n, t))
          return Ln(Ln({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Oe.transform(n, e), o = Oe.transform(Oe.next(n), e);
        return Ln(Ln({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Ln(Ln({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Ln(Ln({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Ln(Ln({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? Ln(Ln({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Ln(Ln({}, e), {}, {
          properties: null,
          newProperties: a
        }) : Ln(Ln({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return Ln(Ln({}, e), {}, {
          type: "merge_node",
          path: Oe.next(e.path)
        });
    }
  }
}, O1 = /* @__PURE__ */ new WeakMap(), RR = (e) => {
  var t = O1.get(e);
  if (t !== void 0)
    return t;
  if (!br(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || br(e.marks)) && (e.selection === null || dt.isRange(e.selection)) && Je.isNodeList(e.children) && ma.isOperationList(e.operations);
  return O1.set(e, n), n;
}, Xt = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return RR(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function M1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function P1(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? M1(Object(n), !0).forEach(function(r) {
      Rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : M1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Cn = {
  compare(e, t) {
    var n = Oe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return Cn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return Cn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Oe.equals(e.path, t.path);
  },
  isPoint(e) {
    return br(e) && typeof e.offset == "number" && Oe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return xm(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Oe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Oe.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Oe.equals(t.path, i) && (r.offset += t.position), r.path = Oe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Oe.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Oe.equals(t.path, i) || Oe.isAncestor(t.path, i))
            return null;
          r.path = Oe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Oe.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = Oe.transform(i, t, P1(P1({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Oe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, T1 = void 0, Ur = {
  setScrubber(e) {
    T1 = e;
  },
  stringify(e) {
    return JSON.stringify(e, T1);
  }
}, zR = ["text"], UR = ["anchor", "focus"];
function A1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Mo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? A1(Object(n), !0).forEach(function(r) {
      Rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : A1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Yn = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = Za(i, zR);
      return s;
    }
    return iO(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return br(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Yn.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Mo({}, e)];
    for (var r of t) {
      var o = Za(r, UR), [i, s] = dt.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          a.push(p);
          continue;
        }
        var m = p, f = void 0, h = void 0;
        if (c < l) {
          var E = c - g;
          h = Mo(Mo({}, m), {}, {
            text: m.text.slice(E)
          }), m = Mo(Mo({}, m), {}, {
            text: m.text.slice(0, E)
          });
        }
        if (u > g) {
          var L = u - g;
          f = Mo(Mo({}, m), {}, {
            text: m.text.slice(0, L)
          }), m = Mo(Mo({}, m), {}, {
            text: m.text.slice(L)
          });
        }
        Object.assign(m, o), f && a.push(f), a.push(m), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, $R = (e) => e.selection ? e.selection : e.children.length > 0 ? Xt.end(e, []) : [0], yn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(yn || (yn = {}));
yn.L, yn.L | yn.V | yn.LV | yn.LVT, yn.LV | yn.V, yn.V | yn.T, yn.LVT | yn.T, yn.T, yn.Any, yn.Extend | yn.ZWJ, yn.Any, yn.SpacingMark, yn.Prepend, yn.Any, yn.ZWJ, yn.ExtPict, yn.RI, yn.RI;
var WR = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Xt.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = $R(e)
      } = n;
      if (Oe.isPath(o) && (o = Xt.range(e, o)), dt.isRange(o))
        if (dt.isCollapsed(o))
          o = o.anchor;
        else {
          var i = dt.end(o);
          if (!r && Xt.void(e, {
            at: i
          }))
            return;
          var s = dt.start(o), a = Xt.pointRef(e, s), l = Xt.pointRef(e, i);
          xc.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, xc.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Xt.void(e, {
        at: o
      }) || Xt.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function B1(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function eu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? B1(Object(n), !0).forEach(function(r) {
      Rs(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : B1(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xc = eu(eu(eu(eu({}, TR), AR), BR), WR), HR = typeof rn == "object" && rn && rn.Object === Object && rn, VR = HR, ZR = VR, qR = typeof self == "object" && self && self.Object === Object && self, GR = ZR || qR || Function("return this")(), KR = GR, YR = KR, XR = YR.Symbol, sO = XR, _1 = sO;
_1 && _1.toStringTag;
var I1 = sO;
I1 && I1.toStringTag;
var j1;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(j1 || (j1 = {}));
var Lm = function(e) {
  return Object.freeze(e);
}, QR = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Lm(this);
  }
  return e;
}(), JR = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Lm(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), N1 = typeof window < "u" ? window : {};
/msie|trident/i.test(N1.navigator && N1.navigator.userAgent);
var Vd = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new QR((n ? t : e) || 0, (n ? e : t) || 0);
};
Lm({
  devicePixelContentBoxSize: Vd(),
  borderBoxSize: Vd(),
  contentBoxSize: Vd(),
  contentRect: new JR(0, 0, 0, 0)
});
function qa(e) {
  "@babel/helpers - typeof";
  return qa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, qa(e);
}
function e2(e, t) {
  if (qa(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (qa(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function t2(e) {
  var t = e2(e, "string");
  return qa(t) === "symbol" ? t : String(t);
}
function Sa(e, t, n) {
  return t = t2(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var n2 = /* @__PURE__ */ Ye(null), Zd, qd;
parseInt(Be.version.split(".")[0], 10);
var F1 = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Gd = typeof navigator < "u" && /Android/.test(navigator.userAgent), tu = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), r2 = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (Zd = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Zd !== void 0 && Zd[1] && parseInt((qd = navigator.userAgent.match(/Version\/(\d+)/)) === null || qd === void 0 ? void 0 : qd[1], 10) < 17;
var o2 = /* @__PURE__ */ new WeakMap(), i2 = /* @__PURE__ */ new WeakMap(), s2 = /* @__PURE__ */ new WeakMap(), a2 = /* @__PURE__ */ new WeakMap(), l2 = /* @__PURE__ */ new WeakMap(), R1 = /* @__PURE__ */ new WeakMap(), u2 = /* @__PURE__ */ new WeakMap(), z1 = /* @__PURE__ */ new WeakMap(), nu = /* @__PURE__ */ new WeakMap(), c2 = /* @__PURE__ */ new WeakMap(), p2 = /* @__PURE__ */ new WeakMap(), d2 = /* @__PURE__ */ new WeakMap(), aO = globalThis.Node, f2 = globalThis.Text, lO = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, h2 = (e) => Lc(e) && e.nodeType === 8, Eo = (e) => Lc(e) && e.nodeType === 1, Lc = (e) => {
  var t = lO(e);
  return !!t && e instanceof t.Node;
}, U1 = (e) => {
  var t = e && e.anchorNode && lO(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, g2 = (e) => {
  var [t, n] = e;
  if (Eo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = uO(t, o, r ? "backward" : "forward"), r = o < n; Eo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = v2(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, m2 = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, uO = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (h2(o) || Eo(o) && o.childNodes.length === 0 || Eo(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, v2 = (e, t, n) => {
  var [r] = uO(e, t, n);
  return r;
}, $1 = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), cO = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Eo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Pt.getWindow(e);
  if (o.contains(r))
    return Pt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : cO(e, i, n);
}, W1 = (e, t) => !!(e.compareDocumentPosition(t) & aO.DOCUMENT_POSITION_PRECEDING), y2 = (e, t) => !!(e.compareDocumentPosition(t) & aO.DOCUMENT_POSITION_FOLLOWING), b2 = 0;
class w2 {
  constructor() {
    Sa(this, "id", void 0), this.id = "".concat(b2++);
  }
}
var Pt = {
  androidPendingDiffs: (e) => d2.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = p2.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Pt.toDOMNode(e, e), n = Pt.findDocumentOrShadowRoot(e);
    nu.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Pt.findDocumentOrShadowRoot(e), r = $1(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && xc.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Pt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Pt.toSlateNode(e, t.target), s = Pt.findPath(e, i);
    if (No.isElement(i) && Xt.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = Xt.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? Xt.before(e, u) : Xt.after(e, u);
      if (c) {
        var p = Xt.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = Pt.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var m = g.caretPositionFromPoint(n, r);
      m && (d = g.createRange(), d.setStart(m.offsetNode, m.offset), d.setEnd(m.offsetNode, m.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var f = Pt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return f;
  },
  findKey: (e, t) => {
    var n = R1.get(t);
    return n || (n = new w2(), R1.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = i2.get(r);
      if (o == null) {
        if (Xt.isEditor(r))
          return n;
        break;
      }
      var i = o2.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Ur.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!nu.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Pt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Pt.toDOMNode(e, e), r = Pt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = $1(r), i = Pt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || xc.select(e, Xt.start(e, [])), nu.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = s2.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Pt.toDOMNode(e, e), i;
    try {
      i = Eo(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Lc(t) && Pt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Xt.hasPath(e, n.path) && Xt.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Pt.hasEditableTarget(e, t) || Pt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Lc(t) && Pt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!c2.get(e),
  isFocused: (e) => !!nu.get(e),
  isReadOnly: (e) => !!z1.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (z1.get(e)) return !1;
    var n = Pt.hasTarget(e, t) && Pt.toSlateNode(e, t);
    return No.isElement(n) && Xt.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = u2.get(e), r = Xt.isEditor(t) ? a2.get(e) : n == null ? void 0 : n.get(Pt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Ur.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Xt.node(e, t.path), r = Pt.toDOMNode(e, n), o;
    Xt.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), m = a + g, f = s[l + 1];
        if (t.offset === m && f !== null && f !== void 0 && f.hasAttribute("data-slate-mark-placeholder")) {
          var h, E = f.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof f2 ? E : f,
            (h = f.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= m) {
          var L = Math.min(p, Math.max(0, t.offset - a));
          o = [c, L];
          break;
        }
        a = m;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Ur.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = dt.isBackward(t), i = Pt.toDOMPoint(e, n), s = dt.isCollapsed(t) ? i : Pt.toDOMPoint(e, r), a = Pt.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, g = Eo(u) ? u : u.parentElement, m = !!g.getAttribute("data-slate-zero-width"), f = Eo(p) ? p : p.parentElement, h = !!f.getAttribute("data-slate-zero-width");
    return l.setStart(u, m ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Eo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? l2.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : g2(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = Pt.toDOMNode(e, e), m = l.closest('[data-slate-void="true"]'), f = m && g.contains(m) ? m : null, h = l.closest('[contenteditable="false"]'), E = h && g.contains(h) ? h : null, L = l.closest("[data-slate-leaf]"), x = null;
      if (L) {
        if (u = L.closest('[data-slate-node="text"]'), u) {
          var T = Pt.getWindow(e), w = T.document.createRange();
          w.setStart(u, 0), w.setEnd(s, a);
          var C = w.cloneContents(), k = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          k.forEach((j) => {
            if (Gd && !r && j.hasAttribute("data-slate-zero-width") && j.textContent.length > 0 && j.textContext !== "\uFEFF") {
              j.textContent.startsWith("\uFEFF") && (j.textContent = j.textContent.slice(1));
              return;
            }
            j.parentNode.removeChild(j);
          }), c = C.textContent.length, x = u;
        }
      } else if (f) {
        for (var O = f.querySelectorAll("[data-slate-leaf]"), U = 0; U < O.length; U++) {
          var M = O[U];
          if (Pt.hasDOMNode(e, M)) {
            L = M;
            break;
          }
        }
        L ? (u = L.closest('[data-slate-node="text"]'), x = L, c = x.textContent.length, x.querySelectorAll("[data-slate-zero-width]").forEach((j) => {
          c -= j.textContent.length;
        })) : c = 1;
      } else if (E) {
        var V = (j) => j ? j.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var W, R = [...V($), ...V($ == null ? void 0 : $.nextElementSibling)];
          L = (W = R.find((j) => y2(E, j))) !== null && W !== void 0 ? W : null;
        } else {
          var H, X = [...V($ == null ? void 0 : $.previousElementSibling), ...V($)];
          L = (H = X.findLast((j) => W1(E, j))) !== null && H !== void 0 ? H : null;
        }
        L && (u = L.closest('[data-slate-node="text"]'), x = L, i === "forward" ? c = 0 : (c = x.textContent.length, x.querySelectorAll("[data-slate-zero-width]").forEach((j) => {
          c -= j.textContent.length;
        })));
      }
      x && c === x.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Gd && x.getAttribute("data-slate-zero-width") === "z" && (p = x.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      tu && (d = x.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Gd && !u && !r) {
      var I = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (I && Pt.hasDOMNode(e, I, {
        editable: !0
      })) {
        var J = Pt.toSlateNode(e, I), {
          path: te,
          offset: S
        } = Xt.start(e, Pt.findPath(e, J));
        return I.querySelector("[data-slate-leaf]") || (S = a), {
          path: te,
          offset: S
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var P = Pt.toSlateNode(e, u), q = Pt.findPath(e, P);
    return {
      path: q,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = U1(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (U1(t)) {
        if (tu && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(k) {
              return k.childElementCount > 0 ? C(k.children[0]) : k;
            };
            var m = d.startContainer, f = g.startContainer, h = C(m.children[d.startOffset]), E = C(f.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? a = E.childNodes[0] : a = E, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = g.endContainer, l = g.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        r2 && m2(a) || tu ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    tu && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var L = Pt.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!L)
      return null;
    var x = W1(a, u) || a === u && c < l, T = p ? L : Pt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: x ? "forward" : "backward"
    });
    if (!T)
      return null;
    var w = {
      anchor: L,
      focus: T
    };
    return dt.isExpanded(w) && dt.isForward(w) && Eo(u) && Xt.void(e, {
      at: w.focus,
      mode: "highest"
    }) && (w = Xt.unhangRange(e, w, {
      voids: !0
    })), w;
  }
}, C2 = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, E2 = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, x2 = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, kn = (e) => {
  var t = C2[e], n = E2[e], r = x2[e], o = t && $d(t), i = n && $d(n), s = r && $d(r);
  return (a) => !!(o && o(a) || F1 && i && i(a) || !F1 && s && s(a));
};
kn("bold"), kn("compose"), kn("moveBackward"), kn("moveForward"), kn("deleteBackward"), kn("deleteForward"), kn("deleteLineBackward"), kn("deleteLineForward"), kn("deleteWordBackward"), kn("deleteWordForward"), kn("extendBackward"), kn("extendForward"), kn("extendLineBackward"), kn("extendLineForward"), kn("italic"), kn("moveLineBackward"), kn("moveLineForward"), kn("moveWordBackward"), kn("moveWordForward"), kn("redo"), kn("insertSoftBreak"), kn("splitBlock"), kn("transposeCharacter"), kn("undo");
var L2 = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => cO(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, k2 = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class D2 extends Yc {
  constructor() {
    super(...arguments), Sa(this, "context", null), Sa(this, "manager", null), Sa(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, k2);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = L2(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Sa(D2, "contextType", n2);
var pO = {}, km = {}, Dm = {};
Object.defineProperty(Dm, "__esModule", { value: !0 });
Dm.default = P2;
var H1 = "html", V1 = "head", ru = "body", S2 = /<([a-zA-Z]+[0-9]?)/, Z1 = /<head[^]*>/i, q1 = /<body[^]*>/i, kc = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Yh = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, G1 = typeof window == "object" && window.DOMParser;
if (typeof G1 == "function") {
  var O2 = new G1(), M2 = "text/html";
  Yh = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), O2.parseFromString(e, M2);
  }, kc = Yh;
}
if (typeof document == "object" && document.implementation) {
  var ou = document.implementation.createHTMLDocument();
  kc = function(e, t) {
    if (t) {
      var n = ou.documentElement.querySelector(t);
      return n && (n.innerHTML = e), ou;
    }
    return ou.documentElement.innerHTML = e, ou;
  };
}
var iu = typeof document == "object" && document.createElement("template"), Xh;
iu && iu.content && (Xh = function(e) {
  return iu.innerHTML = e, iu.content.childNodes;
});
function P2(e) {
  var t, n, r = e.match(S2), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case H1: {
      var i = Yh(e);
      if (!Z1.test(e)) {
        var s = i.querySelector(V1);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!q1.test(e)) {
        var s = i.querySelector(ru);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(H1);
    }
    case V1:
    case ru: {
      var a = kc(e).querySelectorAll(o);
      return q1.test(e) && Z1.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (Xh)
        return Xh(e);
      var s = kc(e, ru).querySelector(ru);
      return s.childNodes;
    }
  }
}
var rp = {}, Sm = {}, Om = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Om);
var Ct = {}, Si = rn && rn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Oa = rn && rn.__assign || function() {
  return Oa = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Oa.apply(this, arguments);
};
Object.defineProperty(Ct, "__esModule", { value: !0 });
Ct.cloneNode = Ct.hasChildren = Ct.isDocument = Ct.isDirective = Ct.isComment = Ct.isText = Ct.isCDATA = Ct.isTag = Ct.Element = Ct.Document = Ct.CDATA = Ct.NodeWithChildren = Ct.ProcessingInstruction = Ct.Comment = Ct.Text = Ct.DataNode = Ct.Node = void 0;
var Nr = Om, Mm = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Pm(this, t);
    }, e;
  }()
);
Ct.Node = Mm;
var op = (
  /** @class */
  function(e) {
    Si(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mm)
);
Ct.DataNode = op;
var dO = (
  /** @class */
  function(e) {
    Si(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Nr.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(op)
);
Ct.Text = dO;
var fO = (
  /** @class */
  function(e) {
    Si(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Nr.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(op)
);
Ct.Comment = fO;
var hO = (
  /** @class */
  function(e) {
    Si(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Nr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(op)
);
Ct.ProcessingInstruction = hO;
var ip = (
  /** @class */
  function(e) {
    Si(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mm)
);
Ct.NodeWithChildren = ip;
var gO = (
  /** @class */
  function(e) {
    Si(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Nr.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ip)
);
Ct.CDATA = gO;
var mO = (
  /** @class */
  function(e) {
    Si(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Nr.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ip)
);
Ct.Document = mO;
var vO = (
  /** @class */
  function(e) {
    Si(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Nr.ElementType.Script : n === "style" ? Nr.ElementType.Style : Nr.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(ip)
);
Ct.Element = vO;
function yO(e) {
  return (0, Nr.isTag)(e);
}
Ct.isTag = yO;
function bO(e) {
  return e.type === Nr.ElementType.CDATA;
}
Ct.isCDATA = bO;
function wO(e) {
  return e.type === Nr.ElementType.Text;
}
Ct.isText = wO;
function CO(e) {
  return e.type === Nr.ElementType.Comment;
}
Ct.isComment = CO;
function EO(e) {
  return e.type === Nr.ElementType.Directive;
}
Ct.isDirective = EO;
function xO(e) {
  return e.type === Nr.ElementType.Root;
}
Ct.isDocument = xO;
function T2(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Ct.hasChildren = T2;
function Pm(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (wO(e))
    n = new dO(e.data);
  else if (CO(e))
    n = new fO(e.data);
  else if (yO(e)) {
    var r = t ? Kd(e.children) : [], o = new vO(e.name, Oa({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Oa({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Oa({}, e["x-attribsPrefix"])), n = o;
  } else if (bO(e)) {
    var r = t ? Kd(e.children) : [], i = new gO(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (xO(e)) {
    var r = t ? Kd(e.children) : [], s = new mO(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (EO(e)) {
    var a = new hO(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Ct.cloneNode = Pm;
function Kd(e) {
  for (var t = e.map(function(r) {
    return Pm(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = rn && rn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = rn && rn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Om, o = Ct;
  n(Ct, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Sm);
var LO = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(LO);
Object.defineProperty(rp, "__esModule", { value: !0 });
rp.formatAttributes = kO;
rp.formatDOM = DO;
var su = Sm, A2 = LO;
function B2(e) {
  return A2.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function kO(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function _2(e) {
  e = e.toLowerCase();
  var t = B2(e);
  return t || e;
}
function DO(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = _2(a.nodeName);
        o = new su.Element(l, kO(a.attributes)), o.children = DO(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new su.Text(a.nodeValue);
        break;
      case 8:
        o = new su.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new su.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var I2 = rn && rn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(km, "__esModule", { value: !0 });
km.default = R2;
var j2 = I2(Dm), N2 = rp, F2 = /<(![a-zA-Z\s]+)>/;
function R2(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(F2), n = t ? t[1] : void 0;
  return (0, N2.formatDOM)((0, j2.default)(e), null, n);
}
var sp = {}, po = {}, ap = {}, z2 = 0;
ap.SAME = z2;
var U2 = 1;
ap.CAMELCASE = U2;
ap.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const SO = 0, Oi = 1, lp = 2, up = 3, Tm = 4, OO = 5, MO = 6;
function $2(e) {
  return gr.hasOwnProperty(e) ? gr[e] : null;
}
function Sr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === lp || t === up || t === Tm, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const gr = {}, W2 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
W2.forEach((e) => {
  gr[e] = new Sr(
    e,
    SO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  gr[e] = new Sr(
    e,
    Oi,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  gr[e] = new Sr(
    e,
    lp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  gr[e] = new Sr(
    e,
    lp,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  gr[e] = new Sr(
    e,
    up,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  gr[e] = new Sr(
    e,
    up,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  gr[e] = new Sr(
    e,
    Tm,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  gr[e] = new Sr(
    e,
    MO,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  gr[e] = new Sr(
    e,
    OO,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Am = /[\-\:]([a-z])/g, Bm = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Am, Bm);
  gr[t] = new Sr(
    t,
    Oi,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Am, Bm);
  gr[t] = new Sr(
    t,
    Oi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Am, Bm);
  gr[t] = new Sr(
    t,
    Oi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  gr[e] = new Sr(
    e,
    Oi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const H2 = "xlinkHref";
gr[H2] = new Sr(
  "xlinkHref",
  Oi,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  gr[e] = new Sr(
    e,
    Oi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: V2,
  SAME: Z2,
  possibleStandardNames: K1
} = ap, q2 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", G2 = q2 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", K2 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + G2 + "]*$")
), Y2 = Object.keys(
  K1
).reduce((e, t) => {
  const n = K1[t];
  return n === Z2 ? e[t] = t : n === V2 ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
po.BOOLEAN = up;
po.BOOLEANISH_STRING = lp;
po.NUMERIC = OO;
po.OVERLOADED_BOOLEAN = Tm;
po.POSITIVE_NUMERIC = MO;
po.RESERVED = SO;
po.STRING = Oi;
po.getPropertyInfo = $2;
po.isCustomAttribute = K2;
po.possibleStandardNames = Y2;
var _m = {}, Im = {}, Y1 = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, X2 = /\n/g, Q2 = /^\s*/, J2 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, ez = /^:\s*/, tz = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, nz = /^[;\s]*/, rz = /^\s+|\s+$/g, oz = `
`, X1 = "/", Q1 = "*", ns = "", iz = "comment", sz = "declaration", az = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(m) {
    var f = m.match(X2);
    f && (n += f.length);
    var h = m.lastIndexOf(oz);
    r = ~h ? m.length - h : r + m.length;
  }
  function i() {
    var m = { line: n, column: r };
    return function(f) {
      return f.position = new s(m), u(), f;
    };
  }
  function s(m) {
    this.start = m, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(m) {
    var f = new Error(
      t.source + ":" + n + ":" + r + ": " + m
    );
    if (f.reason = m, f.filename = t.source, f.line = n, f.column = r, f.source = e, !t.silent) throw f;
  }
  function l(m) {
    var f = m.exec(e);
    if (f) {
      var h = f[0];
      return o(h), e = e.slice(h.length), f;
    }
  }
  function u() {
    l(Q2);
  }
  function c(m) {
    var f;
    for (m = m || []; f = p(); )
      f !== !1 && m.push(f);
    return m;
  }
  function p() {
    var m = i();
    if (!(X1 != e.charAt(0) || Q1 != e.charAt(1))) {
      for (var f = 2; ns != e.charAt(f) && (Q1 != e.charAt(f) || X1 != e.charAt(f + 1)); )
        ++f;
      if (f += 2, ns === e.charAt(f - 1))
        return a("End of comment missing");
      var h = e.slice(2, f - 2);
      return r += 2, o(h), e = e.slice(f), r += 2, m({
        type: iz,
        comment: h
      });
    }
  }
  function d() {
    var m = i(), f = l(J2);
    if (f) {
      if (p(), !l(ez)) return a("property missing ':'");
      var h = l(tz), E = m({
        type: sz,
        property: J1(f[0].replace(Y1, ns)),
        value: h ? J1(h[0].replace(Y1, ns)) : ns
      });
      return l(nz), E;
    }
  }
  function g() {
    var m = [];
    c(m);
    for (var f; f = d(); )
      f !== !1 && (m.push(f), c(m));
    return m;
  }
  return u(), g();
};
function J1(e) {
  return e ? e.replace(rz, ns) : ns;
}
var lz = rn && rn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Im, "__esModule", { value: !0 });
Im.default = cz;
var uz = lz(az);
function cz(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, uz.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var cp = {};
Object.defineProperty(cp, "__esModule", { value: !0 });
cp.camelCase = void 0;
var pz = /^--[a-zA-Z0-9-]+$/, dz = /-([a-z])/g, fz = /^[^-]+$/, hz = /^-(webkit|moz|ms|o|khtml)-/, gz = /^-(ms)-/, mz = function(e) {
  return !e || fz.test(e) || pz.test(e);
}, vz = function(e, t) {
  return t.toUpperCase();
}, eC = function(e, t) {
  return "".concat(t, "-");
}, yz = function(e, t) {
  return t === void 0 && (t = {}), mz(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(gz, eC) : e = e.replace(hz, eC), e.replace(dz, vz));
};
cp.camelCase = yz;
var bz = rn && rn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, wz = bz(Im), Cz = cp;
function Qh(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, wz.default)(e, function(r, o) {
    r && o && (n[(0, Cz.camelCase)(r, t)] = o);
  }), n;
}
Qh.default = Qh;
var Ez = Qh;
(function(e) {
  var t = rn && rn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Be, r = t(Ez), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(_m);
Object.defineProperty(sp, "__esModule", { value: !0 });
sp.default = Dz;
var va = po, tC = _m, xz = ["checked", "value"], Lz = ["input", "select", "textarea"], kz = {
  reset: !0,
  submit: !0
};
function Dz(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && kz[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, va.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = nC(s);
    if (a) {
      var l = (0, va.getPropertyInfo)(a);
      switch (xz.includes(a) && Lz.includes(t) && !r && (a = nC("default" + s)), n[a] = i, l && l.type) {
        case va.BOOLEAN:
          n[a] = !0;
          break;
        case va.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    tC.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, tC.setStyleProp)(e.style, n), n;
}
function nC(e) {
  return va.possibleStandardNames[e];
}
var jm = {}, Sz = rn && rn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(jm, "__esModule", { value: !0 });
jm.default = PO;
var Yd = Be, Oz = Sz(sp), Ma = _m, Mz = {
  cloneElement: Yd.cloneElement,
  createElement: Yd.createElement,
  isValidElement: Yd.isValidElement
};
function PO(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Ma.returnFirstArg, i = t.library || Mz, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Ma.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var m = p, f = {};
    Pz(m) ? ((0, Ma.setStyleProp)(m.attribs.style, m.attribs), f = m.attribs) : m.attribs && (f = (0, Oz.default)(m.attribs, m.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (f.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? f.defaultValue = p.children[0].data : p.children && p.children.length && (h = PO(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (f.key = c), n.push(o(a(p.name, f, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Pz(e) {
  return Ma.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Ma.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = rn && rn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(km);
  e.htmlToDOM = n.default;
  var r = t(sp);
  e.attributesToProps = r.default;
  var o = t(jm);
  e.domToReact = o.default;
  var i = Sm;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(pO);
const Tz = /* @__PURE__ */ GN(pO);
Tz.default;
Ye({});
Ye({});
Ye({});
var Jn = {}, Nm = {}, dl = {}, fl = {}, TO = "Expected a function", rC = NaN, Az = "[object Symbol]", Bz = /^\s+|\s+$/g, _z = /^[-+]0x[0-9a-f]+$/i, Iz = /^0b[01]+$/i, jz = /^0o[0-7]+$/i, Nz = parseInt, Fz = typeof rn == "object" && rn && rn.Object === Object && rn, Rz = typeof self == "object" && self && self.Object === Object && self, zz = Fz || Rz || Function("return this")(), Uz = Object.prototype, $z = Uz.toString, Wz = Math.max, Hz = Math.min, Xd = function() {
  return zz.Date.now();
};
function Vz(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(TO);
  t = oC(t) || 0, Dc(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? Wz(oC(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var k = r, O = o;
    return r = o = void 0, u = C, s = e.apply(O, k), s;
  }
  function m(C) {
    return u = C, a = setTimeout(E, t), c ? g(C) : s;
  }
  function f(C) {
    var k = C - l, O = C - u, U = t - k;
    return p ? Hz(U, i - O) : U;
  }
  function h(C) {
    var k = C - l, O = C - u;
    return l === void 0 || k >= t || k < 0 || p && O >= i;
  }
  function E() {
    var C = Xd();
    if (h(C))
      return L(C);
    a = setTimeout(E, f(C));
  }
  function L(C) {
    return a = void 0, d && r ? g(C) : (r = o = void 0, s);
  }
  function x() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function T() {
    return a === void 0 ? s : L(Xd());
  }
  function w() {
    var C = Xd(), k = h(C);
    if (r = arguments, o = this, l = C, k) {
      if (a === void 0)
        return m(l);
      if (p)
        return a = setTimeout(E, t), g(l);
    }
    return a === void 0 && (a = setTimeout(E, t)), s;
  }
  return w.cancel = x, w.flush = T, w;
}
function Zz(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(TO);
  return Dc(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), Vz(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Dc(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function qz(e) {
  return !!e && typeof e == "object";
}
function Gz(e) {
  return typeof e == "symbol" || qz(e) && $z.call(e) == Az;
}
function oC(e) {
  if (typeof e == "number")
    return e;
  if (Gz(e))
    return rC;
  if (Dc(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Dc(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(Bz, "");
  var n = Iz.test(e);
  return n || jz.test(e) ? Nz(e.slice(2), n ? 2 : 8) : _z.test(e) ? rC : +e;
}
var Kz = Zz, hl = {};
Object.defineProperty(hl, "__esModule", {
  value: !0
});
hl.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), rc.has(t) || rc.set(t, /* @__PURE__ */ new Set());
  var o = rc.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
hl.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), rc.get(t).delete(n.name || t);
};
var rc = /* @__PURE__ */ new Map();
Object.defineProperty(fl, "__esModule", {
  value: !0
});
var Yz = Kz, Xz = Jz(Yz), Qz = hl;
function Jz(e) {
  return e && e.__esModule ? e : { default: e };
}
var e3 = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, Xz.default)(e, t);
}, $n = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = e3(function(r) {
        $n.scrollHandler(e);
      }, t);
      $n.scrollSpyContainers.push(e), (0, Qz.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return $n.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = $n.scrollSpyContainers[$n.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n($n.currentPositionX(e), $n.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    $n.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = $n.scrollSpyContainers[$n.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e($n.currentPositionX(t), $n.currentPositionY(t));
  },
  updateStates: function() {
    $n.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    $n.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), $n.spySetState && $n.spySetState.length && $n.spySetState.indexOf(e) > -1 && $n.spySetState.splice($n.spySetState.indexOf(e), 1), document.removeEventListener("scroll", $n.scrollHandler);
  },
  update: function() {
    return $n.scrollSpyContainers.forEach(function(e) {
      return $n.scrollHandler(e);
    });
  }
};
fl.default = $n;
var zs = {}, gl = {};
Object.defineProperty(gl, "__esModule", {
  value: !0
});
var t3 = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, n3 = function() {
  return window.location.hash.replace(/^#/, "");
}, r3 = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, o3 = function(e) {
  return getComputedStyle(e).position !== "static";
}, Qd = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, i3 = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (o3(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Qd(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return Qd(t, a).offsetTop - Qd(e, a).offsetTop;
};
gl.default = {
  updateHash: t3,
  getHash: n3,
  filterElementInContainer: r3,
  scrollOffset: i3
};
var pp = {}, Fm = {};
Object.defineProperty(Fm, "__esModule", {
  value: !0
});
Fm.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Rm = {};
Object.defineProperty(Rm, "__esModule", {
  value: !0
});
var s3 = hl, a3 = ["mousedown", "mousewheel", "touchmove", "keydown"];
Rm.default = {
  subscribe: function(e) {
    return typeof document < "u" && a3.forEach(function(t) {
      return (0, s3.addPassiveEventListener)(document, t, e);
    });
  }
};
var ml = {};
Object.defineProperty(ml, "__esModule", {
  value: !0
});
var Jh = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Jh.registered[e] = t;
    },
    remove: function(e) {
      Jh.registered[e] = null;
    }
  }
};
ml.default = Jh;
Object.defineProperty(pp, "__esModule", {
  value: !0
});
var l3 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, u3 = gl;
dp(u3);
var c3 = Fm, iC = dp(c3), p3 = Rm, d3 = dp(p3), f3 = ml, yo = dp(f3);
function dp(e) {
  return e && e.__esModule ? e : { default: e };
}
var AO = function(e) {
  return iC.default[e.smooth] || iC.default.defaultEasing;
}, h3 = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, g3 = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, eg = function() {
  return g3() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), BO = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, _O = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, IO = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, m3 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, v3 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, y3 = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    yo.default.registered.end && yo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    eg.call(window, i);
    return;
  }
  yo.default.registered.end && yo.default.registered.end(o.to, o.target, o.currentPosition);
}, zm = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, vl = function(e, t, n, r) {
  t.data = t.data || BO(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (d3.default.subscribe(o), zm(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? _O(t) : IO(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    yo.default.registered.end && yo.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = h3(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = AO(t), s = y3.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      yo.default.registered.begin && yo.default.registered.begin(t.data.to, t.data.target), eg.call(window, s);
    }, t.delay);
    return;
  }
  yo.default.registered.begin && yo.default.registered.begin(t.data.to, t.data.target), eg.call(window, s);
}, fp = function(e) {
  return e = l3({}, e), e.data = e.data || BO(), e.absolute = !0, e;
}, b3 = function(e) {
  vl(0, fp(e));
}, w3 = function(e, t) {
  vl(e, fp(t));
}, C3 = function(e) {
  e = fp(e), zm(e), vl(e.horizontal ? m3(e) : v3(e), e);
}, E3 = function(e, t) {
  t = fp(t), zm(t);
  var n = t.horizontal ? _O(t) : IO(t);
  vl(e + n, t);
};
pp.default = {
  animateTopScroll: vl,
  getAnimationType: AO,
  scrollToTop: b3,
  scrollToBottom: C3,
  scrollTo: w3,
  scrollMore: E3
};
Object.defineProperty(zs, "__esModule", {
  value: !0
});
var x3 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, L3 = gl, k3 = Um(L3), D3 = pp, S3 = Um(D3), O3 = ml, au = Um(O3);
function Um(e) {
  return e && e.__esModule ? e : { default: e };
}
var lu = {}, sC = void 0;
zs.default = {
  unmount: function() {
    lu = {};
  },
  register: function(e, t) {
    lu[e] = t;
  },
  unregister: function(e) {
    delete lu[e];
  },
  get: function(e) {
    return lu[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return sC = e;
  },
  getActiveLink: function() {
    return sC;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = x3({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = k3.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      au.default.registered.begin && au.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, au.default.registered.end && au.default.registered.end(e, n);
      return;
    }
    S3.default.animateTopScroll(a, t, e, n);
  }
};
var tg = { exports: {} }, Jd = { exports: {} }, Ut = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var aC;
function M3() {
  if (aC) return Ut;
  aC = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
  function x(w) {
    if (typeof w == "object" && w !== null) {
      var C = w.$$typeof;
      switch (C) {
        case t:
          switch (w = w.type, w) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return w;
            default:
              switch (w = w && w.$$typeof, w) {
                case a:
                case c:
                case m:
                case g:
                case s:
                  return w;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function T(w) {
    return x(w) === u;
  }
  return Ut.AsyncMode = l, Ut.ConcurrentMode = u, Ut.ContextConsumer = a, Ut.ContextProvider = s, Ut.Element = t, Ut.ForwardRef = c, Ut.Fragment = r, Ut.Lazy = m, Ut.Memo = g, Ut.Portal = n, Ut.Profiler = i, Ut.StrictMode = o, Ut.Suspense = p, Ut.isAsyncMode = function(w) {
    return T(w) || x(w) === l;
  }, Ut.isConcurrentMode = T, Ut.isContextConsumer = function(w) {
    return x(w) === a;
  }, Ut.isContextProvider = function(w) {
    return x(w) === s;
  }, Ut.isElement = function(w) {
    return typeof w == "object" && w !== null && w.$$typeof === t;
  }, Ut.isForwardRef = function(w) {
    return x(w) === c;
  }, Ut.isFragment = function(w) {
    return x(w) === r;
  }, Ut.isLazy = function(w) {
    return x(w) === m;
  }, Ut.isMemo = function(w) {
    return x(w) === g;
  }, Ut.isPortal = function(w) {
    return x(w) === n;
  }, Ut.isProfiler = function(w) {
    return x(w) === i;
  }, Ut.isStrictMode = function(w) {
    return x(w) === o;
  }, Ut.isSuspense = function(w) {
    return x(w) === p;
  }, Ut.isValidElementType = function(w) {
    return typeof w == "string" || typeof w == "function" || w === r || w === u || w === i || w === o || w === p || w === d || typeof w == "object" && w !== null && (w.$$typeof === m || w.$$typeof === g || w.$$typeof === s || w.$$typeof === a || w.$$typeof === c || w.$$typeof === h || w.$$typeof === E || w.$$typeof === L || w.$$typeof === f);
  }, Ut.typeOf = x, Ut;
}
var Gt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var lC;
function P3() {
  return lC || (lC = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
    function x(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === m || B.$$typeof === g || B.$$typeof === s || B.$$typeof === a || B.$$typeof === c || B.$$typeof === h || B.$$typeof === E || B.$$typeof === L || B.$$typeof === f);
    }
    function T(B) {
      if (typeof B == "object" && B !== null) {
        var se = B.$$typeof;
        switch (se) {
          case t:
            var ue = B.type;
            switch (ue) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ue;
              default:
                var ce = ue && ue.$$typeof;
                switch (ce) {
                  case a:
                  case c:
                  case m:
                  case g:
                  case s:
                    return ce;
                  default:
                    return se;
                }
            }
          case n:
            return se;
        }
      }
    }
    var w = l, C = u, k = a, O = s, U = t, M = c, V = r, $ = m, W = g, R = n, H = i, X = o, I = p, J = !1;
    function te(B) {
      return J || (J = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), S(B) || T(B) === l;
    }
    function S(B) {
      return T(B) === u;
    }
    function P(B) {
      return T(B) === a;
    }
    function q(B) {
      return T(B) === s;
    }
    function j(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function Z(B) {
      return T(B) === c;
    }
    function G(B) {
      return T(B) === r;
    }
    function b(B) {
      return T(B) === m;
    }
    function F(B) {
      return T(B) === g;
    }
    function z(B) {
      return T(B) === n;
    }
    function A(B) {
      return T(B) === i;
    }
    function Y(B) {
      return T(B) === o;
    }
    function ee(B) {
      return T(B) === p;
    }
    Gt.AsyncMode = w, Gt.ConcurrentMode = C, Gt.ContextConsumer = k, Gt.ContextProvider = O, Gt.Element = U, Gt.ForwardRef = M, Gt.Fragment = V, Gt.Lazy = $, Gt.Memo = W, Gt.Portal = R, Gt.Profiler = H, Gt.StrictMode = X, Gt.Suspense = I, Gt.isAsyncMode = te, Gt.isConcurrentMode = S, Gt.isContextConsumer = P, Gt.isContextProvider = q, Gt.isElement = j, Gt.isForwardRef = Z, Gt.isFragment = G, Gt.isLazy = b, Gt.isMemo = F, Gt.isPortal = z, Gt.isProfiler = A, Gt.isStrictMode = Y, Gt.isSuspense = ee, Gt.isValidElementType = x, Gt.typeOf = T;
  }()), Gt;
}
var uC;
function jO() {
  return uC || (uC = 1, process.env.NODE_ENV === "production" ? Jd.exports = M3() : Jd.exports = P3()), Jd.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var ef, cC;
function T3() {
  if (cC) return ef;
  cC = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return ef = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, ef;
}
var tf, pC;
function $m() {
  if (pC) return tf;
  pC = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return tf = e, tf;
}
var dC, fC;
function NO() {
  return fC || (fC = 1, dC = Function.call.bind(Object.prototype.hasOwnProperty)), dC;
}
var nf, hC;
function A3() {
  if (hC) return nf;
  hC = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = $m(), n = {}, r = NO();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (m) {
            p = m;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, nf = o, nf;
}
var rf, gC;
function B3() {
  if (gC) return rf;
  gC = 1;
  var e = jO(), t = T3(), n = $m(), r = NO(), o = A3(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return rf = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(S) {
      var P = S && (u && S[u] || S[c]);
      if (typeof P == "function")
        return P;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: L(),
      arrayOf: x,
      element: T(),
      elementType: w(),
      instanceOf: C,
      node: M(),
      objectOf: O,
      oneOf: k,
      oneOfType: U,
      shape: $,
      exact: W
    };
    function m(S, P) {
      return S === P ? S !== 0 || 1 / S === 1 / P : S !== S && P !== P;
    }
    function f(S, P) {
      this.message = S, this.data = P && typeof P == "object" ? P : {}, this.stack = "";
    }
    f.prototype = Error.prototype;
    function h(S) {
      if (process.env.NODE_ENV !== "production")
        var P = {}, q = 0;
      function j(G, b, F, z, A, Y, ee) {
        if (z = z || d, Y = Y || F, ee !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var se = z + ":" + F;
            !P[se] && // Avoid spamming the console because they are often not actionable except for lib authors
            q < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + Y + "` prop on `" + z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), P[se] = !0, q++);
          }
        }
        return b[F] == null ? G ? b[F] === null ? new f("The " + A + " `" + Y + "` is marked as required " + ("in `" + z + "`, but its value is `null`.")) : new f("The " + A + " `" + Y + "` is marked as required in " + ("`" + z + "`, but its value is `undefined`.")) : null : S(b, F, z, A, Y);
      }
      var Z = j.bind(null, !1);
      return Z.isRequired = j.bind(null, !0), Z;
    }
    function E(S) {
      function P(q, j, Z, G, b, F) {
        var z = q[j], A = X(z);
        if (A !== S) {
          var Y = I(z);
          return new f(
            "Invalid " + G + " `" + b + "` of type " + ("`" + Y + "` supplied to `" + Z + "`, expected ") + ("`" + S + "`."),
            { expectedType: S }
          );
        }
        return null;
      }
      return h(P);
    }
    function L() {
      return h(s);
    }
    function x(S) {
      function P(q, j, Z, G, b) {
        if (typeof S != "function")
          return new f("Property `" + b + "` of component `" + Z + "` has invalid PropType notation inside arrayOf.");
        var F = q[j];
        if (!Array.isArray(F)) {
          var z = X(F);
          return new f("Invalid " + G + " `" + b + "` of type " + ("`" + z + "` supplied to `" + Z + "`, expected an array."));
        }
        for (var A = 0; A < F.length; A++) {
          var Y = S(F, A, Z, G, b + "[" + A + "]", n);
          if (Y instanceof Error)
            return Y;
        }
        return null;
      }
      return h(P);
    }
    function T() {
      function S(P, q, j, Z, G) {
        var b = P[q];
        if (!a(b)) {
          var F = X(b);
          return new f("Invalid " + Z + " `" + G + "` of type " + ("`" + F + "` supplied to `" + j + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(S);
    }
    function w() {
      function S(P, q, j, Z, G) {
        var b = P[q];
        if (!e.isValidElementType(b)) {
          var F = X(b);
          return new f("Invalid " + Z + " `" + G + "` of type " + ("`" + F + "` supplied to `" + j + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(S);
    }
    function C(S) {
      function P(q, j, Z, G, b) {
        if (!(q[j] instanceof S)) {
          var F = S.name || d, z = te(q[j]);
          return new f("Invalid " + G + " `" + b + "` of type " + ("`" + z + "` supplied to `" + Z + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return h(P);
    }
    function k(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function P(q, j, Z, G, b) {
        for (var F = q[j], z = 0; z < S.length; z++)
          if (m(F, S[z]))
            return null;
        var A = JSON.stringify(S, function(Y, ee) {
          var B = I(ee);
          return B === "symbol" ? String(ee) : ee;
        });
        return new f("Invalid " + G + " `" + b + "` of value `" + String(F) + "` " + ("supplied to `" + Z + "`, expected one of " + A + "."));
      }
      return h(P);
    }
    function O(S) {
      function P(q, j, Z, G, b) {
        if (typeof S != "function")
          return new f("Property `" + b + "` of component `" + Z + "` has invalid PropType notation inside objectOf.");
        var F = q[j], z = X(F);
        if (z !== "object")
          return new f("Invalid " + G + " `" + b + "` of type " + ("`" + z + "` supplied to `" + Z + "`, expected an object."));
        for (var A in F)
          if (r(F, A)) {
            var Y = S(F, A, Z, G, b + "." + A, n);
            if (Y instanceof Error)
              return Y;
          }
        return null;
      }
      return h(P);
    }
    function U(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var P = 0; P < S.length; P++) {
        var q = S[P];
        if (typeof q != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + J(q) + " at index " + P + "."
          ), s;
      }
      function j(Z, G, b, F, z) {
        for (var A = [], Y = 0; Y < S.length; Y++) {
          var ee = S[Y], B = ee(Z, G, b, F, z, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && A.push(B.data.expectedType);
        }
        var se = A.length > 0 ? ", expected one of type [" + A.join(", ") + "]" : "";
        return new f("Invalid " + F + " `" + z + "` supplied to " + ("`" + b + "`" + se + "."));
      }
      return h(j);
    }
    function M() {
      function S(P, q, j, Z, G) {
        return R(P[q]) ? null : new f("Invalid " + Z + " `" + G + "` supplied to " + ("`" + j + "`, expected a ReactNode."));
      }
      return h(S);
    }
    function V(S, P, q, j, Z) {
      return new f(
        (S || "React class") + ": " + P + " type `" + q + "." + j + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Z + "`."
      );
    }
    function $(S) {
      function P(q, j, Z, G, b) {
        var F = q[j], z = X(F);
        if (z !== "object")
          return new f("Invalid " + G + " `" + b + "` of type `" + z + "` " + ("supplied to `" + Z + "`, expected `object`."));
        for (var A in S) {
          var Y = S[A];
          if (typeof Y != "function")
            return V(Z, G, b, A, I(Y));
          var ee = Y(F, A, Z, G, b + "." + A, n);
          if (ee)
            return ee;
        }
        return null;
      }
      return h(P);
    }
    function W(S) {
      function P(q, j, Z, G, b) {
        var F = q[j], z = X(F);
        if (z !== "object")
          return new f("Invalid " + G + " `" + b + "` of type `" + z + "` " + ("supplied to `" + Z + "`, expected `object`."));
        var A = t({}, q[j], S);
        for (var Y in A) {
          var ee = S[Y];
          if (r(S, Y) && typeof ee != "function")
            return V(Z, G, b, Y, I(ee));
          if (!ee)
            return new f(
              "Invalid " + G + " `" + b + "` key `" + Y + "` supplied to `" + Z + "`.\nBad object: " + JSON.stringify(q[j], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(S), null, "  ")
            );
          var B = ee(F, Y, Z, G, b + "." + Y, n);
          if (B)
            return B;
        }
        return null;
      }
      return h(P);
    }
    function R(S) {
      switch (typeof S) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !S;
        case "object":
          if (Array.isArray(S))
            return S.every(R);
          if (S === null || a(S))
            return !0;
          var P = p(S);
          if (P) {
            var q = P.call(S), j;
            if (P !== S.entries) {
              for (; !(j = q.next()).done; )
                if (!R(j.value))
                  return !1;
            } else
              for (; !(j = q.next()).done; ) {
                var Z = j.value;
                if (Z && !R(Z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function H(S, P) {
      return S === "symbol" ? !0 : P ? P["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && P instanceof Symbol : !1;
    }
    function X(S) {
      var P = typeof S;
      return Array.isArray(S) ? "array" : S instanceof RegExp ? "object" : H(P, S) ? "symbol" : P;
    }
    function I(S) {
      if (typeof S > "u" || S === null)
        return "" + S;
      var P = X(S);
      if (P === "object") {
        if (S instanceof Date)
          return "date";
        if (S instanceof RegExp)
          return "regexp";
      }
      return P;
    }
    function J(S) {
      var P = I(S);
      switch (P) {
        case "array":
        case "object":
          return "an " + P;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + P;
        default:
          return P;
      }
    }
    function te(S) {
      return !S.constructor || !S.constructor.name ? d : S.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, rf;
}
var of, mC;
function _3() {
  if (mC) return of;
  mC = 1;
  var e = $m();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, of = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, of;
}
if (process.env.NODE_ENV !== "production") {
  var I3 = jO(), j3 = !0;
  tg.exports = B3()(I3.isElement, j3);
} else
  tg.exports = _3()();
var hp = tg.exports, gp = {};
Object.defineProperty(gp, "__esModule", {
  value: !0
});
var N3 = gl, sf = F3(N3);
function F3(e) {
  return e && e.__esModule ? e : { default: e };
}
var R3 = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return sf.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && sf.default.getHash() !== e && sf.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
gp.default = R3;
Object.defineProperty(dl, "__esModule", {
  value: !0
});
var uu = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, z3 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), U3 = Be, vC = yl(U3), $3 = fl, cu = yl($3), W3 = zs, H3 = yl(W3), V3 = hp, Dn = yl(V3), Z3 = gp, Xo = yl(Z3);
function yl(e) {
  return e && e.__esModule ? e : { default: e };
}
function q3(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function G3(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function K3(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var yC = {
  to: Dn.default.string.isRequired,
  containerId: Dn.default.string,
  container: Dn.default.object,
  activeClass: Dn.default.string,
  activeStyle: Dn.default.object,
  spy: Dn.default.bool,
  horizontal: Dn.default.bool,
  smooth: Dn.default.oneOfType([Dn.default.bool, Dn.default.string]),
  offset: Dn.default.number,
  delay: Dn.default.number,
  isDynamic: Dn.default.bool,
  onClick: Dn.default.func,
  duration: Dn.default.oneOfType([Dn.default.number, Dn.default.func]),
  absolute: Dn.default.bool,
  onSetActive: Dn.default.func,
  onSetInactive: Dn.default.func,
  ignoreCancelEvents: Dn.default.bool,
  hashSpy: Dn.default.bool,
  saveHashHistory: Dn.default.bool,
  spyThrottle: Dn.default.number
};
dl.default = function(e, t) {
  var n = t || H3.default, r = function(i) {
    K3(s, i);
    function s(a) {
      q3(this, s);
      var l = G3(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return z3(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          cu.default.isMounted(a) || cu.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (Xo.default.isMounted() || Xo.default.mount(n), Xo.default.mapContainer(this.props.to, a)), cu.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        cu.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = uu({}, this.props.style, this.props.activeStyle) : l = uu({}, this.props.style);
        var u = uu({}, this.props);
        for (var c in yC)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, vC.default.createElement(e, u);
      }
    }]), s;
  }(vC.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, uu({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Xo.default.isMounted() && !Xo.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var m = 0, f = 0, h = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            h = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var L = p.getBoundingClientRect();
            m = L.left - h + s, f = m + L.width;
          }
          var x = s - i.props.offset;
          d = x >= Math.floor(m) && x < Math.floor(f), g = x < Math.floor(m) || x >= Math.floor(f);
        } else {
          var T = 0, w = 0, C = 0;
          if (l.getBoundingClientRect) {
            var k = l.getBoundingClientRect();
            C = k.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var O = p.getBoundingClientRect();
            T = O.top - C + a, w = T + O.height;
          }
          var U = a - i.props.offset;
          d = U >= Math.floor(T) && U < Math.floor(w), g = U < Math.floor(T) || U >= Math.floor(w);
        }
        var M = n.getActiveLink();
        if (g) {
          if (c === M && n.setActiveLink(void 0), i.props.hashSpy && Xo.default.getHash() === c) {
            var V = i.props.saveHashHistory, $ = V === void 0 ? !1 : V;
            Xo.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (M !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var W = i.props.saveHashHistory, R = W === void 0 ? !1 : W;
          i.props.hashSpy && Xo.default.changeHash(c, R), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = yC, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Nm, "__esModule", {
  value: !0
});
var Y3 = Be, bC = FO(Y3), X3 = dl, Q3 = FO(X3);
function FO(e) {
  return e && e.__esModule ? e : { default: e };
}
function J3(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function wC(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function eU(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var tU = function(e) {
  eU(t, e);
  function t() {
    var n, r, o, i;
    J3(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = wC(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return bC.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), wC(o, i);
  }
  return t;
}(bC.default.Component);
Nm.default = (0, Q3.default)(tU);
var Wm = {};
Object.defineProperty(Wm, "__esModule", {
  value: !0
});
var nU = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), rU = Be, CC = RO(rU), oU = dl, iU = RO(oU);
function RO(e) {
  return e && e.__esModule ? e : { default: e };
}
function sU(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function aU(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function lU(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var uU = function(e) {
  lU(t, e);
  function t() {
    return sU(this, t), aU(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return nU(t, [{
    key: "render",
    value: function() {
      return CC.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(CC.default.Component);
Wm.default = (0, iU.default)(uU);
var Hm = {}, mp = {};
Object.defineProperty(mp, "__esModule", {
  value: !0
});
var cU = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, pU = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), dU = Be, EC = vp(dU), fU = pl;
vp(fU);
var hU = zs, xC = vp(hU), gU = hp, LC = vp(gU);
function vp(e) {
  return e && e.__esModule ? e : { default: e };
}
function mU(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vU(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function yU(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
mp.default = function(e) {
  var t = function(n) {
    yU(r, n);
    function r(o) {
      mU(this, r);
      var i = vU(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return pU(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        xC.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        xC.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return EC.default.createElement(e, cU({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(EC.default.Component);
  return t.propTypes = {
    name: LC.default.string,
    id: LC.default.string
  }, t;
};
Object.defineProperty(Hm, "__esModule", {
  value: !0
});
var kC = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, bU = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), wU = Be, DC = Vm(wU), CU = mp, EU = Vm(CU), xU = hp, SC = Vm(xU);
function Vm(e) {
  return e && e.__esModule ? e : { default: e };
}
function LU(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kU(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function DU(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var zO = function(e) {
  DU(t, e);
  function t() {
    return LU(this, t), kU(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return bU(t, [{
    key: "render",
    value: function() {
      var n = this, r = kC({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, DC.default.createElement(
        "div",
        kC({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(DC.default.Component);
zO.propTypes = {
  name: SC.default.string,
  id: SC.default.string
};
Hm.default = (0, EU.default)(zO);
var af = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, OC = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function MC(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function PC(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function TC(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var pu = Be, Zi = fl, lf = zs, Zn = hp, Qo = gp, AC = {
  to: Zn.string.isRequired,
  containerId: Zn.string,
  container: Zn.object,
  activeClass: Zn.string,
  spy: Zn.bool,
  smooth: Zn.oneOfType([Zn.bool, Zn.string]),
  offset: Zn.number,
  delay: Zn.number,
  isDynamic: Zn.bool,
  onClick: Zn.func,
  duration: Zn.oneOfType([Zn.number, Zn.func]),
  absolute: Zn.bool,
  onSetActive: Zn.func,
  onSetInactive: Zn.func,
  ignoreCancelEvents: Zn.bool,
  hashSpy: Zn.bool,
  spyThrottle: Zn.number
}, SU = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || lf, r = function(i) {
      TC(s, i);
      function s(a) {
        MC(this, s);
        var l = PC(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return OC(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Zi.isMounted(a) || Zi.mount(a, this.props.spyThrottle), this.props.hashSpy && (Qo.isMounted() || Qo.mount(n), Qo.mapContainer(this.props.to, a)), this.props.spy && Zi.addStateHandler(this.stateHandler), Zi.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Zi.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = af({}, this.props);
          for (var u in AC)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, pu.createElement(e, l);
        }
      }]), s;
    }(pu.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, af({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(Qo.isMounted() && !Qo.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var g = a.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var m = u.getBoundingClientRect();
            c = m.top - d + s, p = c + m.height;
          }
          var f = s - i.props.offset, h = f >= Math.floor(c) && f < Math.floor(p), E = f < Math.floor(c) || f >= Math.floor(p), L = n.getActiveLink();
          if (E)
            return l === L && n.setActiveLink(void 0), i.props.hashSpy && Qo.getHash() === l && Qo.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Zi.updateStates();
          if (h && L !== l)
            return n.setActiveLink(l), i.props.hashSpy && Qo.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Zi.updateStates();
        }
      };
    };
    return r.propTypes = AC, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      TC(r, n);
      function r(o) {
        MC(this, r);
        var i = PC(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return OC(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          lf.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          lf.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return pu.createElement(e, af({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(pu.Component);
    return t.propTypes = {
      name: Zn.string,
      id: Zn.string
    }, t;
  }
}, OU = SU;
Object.defineProperty(Jn, "__esModule", {
  value: !0
});
Jn.Helpers = Jn.ScrollElement = Jn.ScrollLink = Jn.animateScroll = Jn.scrollSpy = Jn.Events = Jn.scroller = Jn.Element = Jn.Button = Jn.Link = void 0;
var MU = Nm, UO = ko(MU), PU = Wm, $O = ko(PU), TU = Hm, WO = ko(TU), AU = zs, HO = ko(AU), BU = ml, VO = ko(BU), _U = fl, ZO = ko(_U), IU = pp, qO = ko(IU), jU = dl, GO = ko(jU), NU = mp, KO = ko(NU), FU = OU, YO = ko(FU);
function ko(e) {
  return e && e.__esModule ? e : { default: e };
}
Jn.Link = UO.default;
Jn.Button = $O.default;
Jn.Element = WO.default;
Jn.scroller = HO.default;
Jn.Events = VO.default;
Jn.scrollSpy = ZO.default;
Jn.animateScroll = qO.default;
Jn.ScrollLink = GO.default;
Jn.ScrollElement = KO.default;
Jn.Helpers = YO.default;
Jn.default = { Link: UO.default, Button: $O.default, Element: WO.default, scroller: HO.default, Events: VO.default, scrollSpy: ZO.default, animateScroll: qO.default, ScrollLink: GO.default, ScrollElement: KO.default, Helpers: YO.default };
Ye({});
Ye({});
Ye({});
let RU = { data: "" }, zU = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || RU, UU = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, $U = /\/\*[^]*?\*\/|  +/g, BC = /\n+/g, mi = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? mi(s, i) : i + "{" + mi(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += mi(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += mi.p ? mi.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Po = {}, XO = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + XO(e[n]);
    return t;
  }
  return e;
}, WU = (e, t, n, r, o) => {
  let i = XO(e), s = Po[i] || (Po[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Po[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = UU.exec(u.replace($U, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(BC, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(BC, " ").trim();
      return d[0];
    })(e);
    Po[s] = mi(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Po.g ? Po.g : null;
  return n && (Po.g = Po[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Po[s], t, r, a), s;
}, HU = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : mi(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function yp(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return WU(n.unshift ? n.raw ? HU(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, zU(t.target), t.g, t.o, t.k);
}
let QO, ng, rg;
yp.bind({ g: 1 });
let Uo = yp.bind({ k: 1 });
function VU(e, t, n, r) {
  mi.p = t, QO = e, ng = n, rg = r;
}
function Mi(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: ng && ng() }, a), n.o = / *go\d+/.test(l), a.className = yp.apply(n, r) + (l ? " " + l : ""), t && (a.ref = s);
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), rg && u[0] && rg(a), QO(u, a);
    }
    return t ? t(o) : o;
  };
}
var ZU = (e) => typeof e == "function", qU = (e, t) => ZU(e) ? e(t) : e, GU = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), KU = Uo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, YU = Uo`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, XU = Uo`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, QU = Mi("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${KU} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${YU} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${XU} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, JU = Uo`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, e$ = Mi("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${JU} 1s linear infinite;
`, t$ = Uo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, n$ = Uo`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, r$ = Mi("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${t$} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${n$} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, o$ = Mi("div")`
  position: absolute;
`, i$ = Mi("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, s$ = Uo`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, a$ = Mi("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${s$} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, l$ = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ve.createElement(a$, null, t) : t : n === "blank" ? null : Ve.createElement(i$, null, Ve.createElement(e$, { ...r }), n !== "loading" && Ve.createElement(o$, null, n === "error" ? Ve.createElement(QU, { ...r }) : Ve.createElement(r$, { ...r })));
}, u$ = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, c$ = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, p$ = "0%{opacity:0;} 100%{opacity:1;}", d$ = "0%{opacity:1;} 100%{opacity:0;}", f$ = Mi("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, h$ = Mi("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, g$ = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = GU() ? [p$, d$] : [u$(n), c$(n)];
  return { animation: t ? `${Uo(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Uo(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ve.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? g$(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ve.createElement(l$, { toast: e }), s = Ve.createElement(h$, { ...e.ariaProps }, qU(e.message, e));
  return Ve.createElement(f$, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ve.createElement(Ve.Fragment, null, i, s));
});
VU(Ve.createElement);
yp`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ye({});
var Go = {};
Object.defineProperty(Go, "__esModule", {
  value: !0
});
var m$ = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), uf = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, JO = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: m$ ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, Zm = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var du = 1; du < 20; du++)
  Zm["f" + du] = 111 + du;
function bp(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return eM(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return tM(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function v$(e, t) {
  return bp(e, t);
}
function y$(e, t) {
  return bp(e, { byKey: !0 }, t);
}
function eM(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in uf)
    r[uf[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var m = qm(d), f = uf[m];
      if (d.length > 1 && !f && !JO[d] && !Zm[m])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !f) && (n ? r.key = m : r.which = nM(d)), f && (r[f] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function tM(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function nM(e) {
  e = qm(e);
  var t = Zm[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function qm(e) {
  return e = e.toLowerCase(), e = JO[e] || e, e;
}
Go.default = bp;
var cf = Go.isHotkey = bp;
Go.isCodeHotkey = v$;
Go.isKeyHotkey = y$;
Go.parseHotkey = eM;
Go.compareHotkey = tM;
Go.toKeyCode = nM;
Go.toKeyName = qm;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function _C(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function wr(e) {
  var t, n;
  return _C(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(_C(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var rM = Symbol.for("immer-nothing"), IC = Symbol.for("immer-draftable"), Xr = Symbol.for("immer-state"), b$ = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function _r(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = b$[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Bs = Object.getPrototypeOf;
function ys(e) {
  return !!e && !!e[Xr];
}
function bs(e) {
  var t;
  return e ? oM(e) || Array.isArray(e) || !!e[IC] || !!((t = e.constructor) != null && t[IC]) || Cp(e) || Ep(e) : !1;
}
var w$ = Object.prototype.constructor.toString();
function oM(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Bs(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === w$;
}
function Sc(e, t) {
  wp(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function wp(e) {
  const t = e[Xr];
  return t ? t.type_ : Array.isArray(e) ? 1 : Cp(e) ? 2 : Ep(e) ? 3 : 0;
}
function og(e, t) {
  return wp(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function iM(e, t, n) {
  const r = wp(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function C$(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function Cp(e) {
  return e instanceof Map;
}
function Ep(e) {
  return e instanceof Set;
}
function Qi(e) {
  return e.copy_ || e.base_;
}
function ig(e, t) {
  if (Cp(e))
    return new Map(e);
  if (Ep(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = oM(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Xr];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Bs(e), r);
  } else {
    const r = Bs(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Gm(e, t = !1) {
  return xp(e) || ys(e) || !bs(e) || (wp(e) > 1 && (e.set = e.add = e.clear = e.delete = E$), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Gm(r, !0))), e;
}
function E$() {
  _r(2);
}
function xp(e) {
  return Object.isFrozen(e);
}
var x$ = {};
function ws(e) {
  const t = x$[e];
  return t || _r(0, e), t;
}
var Ga;
function sM() {
  return Ga;
}
function L$(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function jC(e, t) {
  t && (ws("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function sg(e) {
  ag(e), e.drafts_.forEach(k$), e.drafts_ = null;
}
function ag(e) {
  e === Ga && (Ga = e.parent_);
}
function NC(e) {
  return Ga = L$(Ga, e);
}
function k$(e) {
  const t = e[Xr];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function FC(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Xr].modified_ && (sg(t), _r(4)), bs(e) && (e = Oc(t, e), t.parent_ || Mc(t, e)), t.patches_ && ws("Patches").generateReplacementPatches_(
    n[Xr].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Oc(t, n, []), sg(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== rM ? e : void 0;
}
function Oc(e, t, n) {
  if (xp(t))
    return t;
  const r = t[Xr];
  if (!r)
    return Sc(
      t,
      (o, i) => RC(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Mc(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Sc(
      i,
      (a, l) => RC(e, r, o, a, l, n, s)
    ), Mc(e, o, !1), n && e.patches_ && ws("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function RC(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && _r(5), ys(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !og(t.assigned_, r) ? i.concat(r) : void 0, l = Oc(e, o, a);
    if (iM(n, r, l), ys(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (bs(o) && !xp(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Oc(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Mc(e, o);
  }
}
function Mc(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Gm(t, n);
}
function D$(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : sM(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Km;
  n && (o = [r], i = Ka);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var Km = {
  get(e, t) {
    if (t === Xr)
      return e;
    const n = Qi(e);
    if (!og(n, t))
      return S$(e, n, t);
    const r = n[t];
    return e.finalized_ || !bs(r) ? r : r === pf(e.base_, t) ? (df(e), e.copy_[t] = ug(r, e)) : r;
  },
  has(e, t) {
    return t in Qi(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Qi(e));
  },
  set(e, t, n) {
    const r = aM(Qi(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = pf(Qi(e), t), i = o == null ? void 0 : o[Xr];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (C$(n, o) && (n !== void 0 || og(e.base_, t)))
        return !0;
      df(e), lg(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return pf(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, df(e), lg(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Qi(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    _r(11);
  },
  getPrototypeOf(e) {
    return Bs(e.base_);
  },
  setPrototypeOf() {
    _r(12);
  }
}, Ka = {};
Sc(Km, (e, t) => {
  Ka[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
Ka.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && _r(13), Ka.set.call(this, e, t, void 0);
};
Ka.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && _r(14), Km.set.call(this, e[0], t, n, e[0]);
};
function pf(e, t) {
  const n = e[Xr];
  return (n ? Qi(n) : e)[t];
}
function S$(e, t, n) {
  var r;
  const o = aM(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function aM(e, t) {
  if (!(t in e))
    return;
  let n = Bs(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Bs(n);
  }
}
function lg(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && lg(e.parent_));
}
function df(e) {
  e.copy_ || (e.copy_ = ig(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var O$ = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && _r(6), r !== void 0 && typeof r != "function" && _r(7);
      let o;
      if (bs(t)) {
        const i = NC(this), s = ug(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? sg(i) : ag(i);
        }
        return jC(i, r), FC(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === rM && (o = void 0), this.autoFreeze_ && Gm(o, !0), r) {
          const i = [], s = [];
          ws("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        _r(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    bs(e) || _r(8), ys(e) && (e = M$(e));
    const t = NC(this), n = ug(e, void 0);
    return n[Xr].isManual_ = !0, ag(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Xr];
    (!n || !n.isManual_) && _r(9);
    const { scope_: r } = n;
    return jC(r, t), FC(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = ws("Patches").applyPatches_;
    return ys(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function ug(e, t) {
  const n = Cp(e) ? ws("MapSet").proxyMap_(e, t) : Ep(e) ? ws("MapSet").proxySet_(e, t) : D$(e, t);
  return (t ? t.scope_ : sM()).drafts_.push(n), n;
}
function M$(e) {
  return ys(e) || _r(10, e), lM(e);
}
function lM(e) {
  if (!bs(e) || xp(e))
    return e;
  const t = e[Xr];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = ig(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = ig(e, !0);
  return Sc(n, (r, o) => {
    iM(n, r, lM(o));
  }), t && (t.finalized_ = !1), n;
}
var Qr = new O$(), Ym = Qr.produce;
Qr.produceWithPatches.bind(
  Qr
);
Qr.setAutoFreeze.bind(Qr);
Qr.setUseStrictShallowCopy.bind(Qr);
Qr.applyPatches.bind(Qr);
var zC = Qr.createDraft.bind(Qr), UC = Qr.finishDraft.bind(Qr), Me = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Me.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Me.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Me.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Me.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Me.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Me.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Me.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Me.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Me.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Me.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Me.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Me.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Me.isAncestor(t, e) && !Me.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Me.equals(i, r) || Me.endsBefore(i, r) || Me.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (Me.equals(s, r) || Me.isAncestor(s, r))
          return null;
        Me.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        Me.equals(a, r) || Me.endsBefore(a, r) ? r[a.length - 1] -= 1 : Me.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Me.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Me.endsBefore(u, r) ? r[u.length - 1] += 1 : Me.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Me.equals(p, d))
          return r;
        if (Me.isAncestor(p, r) || Me.equals(p, r)) {
          var g = d.slice();
          return Me.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Me.isSibling(p, d) && (Me.isAncestor(d, r) || Me.equals(d, r)) ? Me.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Me.endsBefore(d, r) || Me.equals(d, r) || Me.isAncestor(d, r) ? (Me.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Me.endsBefore(p, r) && (Me.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Ya(e) {
  "@babel/helpers - typeof";
  return Ya = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Ya(e);
}
function P$(e, t) {
  if (Ya(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Ya(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function T$(e) {
  var t = P$(e, "string");
  return Ya(t) === "symbol" ? t : String(t);
}
function Us(e, t, n) {
  return t = T$(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function $C(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function pa(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $C(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $C(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var A$ = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = et.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of ft.points(t))
          t[l] = En.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = et.leaf(e, u), g = d.text.slice(0, c), m = d.text.slice(c);
      if (d.text = g + p + m, t)
        for (var [f, h] of ft.points(t))
          t[h] = En.transform(f, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, L = et.get(e, E), x = Me.previous(E), T = et.get(e, x), w = et.parent(e, E), C = E[E.length - 1];
      if (Xn.isText(L) && Xn.isText(T))
        T.text += L.text;
      else if (!Xn.isText(L) && !Xn.isText(T))
        T.children.push(...L.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat($r.stringify(L), " ").concat($r.stringify(T)));
      if (w.children.splice(C, 1), t)
        for (var [k, O] of ft.points(t))
          t[O] = En.transform(k, n);
      break;
    }
    case "move_node": {
      var {
        path: U,
        newPath: M
      } = n;
      if (Me.isAncestor(U, M))
        throw new Error("Cannot move a path [".concat(U, "] to new path [").concat(M, "] because the destination is inside itself."));
      var V = et.get(e, U), $ = et.parent(e, U), W = U[U.length - 1];
      $.children.splice(W, 1);
      var R = Me.transform(U, n), H = et.get(e, Me.parent(R)), X = R[R.length - 1];
      if (H.children.splice(X, 0, V), t)
        for (var [I, J] of ft.points(t))
          t[J] = En.transform(I, n);
      break;
    }
    case "remove_node": {
      var {
        path: te
      } = n, S = te[te.length - 1], P = et.parent(e, te);
      if (P.children.splice(S, 1), t)
        for (var [q, j] of ft.points(t)) {
          var Z = En.transform(q, n);
          if (t != null && Z != null)
            t[j] = Z;
          else {
            var G = void 0, b = void 0;
            for (var [F, z] of et.texts(e))
              if (Me.compare(z, te) === -1)
                G = [F, z];
              else {
                b = [F, z];
                break;
              }
            var A = !1;
            G && b && (Me.equals(b[1], te) ? A = !Me.hasPrevious(b[1]) : A = Me.common(G[1], te).length < Me.common(b[1], te).length), G && !A ? (q.path = G[1], q.offset = G[0].text.length) : b ? (q.path = b[1], q.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: Y,
        offset: ee,
        text: B
      } = n;
      if (B.length === 0) break;
      var se = et.leaf(e, Y), ue = se.text.slice(0, ee), ce = se.text.slice(ee + B.length);
      if (se.text = ue + ce, t)
        for (var [de, be] of ft.points(t))
          t[be] = En.transform(de, n);
      break;
    }
    case "set_node": {
      var {
        path: ge,
        properties: me,
        newProperties: ae
      } = n;
      if (ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var xe = et.get(e, ge);
      for (var re in ae) {
        if (re === "children" || re === "text")
          throw new Error('Cannot set the "'.concat(re, '" property of nodes!'));
        var Te = ae[re];
        Te == null ? delete xe[re] : xe[re] = Te;
      }
      for (var ne in me)
        ae.hasOwnProperty(ne) || delete xe[ne];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Ee
      } = n;
      if (Ee == null)
        t = Ee;
      else {
        if (t == null) {
          if (!ft.isRange(Ee))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat($r.stringify(Ee), " when there is no current selection."));
          t = pa({}, Ee);
        }
        for (var Ne in Ee) {
          var Fe = Ee[Ne];
          if (Fe == null) {
            if (Ne === "anchor" || Ne === "focus")
              throw new Error('Cannot remove the "'.concat(Ne, '" selection property'));
            delete t[Ne];
          } else
            t[Ne] = Fe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: he,
        properties: Xe
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var He = et.get(e, Ue), qt = et.parent(e, Ue), lt = Ue[Ue.length - 1], mt;
      if (Xn.isText(He)) {
        var on = He.text.slice(0, he), sn = He.text.slice(he);
        He.text = on, mt = pa(pa({}, Xe), {}, {
          text: sn
        });
      } else {
        var an = He.children.slice(0, he), ln = He.children.slice(he);
        He.children = an, mt = pa(pa({}, Xe), {}, {
          children: ln
        });
      }
      if (qt.children.splice(lt + 1, 0, mt), t)
        for (var [nt, Rt] of ft.points(t))
          t[Rt] = En.transform(nt, n);
      break;
    }
  }
  return t;
}, B$ = {
  transform(e, t) {
    e.children = zC(e.children);
    var n = e.selection && zC(e.selection);
    try {
      n = A$(e, n, t);
    } finally {
      e.children = UC(e.children), n ? e.selection = ys(n) ? UC(n) : n : e.selection = null;
    }
  }
}, _$ = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, I$ = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, uM = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (wr(r) && wr(o)) {
      if (!uM(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function j$(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Xa(e, t) {
  if (e == null) return {};
  var n = j$(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var N$ = ["anchor", "focus"];
function WC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function F$(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? WC(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : WC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ft = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return ft.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = ft.edges(e);
    return t;
  },
  equals(e, t) {
    return En.equals(e.anchor, t.anchor) && En.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (ft.isRange(t)) {
      if (ft.includes(e, t.anchor) || ft.includes(e, t.focus))
        return !0;
      var [n, r] = ft.edges(e), [o, i] = ft.edges(t);
      return En.isBefore(n, o) && En.isAfter(r, i);
    }
    var [s, a] = ft.edges(e), l = !1, u = !1;
    return En.isPoint(t) ? (l = En.compare(t, s) >= 0, u = En.compare(t, a) <= 0) : (l = Me.compare(t, s.path) >= 0, u = Me.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Xa(e, N$), [r, o] = ft.edges(e), [i, s] = ft.edges(t), a = En.isBefore(r, i) ? i : r, l = En.isBefore(o, s) ? o : s;
    return En.isBefore(l, a) ? null : F$({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return En.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return En.equals(t, n);
  },
  isExpanded(e) {
    return !ft.isCollapsed(e);
  },
  isForward(e) {
    return !ft.isBackward(e);
  },
  isRange(e) {
    return wr(e) && En.isPoint(e.anchor) && En.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = ft.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Ym(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = ft.isCollapsed(r);
        ft.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? ft.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = En.transform(r.anchor, t, {
        affinity: i
      }), u = En.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, HC = (e) => wr(e) && et.isNodeList(e.children) && !Qt.isEditor(e), Fo = {
  isAncestor(e) {
    return wr(e) && et.isNodeList(e.children);
  },
  isElement: HC,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Fo.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return HC(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, R$ = ["children"], z$ = ["text"], VC = /* @__PURE__ */ new WeakMap(), et = {
  ancestor(e, t) {
    var n = et.get(e, t);
    if (Xn.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat($r.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Me.ancestors(t, n)) {
        var o = et.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Xn.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat($r.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat($r.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = et.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = et.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Me.common(t, n), o = et.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = et.get(e, t);
    if (Qt.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat($r.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of et.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of et.nodes(e, t))
        Fo.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Fo.isAncestor(e)) {
      var t = Xa(e, R$);
      return t;
    } else {
      var t = Xa(e, z$);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = et.get(e, n); r && !(Xn.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Xn.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat($r.stringify(e)));
    var n = Ym({
      children: e.children
    }, (r) => {
      var [o, i] = ft.edges(t), s = et.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !ft.includes(t, g);
        }
      });
      for (var [, a] of s) {
        if (!ft.includes(t, a)) {
          var l = et.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (Me.equals(a, i.path)) {
          var c = et.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (Me.equals(a, o.path)) {
          var p = et.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      Qt.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Xn.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat($r.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Xn.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Xn.isText(e) || Fo.isElement(e) || Qt.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = VC.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => et.isNode(r));
    return VC.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = et.get(e, n); r && !(Xn.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = et.get(e, t);
    if (!Xn.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat($r.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Me.levels(t, n)) {
        var o = et.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Fo.isElement(e) && Fo.isElementProps(t) && Fo.matches(e, t) || Xn.isText(e) && Xn.isTextProps(t) && Xn.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? Me.isBefore(a, i) : Me.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Xn.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          Me.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = et.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = Me.next(a);
          if (et.has(e, c)) {
            a = c, l = et.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = Me.previous(a);
          a = p, l = et.get(e, a);
          continue;
        }
        a = Me.parent(a), l = et.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Me.parent(t), r = et.get(e, n);
    if (Xn.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Xn.isText(e) ? e.text : e.children.map(et.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of et.nodes(e, t))
        Xn.isText(n) && (yield [n, r]);
    }();
  }
};
function ZC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZC(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ya = {
  isNodeOperation(e) {
    return ya.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!wr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Me.isPath(e.path) && et.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Me.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Me.isPath(e.path) && wr(e.properties);
      case "move_node":
        return Me.isPath(e.path) && Me.isPath(e.newPath);
      case "remove_node":
        return Me.isPath(e.path) && et.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Me.isPath(e.path);
      case "set_node":
        return Me.isPath(e.path) && wr(e.properties) && wr(e.newProperties);
      case "set_selection":
        return e.properties === null && ft.isRange(e.newProperties) || e.newProperties === null && ft.isRange(e.properties) || wr(e.properties) && wr(e.newProperties);
      case "split_node":
        return Me.isPath(e.path) && typeof e.position == "number" && wr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => ya.isOperation(t));
  },
  isSelectionOperation(e) {
    return ya.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return ya.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Sn(Sn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Sn(Sn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Sn(Sn({}, e), {}, {
          type: "split_node",
          path: Me.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Me.equals(t, n))
          return e;
        if (Me.isSibling(n, t))
          return Sn(Sn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Me.transform(n, e), o = Me.transform(Me.next(n), e);
        return Sn(Sn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Sn(Sn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Sn(Sn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Sn(Sn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? Sn(Sn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Sn(Sn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : Sn(Sn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return Sn(Sn({}, e), {}, {
          type: "merge_node",
          path: Me.next(e.path)
        });
    }
  }
}, qC = /* @__PURE__ */ new WeakMap(), U$ = (e) => {
  var t = qC.get(e);
  if (t !== void 0)
    return t;
  if (!wr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || wr(e.marks)) && (e.selection === null || ft.isRange(e.selection)) && et.isNodeList(e.children) && ya.isOperationList(e.operations);
  return qC.set(e, n), n;
}, Qt = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return U$(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function GC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KC(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GC(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var En = {
  compare(e, t) {
    var n = Me.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return En.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return En.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Me.equals(e.path, t.path);
  },
  isPoint(e) {
    return wr(e) && typeof e.offset == "number" && Me.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Ym(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Me.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Me.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Me.equals(t.path, i) && (r.offset += t.position), r.path = Me.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Me.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Me.equals(t.path, i) || Me.isAncestor(t.path, i))
            return null;
          r.path = Me.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Me.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = Me.transform(i, t, KC(KC({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Me.transform(i, t, n);
          break;
        }
      }
    });
  }
}, YC = void 0, $r = {
  setScrubber(e) {
    YC = e;
  },
  stringify(e) {
    return JSON.stringify(e, YC);
  }
}, $$ = ["text"], W$ = ["anchor", "focus"];
function XC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function To(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? XC(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : XC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Xn = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = Xa(i, $$);
      return s;
    }
    return uM(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return wr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Xn.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [To({}, e)];
    for (var r of t) {
      var o = Xa(r, W$), [i, s] = ft.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          a.push(p);
          continue;
        }
        var m = p, f = void 0, h = void 0;
        if (c < l) {
          var E = c - g;
          h = To(To({}, m), {}, {
            text: m.text.slice(E)
          }), m = To(To({}, m), {}, {
            text: m.text.slice(0, E)
          });
        }
        if (u > g) {
          var L = u - g;
          f = To(To({}, m), {}, {
            text: m.text.slice(0, L)
          }), m = To(To({}, m), {}, {
            text: m.text.slice(L)
          });
        }
        Object.assign(m, o), f && a.push(f), a.push(m), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, H$ = (e) => e.selection ? e.selection : e.children.length > 0 ? Qt.end(e, []) : [0], bn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(bn || (bn = {}));
bn.L, bn.L | bn.V | bn.LV | bn.LVT, bn.LV | bn.V, bn.V | bn.T, bn.LVT | bn.T, bn.T, bn.Any, bn.Extend | bn.ZWJ, bn.Any, bn.SpacingMark, bn.Prepend, bn.Any, bn.ZWJ, bn.ExtPict, bn.RI, bn.RI;
var V$ = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Qt.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = H$(e)
      } = n;
      if (Me.isPath(o) && (o = Qt.range(e, o)), ft.isRange(o))
        if (ft.isCollapsed(o))
          o = o.anchor;
        else {
          var i = ft.end(o);
          if (!r && Qt.void(e, {
            at: i
          }))
            return;
          var s = ft.start(o), a = Qt.pointRef(e, s), l = Qt.pointRef(e, i);
          Pc.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Pc.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Qt.void(e, {
        at: o
      }) || Qt.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function QC(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QC(Object(n), !0).forEach(function(r) {
      Us(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QC(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Pc = fu(fu(fu(fu({}, B$), _$), I$), V$), Z$ = typeof nn == "object" && nn && nn.Object === Object && nn, q$ = Z$, G$ = q$, K$ = typeof self == "object" && self && self.Object === Object && self, Y$ = G$ || K$ || Function("return this")(), X$ = Y$, Q$ = X$, J$ = Q$.Symbol, cM = J$, JC = cM;
JC && JC.toStringTag;
var eE = cM;
eE && eE.toStringTag;
var tE;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(tE || (tE = {}));
var Xm = function(e) {
  return Object.freeze(e);
}, eW = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Xm(this);
  }
  return e;
}(), tW = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Xm(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), nE = typeof window < "u" ? window : {};
/msie|trident/i.test(nE.navigator && nE.navigator.userAgent);
var ff = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new eW((n ? t : e) || 0, (n ? e : t) || 0);
};
Xm({
  devicePixelContentBoxSize: ff(),
  borderBoxSize: ff(),
  contentBoxSize: ff(),
  contentRect: new tW(0, 0, 0, 0)
});
function Qa(e) {
  "@babel/helpers - typeof";
  return Qa = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, Qa(e);
}
function nW(e, t) {
  if (Qa(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (Qa(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function rW(e) {
  var t = nW(e, "string");
  return Qa(t) === "symbol" ? t : String(t);
}
function Pa(e, t, n) {
  return t = rW(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var oW = /* @__PURE__ */ Ye(null), hf, gf;
parseInt(Be.version.split(".")[0], 10);
var rE = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), mf = typeof navigator < "u" && /Android/.test(navigator.userAgent), hu = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), iW = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (hf = navigator.userAgent.match(/Version\/(\d+)/)) !== null && hf !== void 0 && hf[1] && parseInt((gf = navigator.userAgent.match(/Version\/(\d+)/)) === null || gf === void 0 ? void 0 : gf[1], 10) < 17;
var sW = /* @__PURE__ */ new WeakMap(), aW = /* @__PURE__ */ new WeakMap(), lW = /* @__PURE__ */ new WeakMap(), uW = /* @__PURE__ */ new WeakMap(), cW = /* @__PURE__ */ new WeakMap(), oE = /* @__PURE__ */ new WeakMap(), pW = /* @__PURE__ */ new WeakMap(), iE = /* @__PURE__ */ new WeakMap(), gu = /* @__PURE__ */ new WeakMap(), dW = /* @__PURE__ */ new WeakMap(), fW = /* @__PURE__ */ new WeakMap(), hW = /* @__PURE__ */ new WeakMap(), pM = globalThis.Node, gW = globalThis.Text, dM = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, mW = (e) => Tc(e) && e.nodeType === 8, xo = (e) => Tc(e) && e.nodeType === 1, Tc = (e) => {
  var t = dM(e);
  return !!t && e instanceof t.Node;
}, sE = (e) => {
  var t = e && e.anchorNode && dM(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, vW = (e) => {
  var [t, n] = e;
  if (xo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = fM(t, o, r ? "backward" : "forward"), r = o < n; xo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = bW(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, yW = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, fM = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (mW(o) || xo(o) && o.childNodes.length === 0 || xo(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, bW = (e, t, n) => {
  var [r] = fM(e, t, n);
  return r;
}, aE = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), hM = (e, t, n) => {
  var {
    target: r
  } = t;
  if (xo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Tt.getWindow(e);
  if (o.contains(r))
    return Tt.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : hM(e, i, n);
}, lE = (e, t) => !!(e.compareDocumentPosition(t) & pM.DOCUMENT_POSITION_PRECEDING), wW = (e, t) => !!(e.compareDocumentPosition(t) & pM.DOCUMENT_POSITION_FOLLOWING), CW = 0;
class EW {
  constructor() {
    Pa(this, "id", void 0), this.id = "".concat(CW++);
  }
}
var Tt = {
  androidPendingDiffs: (e) => hW.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = fW.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Tt.toDOMNode(e, e), n = Tt.findDocumentOrShadowRoot(e);
    gu.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Tt.findDocumentOrShadowRoot(e), r = aE(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Pc.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Tt.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Tt.toSlateNode(e, t.target), s = Tt.findPath(e, i);
    if (Fo.isElement(i) && Qt.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = Qt.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? Qt.before(e, u) : Qt.after(e, u);
      if (c) {
        var p = Qt.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = Tt.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var m = g.caretPositionFromPoint(n, r);
      m && (d = g.createRange(), d.setStart(m.offsetNode, m.offset), d.setEnd(m.offsetNode, m.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var f = Tt.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return f;
  },
  findKey: (e, t) => {
    var n = oE.get(t);
    return n || (n = new EW(), oE.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = aW.get(r);
      if (o == null) {
        if (Qt.isEditor(r))
          return n;
        break;
      }
      var i = sW.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat($r.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!gu.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          Tt.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = Tt.toDOMNode(e, e), r = Tt.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = aE(r), i = Tt.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Pc.select(e, Qt.start(e, [])), gu.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = lW.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Tt.toDOMNode(e, e), i;
    try {
      i = xo(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Tc(t) && Tt.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Qt.hasPath(e, n.path) && Qt.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Tt.hasEditableTarget(e, t) || Tt.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Tc(t) && Tt.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!dW.get(e),
  isFocused: (e) => !!gu.get(e),
  isReadOnly: (e) => !!iE.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (iE.get(e)) return !1;
    var n = Tt.hasTarget(e, t) && Tt.toSlateNode(e, t);
    return Fo.isElement(n) && Qt.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = pW.get(e), r = Qt.isEditor(t) ? uW.get(e) : n == null ? void 0 : n.get(Tt.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat($r.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Qt.node(e, t.path), r = Tt.toDOMNode(e, n), o;
    Qt.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), m = a + g, f = s[l + 1];
        if (t.offset === m && f !== null && f !== void 0 && f.hasAttribute("data-slate-mark-placeholder")) {
          var h, E = f.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof gW ? E : f,
            (h = f.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= m) {
          var L = Math.min(p, Math.max(0, t.offset - a));
          o = [c, L];
          break;
        }
        a = m;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat($r.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = ft.isBackward(t), i = Tt.toDOMPoint(e, n), s = ft.isCollapsed(t) ? i : Tt.toDOMPoint(e, r), a = Tt.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, g = xo(u) ? u : u.parentElement, m = !!g.getAttribute("data-slate-zero-width"), f = xo(p) ? p : p.parentElement, h = !!f.getAttribute("data-slate-zero-width");
    return l.setStart(u, m ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = xo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? cW.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : vW(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = Tt.toDOMNode(e, e), m = l.closest('[data-slate-void="true"]'), f = m && g.contains(m) ? m : null, h = l.closest('[contenteditable="false"]'), E = h && g.contains(h) ? h : null, L = l.closest("[data-slate-leaf]"), x = null;
      if (L) {
        if (u = L.closest('[data-slate-node="text"]'), u) {
          var T = Tt.getWindow(e), w = T.document.createRange();
          w.setStart(u, 0), w.setEnd(s, a);
          var C = w.cloneContents(), k = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          k.forEach((j) => {
            if (mf && !r && j.hasAttribute("data-slate-zero-width") && j.textContent.length > 0 && j.textContext !== "\uFEFF") {
              j.textContent.startsWith("\uFEFF") && (j.textContent = j.textContent.slice(1));
              return;
            }
            j.parentNode.removeChild(j);
          }), c = C.textContent.length, x = u;
        }
      } else if (f) {
        for (var O = f.querySelectorAll("[data-slate-leaf]"), U = 0; U < O.length; U++) {
          var M = O[U];
          if (Tt.hasDOMNode(e, M)) {
            L = M;
            break;
          }
        }
        L ? (u = L.closest('[data-slate-node="text"]'), x = L, c = x.textContent.length, x.querySelectorAll("[data-slate-zero-width]").forEach((j) => {
          c -= j.textContent.length;
        })) : c = 1;
      } else if (E) {
        var V = (j) => j ? j.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var W, R = [...V($), ...V($ == null ? void 0 : $.nextElementSibling)];
          L = (W = R.find((j) => wW(E, j))) !== null && W !== void 0 ? W : null;
        } else {
          var H, X = [...V($ == null ? void 0 : $.previousElementSibling), ...V($)];
          L = (H = X.findLast((j) => lE(E, j))) !== null && H !== void 0 ? H : null;
        }
        L && (u = L.closest('[data-slate-node="text"]'), x = L, i === "forward" ? c = 0 : (c = x.textContent.length, x.querySelectorAll("[data-slate-zero-width]").forEach((j) => {
          c -= j.textContent.length;
        })));
      }
      x && c === x.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      mf && x.getAttribute("data-slate-zero-width") === "z" && (p = x.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      hu && (d = x.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (mf && !u && !r) {
      var I = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (I && Tt.hasDOMNode(e, I, {
        editable: !0
      })) {
        var J = Tt.toSlateNode(e, I), {
          path: te,
          offset: S
        } = Qt.start(e, Tt.findPath(e, J));
        return I.querySelector("[data-slate-leaf]") || (S = a), {
          path: te,
          offset: S
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var P = Tt.toSlateNode(e, u), q = Tt.findPath(e, P);
    return {
      path: q,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = sE(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (sE(t)) {
        if (hu && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(k) {
              return k.childElementCount > 0 ? C(k.children[0]) : k;
            };
            var m = d.startContainer, f = g.startContainer, h = C(m.children[d.startOffset]), E = C(f.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? a = E.childNodes[0] : a = E, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = g.endContainer, l = g.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        iW && yW(a) || hu ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    hu && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var L = Tt.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!L)
      return null;
    var x = lE(a, u) || a === u && c < l, T = p ? L : Tt.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: x ? "forward" : "backward"
    });
    if (!T)
      return null;
    var w = {
      anchor: L,
      focus: T
    };
    return ft.isExpanded(w) && ft.isForward(w) && xo(u) && Qt.void(e, {
      at: w.focus,
      mode: "highest"
    }) && (w = Qt.unhangRange(e, w, {
      voids: !0
    })), w;
  }
}, xW = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, LW = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, kW = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, On = (e) => {
  var t = xW[e], n = LW[e], r = kW[e], o = t && cf(t), i = n && cf(n), s = r && cf(r);
  return (a) => !!(o && o(a) || rE && i && i(a) || !rE && s && s(a));
};
On("bold"), On("compose"), On("moveBackward"), On("moveForward"), On("deleteBackward"), On("deleteForward"), On("deleteLineBackward"), On("deleteLineForward"), On("deleteWordBackward"), On("deleteWordForward"), On("extendBackward"), On("extendForward"), On("extendLineBackward"), On("extendLineForward"), On("italic"), On("moveLineBackward"), On("moveLineForward"), On("moveWordBackward"), On("moveWordForward"), On("redo"), On("insertSoftBreak"), On("splitBlock"), On("transposeCharacter"), On("undo");
var DW = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => hM(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, SW = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class OW extends Yc {
  constructor() {
    super(...arguments), Pa(this, "context", null), Pa(this, "manager", null), Pa(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, SW);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = DW(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Pa(OW, "contextType", oW);
var gM = {}, Qm = {}, Jm = {};
Object.defineProperty(Jm, "__esModule", { value: !0 });
Jm.default = AW;
var uE = "html", cE = "head", mu = "body", MW = /<([a-zA-Z]+[0-9]?)/, pE = /<head[^]*>/i, dE = /<body[^]*>/i, Ac = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, cg = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, fE = typeof window == "object" && window.DOMParser;
if (typeof fE == "function") {
  var PW = new fE(), TW = "text/html";
  cg = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), PW.parseFromString(e, TW);
  }, Ac = cg;
}
if (typeof document == "object" && document.implementation) {
  var vu = document.implementation.createHTMLDocument();
  Ac = function(e, t) {
    if (t) {
      var n = vu.documentElement.querySelector(t);
      return n && (n.innerHTML = e), vu;
    }
    return vu.documentElement.innerHTML = e, vu;
  };
}
var yu = typeof document == "object" && document.createElement("template"), pg;
yu && yu.content && (pg = function(e) {
  return yu.innerHTML = e, yu.content.childNodes;
});
function AW(e) {
  var t, n, r = e.match(MW), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case uE: {
      var i = cg(e);
      if (!pE.test(e)) {
        var s = i.querySelector(cE);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!dE.test(e)) {
        var s = i.querySelector(mu);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(uE);
    }
    case cE:
    case mu: {
      var a = Ac(e).querySelectorAll(o);
      return dE.test(e) && pE.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (pg)
        return pg(e);
      var s = Ac(e, mu).querySelector(mu);
      return s.childNodes;
    }
  }
}
var Lp = {}, ev = {}, tv = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(tv);
var Et = {}, Pi = nn && nn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Ta = nn && nn.__assign || function() {
  return Ta = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, Ta.apply(this, arguments);
};
Object.defineProperty(Et, "__esModule", { value: !0 });
Et.cloneNode = Et.hasChildren = Et.isDocument = Et.isDirective = Et.isComment = Et.isText = Et.isCDATA = Et.isTag = Et.Element = Et.Document = Et.CDATA = Et.NodeWithChildren = Et.ProcessingInstruction = Et.Comment = Et.Text = Et.DataNode = Et.Node = void 0;
var Fr = tv, nv = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), rv(this, t);
    }, e;
  }()
);
Et.Node = nv;
var kp = (
  /** @class */
  function(e) {
    Pi(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(nv)
);
Et.DataNode = kp;
var mM = (
  /** @class */
  function(e) {
    Pi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Fr.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kp)
);
Et.Text = mM;
var vM = (
  /** @class */
  function(e) {
    Pi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Fr.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kp)
);
Et.Comment = vM;
var yM = (
  /** @class */
  function(e) {
    Pi(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Fr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(kp)
);
Et.ProcessingInstruction = yM;
var Dp = (
  /** @class */
  function(e) {
    Pi(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(nv)
);
Et.NodeWithChildren = Dp;
var bM = (
  /** @class */
  function(e) {
    Pi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Fr.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Dp)
);
Et.CDATA = bM;
var wM = (
  /** @class */
  function(e) {
    Pi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Fr.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Dp)
);
Et.Document = wM;
var CM = (
  /** @class */
  function(e) {
    Pi(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Fr.ElementType.Script : n === "style" ? Fr.ElementType.Style : Fr.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Dp)
);
Et.Element = CM;
function EM(e) {
  return (0, Fr.isTag)(e);
}
Et.isTag = EM;
function xM(e) {
  return e.type === Fr.ElementType.CDATA;
}
Et.isCDATA = xM;
function LM(e) {
  return e.type === Fr.ElementType.Text;
}
Et.isText = LM;
function kM(e) {
  return e.type === Fr.ElementType.Comment;
}
Et.isComment = kM;
function DM(e) {
  return e.type === Fr.ElementType.Directive;
}
Et.isDirective = DM;
function SM(e) {
  return e.type === Fr.ElementType.Root;
}
Et.isDocument = SM;
function BW(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Et.hasChildren = BW;
function rv(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (LM(e))
    n = new mM(e.data);
  else if (kM(e))
    n = new vM(e.data);
  else if (EM(e)) {
    var r = t ? vf(e.children) : [], o = new CM(e.name, Ta({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = Ta({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = Ta({}, e["x-attribsPrefix"])), n = o;
  } else if (xM(e)) {
    var r = t ? vf(e.children) : [], i = new bM(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (SM(e)) {
    var r = t ? vf(e.children) : [], s = new wM(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (DM(e)) {
    var a = new yM(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Et.cloneNode = rv;
function vf(e) {
  for (var t = e.map(function(r) {
    return rv(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = nn && nn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = nn && nn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = tv, o = Et;
  n(Et, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(ev);
var OM = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(OM);
Object.defineProperty(Lp, "__esModule", { value: !0 });
Lp.formatAttributes = MM;
Lp.formatDOM = PM;
var bu = ev, _W = OM;
function IW(e) {
  return _W.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function MM(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function jW(e) {
  e = e.toLowerCase();
  var t = IW(e);
  return t || e;
}
function PM(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = jW(a.nodeName);
        o = new bu.Element(l, MM(a.attributes)), o.children = PM(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new bu.Text(a.nodeValue);
        break;
      case 8:
        o = new bu.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new bu.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var NW = nn && nn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Qm, "__esModule", { value: !0 });
Qm.default = UW;
var FW = NW(Jm), RW = Lp, zW = /<(![a-zA-Z\s]+)>/;
function UW(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(zW), n = t ? t[1] : void 0;
  return (0, RW.formatDOM)((0, FW.default)(e), null, n);
}
var Sp = {}, fo = {}, Op = {}, $W = 0;
Op.SAME = $W;
var WW = 1;
Op.CAMELCASE = WW;
Op.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const TM = 0, Ti = 1, Mp = 2, Pp = 3, ov = 4, AM = 5, BM = 6;
function HW(e) {
  return mr.hasOwnProperty(e) ? mr[e] : null;
}
function Or(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === Mp || t === Pp || t === ov, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const mr = {}, VW = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
VW.forEach((e) => {
  mr[e] = new Or(
    e,
    TM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  mr[e] = new Or(
    e,
    Ti,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  mr[e] = new Or(
    e,
    Mp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  mr[e] = new Or(
    e,
    Mp,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  mr[e] = new Or(
    e,
    Pp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  mr[e] = new Or(
    e,
    Pp,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  mr[e] = new Or(
    e,
    ov,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  mr[e] = new Or(
    e,
    BM,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  mr[e] = new Or(
    e,
    AM,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const iv = /[\-\:]([a-z])/g, sv = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(iv, sv);
  mr[t] = new Or(
    t,
    Ti,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(iv, sv);
  mr[t] = new Or(
    t,
    Ti,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(iv, sv);
  mr[t] = new Or(
    t,
    Ti,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  mr[e] = new Or(
    e,
    Ti,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const ZW = "xlinkHref";
mr[ZW] = new Or(
  "xlinkHref",
  Ti,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  mr[e] = new Or(
    e,
    Ti,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: qW,
  SAME: GW,
  possibleStandardNames: hE
} = Op, KW = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", YW = KW + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", XW = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + YW + "]*$")
), QW = Object.keys(
  hE
).reduce((e, t) => {
  const n = hE[t];
  return n === GW ? e[t] = t : n === qW ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
fo.BOOLEAN = Pp;
fo.BOOLEANISH_STRING = Mp;
fo.NUMERIC = AM;
fo.OVERLOADED_BOOLEAN = ov;
fo.POSITIVE_NUMERIC = BM;
fo.RESERVED = TM;
fo.STRING = Ti;
fo.getPropertyInfo = HW;
fo.isCustomAttribute = XW;
fo.possibleStandardNames = QW;
var av = {}, lv = {}, gE = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, JW = /\n/g, eH = /^\s*/, tH = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, nH = /^:\s*/, rH = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, oH = /^[;\s]*/, iH = /^\s+|\s+$/g, sH = `
`, mE = "/", vE = "*", rs = "", aH = "comment", lH = "declaration", uH = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(m) {
    var f = m.match(JW);
    f && (n += f.length);
    var h = m.lastIndexOf(sH);
    r = ~h ? m.length - h : r + m.length;
  }
  function i() {
    var m = { line: n, column: r };
    return function(f) {
      return f.position = new s(m), u(), f;
    };
  }
  function s(m) {
    this.start = m, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(m) {
    var f = new Error(
      t.source + ":" + n + ":" + r + ": " + m
    );
    if (f.reason = m, f.filename = t.source, f.line = n, f.column = r, f.source = e, !t.silent) throw f;
  }
  function l(m) {
    var f = m.exec(e);
    if (f) {
      var h = f[0];
      return o(h), e = e.slice(h.length), f;
    }
  }
  function u() {
    l(eH);
  }
  function c(m) {
    var f;
    for (m = m || []; f = p(); )
      f !== !1 && m.push(f);
    return m;
  }
  function p() {
    var m = i();
    if (!(mE != e.charAt(0) || vE != e.charAt(1))) {
      for (var f = 2; rs != e.charAt(f) && (vE != e.charAt(f) || mE != e.charAt(f + 1)); )
        ++f;
      if (f += 2, rs === e.charAt(f - 1))
        return a("End of comment missing");
      var h = e.slice(2, f - 2);
      return r += 2, o(h), e = e.slice(f), r += 2, m({
        type: aH,
        comment: h
      });
    }
  }
  function d() {
    var m = i(), f = l(tH);
    if (f) {
      if (p(), !l(nH)) return a("property missing ':'");
      var h = l(rH), E = m({
        type: lH,
        property: yE(f[0].replace(gE, rs)),
        value: h ? yE(h[0].replace(gE, rs)) : rs
      });
      return l(oH), E;
    }
  }
  function g() {
    var m = [];
    c(m);
    for (var f; f = d(); )
      f !== !1 && (m.push(f), c(m));
    return m;
  }
  return u(), g();
};
function yE(e) {
  return e ? e.replace(iH, rs) : rs;
}
var cH = nn && nn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(lv, "__esModule", { value: !0 });
lv.default = dH;
var pH = cH(uH);
function dH(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, pH.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Tp = {};
Object.defineProperty(Tp, "__esModule", { value: !0 });
Tp.camelCase = void 0;
var fH = /^--[a-zA-Z0-9-]+$/, hH = /-([a-z])/g, gH = /^[^-]+$/, mH = /^-(webkit|moz|ms|o|khtml)-/, vH = /^-(ms)-/, yH = function(e) {
  return !e || gH.test(e) || fH.test(e);
}, bH = function(e, t) {
  return t.toUpperCase();
}, bE = function(e, t) {
  return "".concat(t, "-");
}, wH = function(e, t) {
  return t === void 0 && (t = {}), yH(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(vH, bE) : e = e.replace(mH, bE), e.replace(hH, bH));
};
Tp.camelCase = wH;
var CH = nn && nn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, EH = CH(lv), xH = Tp;
function dg(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, EH.default)(e, function(r, o) {
    r && o && (n[(0, xH.camelCase)(r, t)] = o);
  }), n;
}
dg.default = dg;
var LH = dg;
(function(e) {
  var t = nn && nn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Be, r = t(LH), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(av);
Object.defineProperty(Sp, "__esModule", { value: !0 });
Sp.default = OH;
var ba = fo, wE = av, kH = ["checked", "value"], DH = ["input", "select", "textarea"], SH = {
  reset: !0,
  submit: !0
};
function OH(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && SH[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, ba.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = CE(s);
    if (a) {
      var l = (0, ba.getPropertyInfo)(a);
      switch (kH.includes(a) && DH.includes(t) && !r && (a = CE("default" + s)), n[a] = i, l && l.type) {
        case ba.BOOLEAN:
          n[a] = !0;
          break;
        case ba.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    wE.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, wE.setStyleProp)(e.style, n), n;
}
function CE(e) {
  return ba.possibleStandardNames[e];
}
var uv = {}, MH = nn && nn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(uv, "__esModule", { value: !0 });
uv.default = _M;
var yf = Be, PH = MH(Sp), Aa = av, TH = {
  cloneElement: yf.cloneElement,
  createElement: yf.createElement,
  isValidElement: yf.isValidElement
};
function _M(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Aa.returnFirstArg, i = t.library || TH, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Aa.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var m = p, f = {};
    AH(m) ? ((0, Aa.setStyleProp)(m.attribs.style, m.attribs), f = m.attribs) : m.attribs && (f = (0, PH.default)(m.attribs, m.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (f.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? f.defaultValue = p.children[0].data : p.children && p.children.length && (h = _M(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (f.key = c), n.push(o(a(p.name, f, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function AH(e) {
  return Aa.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Aa.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = nn && nn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(Qm);
  e.htmlToDOM = n.default;
  var r = t(Sp);
  e.attributesToProps = r.default;
  var o = t(uv);
  e.domToReact = o.default;
  var i = ev;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(gM);
const BH = /* @__PURE__ */ Oj(gM);
BH.default;
Ye({});
Ye({});
Ye({});
var er = {}, cv = {}, bl = {}, wl = {}, IM = "Expected a function", EE = NaN, _H = "[object Symbol]", IH = /^\s+|\s+$/g, jH = /^[-+]0x[0-9a-f]+$/i, NH = /^0b[01]+$/i, FH = /^0o[0-7]+$/i, RH = parseInt, zH = typeof nn == "object" && nn && nn.Object === Object && nn, UH = typeof self == "object" && self && self.Object === Object && self, $H = zH || UH || Function("return this")(), WH = Object.prototype, HH = WH.toString, VH = Math.max, ZH = Math.min, bf = function() {
  return $H.Date.now();
};
function qH(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(IM);
  t = xE(t) || 0, Bc(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? VH(xE(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var k = r, O = o;
    return r = o = void 0, u = C, s = e.apply(O, k), s;
  }
  function m(C) {
    return u = C, a = setTimeout(E, t), c ? g(C) : s;
  }
  function f(C) {
    var k = C - l, O = C - u, U = t - k;
    return p ? ZH(U, i - O) : U;
  }
  function h(C) {
    var k = C - l, O = C - u;
    return l === void 0 || k >= t || k < 0 || p && O >= i;
  }
  function E() {
    var C = bf();
    if (h(C))
      return L(C);
    a = setTimeout(E, f(C));
  }
  function L(C) {
    return a = void 0, d && r ? g(C) : (r = o = void 0, s);
  }
  function x() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function T() {
    return a === void 0 ? s : L(bf());
  }
  function w() {
    var C = bf(), k = h(C);
    if (r = arguments, o = this, l = C, k) {
      if (a === void 0)
        return m(l);
      if (p)
        return a = setTimeout(E, t), g(l);
    }
    return a === void 0 && (a = setTimeout(E, t)), s;
  }
  return w.cancel = x, w.flush = T, w;
}
function GH(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(IM);
  return Bc(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), qH(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Bc(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function KH(e) {
  return !!e && typeof e == "object";
}
function YH(e) {
  return typeof e == "symbol" || KH(e) && HH.call(e) == _H;
}
function xE(e) {
  if (typeof e == "number")
    return e;
  if (YH(e))
    return EE;
  if (Bc(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Bc(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(IH, "");
  var n = NH.test(e);
  return n || FH.test(e) ? RH(e.slice(2), n ? 2 : 8) : jH.test(e) ? EE : +e;
}
var XH = GH, Cl = {};
Object.defineProperty(Cl, "__esModule", {
  value: !0
});
Cl.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), oc.has(t) || oc.set(t, /* @__PURE__ */ new Set());
  var o = oc.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Cl.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), oc.get(t).delete(n.name || t);
};
var oc = /* @__PURE__ */ new Map();
Object.defineProperty(wl, "__esModule", {
  value: !0
});
var QH = XH, JH = t9(QH), e9 = Cl;
function t9(e) {
  return e && e.__esModule ? e : { default: e };
}
var n9 = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, JH.default)(e, t);
}, Wn = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = n9(function(r) {
        Wn.scrollHandler(e);
      }, t);
      Wn.scrollSpyContainers.push(e), (0, e9.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Wn.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Wn.scrollSpyContainers[Wn.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Wn.currentPositionX(e), Wn.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Wn.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Wn.scrollSpyContainers[Wn.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Wn.currentPositionX(t), Wn.currentPositionY(t));
  },
  updateStates: function() {
    Wn.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Wn.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Wn.spySetState && Wn.spySetState.length && Wn.spySetState.indexOf(e) > -1 && Wn.spySetState.splice(Wn.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Wn.scrollHandler);
  },
  update: function() {
    return Wn.scrollSpyContainers.forEach(function(e) {
      return Wn.scrollHandler(e);
    });
  }
};
wl.default = Wn;
var $s = {}, El = {};
Object.defineProperty(El, "__esModule", {
  value: !0
});
var r9 = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, o9 = function() {
  return window.location.hash.replace(/^#/, "");
}, i9 = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, s9 = function(e) {
  return getComputedStyle(e).position !== "static";
}, wf = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, a9 = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (s9(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = wf(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return wf(t, a).offsetTop - wf(e, a).offsetTop;
};
El.default = {
  updateHash: r9,
  getHash: o9,
  filterElementInContainer: i9,
  scrollOffset: a9
};
var Ap = {}, pv = {};
Object.defineProperty(pv, "__esModule", {
  value: !0
});
pv.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var dv = {};
Object.defineProperty(dv, "__esModule", {
  value: !0
});
var l9 = Cl, u9 = ["mousedown", "mousewheel", "touchmove", "keydown"];
dv.default = {
  subscribe: function(e) {
    return typeof document < "u" && u9.forEach(function(t) {
      return (0, l9.addPassiveEventListener)(document, t, e);
    });
  }
};
var xl = {};
Object.defineProperty(xl, "__esModule", {
  value: !0
});
var fg = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      fg.registered[e] = t;
    },
    remove: function(e) {
      fg.registered[e] = null;
    }
  }
};
xl.default = fg;
Object.defineProperty(Ap, "__esModule", {
  value: !0
});
var c9 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, p9 = El;
Bp(p9);
var d9 = pv, LE = Bp(d9), f9 = dv, h9 = Bp(f9), g9 = xl, bo = Bp(g9);
function Bp(e) {
  return e && e.__esModule ? e : { default: e };
}
var jM = function(e) {
  return LE.default[e.smooth] || LE.default.defaultEasing;
}, m9 = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, v9 = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, hg = function() {
  return v9() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), NM = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, FM = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, RM = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, y9 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, b9 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, w9 = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    bo.default.registered.end && bo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    hg.call(window, i);
    return;
  }
  bo.default.registered.end && bo.default.registered.end(o.to, o.target, o.currentPosition);
}, fv = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Ll = function(e, t, n, r) {
  t.data = t.data || NM(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (h9.default.subscribe(o), fv(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? FM(t) : RM(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    bo.default.registered.end && bo.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = m9(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = jM(t), s = w9.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      bo.default.registered.begin && bo.default.registered.begin(t.data.to, t.data.target), hg.call(window, s);
    }, t.delay);
    return;
  }
  bo.default.registered.begin && bo.default.registered.begin(t.data.to, t.data.target), hg.call(window, s);
}, _p = function(e) {
  return e = c9({}, e), e.data = e.data || NM(), e.absolute = !0, e;
}, C9 = function(e) {
  Ll(0, _p(e));
}, E9 = function(e, t) {
  Ll(e, _p(t));
}, x9 = function(e) {
  e = _p(e), fv(e), Ll(e.horizontal ? y9(e) : b9(e), e);
}, L9 = function(e, t) {
  t = _p(t), fv(t);
  var n = t.horizontal ? FM(t) : RM(t);
  Ll(e + n, t);
};
Ap.default = {
  animateTopScroll: Ll,
  getAnimationType: jM,
  scrollToTop: C9,
  scrollToBottom: x9,
  scrollTo: E9,
  scrollMore: L9
};
Object.defineProperty($s, "__esModule", {
  value: !0
});
var k9 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, D9 = El, S9 = hv(D9), O9 = Ap, M9 = hv(O9), P9 = xl, wu = hv(P9);
function hv(e) {
  return e && e.__esModule ? e : { default: e };
}
var Cu = {}, kE = void 0;
$s.default = {
  unmount: function() {
    Cu = {};
  },
  register: function(e, t) {
    Cu[e] = t;
  },
  unregister: function(e) {
    delete Cu[e];
  },
  get: function(e) {
    return Cu[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return kE = e;
  },
  getActiveLink: function() {
    return kE;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = k9({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = S9.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      wu.default.registered.begin && wu.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, wu.default.registered.end && wu.default.registered.end(e, n);
      return;
    }
    M9.default.animateTopScroll(a, t, e, n);
  }
};
var gg = { exports: {} }, Cf = { exports: {} }, $t = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var DE;
function T9() {
  if (DE) return $t;
  DE = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
  function x(w) {
    if (typeof w == "object" && w !== null) {
      var C = w.$$typeof;
      switch (C) {
        case t:
          switch (w = w.type, w) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return w;
            default:
              switch (w = w && w.$$typeof, w) {
                case a:
                case c:
                case m:
                case g:
                case s:
                  return w;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function T(w) {
    return x(w) === u;
  }
  return $t.AsyncMode = l, $t.ConcurrentMode = u, $t.ContextConsumer = a, $t.ContextProvider = s, $t.Element = t, $t.ForwardRef = c, $t.Fragment = r, $t.Lazy = m, $t.Memo = g, $t.Portal = n, $t.Profiler = i, $t.StrictMode = o, $t.Suspense = p, $t.isAsyncMode = function(w) {
    return T(w) || x(w) === l;
  }, $t.isConcurrentMode = T, $t.isContextConsumer = function(w) {
    return x(w) === a;
  }, $t.isContextProvider = function(w) {
    return x(w) === s;
  }, $t.isElement = function(w) {
    return typeof w == "object" && w !== null && w.$$typeof === t;
  }, $t.isForwardRef = function(w) {
    return x(w) === c;
  }, $t.isFragment = function(w) {
    return x(w) === r;
  }, $t.isLazy = function(w) {
    return x(w) === m;
  }, $t.isMemo = function(w) {
    return x(w) === g;
  }, $t.isPortal = function(w) {
    return x(w) === n;
  }, $t.isProfiler = function(w) {
    return x(w) === i;
  }, $t.isStrictMode = function(w) {
    return x(w) === o;
  }, $t.isSuspense = function(w) {
    return x(w) === p;
  }, $t.isValidElementType = function(w) {
    return typeof w == "string" || typeof w == "function" || w === r || w === u || w === i || w === o || w === p || w === d || typeof w == "object" && w !== null && (w.$$typeof === m || w.$$typeof === g || w.$$typeof === s || w.$$typeof === a || w.$$typeof === c || w.$$typeof === h || w.$$typeof === E || w.$$typeof === L || w.$$typeof === f);
  }, $t.typeOf = x, $t;
}
var Kt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var SE;
function A9() {
  return SE || (SE = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
    function x(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === m || B.$$typeof === g || B.$$typeof === s || B.$$typeof === a || B.$$typeof === c || B.$$typeof === h || B.$$typeof === E || B.$$typeof === L || B.$$typeof === f);
    }
    function T(B) {
      if (typeof B == "object" && B !== null) {
        var se = B.$$typeof;
        switch (se) {
          case t:
            var ue = B.type;
            switch (ue) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ue;
              default:
                var ce = ue && ue.$$typeof;
                switch (ce) {
                  case a:
                  case c:
                  case m:
                  case g:
                  case s:
                    return ce;
                  default:
                    return se;
                }
            }
          case n:
            return se;
        }
      }
    }
    var w = l, C = u, k = a, O = s, U = t, M = c, V = r, $ = m, W = g, R = n, H = i, X = o, I = p, J = !1;
    function te(B) {
      return J || (J = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), S(B) || T(B) === l;
    }
    function S(B) {
      return T(B) === u;
    }
    function P(B) {
      return T(B) === a;
    }
    function q(B) {
      return T(B) === s;
    }
    function j(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function Z(B) {
      return T(B) === c;
    }
    function G(B) {
      return T(B) === r;
    }
    function b(B) {
      return T(B) === m;
    }
    function F(B) {
      return T(B) === g;
    }
    function z(B) {
      return T(B) === n;
    }
    function A(B) {
      return T(B) === i;
    }
    function Y(B) {
      return T(B) === o;
    }
    function ee(B) {
      return T(B) === p;
    }
    Kt.AsyncMode = w, Kt.ConcurrentMode = C, Kt.ContextConsumer = k, Kt.ContextProvider = O, Kt.Element = U, Kt.ForwardRef = M, Kt.Fragment = V, Kt.Lazy = $, Kt.Memo = W, Kt.Portal = R, Kt.Profiler = H, Kt.StrictMode = X, Kt.Suspense = I, Kt.isAsyncMode = te, Kt.isConcurrentMode = S, Kt.isContextConsumer = P, Kt.isContextProvider = q, Kt.isElement = j, Kt.isForwardRef = Z, Kt.isFragment = G, Kt.isLazy = b, Kt.isMemo = F, Kt.isPortal = z, Kt.isProfiler = A, Kt.isStrictMode = Y, Kt.isSuspense = ee, Kt.isValidElementType = x, Kt.typeOf = T;
  }()), Kt;
}
var OE;
function zM() {
  return OE || (OE = 1, process.env.NODE_ENV === "production" ? Cf.exports = T9() : Cf.exports = A9()), Cf.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Ef, ME;
function B9() {
  if (ME) return Ef;
  ME = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Ef = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, Ef;
}
var xf, PE;
function gv() {
  if (PE) return xf;
  PE = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return xf = e, xf;
}
var TE, AE;
function UM() {
  return AE || (AE = 1, TE = Function.call.bind(Object.prototype.hasOwnProperty)), TE;
}
var Lf, BE;
function _9() {
  if (BE) return Lf;
  BE = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = gv(), n = {}, r = UM();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (m) {
            p = m;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Lf = o, Lf;
}
var kf, _E;
function I9() {
  if (_E) return kf;
  _E = 1;
  var e = zM(), t = B9(), n = gv(), r = UM(), o = _9(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return kf = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(S) {
      var P = S && (u && S[u] || S[c]);
      if (typeof P == "function")
        return P;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: L(),
      arrayOf: x,
      element: T(),
      elementType: w(),
      instanceOf: C,
      node: M(),
      objectOf: O,
      oneOf: k,
      oneOfType: U,
      shape: $,
      exact: W
    };
    function m(S, P) {
      return S === P ? S !== 0 || 1 / S === 1 / P : S !== S && P !== P;
    }
    function f(S, P) {
      this.message = S, this.data = P && typeof P == "object" ? P : {}, this.stack = "";
    }
    f.prototype = Error.prototype;
    function h(S) {
      if (process.env.NODE_ENV !== "production")
        var P = {}, q = 0;
      function j(G, b, F, z, A, Y, ee) {
        if (z = z || d, Y = Y || F, ee !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var se = z + ":" + F;
            !P[se] && // Avoid spamming the console because they are often not actionable except for lib authors
            q < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + Y + "` prop on `" + z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), P[se] = !0, q++);
          }
        }
        return b[F] == null ? G ? b[F] === null ? new f("The " + A + " `" + Y + "` is marked as required " + ("in `" + z + "`, but its value is `null`.")) : new f("The " + A + " `" + Y + "` is marked as required in " + ("`" + z + "`, but its value is `undefined`.")) : null : S(b, F, z, A, Y);
      }
      var Z = j.bind(null, !1);
      return Z.isRequired = j.bind(null, !0), Z;
    }
    function E(S) {
      function P(q, j, Z, G, b, F) {
        var z = q[j], A = X(z);
        if (A !== S) {
          var Y = I(z);
          return new f(
            "Invalid " + G + " `" + b + "` of type " + ("`" + Y + "` supplied to `" + Z + "`, expected ") + ("`" + S + "`."),
            { expectedType: S }
          );
        }
        return null;
      }
      return h(P);
    }
    function L() {
      return h(s);
    }
    function x(S) {
      function P(q, j, Z, G, b) {
        if (typeof S != "function")
          return new f("Property `" + b + "` of component `" + Z + "` has invalid PropType notation inside arrayOf.");
        var F = q[j];
        if (!Array.isArray(F)) {
          var z = X(F);
          return new f("Invalid " + G + " `" + b + "` of type " + ("`" + z + "` supplied to `" + Z + "`, expected an array."));
        }
        for (var A = 0; A < F.length; A++) {
          var Y = S(F, A, Z, G, b + "[" + A + "]", n);
          if (Y instanceof Error)
            return Y;
        }
        return null;
      }
      return h(P);
    }
    function T() {
      function S(P, q, j, Z, G) {
        var b = P[q];
        if (!a(b)) {
          var F = X(b);
          return new f("Invalid " + Z + " `" + G + "` of type " + ("`" + F + "` supplied to `" + j + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(S);
    }
    function w() {
      function S(P, q, j, Z, G) {
        var b = P[q];
        if (!e.isValidElementType(b)) {
          var F = X(b);
          return new f("Invalid " + Z + " `" + G + "` of type " + ("`" + F + "` supplied to `" + j + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(S);
    }
    function C(S) {
      function P(q, j, Z, G, b) {
        if (!(q[j] instanceof S)) {
          var F = S.name || d, z = te(q[j]);
          return new f("Invalid " + G + " `" + b + "` of type " + ("`" + z + "` supplied to `" + Z + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return h(P);
    }
    function k(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function P(q, j, Z, G, b) {
        for (var F = q[j], z = 0; z < S.length; z++)
          if (m(F, S[z]))
            return null;
        var A = JSON.stringify(S, function(Y, ee) {
          var B = I(ee);
          return B === "symbol" ? String(ee) : ee;
        });
        return new f("Invalid " + G + " `" + b + "` of value `" + String(F) + "` " + ("supplied to `" + Z + "`, expected one of " + A + "."));
      }
      return h(P);
    }
    function O(S) {
      function P(q, j, Z, G, b) {
        if (typeof S != "function")
          return new f("Property `" + b + "` of component `" + Z + "` has invalid PropType notation inside objectOf.");
        var F = q[j], z = X(F);
        if (z !== "object")
          return new f("Invalid " + G + " `" + b + "` of type " + ("`" + z + "` supplied to `" + Z + "`, expected an object."));
        for (var A in F)
          if (r(F, A)) {
            var Y = S(F, A, Z, G, b + "." + A, n);
            if (Y instanceof Error)
              return Y;
          }
        return null;
      }
      return h(P);
    }
    function U(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var P = 0; P < S.length; P++) {
        var q = S[P];
        if (typeof q != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + J(q) + " at index " + P + "."
          ), s;
      }
      function j(Z, G, b, F, z) {
        for (var A = [], Y = 0; Y < S.length; Y++) {
          var ee = S[Y], B = ee(Z, G, b, F, z, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && A.push(B.data.expectedType);
        }
        var se = A.length > 0 ? ", expected one of type [" + A.join(", ") + "]" : "";
        return new f("Invalid " + F + " `" + z + "` supplied to " + ("`" + b + "`" + se + "."));
      }
      return h(j);
    }
    function M() {
      function S(P, q, j, Z, G) {
        return R(P[q]) ? null : new f("Invalid " + Z + " `" + G + "` supplied to " + ("`" + j + "`, expected a ReactNode."));
      }
      return h(S);
    }
    function V(S, P, q, j, Z) {
      return new f(
        (S || "React class") + ": " + P + " type `" + q + "." + j + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Z + "`."
      );
    }
    function $(S) {
      function P(q, j, Z, G, b) {
        var F = q[j], z = X(F);
        if (z !== "object")
          return new f("Invalid " + G + " `" + b + "` of type `" + z + "` " + ("supplied to `" + Z + "`, expected `object`."));
        for (var A in S) {
          var Y = S[A];
          if (typeof Y != "function")
            return V(Z, G, b, A, I(Y));
          var ee = Y(F, A, Z, G, b + "." + A, n);
          if (ee)
            return ee;
        }
        return null;
      }
      return h(P);
    }
    function W(S) {
      function P(q, j, Z, G, b) {
        var F = q[j], z = X(F);
        if (z !== "object")
          return new f("Invalid " + G + " `" + b + "` of type `" + z + "` " + ("supplied to `" + Z + "`, expected `object`."));
        var A = t({}, q[j], S);
        for (var Y in A) {
          var ee = S[Y];
          if (r(S, Y) && typeof ee != "function")
            return V(Z, G, b, Y, I(ee));
          if (!ee)
            return new f(
              "Invalid " + G + " `" + b + "` key `" + Y + "` supplied to `" + Z + "`.\nBad object: " + JSON.stringify(q[j], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(S), null, "  ")
            );
          var B = ee(F, Y, Z, G, b + "." + Y, n);
          if (B)
            return B;
        }
        return null;
      }
      return h(P);
    }
    function R(S) {
      switch (typeof S) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !S;
        case "object":
          if (Array.isArray(S))
            return S.every(R);
          if (S === null || a(S))
            return !0;
          var P = p(S);
          if (P) {
            var q = P.call(S), j;
            if (P !== S.entries) {
              for (; !(j = q.next()).done; )
                if (!R(j.value))
                  return !1;
            } else
              for (; !(j = q.next()).done; ) {
                var Z = j.value;
                if (Z && !R(Z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function H(S, P) {
      return S === "symbol" ? !0 : P ? P["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && P instanceof Symbol : !1;
    }
    function X(S) {
      var P = typeof S;
      return Array.isArray(S) ? "array" : S instanceof RegExp ? "object" : H(P, S) ? "symbol" : P;
    }
    function I(S) {
      if (typeof S > "u" || S === null)
        return "" + S;
      var P = X(S);
      if (P === "object") {
        if (S instanceof Date)
          return "date";
        if (S instanceof RegExp)
          return "regexp";
      }
      return P;
    }
    function J(S) {
      var P = I(S);
      switch (P) {
        case "array":
        case "object":
          return "an " + P;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + P;
        default:
          return P;
      }
    }
    function te(S) {
      return !S.constructor || !S.constructor.name ? d : S.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, kf;
}
var Df, IE;
function j9() {
  if (IE) return Df;
  IE = 1;
  var e = gv();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, Df = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, Df;
}
if (process.env.NODE_ENV !== "production") {
  var N9 = zM(), F9 = !0;
  gg.exports = I9()(N9.isElement, F9);
} else
  gg.exports = j9()();
var Ip = gg.exports, jp = {};
Object.defineProperty(jp, "__esModule", {
  value: !0
});
var R9 = El, Sf = z9(R9);
function z9(e) {
  return e && e.__esModule ? e : { default: e };
}
var U9 = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Sf.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Sf.default.getHash() !== e && Sf.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
jp.default = U9;
Object.defineProperty(bl, "__esModule", {
  value: !0
});
var Eu = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, $9 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), W9 = Be, jE = kl(W9), H9 = wl, xu = kl(H9), V9 = $s, Z9 = kl(V9), q9 = Ip, Mn = kl(q9), G9 = jp, Jo = kl(G9);
function kl(e) {
  return e && e.__esModule ? e : { default: e };
}
function K9(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Y9(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function X9(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var NE = {
  to: Mn.default.string.isRequired,
  containerId: Mn.default.string,
  container: Mn.default.object,
  activeClass: Mn.default.string,
  activeStyle: Mn.default.object,
  spy: Mn.default.bool,
  horizontal: Mn.default.bool,
  smooth: Mn.default.oneOfType([Mn.default.bool, Mn.default.string]),
  offset: Mn.default.number,
  delay: Mn.default.number,
  isDynamic: Mn.default.bool,
  onClick: Mn.default.func,
  duration: Mn.default.oneOfType([Mn.default.number, Mn.default.func]),
  absolute: Mn.default.bool,
  onSetActive: Mn.default.func,
  onSetInactive: Mn.default.func,
  ignoreCancelEvents: Mn.default.bool,
  hashSpy: Mn.default.bool,
  saveHashHistory: Mn.default.bool,
  spyThrottle: Mn.default.number
};
bl.default = function(e, t) {
  var n = t || Z9.default, r = function(i) {
    X9(s, i);
    function s(a) {
      K9(this, s);
      var l = Y9(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return $9(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          xu.default.isMounted(a) || xu.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (Jo.default.isMounted() || Jo.default.mount(n), Jo.default.mapContainer(this.props.to, a)), xu.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        xu.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Eu({}, this.props.style, this.props.activeStyle) : l = Eu({}, this.props.style);
        var u = Eu({}, this.props);
        for (var c in NE)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, jE.default.createElement(e, u);
      }
    }]), s;
  }(jE.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, Eu({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(Jo.default.isMounted() && !Jo.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var m = 0, f = 0, h = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            h = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var L = p.getBoundingClientRect();
            m = L.left - h + s, f = m + L.width;
          }
          var x = s - i.props.offset;
          d = x >= Math.floor(m) && x < Math.floor(f), g = x < Math.floor(m) || x >= Math.floor(f);
        } else {
          var T = 0, w = 0, C = 0;
          if (l.getBoundingClientRect) {
            var k = l.getBoundingClientRect();
            C = k.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var O = p.getBoundingClientRect();
            T = O.top - C + a, w = T + O.height;
          }
          var U = a - i.props.offset;
          d = U >= Math.floor(T) && U < Math.floor(w), g = U < Math.floor(T) || U >= Math.floor(w);
        }
        var M = n.getActiveLink();
        if (g) {
          if (c === M && n.setActiveLink(void 0), i.props.hashSpy && Jo.default.getHash() === c) {
            var V = i.props.saveHashHistory, $ = V === void 0 ? !1 : V;
            Jo.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (M !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var W = i.props.saveHashHistory, R = W === void 0 ? !1 : W;
          i.props.hashSpy && Jo.default.changeHash(c, R), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = NE, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(cv, "__esModule", {
  value: !0
});
var Q9 = Be, FE = $M(Q9), J9 = bl, e8 = $M(J9);
function $M(e) {
  return e && e.__esModule ? e : { default: e };
}
function t8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function RE(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function n8(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var r8 = function(e) {
  n8(t, e);
  function t() {
    var n, r, o, i;
    t8(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = RE(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return FE.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), RE(o, i);
  }
  return t;
}(FE.default.Component);
cv.default = (0, e8.default)(r8);
var mv = {};
Object.defineProperty(mv, "__esModule", {
  value: !0
});
var o8 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), i8 = Be, zE = WM(i8), s8 = bl, a8 = WM(s8);
function WM(e) {
  return e && e.__esModule ? e : { default: e };
}
function l8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function u8(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function c8(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var p8 = function(e) {
  c8(t, e);
  function t() {
    return l8(this, t), u8(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return o8(t, [{
    key: "render",
    value: function() {
      return zE.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(zE.default.Component);
mv.default = (0, a8.default)(p8);
var vv = {}, Np = {};
Object.defineProperty(Np, "__esModule", {
  value: !0
});
var d8 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, f8 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), h8 = Be, UE = Fp(h8), g8 = pl;
Fp(g8);
var m8 = $s, $E = Fp(m8), v8 = Ip, WE = Fp(v8);
function Fp(e) {
  return e && e.__esModule ? e : { default: e };
}
function y8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function b8(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function w8(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Np.default = function(e) {
  var t = function(n) {
    w8(r, n);
    function r(o) {
      y8(this, r);
      var i = b8(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return f8(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        $E.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        $E.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return UE.default.createElement(e, d8({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(UE.default.Component);
  return t.propTypes = {
    name: WE.default.string,
    id: WE.default.string
  }, t;
};
Object.defineProperty(vv, "__esModule", {
  value: !0
});
var HE = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, C8 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), E8 = Be, VE = yv(E8), x8 = Np, L8 = yv(x8), k8 = Ip, ZE = yv(k8);
function yv(e) {
  return e && e.__esModule ? e : { default: e };
}
function D8(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function S8(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function O8(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var HM = function(e) {
  O8(t, e);
  function t() {
    return D8(this, t), S8(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return C8(t, [{
    key: "render",
    value: function() {
      var n = this, r = HE({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, VE.default.createElement(
        "div",
        HE({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(VE.default.Component);
HM.propTypes = {
  name: ZE.default.string,
  id: ZE.default.string
};
vv.default = (0, L8.default)(HM);
var Of = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, qE = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function GE(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function KE(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function YE(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Lu = Be, qi = wl, Mf = $s, qn = Ip, ei = jp, XE = {
  to: qn.string.isRequired,
  containerId: qn.string,
  container: qn.object,
  activeClass: qn.string,
  spy: qn.bool,
  smooth: qn.oneOfType([qn.bool, qn.string]),
  offset: qn.number,
  delay: qn.number,
  isDynamic: qn.bool,
  onClick: qn.func,
  duration: qn.oneOfType([qn.number, qn.func]),
  absolute: qn.bool,
  onSetActive: qn.func,
  onSetInactive: qn.func,
  ignoreCancelEvents: qn.bool,
  hashSpy: qn.bool,
  spyThrottle: qn.number
}, M8 = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Mf, r = function(i) {
      YE(s, i);
      function s(a) {
        GE(this, s);
        var l = KE(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return qE(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            qi.isMounted(a) || qi.mount(a, this.props.spyThrottle), this.props.hashSpy && (ei.isMounted() || ei.mount(n), ei.mapContainer(this.props.to, a)), this.props.spy && qi.addStateHandler(this.stateHandler), qi.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          qi.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = Of({}, this.props);
          for (var u in XE)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Lu.createElement(e, l);
        }
      }]), s;
    }(Lu.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, Of({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(ei.isMounted() && !ei.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var g = a.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var m = u.getBoundingClientRect();
            c = m.top - d + s, p = c + m.height;
          }
          var f = s - i.props.offset, h = f >= Math.floor(c) && f < Math.floor(p), E = f < Math.floor(c) || f >= Math.floor(p), L = n.getActiveLink();
          if (E)
            return l === L && n.setActiveLink(void 0), i.props.hashSpy && ei.getHash() === l && ei.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), qi.updateStates();
          if (h && L !== l)
            return n.setActiveLink(l), i.props.hashSpy && ei.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), qi.updateStates();
        }
      };
    };
    return r.propTypes = XE, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      YE(r, n);
      function r(o) {
        GE(this, r);
        var i = KE(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return qE(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Mf.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Mf.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Lu.createElement(e, Of({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Lu.Component);
    return t.propTypes = {
      name: qn.string,
      id: qn.string
    }, t;
  }
}, P8 = M8;
Object.defineProperty(er, "__esModule", {
  value: !0
});
er.Helpers = er.ScrollElement = er.ScrollLink = er.animateScroll = er.scrollSpy = er.Events = er.scroller = er.Element = er.Button = er.Link = void 0;
var T8 = cv, VM = Do(T8), A8 = mv, ZM = Do(A8), B8 = vv, qM = Do(B8), _8 = $s, GM = Do(_8), I8 = xl, KM = Do(I8), j8 = wl, YM = Do(j8), N8 = Ap, XM = Do(N8), F8 = bl, QM = Do(F8), R8 = Np, JM = Do(R8), z8 = P8, eP = Do(z8);
function Do(e) {
  return e && e.__esModule ? e : { default: e };
}
er.Link = VM.default;
er.Button = ZM.default;
er.Element = qM.default;
er.scroller = GM.default;
er.Events = KM.default;
er.scrollSpy = YM.default;
er.animateScroll = XM.default;
er.ScrollLink = QM.default;
er.ScrollElement = JM.default;
er.Helpers = eP.default;
er.default = { Link: VM.default, Button: ZM.default, Element: qM.default, scroller: GM.default, Events: KM.default, scrollSpy: YM.default, animateScroll: XM.default, ScrollLink: QM.default, ScrollElement: JM.default, Helpers: eP.default };
Ye({});
Ye({});
Ye({});
let U8 = { data: "" }, $8 = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || U8, W8 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, H8 = /\/\*[^]*?\*\/|  +/g, QE = /\n+/g, vi = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? vi(s, i) : i + "{" + vi(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += vi(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += vi.p ? vi.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, Ao = {}, tP = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + tP(e[n]);
    return t;
  }
  return e;
}, V8 = (e, t, n, r, o) => {
  let i = tP(e), s = Ao[i] || (Ao[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Ao[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = W8.exec(u.replace(H8, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(QE, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(QE, " ").trim();
      return d[0];
    })(e);
    Ao[s] = vi(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && Ao.g ? Ao.g : null;
  return n && (Ao.g = Ao[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Ao[s], t, r, a), s;
}, Z8 = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : vi(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Rp(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return V8(n.unshift ? n.raw ? Z8(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, $8(t.target), t.g, t.o, t.k);
}
let nP, mg, vg;
Rp.bind({ g: 1 });
let $o = Rp.bind({ k: 1 });
function q8(e, t, n, r) {
  vi.p = t, nP = e, mg = n, vg = r;
}
function Ai(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: mg && mg() }, a), n.o = / *go\d+/.test(l), a.className = Rp.apply(n, r) + (l ? " " + l : ""), t && (a.ref = s);
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), vg && u[0] && vg(a), nP(u, a);
    }
    return t ? t(o) : o;
  };
}
var G8 = (e) => typeof e == "function", K8 = (e, t) => G8(e) ? e(t) : e, Y8 = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), X8 = $o`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, Q8 = $o`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, J8 = $o`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, eV = Ai("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${X8} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${Q8} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${J8} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, tV = $o`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, nV = Ai("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${tV} 1s linear infinite;
`, rV = $o`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, oV = $o`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, iV = Ai("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${rV} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${oV} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, sV = Ai("div")`
  position: absolute;
`, aV = Ai("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, lV = $o`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, uV = Ai("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${lV} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, cV = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ve.createElement(uV, null, t) : t : n === "blank" ? null : Ve.createElement(aV, null, Ve.createElement(nV, { ...r }), n !== "loading" && Ve.createElement(sV, null, n === "error" ? Ve.createElement(eV, { ...r }) : Ve.createElement(iV, { ...r })));
}, pV = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, dV = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, fV = "0%{opacity:0;} 100%{opacity:1;}", hV = "0%{opacity:1;} 100%{opacity:0;}", gV = Ai("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, mV = Ai("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, vV = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Y8() ? [fV, hV] : [pV(n), dV(n)];
  return { animation: t ? `${$o(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${$o(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ve.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? vV(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ve.createElement(cV, { toast: e }), s = Ve.createElement(mV, { ...e.ariaProps }, K8(e.message, e));
  return Ve.createElement(gV, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ve.createElement(Ve.Fragment, null, i, s));
});
q8(Ve.createElement);
Rp`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
Ye({});
var Ko = {};
Object.defineProperty(Ko, "__esModule", {
  value: !0
});
var yV = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Pf = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, rP = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: yV ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, bv = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var ku = 1; ku < 20; ku++)
  bv["f" + ku] = 111 + ku;
function zp(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return oP(s, t);
  }), o = function(s) {
    return r.some(function(a) {
      return iP(a, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function bV(e, t) {
  return zp(e, t);
}
function wV(e, t) {
  return zp(e, { byKey: !0 }, t);
}
function oP(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Pf)
    r[Pf[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var m = wv(d), f = Pf[m];
      if (d.length > 1 && !f && !rP[d] && !bv[m])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !f) && (n ? r.key = m : r.which = sP(d)), f && (r[f] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function iP(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function sP(e) {
  e = wv(e);
  var t = bv[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function wv(e) {
  return e = e.toLowerCase(), e = rP[e] || e, e;
}
Ko.default = zp;
var Tf = Ko.isHotkey = zp;
Ko.isCodeHotkey = bV;
Ko.isKeyHotkey = wV;
Ko.parseHotkey = oP;
Ko.compareHotkey = iP;
Ko.toKeyCode = sP;
Ko.toKeyName = wv;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function JE(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Cr(e) {
  var t, n;
  return JE(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(JE(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var aP = Symbol.for("immer-nothing"), ex = Symbol.for("immer-draftable"), Jr = Symbol.for("immer-state"), CV = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function Ir(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = CV[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var _s = Object.getPrototypeOf;
function Cs(e) {
  return !!e && !!e[Jr];
}
function Es(e) {
  var t;
  return e ? lP(e) || Array.isArray(e) || !!e[ex] || !!((t = e.constructor) != null && t[ex]) || $p(e) || Wp(e) : !1;
}
var EV = Object.prototype.constructor.toString();
function lP(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = _s(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === EV;
}
function _c(e, t) {
  Up(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function Up(e) {
  const t = e[Jr];
  return t ? t.type_ : Array.isArray(e) ? 1 : $p(e) ? 2 : Wp(e) ? 3 : 0;
}
function yg(e, t) {
  return Up(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function uP(e, t, n) {
  const r = Up(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function xV(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function $p(e) {
  return e instanceof Map;
}
function Wp(e) {
  return e instanceof Set;
}
function Ji(e) {
  return e.copy_ || e.base_;
}
function bg(e, t) {
  if ($p(e))
    return new Map(e);
  if (Wp(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = lP(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[Jr];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(_s(e), r);
  } else {
    const r = _s(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Cv(e, t = !1) {
  return Hp(e) || Cs(e) || !Es(e) || (Up(e) > 1 && (e.set = e.add = e.clear = e.delete = LV), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Cv(r, !0))), e;
}
function LV() {
  Ir(2);
}
function Hp(e) {
  return Object.isFrozen(e);
}
var kV = {};
function xs(e) {
  const t = kV[e];
  return t || Ir(0, e), t;
}
var Ja;
function cP() {
  return Ja;
}
function DV(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function tx(e, t) {
  t && (xs("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function wg(e) {
  Cg(e), e.drafts_.forEach(SV), e.drafts_ = null;
}
function Cg(e) {
  e === Ja && (Ja = e.parent_);
}
function nx(e) {
  return Ja = DV(Ja, e);
}
function SV(e) {
  const t = e[Jr];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function rx(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[Jr].modified_ && (wg(t), Ir(4)), Es(e) && (e = Ic(t, e), t.parent_ || jc(t, e)), t.patches_ && xs("Patches").generateReplacementPatches_(
    n[Jr].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = Ic(t, n, []), wg(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== aP ? e : void 0;
}
function Ic(e, t, n) {
  if (Hp(t))
    return t;
  const r = t[Jr];
  if (!r)
    return _c(
      t,
      (o, i) => ox(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return jc(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), _c(
      i,
      (a, l) => ox(e, r, o, a, l, n, s)
    ), jc(e, o, !1), n && e.patches_ && xs("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function ox(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && Ir(5), Cs(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !yg(t.assigned_, r) ? i.concat(r) : void 0, l = Ic(e, o, a);
    if (uP(n, r, l), Cs(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (Es(o) && !Hp(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    Ic(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && jc(e, o);
  }
}
function jc(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Cv(t, n);
}
function OV(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : cP(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Ev;
  n && (o = [r], i = el);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var Ev = {
  get(e, t) {
    if (t === Jr)
      return e;
    const n = Ji(e);
    if (!yg(n, t))
      return MV(e, n, t);
    const r = n[t];
    return e.finalized_ || !Es(r) ? r : r === Af(e.base_, t) ? (Bf(e), e.copy_[t] = xg(r, e)) : r;
  },
  has(e, t) {
    return t in Ji(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(Ji(e));
  },
  set(e, t, n) {
    const r = pP(Ji(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Af(Ji(e), t), i = o == null ? void 0 : o[Jr];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (xV(n, o) && (n !== void 0 || yg(e.base_, t)))
        return !0;
      Bf(e), Eg(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Af(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, Bf(e), Eg(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = Ji(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    Ir(11);
  },
  getPrototypeOf(e) {
    return _s(e.base_);
  },
  setPrototypeOf() {
    Ir(12);
  }
}, el = {};
_c(Ev, (e, t) => {
  el[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
el.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && Ir(13), el.set.call(this, e, t, void 0);
};
el.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && Ir(14), Ev.set.call(this, e[0], t, n, e[0]);
};
function Af(e, t) {
  const n = e[Jr];
  return (n ? Ji(n) : e)[t];
}
function MV(e, t, n) {
  var r;
  const o = pP(t, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(e.draft_)
  ) : void 0;
}
function pP(e, t) {
  if (!(t in e))
    return;
  let n = _s(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = _s(n);
  }
}
function Eg(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && Eg(e.parent_));
}
function Bf(e) {
  e.copy_ || (e.copy_ = bg(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var PV = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(a = i, ...l) {
          return s.produce(a, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && Ir(6), r !== void 0 && typeof r != "function" && Ir(7);
      let o;
      if (Es(t)) {
        const i = nx(this), s = xg(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? wg(i) : Cg(i);
        }
        return tx(i, r), rx(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === aP && (o = void 0), this.autoFreeze_ && Cv(o, !0), r) {
          const i = [], s = [];
          xs("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        Ir(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (i, ...s) => this.produceWithPatches(i, (a) => t(a, ...s));
      let r, o;
      return [this.produce(t, n, (i, s) => {
        r = i, o = s;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    Es(e) || Ir(8), Cs(e) && (e = TV(e));
    const t = nx(this), n = xg(e, void 0);
    return n[Jr].isManual_ = !0, Cg(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[Jr];
    (!n || !n.isManual_) && Ir(9);
    const { scope_: r } = n;
    return tx(r, t), rx(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = xs("Patches").applyPatches_;
    return Cs(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function xg(e, t) {
  const n = $p(e) ? xs("MapSet").proxyMap_(e, t) : Wp(e) ? xs("MapSet").proxySet_(e, t) : OV(e, t);
  return (t ? t.scope_ : cP()).drafts_.push(n), n;
}
function TV(e) {
  return Cs(e) || Ir(10, e), dP(e);
}
function dP(e) {
  if (!Es(e) || Hp(e))
    return e;
  const t = e[Jr];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = bg(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = bg(e, !0);
  return _c(n, (r, o) => {
    uP(n, r, dP(o));
  }), t && (t.finalized_ = !1), n;
}
var eo = new PV(), xv = eo.produce;
eo.produceWithPatches.bind(
  eo
);
eo.setAutoFreeze.bind(eo);
eo.setUseStrictShallowCopy.bind(eo);
eo.applyPatches.bind(eo);
var ix = eo.createDraft.bind(eo), sx = eo.finishDraft.bind(eo), Pe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = Pe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Pe.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return Pe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return Pe.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return Pe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && Pe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return Pe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && Pe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && Pe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && Pe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && Pe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && Pe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!Pe.isAncestor(t, e) && !Pe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (Pe.equals(i, r) || Pe.endsBefore(i, r) || Pe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (Pe.equals(s, r) || Pe.isAncestor(s, r))
          return null;
        Pe.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        Pe.equals(a, r) || Pe.endsBefore(a, r) ? r[a.length - 1] -= 1 : Pe.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (Pe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else Pe.endsBefore(u, r) ? r[u.length - 1] += 1 : Pe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (Pe.equals(p, d))
          return r;
        if (Pe.isAncestor(p, r) || Pe.equals(p, r)) {
          var g = d.slice();
          return Pe.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else Pe.isSibling(p, d) && (Pe.isAncestor(d, r) || Pe.equals(d, r)) ? Pe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : Pe.endsBefore(d, r) || Pe.equals(d, r) || Pe.isAncestor(d, r) ? (Pe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : Pe.endsBefore(p, r) && (Pe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function tl(e) {
  "@babel/helpers - typeof";
  return tl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, tl(e);
}
function AV(e, t) {
  if (tl(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (tl(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function BV(e) {
  var t = AV(e, "string");
  return tl(t) === "symbol" ? t : String(t);
}
function Ws(e, t, n) {
  return t = BV(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function ax(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function da(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ax(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ax(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var _V = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = tt.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of ht.points(t))
          t[l] = xn.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = tt.leaf(e, u), g = d.text.slice(0, c), m = d.text.slice(c);
      if (d.text = g + p + m, t)
        for (var [f, h] of ht.points(t))
          t[h] = xn.transform(f, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, L = tt.get(e, E), x = Pe.previous(E), T = tt.get(e, x), w = tt.parent(e, E), C = E[E.length - 1];
      if (Qn.isText(L) && Qn.isText(T))
        T.text += L.text;
      else if (!Qn.isText(L) && !Qn.isText(T))
        T.children.push(...L.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(Wr.stringify(L), " ").concat(Wr.stringify(T)));
      if (w.children.splice(C, 1), t)
        for (var [k, O] of ht.points(t))
          t[O] = xn.transform(k, n);
      break;
    }
    case "move_node": {
      var {
        path: U,
        newPath: M
      } = n;
      if (Pe.isAncestor(U, M))
        throw new Error("Cannot move a path [".concat(U, "] to new path [").concat(M, "] because the destination is inside itself."));
      var V = tt.get(e, U), $ = tt.parent(e, U), W = U[U.length - 1];
      $.children.splice(W, 1);
      var R = Pe.transform(U, n), H = tt.get(e, Pe.parent(R)), X = R[R.length - 1];
      if (H.children.splice(X, 0, V), t)
        for (var [I, J] of ht.points(t))
          t[J] = xn.transform(I, n);
      break;
    }
    case "remove_node": {
      var {
        path: te
      } = n, S = te[te.length - 1], P = tt.parent(e, te);
      if (P.children.splice(S, 1), t)
        for (var [q, j] of ht.points(t)) {
          var Z = xn.transform(q, n);
          if (t != null && Z != null)
            t[j] = Z;
          else {
            var G = void 0, b = void 0;
            for (var [F, z] of tt.texts(e))
              if (Pe.compare(z, te) === -1)
                G = [F, z];
              else {
                b = [F, z];
                break;
              }
            var A = !1;
            G && b && (Pe.equals(b[1], te) ? A = !Pe.hasPrevious(b[1]) : A = Pe.common(G[1], te).length < Pe.common(b[1], te).length), G && !A ? (q.path = G[1], q.offset = G[0].text.length) : b ? (q.path = b[1], q.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: Y,
        offset: ee,
        text: B
      } = n;
      if (B.length === 0) break;
      var se = tt.leaf(e, Y), ue = se.text.slice(0, ee), ce = se.text.slice(ee + B.length);
      if (se.text = ue + ce, t)
        for (var [de, be] of ht.points(t))
          t[be] = xn.transform(de, n);
      break;
    }
    case "set_node": {
      var {
        path: ge,
        properties: me,
        newProperties: ae
      } = n;
      if (ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var xe = tt.get(e, ge);
      for (var re in ae) {
        if (re === "children" || re === "text")
          throw new Error('Cannot set the "'.concat(re, '" property of nodes!'));
        var Te = ae[re];
        Te == null ? delete xe[re] : xe[re] = Te;
      }
      for (var ne in me)
        ae.hasOwnProperty(ne) || delete xe[ne];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Ee
      } = n;
      if (Ee == null)
        t = Ee;
      else {
        if (t == null) {
          if (!ht.isRange(Ee))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Wr.stringify(Ee), " when there is no current selection."));
          t = da({}, Ee);
        }
        for (var Ne in Ee) {
          var Fe = Ee[Ne];
          if (Fe == null) {
            if (Ne === "anchor" || Ne === "focus")
              throw new Error('Cannot remove the "'.concat(Ne, '" selection property'));
            delete t[Ne];
          } else
            t[Ne] = Fe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: he,
        properties: Xe
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var He = tt.get(e, Ue), qt = tt.parent(e, Ue), lt = Ue[Ue.length - 1], mt;
      if (Qn.isText(He)) {
        var on = He.text.slice(0, he), sn = He.text.slice(he);
        He.text = on, mt = da(da({}, Xe), {}, {
          text: sn
        });
      } else {
        var an = He.children.slice(0, he), ln = He.children.slice(he);
        He.children = an, mt = da(da({}, Xe), {}, {
          children: ln
        });
      }
      if (qt.children.splice(lt + 1, 0, mt), t)
        for (var [nt, Rt] of ht.points(t))
          t[Rt] = xn.transform(nt, n);
      break;
    }
  }
  return t;
}, IV = {
  transform(e, t) {
    e.children = ix(e.children);
    var n = e.selection && ix(e.selection);
    try {
      n = _V(e, n, t);
    } finally {
      e.children = sx(e.children), n ? e.selection = Cs(n) ? sx(n) : n : e.selection = null;
    }
  }
}, jV = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, NV = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, fP = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Cr(r) && Cr(o)) {
      if (!fP(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function FV(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function nl(e, t) {
  if (e == null) return {};
  var n = FV(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var RV = ["anchor", "focus"];
function lx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zV(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? lx(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : lx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ht = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return ht.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = ht.edges(e);
    return t;
  },
  equals(e, t) {
    return xn.equals(e.anchor, t.anchor) && xn.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (ht.isRange(t)) {
      if (ht.includes(e, t.anchor) || ht.includes(e, t.focus))
        return !0;
      var [n, r] = ht.edges(e), [o, i] = ht.edges(t);
      return xn.isBefore(n, o) && xn.isAfter(r, i);
    }
    var [s, a] = ht.edges(e), l = !1, u = !1;
    return xn.isPoint(t) ? (l = xn.compare(t, s) >= 0, u = xn.compare(t, a) <= 0) : (l = Pe.compare(t, s.path) >= 0, u = Pe.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = nl(e, RV), [r, o] = ht.edges(e), [i, s] = ht.edges(t), a = xn.isBefore(r, i) ? i : r, l = xn.isBefore(o, s) ? o : s;
    return xn.isBefore(l, a) ? null : zV({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return xn.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return xn.equals(t, n);
  },
  isExpanded(e) {
    return !ht.isCollapsed(e);
  },
  isForward(e) {
    return !ht.isBackward(e);
  },
  isRange(e) {
    return Cr(e) && xn.isPoint(e.anchor) && xn.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = ht.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return xv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = ht.isCollapsed(r);
        ht.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? ht.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = xn.transform(r.anchor, t, {
        affinity: i
      }), u = xn.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, ux = (e) => Cr(e) && tt.isNodeList(e.children) && !Jt.isEditor(e), Ro = {
  isAncestor(e) {
    return Cr(e) && tt.isNodeList(e.children);
  },
  isElement: ux,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => Ro.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return ux(e) && e[n] === t;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, UV = ["children"], $V = ["text"], cx = /* @__PURE__ */ new WeakMap(), tt = {
  ancestor(e, t) {
    var n = tt.get(e, t);
    if (Qn.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(Wr.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Pe.ancestors(t, n)) {
        var o = tt.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (Qn.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(Wr.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(Wr.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = tt.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = tt.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = Pe.common(t, n), o = tt.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = tt.get(e, t);
    if (Jt.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(Wr.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of tt.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of tt.nodes(e, t))
        Ro.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if (Ro.isAncestor(e)) {
      var t = nl(e, UV);
      return t;
    } else {
      var t = nl(e, $V);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = tt.get(e, n); r && !(Qn.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (Qn.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Wr.stringify(e)));
    var n = xv({
      children: e.children
    }, (r) => {
      var [o, i] = ht.edges(t), s = tt.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !ht.includes(t, g);
        }
      });
      for (var [, a] of s) {
        if (!ht.includes(t, a)) {
          var l = tt.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (Pe.equals(a, i.path)) {
          var c = tt.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (Pe.equals(a, o.path)) {
          var p = tt.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      Jt.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Qn.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(Wr.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (Qn.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return Qn.isText(e) || Ro.isElement(e) || Jt.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = cx.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => tt.isNode(r));
    return cx.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = tt.get(e, n); r && !(Qn.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = tt.get(e, t);
    if (!Qn.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(Wr.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of Pe.levels(t, n)) {
        var o = tt.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return Ro.isElement(e) && Ro.isElementProps(t) && Ro.matches(e, t) || Qn.isText(e) && Qn.isTextProps(t) && Qn.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? Pe.isBefore(a, i) : Pe.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !Qn.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          Pe.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = tt.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = Pe.next(a);
          if (tt.has(e, c)) {
            a = c, l = tt.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = Pe.previous(a);
          a = p, l = tt.get(e, a);
          continue;
        }
        a = Pe.parent(a), l = tt.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = Pe.parent(t), r = tt.get(e, n);
    if (Qn.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return Qn.isText(e) ? e.text : e.children.map(tt.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of tt.nodes(e, t))
        Qn.isText(n) && (yield [n, r]);
    }();
  }
};
function px(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Pn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? px(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : px(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wa = {
  isNodeOperation(e) {
    return wa.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Cr(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return Pe.isPath(e.path) && tt.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Pe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && Pe.isPath(e.path) && Cr(e.properties);
      case "move_node":
        return Pe.isPath(e.path) && Pe.isPath(e.newPath);
      case "remove_node":
        return Pe.isPath(e.path) && tt.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && Pe.isPath(e.path);
      case "set_node":
        return Pe.isPath(e.path) && Cr(e.properties) && Cr(e.newProperties);
      case "set_selection":
        return e.properties === null && ht.isRange(e.newProperties) || e.newProperties === null && ht.isRange(e.properties) || Cr(e.properties) && Cr(e.newProperties);
      case "split_node":
        return Pe.isPath(e.path) && typeof e.position == "number" && Cr(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => wa.isOperation(t));
  },
  isSelectionOperation(e) {
    return wa.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return wa.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Pn(Pn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Pn(Pn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Pn(Pn({}, e), {}, {
          type: "split_node",
          path: Pe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (Pe.equals(t, n))
          return e;
        if (Pe.isSibling(n, t))
          return Pn(Pn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = Pe.transform(n, e), o = Pe.transform(Pe.next(n), e);
        return Pn(Pn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Pn(Pn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Pn(Pn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Pn(Pn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? Pn(Pn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Pn(Pn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : Pn(Pn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return Pn(Pn({}, e), {}, {
          type: "merge_node",
          path: Pe.next(e.path)
        });
    }
  }
}, dx = /* @__PURE__ */ new WeakMap(), WV = (e) => {
  var t = dx.get(e);
  if (t !== void 0)
    return t;
  if (!Cr(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Cr(e.marks)) && (e.selection === null || ht.isRange(e.selection)) && tt.isNodeList(e.children) && wa.isOperationList(e.operations);
  return dx.set(e, n), n;
}, Jt = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return WV(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
};
function fx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function hx(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? fx(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : fx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var xn = {
  compare(e, t) {
    var n = Pe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return xn.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return xn.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && Pe.equals(e.path, t.path);
  },
  isPoint(e) {
    return Cr(e) && typeof e.offset == "number" && Pe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return xv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = Pe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          Pe.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          Pe.equals(t.path, i) && (r.offset += t.position), r.path = Pe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          Pe.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (Pe.equals(t.path, i) || Pe.isAncestor(t.path, i))
            return null;
          r.path = Pe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (Pe.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = Pe.transform(i, t, hx(hx({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = Pe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, gx = void 0, Wr = {
  setScrubber(e) {
    gx = e;
  },
  stringify(e) {
    return JSON.stringify(e, gx);
  }
}, HV = ["text"], VV = ["anchor", "focus"];
function mx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? mx(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : mx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Qn = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = nl(i, HV);
      return s;
    }
    return fP(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Cr(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => Qn.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Bo({}, e)];
    for (var r of t) {
      var o = nl(r, VV), [i, s] = ht.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          a.push(p);
          continue;
        }
        var m = p, f = void 0, h = void 0;
        if (c < l) {
          var E = c - g;
          h = Bo(Bo({}, m), {}, {
            text: m.text.slice(E)
          }), m = Bo(Bo({}, m), {}, {
            text: m.text.slice(0, E)
          });
        }
        if (u > g) {
          var L = u - g;
          f = Bo(Bo({}, m), {}, {
            text: m.text.slice(0, L)
          }), m = Bo(Bo({}, m), {}, {
            text: m.text.slice(L)
          });
        }
        Object.assign(m, o), f && a.push(f), a.push(m), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, ZV = (e) => e.selection ? e.selection : e.children.length > 0 ? Jt.end(e, []) : [0], wn;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(wn || (wn = {}));
wn.L, wn.L | wn.V | wn.LV | wn.LVT, wn.LV | wn.V, wn.V | wn.T, wn.LVT | wn.T, wn.T, wn.Any, wn.Extend | wn.ZWJ, wn.Any, wn.SpacingMark, wn.Prepend, wn.Any, wn.ZWJ, wn.ExtPict, wn.RI, wn.RI;
var qV = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    Jt.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = ZV(e)
      } = n;
      if (Pe.isPath(o) && (o = Jt.range(e, o)), ht.isRange(o))
        if (ht.isCollapsed(o))
          o = o.anchor;
        else {
          var i = ht.end(o);
          if (!r && Jt.void(e, {
            at: i
          }))
            return;
          var s = ht.start(o), a = Jt.pointRef(e, s), l = Jt.pointRef(e, i);
          Nc.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Nc.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && Jt.void(e, {
        at: o
      }) || Jt.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function vx(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Du(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? vx(Object(n), !0).forEach(function(r) {
      Ws(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : vx(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nc = Du(Du(Du(Du({}, IV), jV), NV), qV), GV = typeof tn == "object" && tn && tn.Object === Object && tn, KV = GV, YV = KV, XV = typeof self == "object" && self && self.Object === Object && self, QV = YV || XV || Function("return this")(), JV = QV, e6 = JV, t6 = e6.Symbol, hP = t6, yx = hP;
yx && yx.toStringTag;
var bx = hP;
bx && bx.toStringTag;
var wx;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(wx || (wx = {}));
var Lv = function(e) {
  return Object.freeze(e);
}, n6 = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, Lv(this);
  }
  return e;
}(), r6 = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Lv(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), Cx = typeof window < "u" ? window : {};
/msie|trident/i.test(Cx.navigator && Cx.navigator.userAgent);
var _f = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new n6((n ? t : e) || 0, (n ? e : t) || 0);
};
Lv({
  devicePixelContentBoxSize: _f(),
  borderBoxSize: _f(),
  contentBoxSize: _f(),
  contentRect: new r6(0, 0, 0, 0)
});
function rl(e) {
  "@babel/helpers - typeof";
  return rl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, rl(e);
}
function o6(e, t) {
  if (rl(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (rl(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function i6(e) {
  var t = o6(e, "string");
  return rl(t) === "symbol" ? t : String(t);
}
function Ba(e, t, n) {
  return t = i6(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var s6 = /* @__PURE__ */ Ye(null), If, jf;
parseInt(Be.version.split(".")[0], 10);
var Ex = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Nf = typeof navigator < "u" && /Android/.test(navigator.userAgent), Su = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), a6 = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (If = navigator.userAgent.match(/Version\/(\d+)/)) !== null && If !== void 0 && If[1] && parseInt((jf = navigator.userAgent.match(/Version\/(\d+)/)) === null || jf === void 0 ? void 0 : jf[1], 10) < 17;
var l6 = /* @__PURE__ */ new WeakMap(), u6 = /* @__PURE__ */ new WeakMap(), c6 = /* @__PURE__ */ new WeakMap(), p6 = /* @__PURE__ */ new WeakMap(), d6 = /* @__PURE__ */ new WeakMap(), xx = /* @__PURE__ */ new WeakMap(), f6 = /* @__PURE__ */ new WeakMap(), Lx = /* @__PURE__ */ new WeakMap(), Ou = /* @__PURE__ */ new WeakMap(), h6 = /* @__PURE__ */ new WeakMap(), g6 = /* @__PURE__ */ new WeakMap(), m6 = /* @__PURE__ */ new WeakMap(), gP = globalThis.Node, v6 = globalThis.Text, mP = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, y6 = (e) => Fc(e) && e.nodeType === 8, Lo = (e) => Fc(e) && e.nodeType === 1, Fc = (e) => {
  var t = mP(e);
  return !!t && e instanceof t.Node;
}, kx = (e) => {
  var t = e && e.anchorNode && mP(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, b6 = (e) => {
  var [t, n] = e;
  if (Lo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = vP(t, o, r ? "backward" : "forward"), r = o < n; Lo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = C6(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, w6 = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, vP = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (y6(o) || Lo(o) && o.childNodes.length === 0 || Lo(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, C6 = (e, t, n) => {
  var [r] = vP(e, t, n);
  return r;
}, Dx = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), yP = (e, t, n) => {
  var {
    target: r
  } = t;
  if (Lo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = At.getWindow(e);
  if (o.contains(r))
    return At.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : yP(e, i, n);
}, Sx = (e, t) => !!(e.compareDocumentPosition(t) & gP.DOCUMENT_POSITION_PRECEDING), E6 = (e, t) => !!(e.compareDocumentPosition(t) & gP.DOCUMENT_POSITION_FOLLOWING), x6 = 0;
class L6 {
  constructor() {
    Ba(this, "id", void 0), this.id = "".concat(x6++);
  }
}
var At = {
  androidPendingDiffs: (e) => m6.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = g6.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = At.toDOMNode(e, e), n = At.findDocumentOrShadowRoot(e);
    Ou.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = At.findDocumentOrShadowRoot(e), r = Dx(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Nc.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = At.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = At.toSlateNode(e, t.target), s = At.findPath(e, i);
    if (Ro.isElement(i) && Jt.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = Jt.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? Jt.before(e, u) : Jt.after(e, u);
      if (c) {
        var p = Jt.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = At.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var m = g.caretPositionFromPoint(n, r);
      m && (d = g.createRange(), d.setStart(m.offsetNode, m.offset), d.setEnd(m.offsetNode, m.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var f = At.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return f;
  },
  findKey: (e, t) => {
    var n = xx.get(t);
    return n || (n = new L6(), xx.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = u6.get(r);
      if (o == null) {
        if (Jt.isEditor(r))
          return n;
        break;
      }
      var i = l6.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Wr.stringify(t)));
  },
  focus: function(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Ou.get(e)) {
      if (t.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          At.focus(e, {
            retries: t.retries - 1
          });
        }, 10);
        return;
      }
      var n = At.toDOMNode(e, e), r = At.findDocumentOrShadowRoot(e);
      if (r.activeElement !== n) {
        if (e.selection && r instanceof Document) {
          var o = Dx(r), i = At.toDOMRange(e, e.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        e.selection || Nc.select(e, Jt.start(e, [])), Ou.set(e, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = c6.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = At.toDOMNode(e, e), i;
    try {
      i = Lo(t) ? t : t.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => Fc(t) && At.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return Jt.hasPath(e, n.path) && Jt.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => At.hasEditableTarget(e, t) || At.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => Fc(t) && At.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!h6.get(e),
  isFocused: (e) => !!Ou.get(e),
  isReadOnly: (e) => !!Lx.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (Lx.get(e)) return !1;
    var n = At.hasTarget(e, t) && At.toSlateNode(e, t);
    return Ro.isElement(n) && Jt.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = f6.get(e), r = Jt.isEditor(t) ? p6.get(e) : n == null ? void 0 : n.get(At.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Wr.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = Jt.node(e, t.path), r = At.toDOMNode(e, n), o;
    Jt.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), m = a + g, f = s[l + 1];
        if (t.offset === m && f !== null && f !== void 0 && f.hasAttribute("data-slate-mark-placeholder")) {
          var h, E = f.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof v6 ? E : f,
            (h = f.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= m) {
          var L = Math.min(p, Math.max(0, t.offset - a));
          o = [c, L];
          break;
        }
        a = m;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Wr.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = ht.isBackward(t), i = At.toDOMPoint(e, n), s = ht.isCollapsed(t) ? i : At.toDOMPoint(e, r), a = At.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, g = Lo(u) ? u : u.parentElement, m = !!g.getAttribute("data-slate-zero-width"), f = Lo(p) ? p : p.parentElement, h = !!f.getAttribute("data-slate-zero-width");
    return l.setStart(u, m ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = Lo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? d6.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : b6(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = At.toDOMNode(e, e), m = l.closest('[data-slate-void="true"]'), f = m && g.contains(m) ? m : null, h = l.closest('[contenteditable="false"]'), E = h && g.contains(h) ? h : null, L = l.closest("[data-slate-leaf]"), x = null;
      if (L) {
        if (u = L.closest('[data-slate-node="text"]'), u) {
          var T = At.getWindow(e), w = T.document.createRange();
          w.setStart(u, 0), w.setEnd(s, a);
          var C = w.cloneContents(), k = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          k.forEach((j) => {
            if (Nf && !r && j.hasAttribute("data-slate-zero-width") && j.textContent.length > 0 && j.textContext !== "\uFEFF") {
              j.textContent.startsWith("\uFEFF") && (j.textContent = j.textContent.slice(1));
              return;
            }
            j.parentNode.removeChild(j);
          }), c = C.textContent.length, x = u;
        }
      } else if (f) {
        for (var O = f.querySelectorAll("[data-slate-leaf]"), U = 0; U < O.length; U++) {
          var M = O[U];
          if (At.hasDOMNode(e, M)) {
            L = M;
            break;
          }
        }
        L ? (u = L.closest('[data-slate-node="text"]'), x = L, c = x.textContent.length, x.querySelectorAll("[data-slate-zero-width]").forEach((j) => {
          c -= j.textContent.length;
        })) : c = 1;
      } else if (E) {
        var V = (j) => j ? j.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var W, R = [...V($), ...V($ == null ? void 0 : $.nextElementSibling)];
          L = (W = R.find((j) => E6(E, j))) !== null && W !== void 0 ? W : null;
        } else {
          var H, X = [...V($ == null ? void 0 : $.previousElementSibling), ...V($)];
          L = (H = X.findLast((j) => Sx(E, j))) !== null && H !== void 0 ? H : null;
        }
        L && (u = L.closest('[data-slate-node="text"]'), x = L, i === "forward" ? c = 0 : (c = x.textContent.length, x.querySelectorAll("[data-slate-zero-width]").forEach((j) => {
          c -= j.textContent.length;
        })));
      }
      x && c === x.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Nf && x.getAttribute("data-slate-zero-width") === "z" && (p = x.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Su && (d = x.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Nf && !u && !r) {
      var I = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (I && At.hasDOMNode(e, I, {
        editable: !0
      })) {
        var J = At.toSlateNode(e, I), {
          path: te,
          offset: S
        } = Jt.start(e, At.findPath(e, J));
        return I.querySelector("[data-slate-leaf]") || (S = a), {
          path: te,
          offset: S
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var P = At.toSlateNode(e, u), q = At.findPath(e, P);
    return {
      path: q,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = kx(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if (kx(t)) {
        if (Su && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(k) {
              return k.childElementCount > 0 ? C(k.children[0]) : k;
            };
            var m = d.startContainer, f = g.startContainer, h = C(m.children[d.startOffset]), E = C(f.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? a = E.childNodes[0] : a = E, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = g.endContainer, l = g.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        a6 && w6(a) || Su ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Su && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var L = At.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!L)
      return null;
    var x = Sx(a, u) || a === u && c < l, T = p ? L : At.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: x ? "forward" : "backward"
    });
    if (!T)
      return null;
    var w = {
      anchor: L,
      focus: T
    };
    return ht.isExpanded(w) && ht.isForward(w) && Lo(u) && Jt.void(e, {
      at: w.focus,
      mode: "highest"
    }) && (w = Jt.unhangRange(e, w, {
      voids: !0
    })), w;
  }
}, k6 = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, D6 = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, S6 = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Tn = (e) => {
  var t = k6[e], n = D6[e], r = S6[e], o = t && Tf(t), i = n && Tf(n), s = r && Tf(r);
  return (a) => !!(o && o(a) || Ex && i && i(a) || !Ex && s && s(a));
};
Tn("bold"), Tn("compose"), Tn("moveBackward"), Tn("moveForward"), Tn("deleteBackward"), Tn("deleteForward"), Tn("deleteLineBackward"), Tn("deleteLineForward"), Tn("deleteWordBackward"), Tn("deleteWordForward"), Tn("extendBackward"), Tn("extendForward"), Tn("extendLineBackward"), Tn("extendLineForward"), Tn("italic"), Tn("moveLineBackward"), Tn("moveLineForward"), Tn("moveWordBackward"), Tn("moveWordForward"), Tn("redo"), Tn("insertSoftBreak"), Tn("splitBlock"), Tn("transposeCharacter"), Tn("undo");
var O6 = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => yP(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, M6 = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class P6 extends Yc {
  constructor() {
    super(...arguments), Ba(this, "context", null), Ba(this, "manager", null), Ba(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, M6);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = O6(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Ba(P6, "contextType", s6);
var bP = {}, kv = {}, Dv = {};
Object.defineProperty(Dv, "__esModule", { value: !0 });
Dv.default = _6;
var Ox = "html", Mx = "head", Mu = "body", T6 = /<([a-zA-Z]+[0-9]?)/, Px = /<head[^]*>/i, Tx = /<body[^]*>/i, Rc = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Lg = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, Ax = typeof window == "object" && window.DOMParser;
if (typeof Ax == "function") {
  var A6 = new Ax(), B6 = "text/html";
  Lg = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), A6.parseFromString(e, B6);
  }, Rc = Lg;
}
if (typeof document == "object" && document.implementation) {
  var Pu = document.implementation.createHTMLDocument();
  Rc = function(e, t) {
    if (t) {
      var n = Pu.documentElement.querySelector(t);
      return n && (n.innerHTML = e), Pu;
    }
    return Pu.documentElement.innerHTML = e, Pu;
  };
}
var Tu = typeof document == "object" && document.createElement("template"), kg;
Tu && Tu.content && (kg = function(e) {
  return Tu.innerHTML = e, Tu.content.childNodes;
});
function _6(e) {
  var t, n, r = e.match(T6), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case Ox: {
      var i = Lg(e);
      if (!Px.test(e)) {
        var s = i.querySelector(Mx);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!Tx.test(e)) {
        var s = i.querySelector(Mu);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll(Ox);
    }
    case Mx:
    case Mu: {
      var a = Rc(e).querySelectorAll(o);
      return Tx.test(e) && Px.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (kg)
        return kg(e);
      var s = Rc(e, Mu).querySelector(Mu);
      return s.childNodes;
    }
  }
}
var Vp = {}, Sv = {}, Ov = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(Ov);
var xt = {}, Bi = tn && tn.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), _a = tn && tn.__assign || function() {
  return _a = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, _a.apply(this, arguments);
};
Object.defineProperty(xt, "__esModule", { value: !0 });
xt.cloneNode = xt.hasChildren = xt.isDocument = xt.isDirective = xt.isComment = xt.isText = xt.isCDATA = xt.isTag = xt.Element = xt.Document = xt.CDATA = xt.NodeWithChildren = xt.ProcessingInstruction = xt.Comment = xt.Text = xt.DataNode = xt.Node = void 0;
var Rr = Ov, Mv = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), Pv(this, t);
    }, e;
  }()
);
xt.Node = Mv;
var Zp = (
  /** @class */
  function(e) {
    Bi(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mv)
);
xt.DataNode = Zp;
var wP = (
  /** @class */
  function(e) {
    Bi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Rr.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zp)
);
xt.Text = wP;
var CP = (
  /** @class */
  function(e) {
    Bi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Rr.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zp)
);
xt.Comment = CP;
var EP = (
  /** @class */
  function(e) {
    Bi(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = Rr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Zp)
);
xt.ProcessingInstruction = EP;
var qp = (
  /** @class */
  function(e) {
    Bi(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(Mv)
);
xt.NodeWithChildren = qp;
var xP = (
  /** @class */
  function(e) {
    Bi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Rr.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qp)
);
xt.CDATA = xP;
var LP = (
  /** @class */
  function(e) {
    Bi(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = Rr.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qp)
);
xt.Document = LP;
var kP = (
  /** @class */
  function(e) {
    Bi(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? Rr.ElementType.Script : n === "style" ? Rr.ElementType.Style : Rr.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(qp)
);
xt.Element = kP;
function DP(e) {
  return (0, Rr.isTag)(e);
}
xt.isTag = DP;
function SP(e) {
  return e.type === Rr.ElementType.CDATA;
}
xt.isCDATA = SP;
function OP(e) {
  return e.type === Rr.ElementType.Text;
}
xt.isText = OP;
function MP(e) {
  return e.type === Rr.ElementType.Comment;
}
xt.isComment = MP;
function PP(e) {
  return e.type === Rr.ElementType.Directive;
}
xt.isDirective = PP;
function TP(e) {
  return e.type === Rr.ElementType.Root;
}
xt.isDocument = TP;
function I6(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
xt.hasChildren = I6;
function Pv(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (OP(e))
    n = new wP(e.data);
  else if (MP(e))
    n = new CP(e.data);
  else if (DP(e)) {
    var r = t ? Ff(e.children) : [], o = new kP(e.name, _a({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = _a({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = _a({}, e["x-attribsPrefix"])), n = o;
  } else if (SP(e)) {
    var r = t ? Ff(e.children) : [], i = new xP(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (TP(e)) {
    var r = t ? Ff(e.children) : [], s = new LP(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (PP(e)) {
    var a = new EP(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
xt.cloneNode = Pv;
function Ff(e) {
  for (var t = e.map(function(r) {
    return Pv(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = tn && tn.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = tn && tn.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = Ov, o = xt;
  n(xt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(Sv);
var AP = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(AP);
Object.defineProperty(Vp, "__esModule", { value: !0 });
Vp.formatAttributes = BP;
Vp.formatDOM = _P;
var Au = Sv, j6 = AP;
function N6(e) {
  return j6.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function BP(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function F6(e) {
  e = e.toLowerCase();
  var t = N6(e);
  return t || e;
}
function _P(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = F6(a.nodeName);
        o = new Au.Element(l, BP(a.attributes)), o.children = _P(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Au.Text(a.nodeValue);
        break;
      case 8:
        o = new Au.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Au.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var R6 = tn && tn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(kv, "__esModule", { value: !0 });
kv.default = W6;
var z6 = R6(Dv), U6 = Vp, $6 = /<(![a-zA-Z\s]+)>/;
function W6(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match($6), n = t ? t[1] : void 0;
  return (0, U6.formatDOM)((0, z6.default)(e), null, n);
}
var Gp = {}, ho = {}, Kp = {}, H6 = 0;
Kp.SAME = H6;
var V6 = 1;
Kp.CAMELCASE = V6;
Kp.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const IP = 0, _i = 1, Yp = 2, Xp = 3, Tv = 4, jP = 5, NP = 6;
function Z6(e) {
  return vr.hasOwnProperty(e) ? vr[e] : null;
}
function Mr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === Yp || t === Xp || t === Tv, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const vr = {}, q6 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
q6.forEach((e) => {
  vr[e] = new Mr(
    e,
    IP,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  vr[e] = new Mr(
    e,
    _i,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  vr[e] = new Mr(
    e,
    Yp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  vr[e] = new Mr(
    e,
    Yp,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  vr[e] = new Mr(
    e,
    Xp,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  vr[e] = new Mr(
    e,
    Xp,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  vr[e] = new Mr(
    e,
    Tv,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  vr[e] = new Mr(
    e,
    NP,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  vr[e] = new Mr(
    e,
    jP,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Av = /[\-\:]([a-z])/g, Bv = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Av, Bv);
  vr[t] = new Mr(
    t,
    _i,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Av, Bv);
  vr[t] = new Mr(
    t,
    _i,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(Av, Bv);
  vr[t] = new Mr(
    t,
    _i,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  vr[e] = new Mr(
    e,
    _i,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const G6 = "xlinkHref";
vr[G6] = new Mr(
  "xlinkHref",
  _i,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  vr[e] = new Mr(
    e,
    _i,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: K6,
  SAME: Y6,
  possibleStandardNames: Bx
} = Kp, X6 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", Q6 = X6 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", J6 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + Q6 + "]*$")
), e5 = Object.keys(
  Bx
).reduce((e, t) => {
  const n = Bx[t];
  return n === Y6 ? e[t] = t : n === K6 ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
ho.BOOLEAN = Xp;
ho.BOOLEANISH_STRING = Yp;
ho.NUMERIC = jP;
ho.OVERLOADED_BOOLEAN = Tv;
ho.POSITIVE_NUMERIC = NP;
ho.RESERVED = IP;
ho.STRING = _i;
ho.getPropertyInfo = Z6;
ho.isCustomAttribute = J6;
ho.possibleStandardNames = e5;
var _v = {}, Iv = {}, _x = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, t5 = /\n/g, n5 = /^\s*/, r5 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, o5 = /^:\s*/, i5 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, s5 = /^[;\s]*/, a5 = /^\s+|\s+$/g, l5 = `
`, Ix = "/", jx = "*", os = "", u5 = "comment", c5 = "declaration", p5 = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(m) {
    var f = m.match(t5);
    f && (n += f.length);
    var h = m.lastIndexOf(l5);
    r = ~h ? m.length - h : r + m.length;
  }
  function i() {
    var m = { line: n, column: r };
    return function(f) {
      return f.position = new s(m), u(), f;
    };
  }
  function s(m) {
    this.start = m, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(m) {
    var f = new Error(
      t.source + ":" + n + ":" + r + ": " + m
    );
    if (f.reason = m, f.filename = t.source, f.line = n, f.column = r, f.source = e, !t.silent) throw f;
  }
  function l(m) {
    var f = m.exec(e);
    if (f) {
      var h = f[0];
      return o(h), e = e.slice(h.length), f;
    }
  }
  function u() {
    l(n5);
  }
  function c(m) {
    var f;
    for (m = m || []; f = p(); )
      f !== !1 && m.push(f);
    return m;
  }
  function p() {
    var m = i();
    if (!(Ix != e.charAt(0) || jx != e.charAt(1))) {
      for (var f = 2; os != e.charAt(f) && (jx != e.charAt(f) || Ix != e.charAt(f + 1)); )
        ++f;
      if (f += 2, os === e.charAt(f - 1))
        return a("End of comment missing");
      var h = e.slice(2, f - 2);
      return r += 2, o(h), e = e.slice(f), r += 2, m({
        type: u5,
        comment: h
      });
    }
  }
  function d() {
    var m = i(), f = l(r5);
    if (f) {
      if (p(), !l(o5)) return a("property missing ':'");
      var h = l(i5), E = m({
        type: c5,
        property: Nx(f[0].replace(_x, os)),
        value: h ? Nx(h[0].replace(_x, os)) : os
      });
      return l(s5), E;
    }
  }
  function g() {
    var m = [];
    c(m);
    for (var f; f = d(); )
      f !== !1 && (m.push(f), c(m));
    return m;
  }
  return u(), g();
};
function Nx(e) {
  return e ? e.replace(a5, os) : os;
}
var d5 = tn && tn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(Iv, "__esModule", { value: !0 });
Iv.default = h5;
var f5 = d5(p5);
function h5(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, f5.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var Qp = {};
Object.defineProperty(Qp, "__esModule", { value: !0 });
Qp.camelCase = void 0;
var g5 = /^--[a-zA-Z0-9-]+$/, m5 = /-([a-z])/g, v5 = /^[^-]+$/, y5 = /^-(webkit|moz|ms|o|khtml)-/, b5 = /^-(ms)-/, w5 = function(e) {
  return !e || v5.test(e) || g5.test(e);
}, C5 = function(e, t) {
  return t.toUpperCase();
}, Fx = function(e, t) {
  return "".concat(t, "-");
}, E5 = function(e, t) {
  return t === void 0 && (t = {}), w5(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(b5, Fx) : e = e.replace(y5, Fx), e.replace(m5, C5));
};
Qp.camelCase = E5;
var x5 = tn && tn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, L5 = x5(Iv), k5 = Qp;
function Dg(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, L5.default)(e, function(r, o) {
    r && o && (n[(0, k5.camelCase)(r, t)] = o);
  }), n;
}
Dg.default = Dg;
var D5 = Dg;
(function(e) {
  var t = tn && tn.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Be, r = t(D5), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(_v);
Object.defineProperty(Gp, "__esModule", { value: !0 });
Gp.default = P5;
var Ca = ho, Rx = _v, S5 = ["checked", "value"], O5 = ["input", "select", "textarea"], M5 = {
  reset: !0,
  submit: !0
};
function P5(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && M5[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Ca.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = zx(s);
    if (a) {
      var l = (0, Ca.getPropertyInfo)(a);
      switch (S5.includes(a) && O5.includes(t) && !r && (a = zx("default" + s)), n[a] = i, l && l.type) {
        case Ca.BOOLEAN:
          n[a] = !0;
          break;
        case Ca.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    Rx.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, Rx.setStyleProp)(e.style, n), n;
}
function zx(e) {
  return Ca.possibleStandardNames[e];
}
var jv = {}, T5 = tn && tn.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(jv, "__esModule", { value: !0 });
jv.default = FP;
var Rf = Be, A5 = T5(Gp), Ia = _v, B5 = {
  cloneElement: Rf.cloneElement,
  createElement: Rf.createElement,
  isValidElement: Rf.isValidElement
};
function FP(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Ia.returnFirstArg, i = t.library || B5, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Ia.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var m = p, f = {};
    _5(m) ? ((0, Ia.setStyleProp)(m.attribs.style, m.attribs), f = m.attribs) : m.attribs && (f = (0, A5.default)(m.attribs, m.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (f.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? f.defaultValue = p.children[0].data : p.children && p.children.length && (h = FP(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (f.key = c), n.push(o(a(p.name, f, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function _5(e) {
  return Ia.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Ia.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = tn && tn.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(kv);
  e.htmlToDOM = n.default;
  var r = t(Gp);
  e.attributesToProps = r.default;
  var o = t(jv);
  e.domToReact = o.default;
  var i = Sv;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(bP);
const Ux = /* @__PURE__ */ sI(bP);
Ux.default;
Ye({});
Ye({});
Ye({});
function I5(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...s
  } = e, a = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ Ft.jsxs("div", { className: a.trim(), ...s, children: [
    r,
    /* @__PURE__ */ Ft.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
var tr = {}, Nv = {}, Dl = {}, Sl = {}, RP = "Expected a function", $x = NaN, j5 = "[object Symbol]", N5 = /^\s+|\s+$/g, F5 = /^[-+]0x[0-9a-f]+$/i, R5 = /^0b[01]+$/i, z5 = /^0o[0-7]+$/i, U5 = parseInt, $5 = typeof tn == "object" && tn && tn.Object === Object && tn, W5 = typeof self == "object" && self && self.Object === Object && self, H5 = $5 || W5 || Function("return this")(), V5 = Object.prototype, Z5 = V5.toString, q5 = Math.max, G5 = Math.min, zf = function() {
  return H5.Date.now();
};
function K5(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(RP);
  t = Wx(t) || 0, zc(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? q5(Wx(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var k = r, O = o;
    return r = o = void 0, u = C, s = e.apply(O, k), s;
  }
  function m(C) {
    return u = C, a = setTimeout(E, t), c ? g(C) : s;
  }
  function f(C) {
    var k = C - l, O = C - u, U = t - k;
    return p ? G5(U, i - O) : U;
  }
  function h(C) {
    var k = C - l, O = C - u;
    return l === void 0 || k >= t || k < 0 || p && O >= i;
  }
  function E() {
    var C = zf();
    if (h(C))
      return L(C);
    a = setTimeout(E, f(C));
  }
  function L(C) {
    return a = void 0, d && r ? g(C) : (r = o = void 0, s);
  }
  function x() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function T() {
    return a === void 0 ? s : L(zf());
  }
  function w() {
    var C = zf(), k = h(C);
    if (r = arguments, o = this, l = C, k) {
      if (a === void 0)
        return m(l);
      if (p)
        return a = setTimeout(E, t), g(l);
    }
    return a === void 0 && (a = setTimeout(E, t)), s;
  }
  return w.cancel = x, w.flush = T, w;
}
function Y5(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(RP);
  return zc(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), K5(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function zc(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function X5(e) {
  return !!e && typeof e == "object";
}
function Q5(e) {
  return typeof e == "symbol" || X5(e) && Z5.call(e) == j5;
}
function Wx(e) {
  if (typeof e == "number")
    return e;
  if (Q5(e))
    return $x;
  if (zc(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = zc(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(N5, "");
  var n = R5.test(e);
  return n || z5.test(e) ? U5(e.slice(2), n ? 2 : 8) : F5.test(e) ? $x : +e;
}
var J5 = Y5, Ol = {};
Object.defineProperty(Ol, "__esModule", {
  value: !0
});
Ol.addPassiveEventListener = function(e, t, n) {
  var r = n.name;
  r || (r = t, console.warn("Listener must be a named function.")), ic.has(t) || ic.set(t, /* @__PURE__ */ new Set());
  var o = ic.get(t);
  if (!o.has(r)) {
    var i = function() {
      var s = !1;
      try {
        var a = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, a);
      } catch {
      }
      return s;
    }();
    e.addEventListener(t, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
Ol.removePassiveEventListener = function(e, t, n) {
  e.removeEventListener(t, n), ic.get(t).delete(n.name || t);
};
var ic = /* @__PURE__ */ new Map();
Object.defineProperty(Sl, "__esModule", {
  value: !0
});
var e4 = J5, t4 = r4(e4), n4 = Ol;
function r4(e) {
  return e && e.__esModule ? e : { default: e };
}
var o4 = function(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, t4.default)(e, t);
}, Hn = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, t) {
    if (e) {
      var n = o4(function(r) {
        Hn.scrollHandler(e);
      }, t);
      Hn.scrollSpyContainers.push(e), (0, n4.addPassiveEventListener)(e, "scroll", n);
    }
  },
  isMounted: function(e) {
    return Hn.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var t = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var t = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return t ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var t = Hn.scrollSpyContainers[Hn.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    t.forEach(function(n) {
      return n(Hn.currentPositionX(e), Hn.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Hn.spySetState.push(e);
  },
  addSpyHandler: function(e, t) {
    var n = Hn.scrollSpyContainers[Hn.scrollSpyContainers.indexOf(t)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(e), e(Hn.currentPositionX(t), Hn.currentPositionY(t));
  },
  updateStates: function() {
    Hn.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, t) {
    Hn.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(t) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(t), 1);
    }), Hn.spySetState && Hn.spySetState.length && Hn.spySetState.indexOf(e) > -1 && Hn.spySetState.splice(Hn.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Hn.scrollHandler);
  },
  update: function() {
    return Hn.scrollSpyContainers.forEach(function(e) {
      return Hn.scrollHandler(e);
    });
  }
};
Sl.default = Hn;
var Hs = {}, Ml = {};
Object.defineProperty(Ml, "__esModule", {
  value: !0
});
var i4 = function(e, t) {
  var n = e.indexOf("#") === 0 ? e.substring(1) : e, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  t ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, s4 = function() {
  return window.location.hash.replace(/^#/, "");
}, a4 = function(e) {
  return function(t) {
    return e.contains ? e != t && e.contains(t) : !!(e.compareDocumentPosition(t) & 16);
  };
}, l4 = function(e) {
  return getComputedStyle(e).position !== "static";
}, Uf = function(e, t) {
  for (var n = e.offsetTop, r = e.offsetParent; r && !t(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, u4 = function(e, t, n) {
  if (n)
    return e === document ? t.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? t.offsetLeft : t.offsetLeft - e.offsetLeft;
  if (e === document)
    return t.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (l4(e)) {
    if (t.offsetParent !== e) {
      var r = function(l) {
        return l === e || l === document;
      }, o = Uf(t, r), i = o.offsetTop, s = o.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return t.offsetTop;
  }
  if (t.offsetParent === e.offsetParent)
    return t.offsetTop - e.offsetTop;
  var a = function(l) {
    return l === document;
  };
  return Uf(t, a).offsetTop - Uf(e, a).offsetTop;
};
Ml.default = {
  updateHash: i4,
  getHash: s4,
  filterElementInContainer: a4,
  scrollOffset: u4
};
var Jp = {}, Fv = {};
Object.defineProperty(Fv, "__esModule", {
  value: !0
});
Fv.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var Rv = {};
Object.defineProperty(Rv, "__esModule", {
  value: !0
});
var c4 = Ol, p4 = ["mousedown", "mousewheel", "touchmove", "keydown"];
Rv.default = {
  subscribe: function(e) {
    return typeof document < "u" && p4.forEach(function(t) {
      return (0, c4.addPassiveEventListener)(document, t, e);
    });
  }
};
var Pl = {};
Object.defineProperty(Pl, "__esModule", {
  value: !0
});
var Sg = {
  registered: {},
  scrollEvent: {
    register: function(e, t) {
      Sg.registered[e] = t;
    },
    remove: function(e) {
      Sg.registered[e] = null;
    }
  }
};
Pl.default = Sg;
Object.defineProperty(Jp, "__esModule", {
  value: !0
});
var d4 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, f4 = Ml;
ed(f4);
var h4 = Fv, Hx = ed(h4), g4 = Rv, m4 = ed(g4), v4 = Pl, wo = ed(v4);
function ed(e) {
  return e && e.__esModule ? e : { default: e };
}
var zP = function(e) {
  return Hx.default[e.smooth] || Hx.default.defaultEasing;
}, y4 = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, b4 = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Og = function() {
  return b4() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), UP = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, $P = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, WP = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, w4 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollWidth - t.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, C4 = function(e) {
  var t = e.data.containerElement;
  if (t && t !== document && t !== document.body)
    return t.scrollHeight - t.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, E4 = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    wo.default.registered.end && wo.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Og.call(window, i);
    return;
  }
  wo.default.registered.end && wo.default.registered.end(o.to, o.target, o.currentPosition);
}, zv = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Tl = function(e, t, n, r) {
  t.data = t.data || UP(), window.clearTimeout(t.data.delayTimeout);
  var o = function() {
    t.data.cancel = !0;
  };
  if (m4.default.subscribe(o), zv(t), t.data.start = null, t.data.cancel = !1, t.data.startPosition = t.horizontal ? $P(t) : WP(t), t.data.targetPosition = t.absolute ? e : e + t.data.startPosition, t.data.startPosition === t.data.targetPosition) {
    wo.default.registered.end && wo.default.registered.end(t.data.to, t.data.target, t.data.currentPosition);
    return;
  }
  t.data.delta = Math.round(t.data.targetPosition - t.data.startPosition), t.data.duration = y4(t.duration)(t.data.delta), t.data.duration = isNaN(parseFloat(t.data.duration)) ? 1e3 : parseFloat(t.data.duration), t.data.to = n, t.data.target = r;
  var i = zP(t), s = E4.bind(null, i, t);
  if (t && t.delay > 0) {
    t.data.delayTimeout = window.setTimeout(function() {
      wo.default.registered.begin && wo.default.registered.begin(t.data.to, t.data.target), Og.call(window, s);
    }, t.delay);
    return;
  }
  wo.default.registered.begin && wo.default.registered.begin(t.data.to, t.data.target), Og.call(window, s);
}, td = function(e) {
  return e = d4({}, e), e.data = e.data || UP(), e.absolute = !0, e;
}, x4 = function(e) {
  Tl(0, td(e));
}, L4 = function(e, t) {
  Tl(e, td(t));
}, k4 = function(e) {
  e = td(e), zv(e), Tl(e.horizontal ? w4(e) : C4(e), e);
}, D4 = function(e, t) {
  t = td(t), zv(t);
  var n = t.horizontal ? $P(t) : WP(t);
  Tl(e + n, t);
};
Jp.default = {
  animateTopScroll: Tl,
  getAnimationType: zP,
  scrollToTop: x4,
  scrollToBottom: k4,
  scrollTo: L4,
  scrollMore: D4
};
Object.defineProperty(Hs, "__esModule", {
  value: !0
});
var S4 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, O4 = Ml, M4 = Uv(O4), P4 = Jp, T4 = Uv(P4), A4 = Pl, Bu = Uv(A4);
function Uv(e) {
  return e && e.__esModule ? e : { default: e };
}
var _u = {}, Vx = void 0;
Hs.default = {
  unmount: function() {
    _u = {};
  },
  register: function(e, t) {
    _u[e] = t;
  },
  unregister: function(e) {
    delete _u[e];
  },
  get: function(e) {
    return _u[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return Vx = e;
  },
  getActiveLink: function() {
    return Vx;
  },
  scrollTo: function(e, t) {
    var n = this.get(e);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    t = S4({}, t, { absolute: !1 });
    var r = t.containerId, o = t.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, t.absolute = !0;
    var s = t.horizontal, a = M4.default.scrollOffset(i, n, s) + (t.offset || 0);
    if (!t.smooth) {
      Bu.default.registered.begin && Bu.default.registered.begin(e, n), i === document ? t.horizontal ? window.scrollTo(a, 0) : window.scrollTo(0, a) : i.scrollTop = a, Bu.default.registered.end && Bu.default.registered.end(e, n);
      return;
    }
    T4.default.animateTopScroll(a, t, e, n);
  }
};
var Mg = { exports: {} }, $f = { exports: {} }, Wt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Zx;
function B4() {
  if (Zx) return Wt;
  Zx = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
  function x(w) {
    if (typeof w == "object" && w !== null) {
      var C = w.$$typeof;
      switch (C) {
        case t:
          switch (w = w.type, w) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return w;
            default:
              switch (w = w && w.$$typeof, w) {
                case a:
                case c:
                case m:
                case g:
                case s:
                  return w;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function T(w) {
    return x(w) === u;
  }
  return Wt.AsyncMode = l, Wt.ConcurrentMode = u, Wt.ContextConsumer = a, Wt.ContextProvider = s, Wt.Element = t, Wt.ForwardRef = c, Wt.Fragment = r, Wt.Lazy = m, Wt.Memo = g, Wt.Portal = n, Wt.Profiler = i, Wt.StrictMode = o, Wt.Suspense = p, Wt.isAsyncMode = function(w) {
    return T(w) || x(w) === l;
  }, Wt.isConcurrentMode = T, Wt.isContextConsumer = function(w) {
    return x(w) === a;
  }, Wt.isContextProvider = function(w) {
    return x(w) === s;
  }, Wt.isElement = function(w) {
    return typeof w == "object" && w !== null && w.$$typeof === t;
  }, Wt.isForwardRef = function(w) {
    return x(w) === c;
  }, Wt.isFragment = function(w) {
    return x(w) === r;
  }, Wt.isLazy = function(w) {
    return x(w) === m;
  }, Wt.isMemo = function(w) {
    return x(w) === g;
  }, Wt.isPortal = function(w) {
    return x(w) === n;
  }, Wt.isProfiler = function(w) {
    return x(w) === i;
  }, Wt.isStrictMode = function(w) {
    return x(w) === o;
  }, Wt.isSuspense = function(w) {
    return x(w) === p;
  }, Wt.isValidElementType = function(w) {
    return typeof w == "string" || typeof w == "function" || w === r || w === u || w === i || w === o || w === p || w === d || typeof w == "object" && w !== null && (w.$$typeof === m || w.$$typeof === g || w.$$typeof === s || w.$$typeof === a || w.$$typeof === c || w.$$typeof === h || w.$$typeof === E || w.$$typeof === L || w.$$typeof === f);
  }, Wt.typeOf = x, Wt;
}
var Yt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var qx;
function _4() {
  return qx || (qx = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
    function x(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === m || B.$$typeof === g || B.$$typeof === s || B.$$typeof === a || B.$$typeof === c || B.$$typeof === h || B.$$typeof === E || B.$$typeof === L || B.$$typeof === f);
    }
    function T(B) {
      if (typeof B == "object" && B !== null) {
        var se = B.$$typeof;
        switch (se) {
          case t:
            var ue = B.type;
            switch (ue) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ue;
              default:
                var ce = ue && ue.$$typeof;
                switch (ce) {
                  case a:
                  case c:
                  case m:
                  case g:
                  case s:
                    return ce;
                  default:
                    return se;
                }
            }
          case n:
            return se;
        }
      }
    }
    var w = l, C = u, k = a, O = s, U = t, M = c, V = r, $ = m, W = g, R = n, H = i, X = o, I = p, J = !1;
    function te(B) {
      return J || (J = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), S(B) || T(B) === l;
    }
    function S(B) {
      return T(B) === u;
    }
    function P(B) {
      return T(B) === a;
    }
    function q(B) {
      return T(B) === s;
    }
    function j(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function Z(B) {
      return T(B) === c;
    }
    function G(B) {
      return T(B) === r;
    }
    function b(B) {
      return T(B) === m;
    }
    function F(B) {
      return T(B) === g;
    }
    function z(B) {
      return T(B) === n;
    }
    function A(B) {
      return T(B) === i;
    }
    function Y(B) {
      return T(B) === o;
    }
    function ee(B) {
      return T(B) === p;
    }
    Yt.AsyncMode = w, Yt.ConcurrentMode = C, Yt.ContextConsumer = k, Yt.ContextProvider = O, Yt.Element = U, Yt.ForwardRef = M, Yt.Fragment = V, Yt.Lazy = $, Yt.Memo = W, Yt.Portal = R, Yt.Profiler = H, Yt.StrictMode = X, Yt.Suspense = I, Yt.isAsyncMode = te, Yt.isConcurrentMode = S, Yt.isContextConsumer = P, Yt.isContextProvider = q, Yt.isElement = j, Yt.isForwardRef = Z, Yt.isFragment = G, Yt.isLazy = b, Yt.isMemo = F, Yt.isPortal = z, Yt.isProfiler = A, Yt.isStrictMode = Y, Yt.isSuspense = ee, Yt.isValidElementType = x, Yt.typeOf = T;
  }()), Yt;
}
var Gx;
function HP() {
  return Gx || (Gx = 1, process.env.NODE_ENV === "production" ? $f.exports = B4() : $f.exports = _4()), $f.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Wf, Kx;
function I4() {
  if (Kx) return Wf;
  Kx = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Wf = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, Wf;
}
var Hf, Yx;
function $v() {
  if (Yx) return Hf;
  Yx = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Hf = e, Hf;
}
var Xx, Qx;
function VP() {
  return Qx || (Qx = 1, Xx = Function.call.bind(Object.prototype.hasOwnProperty)), Xx;
}
var Vf, Jx;
function j4() {
  if (Jx) return Vf;
  Jx = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = $v(), n = {}, r = VP();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (m) {
            p = m;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, Vf = o, Vf;
}
var Zf, eL;
function N4() {
  if (eL) return Zf;
  eL = 1;
  var e = HP(), t = I4(), n = $v(), r = VP(), o = j4(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return Zf = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(S) {
      var P = S && (u && S[u] || S[c]);
      if (typeof P == "function")
        return P;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: L(),
      arrayOf: x,
      element: T(),
      elementType: w(),
      instanceOf: C,
      node: M(),
      objectOf: O,
      oneOf: k,
      oneOfType: U,
      shape: $,
      exact: W
    };
    function m(S, P) {
      return S === P ? S !== 0 || 1 / S === 1 / P : S !== S && P !== P;
    }
    function f(S, P) {
      this.message = S, this.data = P && typeof P == "object" ? P : {}, this.stack = "";
    }
    f.prototype = Error.prototype;
    function h(S) {
      if (process.env.NODE_ENV !== "production")
        var P = {}, q = 0;
      function j(G, b, F, z, A, Y, ee) {
        if (z = z || d, Y = Y || F, ee !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var se = z + ":" + F;
            !P[se] && // Avoid spamming the console because they are often not actionable except for lib authors
            q < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + Y + "` prop on `" + z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), P[se] = !0, q++);
          }
        }
        return b[F] == null ? G ? b[F] === null ? new f("The " + A + " `" + Y + "` is marked as required " + ("in `" + z + "`, but its value is `null`.")) : new f("The " + A + " `" + Y + "` is marked as required in " + ("`" + z + "`, but its value is `undefined`.")) : null : S(b, F, z, A, Y);
      }
      var Z = j.bind(null, !1);
      return Z.isRequired = j.bind(null, !0), Z;
    }
    function E(S) {
      function P(q, j, Z, G, b, F) {
        var z = q[j], A = X(z);
        if (A !== S) {
          var Y = I(z);
          return new f(
            "Invalid " + G + " `" + b + "` of type " + ("`" + Y + "` supplied to `" + Z + "`, expected ") + ("`" + S + "`."),
            { expectedType: S }
          );
        }
        return null;
      }
      return h(P);
    }
    function L() {
      return h(s);
    }
    function x(S) {
      function P(q, j, Z, G, b) {
        if (typeof S != "function")
          return new f("Property `" + b + "` of component `" + Z + "` has invalid PropType notation inside arrayOf.");
        var F = q[j];
        if (!Array.isArray(F)) {
          var z = X(F);
          return new f("Invalid " + G + " `" + b + "` of type " + ("`" + z + "` supplied to `" + Z + "`, expected an array."));
        }
        for (var A = 0; A < F.length; A++) {
          var Y = S(F, A, Z, G, b + "[" + A + "]", n);
          if (Y instanceof Error)
            return Y;
        }
        return null;
      }
      return h(P);
    }
    function T() {
      function S(P, q, j, Z, G) {
        var b = P[q];
        if (!a(b)) {
          var F = X(b);
          return new f("Invalid " + Z + " `" + G + "` of type " + ("`" + F + "` supplied to `" + j + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(S);
    }
    function w() {
      function S(P, q, j, Z, G) {
        var b = P[q];
        if (!e.isValidElementType(b)) {
          var F = X(b);
          return new f("Invalid " + Z + " `" + G + "` of type " + ("`" + F + "` supplied to `" + j + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(S);
    }
    function C(S) {
      function P(q, j, Z, G, b) {
        if (!(q[j] instanceof S)) {
          var F = S.name || d, z = te(q[j]);
          return new f("Invalid " + G + " `" + b + "` of type " + ("`" + z + "` supplied to `" + Z + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return h(P);
    }
    function k(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function P(q, j, Z, G, b) {
        for (var F = q[j], z = 0; z < S.length; z++)
          if (m(F, S[z]))
            return null;
        var A = JSON.stringify(S, function(Y, ee) {
          var B = I(ee);
          return B === "symbol" ? String(ee) : ee;
        });
        return new f("Invalid " + G + " `" + b + "` of value `" + String(F) + "` " + ("supplied to `" + Z + "`, expected one of " + A + "."));
      }
      return h(P);
    }
    function O(S) {
      function P(q, j, Z, G, b) {
        if (typeof S != "function")
          return new f("Property `" + b + "` of component `" + Z + "` has invalid PropType notation inside objectOf.");
        var F = q[j], z = X(F);
        if (z !== "object")
          return new f("Invalid " + G + " `" + b + "` of type " + ("`" + z + "` supplied to `" + Z + "`, expected an object."));
        for (var A in F)
          if (r(F, A)) {
            var Y = S(F, A, Z, G, b + "." + A, n);
            if (Y instanceof Error)
              return Y;
          }
        return null;
      }
      return h(P);
    }
    function U(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var P = 0; P < S.length; P++) {
        var q = S[P];
        if (typeof q != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + J(q) + " at index " + P + "."
          ), s;
      }
      function j(Z, G, b, F, z) {
        for (var A = [], Y = 0; Y < S.length; Y++) {
          var ee = S[Y], B = ee(Z, G, b, F, z, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && A.push(B.data.expectedType);
        }
        var se = A.length > 0 ? ", expected one of type [" + A.join(", ") + "]" : "";
        return new f("Invalid " + F + " `" + z + "` supplied to " + ("`" + b + "`" + se + "."));
      }
      return h(j);
    }
    function M() {
      function S(P, q, j, Z, G) {
        return R(P[q]) ? null : new f("Invalid " + Z + " `" + G + "` supplied to " + ("`" + j + "`, expected a ReactNode."));
      }
      return h(S);
    }
    function V(S, P, q, j, Z) {
      return new f(
        (S || "React class") + ": " + P + " type `" + q + "." + j + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Z + "`."
      );
    }
    function $(S) {
      function P(q, j, Z, G, b) {
        var F = q[j], z = X(F);
        if (z !== "object")
          return new f("Invalid " + G + " `" + b + "` of type `" + z + "` " + ("supplied to `" + Z + "`, expected `object`."));
        for (var A in S) {
          var Y = S[A];
          if (typeof Y != "function")
            return V(Z, G, b, A, I(Y));
          var ee = Y(F, A, Z, G, b + "." + A, n);
          if (ee)
            return ee;
        }
        return null;
      }
      return h(P);
    }
    function W(S) {
      function P(q, j, Z, G, b) {
        var F = q[j], z = X(F);
        if (z !== "object")
          return new f("Invalid " + G + " `" + b + "` of type `" + z + "` " + ("supplied to `" + Z + "`, expected `object`."));
        var A = t({}, q[j], S);
        for (var Y in A) {
          var ee = S[Y];
          if (r(S, Y) && typeof ee != "function")
            return V(Z, G, b, Y, I(ee));
          if (!ee)
            return new f(
              "Invalid " + G + " `" + b + "` key `" + Y + "` supplied to `" + Z + "`.\nBad object: " + JSON.stringify(q[j], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(S), null, "  ")
            );
          var B = ee(F, Y, Z, G, b + "." + Y, n);
          if (B)
            return B;
        }
        return null;
      }
      return h(P);
    }
    function R(S) {
      switch (typeof S) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !S;
        case "object":
          if (Array.isArray(S))
            return S.every(R);
          if (S === null || a(S))
            return !0;
          var P = p(S);
          if (P) {
            var q = P.call(S), j;
            if (P !== S.entries) {
              for (; !(j = q.next()).done; )
                if (!R(j.value))
                  return !1;
            } else
              for (; !(j = q.next()).done; ) {
                var Z = j.value;
                if (Z && !R(Z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function H(S, P) {
      return S === "symbol" ? !0 : P ? P["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && P instanceof Symbol : !1;
    }
    function X(S) {
      var P = typeof S;
      return Array.isArray(S) ? "array" : S instanceof RegExp ? "object" : H(P, S) ? "symbol" : P;
    }
    function I(S) {
      if (typeof S > "u" || S === null)
        return "" + S;
      var P = X(S);
      if (P === "object") {
        if (S instanceof Date)
          return "date";
        if (S instanceof RegExp)
          return "regexp";
      }
      return P;
    }
    function J(S) {
      var P = I(S);
      switch (P) {
        case "array":
        case "object":
          return "an " + P;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + P;
        default:
          return P;
      }
    }
    function te(S) {
      return !S.constructor || !S.constructor.name ? d : S.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, Zf;
}
var qf, tL;
function F4() {
  if (tL) return qf;
  tL = 1;
  var e = $v();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, qf = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, qf;
}
if (process.env.NODE_ENV !== "production") {
  var R4 = HP(), z4 = !0;
  Mg.exports = N4()(R4.isElement, z4);
} else
  Mg.exports = F4()();
var nd = Mg.exports, rd = {};
Object.defineProperty(rd, "__esModule", {
  value: !0
});
var U4 = Ml, Gf = $4(U4);
function $4(e) {
  return e && e.__esModule ? e : { default: e };
}
var W4 = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, t) {
    this.containers[e] = t;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, t = this.getHash();
    t ? window.setTimeout(function() {
      e.scrollTo(t, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, t) {
    var n = this.scroller, r = n.get(e);
    if (r && (t || e !== n.getActiveLink())) {
      var o = this.containers[e] || document;
      n.scrollTo(e, { container: o });
    }
  },
  getHash: function() {
    return Gf.default.getHash();
  },
  changeHash: function(e, t) {
    this.isInitialized() && Gf.default.getHash() !== e && Gf.default.updateHash(e, t);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
rd.default = W4;
Object.defineProperty(Dl, "__esModule", {
  value: !0
});
var Iu = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, H4 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), V4 = Be, nL = Al(V4), Z4 = Sl, ju = Al(Z4), q4 = Hs, G4 = Al(q4), K4 = nd, An = Al(K4), Y4 = rd, ti = Al(Y4);
function Al(e) {
  return e && e.__esModule ? e : { default: e };
}
function X4(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Q4(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function J4(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var rL = {
  to: An.default.string.isRequired,
  containerId: An.default.string,
  container: An.default.object,
  activeClass: An.default.string,
  activeStyle: An.default.object,
  spy: An.default.bool,
  horizontal: An.default.bool,
  smooth: An.default.oneOfType([An.default.bool, An.default.string]),
  offset: An.default.number,
  delay: An.default.number,
  isDynamic: An.default.bool,
  onClick: An.default.func,
  duration: An.default.oneOfType([An.default.number, An.default.func]),
  absolute: An.default.bool,
  onSetActive: An.default.func,
  onSetInactive: An.default.func,
  ignoreCancelEvents: An.default.bool,
  hashSpy: An.default.bool,
  saveHashHistory: An.default.bool,
  spyThrottle: An.default.number
};
Dl.default = function(e, t) {
  var n = t || G4.default, r = function(i) {
    J4(s, i);
    function s(a) {
      X4(this, s);
      var l = Q4(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return H4(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var a = this.props.containerId, l = this.props.container;
        return a && !l ? document.getElementById(a) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var a = this.getScrollSpyContainer();
          ju.default.isMounted(a) || ju.default.mount(a, this.props.spyThrottle), this.props.hashSpy && (ti.default.isMounted() || ti.default.mount(n), ti.default.mapContainer(this.props.to, a)), ju.default.addSpyHandler(this.spyHandler, a), this.setState({
            container: a
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        ju.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var a = "";
        this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Iu({}, this.props.style, this.props.activeStyle) : l = Iu({}, this.props.style);
        var u = Iu({}, this.props);
        for (var c in rL)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = a, u.style = l, u.onClick = this.handleClick, nL.default.createElement(e, u);
      }
    }]), s;
  }(nL.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(s, a) {
      n.scrollTo(s, Iu({}, i.state, a));
    }, this.handleClick = function(s) {
      i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(s, a) {
      var l = i.getScrollSpyContainer();
      if (!(ti.default.isMounted() && !ti.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, p = null, d = void 0, g = void 0;
        if (u) {
          var m = 0, f = 0, h = 0;
          if (l.getBoundingClientRect) {
            var E = l.getBoundingClientRect();
            h = E.left;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var L = p.getBoundingClientRect();
            m = L.left - h + s, f = m + L.width;
          }
          var x = s - i.props.offset;
          d = x >= Math.floor(m) && x < Math.floor(f), g = x < Math.floor(m) || x >= Math.floor(f);
        } else {
          var T = 0, w = 0, C = 0;
          if (l.getBoundingClientRect) {
            var k = l.getBoundingClientRect();
            C = k.top;
          }
          if (!p || i.props.isDynamic) {
            if (p = n.get(c), !p)
              return;
            var O = p.getBoundingClientRect();
            T = O.top - C + a, w = T + O.height;
          }
          var U = a - i.props.offset;
          d = U >= Math.floor(T) && U < Math.floor(w), g = U < Math.floor(T) || U >= Math.floor(w);
        }
        var M = n.getActiveLink();
        if (g) {
          if (c === M && n.setActiveLink(void 0), i.props.hashSpy && ti.default.getHash() === c) {
            var V = i.props.saveHashHistory, $ = V === void 0 ? !1 : V;
            ti.default.changeHash("", $);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, p));
        }
        if (d && (M !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var W = i.props.saveHashHistory, R = W === void 0 ? !1 : W;
          i.props.hashSpy && ti.default.changeHash(c, R), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, p));
        }
      }
    };
  };
  return r.propTypes = rL, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Nv, "__esModule", {
  value: !0
});
var e7 = Be, oL = ZP(e7), t7 = Dl, n7 = ZP(t7);
function ZP(e) {
  return e && e.__esModule ? e : { default: e };
}
function r7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function iL(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function o7(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var i7 = function(e) {
  o7(t, e);
  function t() {
    var n, r, o, i;
    r7(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = iL(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return oL.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), iL(o, i);
  }
  return t;
}(oL.default.Component);
Nv.default = (0, n7.default)(i7);
var Wv = {};
Object.defineProperty(Wv, "__esModule", {
  value: !0
});
var s7 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), a7 = Be, sL = qP(a7), l7 = Dl, u7 = qP(l7);
function qP(e) {
  return e && e.__esModule ? e : { default: e };
}
function c7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function p7(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function d7(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var f7 = function(e) {
  d7(t, e);
  function t() {
    return c7(this, t), p7(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return s7(t, [{
    key: "render",
    value: function() {
      return sL.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(sL.default.Component);
Wv.default = (0, u7.default)(f7);
var Hv = {}, od = {};
Object.defineProperty(od, "__esModule", {
  value: !0
});
var h7 = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, g7 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), m7 = Be, aL = id(m7), v7 = pl;
id(v7);
var y7 = Hs, lL = id(y7), b7 = nd, uL = id(b7);
function id(e) {
  return e && e.__esModule ? e : { default: e };
}
function w7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function C7(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function E7(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
od.default = function(e) {
  var t = function(n) {
    E7(r, n);
    function r(o) {
      w7(this, r);
      var i = C7(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return g7(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        lL.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        lL.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return aL.default.createElement(e, h7({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(aL.default.Component);
  return t.propTypes = {
    name: uL.default.string,
    id: uL.default.string
  }, t;
};
Object.defineProperty(Hv, "__esModule", {
  value: !0
});
var cL = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, x7 = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), L7 = Be, pL = Vv(L7), k7 = od, D7 = Vv(k7), S7 = nd, dL = Vv(S7);
function Vv(e) {
  return e && e.__esModule ? e : { default: e };
}
function O7(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function M7(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function P7(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var GP = function(e) {
  P7(t, e);
  function t() {
    return O7(this, t), M7(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return x7(t, [{
    key: "render",
    value: function() {
      var n = this, r = cL({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, pL.default.createElement(
        "div",
        cL({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), t;
}(pL.default.Component);
GP.propTypes = {
  name: dL.default.string,
  id: dL.default.string
};
Hv.default = (0, D7.default)(GP);
var Kf = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, fL = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function hL(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function gL(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function mL(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var Nu = Be, Gi = Sl, Yf = Hs, Gn = nd, ni = rd, vL = {
  to: Gn.string.isRequired,
  containerId: Gn.string,
  container: Gn.object,
  activeClass: Gn.string,
  spy: Gn.bool,
  smooth: Gn.oneOfType([Gn.bool, Gn.string]),
  offset: Gn.number,
  delay: Gn.number,
  isDynamic: Gn.bool,
  onClick: Gn.func,
  duration: Gn.oneOfType([Gn.number, Gn.func]),
  absolute: Gn.bool,
  onSetActive: Gn.func,
  onSetInactive: Gn.func,
  ignoreCancelEvents: Gn.bool,
  hashSpy: Gn.bool,
  spyThrottle: Gn.number
}, T7 = {
  Scroll: function(e, t) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = t || Yf, r = function(i) {
      mL(s, i);
      function s(a) {
        hL(this, s);
        var l = gL(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return fL(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var a = this.props.containerId, l = this.props.container;
          return a ? document.getElementById(a) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var a = this.getScrollSpyContainer();
            Gi.isMounted(a) || Gi.mount(a, this.props.spyThrottle), this.props.hashSpy && (ni.isMounted() || ni.mount(n), ni.mapContainer(this.props.to, a)), this.props.spy && Gi.addStateHandler(this.stateHandler), Gi.addSpyHandler(this.spyHandler, a), this.setState({
              container: a
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Gi.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var a = "";
          this.state && this.state.active ? a = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : a = this.props.className;
          var l = Kf({}, this.props);
          for (var u in vL)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = a, l.onClick = this.handleClick, Nu.createElement(e, l);
        }
      }]), s;
    }(Nu.Component), o = function() {
      var i = this;
      this.scrollTo = function(s, a) {
        n.scrollTo(s, Kf({}, i.state, a));
      }, this.handleClick = function(s) {
        i.props.onClick && i.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(s) {
        var a = i.getScrollSpyContainer();
        if (!(ni.isMounted() && !ni.isInitialized())) {
          var l = i.props.to, u = null, c = 0, p = 0, d = 0;
          if (a.getBoundingClientRect) {
            var g = a.getBoundingClientRect();
            d = g.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var m = u.getBoundingClientRect();
            c = m.top - d + s, p = c + m.height;
          }
          var f = s - i.props.offset, h = f >= Math.floor(c) && f < Math.floor(p), E = f < Math.floor(c) || f >= Math.floor(p), L = n.getActiveLink();
          if (E)
            return l === L && n.setActiveLink(void 0), i.props.hashSpy && ni.getHash() === l && ni.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Gi.updateStates();
          if (h && L !== l)
            return n.setActiveLink(l), i.props.hashSpy && ni.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Gi.updateStates();
        }
      };
    };
    return r.propTypes = vL, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var t = function(n) {
      mL(r, n);
      function r(o) {
        hL(this, r);
        var i = gL(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return fL(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Yf.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Yf.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return Nu.createElement(e, Kf({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(Nu.Component);
    return t.propTypes = {
      name: Gn.string,
      id: Gn.string
    }, t;
  }
}, A7 = T7;
Object.defineProperty(tr, "__esModule", {
  value: !0
});
tr.Helpers = tr.ScrollElement = tr.ScrollLink = tr.animateScroll = tr.scrollSpy = tr.Events = tr.scroller = tr.Element = tr.Button = tr.Link = void 0;
var B7 = Nv, KP = So(B7), _7 = Wv, YP = So(_7), I7 = Hv, XP = So(I7), j7 = Hs, QP = So(j7), N7 = Pl, JP = So(N7), F7 = Sl, eT = So(F7), R7 = Jp, tT = So(R7), z7 = Dl, nT = So(z7), U7 = od, rT = So(U7), $7 = A7, oT = So($7);
function So(e) {
  return e && e.__esModule ? e : { default: e };
}
tr.Link = KP.default;
tr.Button = YP.default;
tr.Element = XP.default;
tr.scroller = QP.default;
tr.Events = JP.default;
tr.scrollSpy = eT.default;
tr.animateScroll = tT.default;
tr.ScrollLink = nT.default;
tr.ScrollElement = rT.default;
tr.Helpers = oT.default;
tr.default = { Link: KP.default, Button: YP.default, Element: XP.default, scroller: QP.default, Events: JP.default, scrollSpy: eT.default, animateScroll: tT.default, ScrollLink: nT.default, ScrollElement: rT.default, Helpers: oT.default };
Ye({});
Ye({});
Ye({});
let W7 = { data: "" }, H7 = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || W7, V7 = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Z7 = /\/\*[^]*?\*\/|  +/g, yL = /\n+/g, yi = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? yi(s, i) : i + "{" + yi(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += yi(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += yi.p ? yi.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, _o = {}, iT = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + iT(e[n]);
    return t;
  }
  return e;
}, q7 = (e, t, n, r, o) => {
  let i = iT(e), s = _o[i] || (_o[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!_o[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = V7.exec(u.replace(Z7, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(yL, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(yL, " ").trim();
      return d[0];
    })(e);
    _o[s] = yi(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && _o.g ? _o.g : null;
  return n && (_o.g = _o[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(_o[s], t, r, a), s;
}, G7 = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : yi(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function sd(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return q7(n.unshift ? n.raw ? G7(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, H7(t.target), t.g, t.o, t.k);
}
let sT, Pg, Tg;
sd.bind({ g: 1 });
let Wo = sd.bind({ k: 1 });
function K7(e, t, n, r) {
  yi.p = t, sT = e, Pg = n, Tg = r;
}
function Ii(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: Pg && Pg() }, a), n.o = / *go\d+/.test(l), a.className = sd.apply(n, r) + (l ? " " + l : ""), t && (a.ref = s);
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), Tg && u[0] && Tg(a), sT(u, a);
    }
    return t ? t(o) : o;
  };
}
var Y7 = (e) => typeof e == "function", X7 = (e, t) => Y7(e) ? e(t) : e, Q7 = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), J7 = Wo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, eZ = Wo`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, tZ = Wo`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, nZ = Ii("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${J7} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${eZ} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${tZ} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, rZ = Wo`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, oZ = Ii("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${rZ} 1s linear infinite;
`, iZ = Wo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, sZ = Wo`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, aZ = Ii("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${iZ} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${sZ} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, lZ = Ii("div")`
  position: absolute;
`, uZ = Ii("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, cZ = Wo`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, pZ = Ii("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${cZ} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, dZ = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ve.createElement(pZ, null, t) : t : n === "blank" ? null : Ve.createElement(uZ, null, Ve.createElement(oZ, { ...r }), n !== "loading" && Ve.createElement(lZ, null, n === "error" ? Ve.createElement(nZ, { ...r }) : Ve.createElement(aZ, { ...r })));
}, fZ = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, hZ = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, gZ = "0%{opacity:0;} 100%{opacity:1;}", mZ = "0%{opacity:1;} 100%{opacity:0;}", vZ = Ii("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, yZ = Ii("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, bZ = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = Q7() ? [gZ, mZ] : [fZ(n), hZ(n)];
  return { animation: t ? `${Wo(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Wo(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
Ve.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? bZ(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ve.createElement(dZ, { toast: e }), s = Ve.createElement(yZ, { ...e.ariaProps }, X7(e.message, e));
  return Ve.createElement(vZ, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ve.createElement(Ve.Fragment, null, i, s));
});
K7(Ve.createElement);
sd`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function wZ(e) {
  const {
    filePath: t,
    isLoading: n,
    acceptImage: r,
    changeImageButtonText: o,
    handleSelectFile: i,
    reSendImage: s
  } = e;
  function a() {
    const l = document.createElement("input");
    l.type = "file", l.accept = r, l.onchange = (u) => {
      var p;
      const c = (p = u.target.files) == null ? void 0 : p[0];
      c && i(c);
    }, l.click();
  }
  return /* @__PURE__ */ Q.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${t}")` },
      children: [
        s && /* @__PURE__ */ Q.jsx(I5, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ Q.jsx(
          Sj,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: n,
            onClick: s,
            icon: iB
          }
        ) }),
        /* @__PURE__ */ Q.jsx(
          LS,
          {
            isLoading: n,
            onClick: a,
            variant: "outline",
            size: "sm",
            type: "button",
            children: o
          }
        )
      ]
    }
  );
}
function CZ(e) {
  const { error: t } = e, n = "arkynImageUploadError";
  return t ? /* @__PURE__ */ Q.jsx("strong", { className: n, children: t }) : /* @__PURE__ */ Q.jsx(Q.Fragment, {});
}
function EZ(e) {
  const { label: t, showAsterisk: n } = e, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ Q.jsx("strong", { className: o.trim(), children: t });
}
function xZ(e) {
  const {
    dropImageText: t,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i
  } = e;
  function s(l) {
    l.preventDefault();
    const u = l.dataTransfer.files[0];
    u && o(u);
  }
  function a() {
    const l = document.createElement("input");
    l.type = "file", l.accept = r, l.onchange = (u) => {
      var p;
      const c = (p = u.target.files) == null ? void 0 : p[0];
      c && o(c);
    }, l.click();
  }
  return /* @__PURE__ */ Q.jsxs("div", { onDrop: s, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ Q.jsx(
      LS,
      {
        isLoading: n,
        onClick: a,
        variant: "ghost",
        size: "sm",
        type: "button",
        children: i
      }
    ),
    /* @__PURE__ */ Q.jsx("p", { children: t })
  ] });
}
function rre(e) {
  const {
    name: t,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: s = "file",
    method: a = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: p = "Selecionar imagem",
    dropImageText: d = "Ou arraste e solte a imagem aqui",
    onUpload: g
  } = e, f = Lj()[t], [h, E] = D(n), [L, x] = D(""), [T, w] = D(null), [C, k] = D(n), [O, U] = D(!1);
  async function M(X) {
    U(!0), w(X);
    const I = new FormData();
    I.append(s, X), await fetch(i, { method: a, body: I }).then(async (J) => await J.json()).then((J) => {
      J != null && J.error ? x(J.error) : E(J == null ? void 0 : J[u]), g && g(J == null ? void 0 : J[u]);
    }).catch((J) => {
      console.error(J), x("Erro ao enviar imagem");
    }).finally(() => U(!1));
  }
  function V(X) {
    k(URL.createObjectURL(X)), M(X);
  }
  const $ = f || L, H = `arkynImageUpload ${$ ? "hasError" : "noHasError"} ${C ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ Q.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ Q.jsx(EZ, { label: r, showAsterisk: o }),
    /* @__PURE__ */ Q.jsxs("div", { className: H, children: [
      /* @__PURE__ */ Q.jsx("input", { type: "hidden", name: t, value: h || "" }),
      !C && /* @__PURE__ */ Q.jsx(
        xZ,
        {
          isLoading: O,
          acceptImage: l,
          dropImageText: d,
          handleSelectFile: V,
          selectImageButtonText: p
        }
      ),
      C && /* @__PURE__ */ Q.jsx(
        wZ,
        {
          isLoading: O,
          acceptImage: l,
          filePath: C,
          handleSelectFile: V,
          changeImageButtonText: c,
          reSendImage: $ && T ? () => M(T) : void 0
        }
      )
    ] }),
    $ && /* @__PURE__ */ Q.jsx(CZ, { error: $ })
  ] });
}
const aT = Ye({});
function LZ() {
  return _e(aT);
}
function ore(e) {
  const {
    defaultValue: t,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: s = "",
    ...a
  } = e, [l, u] = D(t || ""), { inputRef: c, id: p } = ro();
  function d(m) {
    u(m), o && o(m);
  }
  const g = `arkynRadioGroup ${i} ${s}`;
  return /* @__PURE__ */ Q.jsxs(
    aT.Provider,
    {
      value: { onChange: d, value: r || l, size: i },
      children: [
        /* @__PURE__ */ Q.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: p,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ Q.jsx("div", { className: g.trim(), ...a })
      ]
    }
  );
}
function ire(e) {
  const {
    value: t,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...s
  } = e, { onChange: a, size: l, value: u } = LZ(), { error: c } = ro(), f = `arkynRadioBox ${n || l} ${u === t ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ Q.jsxs("label", { className: f.trim(), children: [
    /* @__PURE__ */ Q.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => a(t),
        onFocus: () => a(t),
        ...s
      }
    ),
    o
  ] });
}
var Yo = {};
Object.defineProperty(Yo, "__esModule", {
  value: !0
});
var kZ = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Xf = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, lT = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: kZ ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, Zv = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Fu = 1; Fu < 20; Fu++)
  Zv["f" + Fu] = 111 + Fu;
function ad(e, t, n) {
  t && !("byKey" in t) && (n = t, t = null), Array.isArray(e) || (e = [e]);
  var r = e.map(function(s) {
    return uT(s, t);
  }), o = function(a) {
    return r.some(function(l) {
      return cT(l, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function DZ(e, t) {
  return ad(e, t);
}
function SZ(e, t) {
  return ad(e, { byKey: !0 }, t);
}
function uT(e, t) {
  var n = t && t.byKey, r = {};
  e = e.replace("++", "+add");
  var o = e.split("+"), i = o.length;
  for (var s in Xf)
    r[Xf[s]] = !1;
  var a = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), p; !(a = (p = c.next()).done); a = !0) {
      var d = p.value, g = d.endsWith("?") && d.length > 1;
      g && (d = d.slice(0, -1));
      var m = qv(d), f = Xf[m];
      if (d.length > 1 && !f && !lT[d] && !Zv[m])
        throw new TypeError('Unknown modifier: "' + d + '"');
      (i === 1 || !f) && (n ? r.key = m : r.which = pT(d)), f && (r[f] = g ? null : !0);
    }
  } catch (h) {
    l = !0, u = h;
  } finally {
    try {
      !a && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function cT(e, t) {
  for (var n in e) {
    var r = e[n], o = void 0;
    if (r != null && (n === "key" && t.key != null ? o = t.key.toLowerCase() : n === "which" ? o = r === 91 && t.which === 93 ? 91 : t.which : o = t[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function pT(e) {
  e = qv(e);
  var t = Zv[e] || e.toUpperCase().charCodeAt(0);
  return t;
}
function qv(e) {
  return e = e.toLowerCase(), e = lT[e] || e, e;
}
var OZ = Yo.default = ad, Qf = Yo.isHotkey = ad;
Yo.isCodeHotkey = DZ;
Yo.isKeyHotkey = SZ;
Yo.parseHotkey = uT;
Yo.compareHotkey = cT;
Yo.toKeyCode = pT;
Yo.toKeyName = qv;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function bL(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function Er(e) {
  var t, n;
  return bL(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(bL(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var dT = Symbol.for("immer-nothing"), wL = Symbol.for("immer-draftable"), to = Symbol.for("immer-state"), MZ = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(e) {
    return `The plugin for '${e}' has not been loaded into Immer. To enable the plugin, import and call \`enable${e}()\` when initializing your application.`;
  },
  function(e) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${e}'`;
  },
  "This object has been frozen and should not be mutated",
  function(e) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + e;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(e) {
    return `'current' expects a draft, got: ${e}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(e) {
    return `'original' expects a draft, got: ${e}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function jr(e, ...t) {
  if (process.env.NODE_ENV !== "production") {
    const n = MZ[e], r = typeof n == "function" ? n.apply(null, t) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${e}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var Is = Object.getPrototypeOf;
function Ls(e) {
  return !!e && !!e[to];
}
function ks(e) {
  var t;
  return e ? fT(e) || Array.isArray(e) || !!e[wL] || !!((t = e.constructor) != null && t[wL]) || ud(e) || cd(e) : !1;
}
var PZ = Object.prototype.constructor.toString();
function fT(e) {
  if (!e || typeof e != "object")
    return !1;
  const t = Is(e);
  if (t === null)
    return !0;
  const n = Object.hasOwnProperty.call(t, "constructor") && t.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === PZ;
}
function Uc(e, t) {
  ld(e) === 0 ? Reflect.ownKeys(e).forEach((n) => {
    t(n, e[n], e);
  }) : e.forEach((n, r) => t(r, n, e));
}
function ld(e) {
  const t = e[to];
  return t ? t.type_ : Array.isArray(e) ? 1 : ud(e) ? 2 : cd(e) ? 3 : 0;
}
function Ag(e, t) {
  return ld(e) === 2 ? e.has(t) : Object.prototype.hasOwnProperty.call(e, t);
}
function hT(e, t, n) {
  const r = ld(e);
  r === 2 ? e.set(t, n) : r === 3 ? e.add(n) : e[t] = n;
}
function TZ(e, t) {
  return e === t ? e !== 0 || 1 / e === 1 / t : e !== e && t !== t;
}
function ud(e) {
  return e instanceof Map;
}
function cd(e) {
  return e instanceof Set;
}
function es(e) {
  return e.copy_ || e.base_;
}
function Bg(e, t) {
  if (ud(e))
    return new Map(e);
  if (cd(e))
    return new Set(e);
  if (Array.isArray(e))
    return Array.prototype.slice.call(e);
  const n = fT(e);
  if (t === !0 || t === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(e);
    delete r[to];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const s = o[i], a = r[s];
      a.writable === !1 && (a.writable = !0, a.configurable = !0), (a.get || a.set) && (r[s] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: a.enumerable,
        value: e[s]
      });
    }
    return Object.create(Is(e), r);
  } else {
    const r = Is(e);
    if (r !== null && n)
      return { ...e };
    const o = Object.create(r);
    return Object.assign(o, e);
  }
}
function Gv(e, t = !1) {
  return pd(e) || Ls(e) || !ks(e) || (ld(e) > 1 && (e.set = e.add = e.clear = e.delete = AZ), Object.freeze(e), t && Object.entries(e).forEach(([n, r]) => Gv(r, !0))), e;
}
function AZ() {
  jr(2);
}
function pd(e) {
  return Object.isFrozen(e);
}
var BZ = {};
function Ds(e) {
  const t = BZ[e];
  return t || jr(0, e), t;
}
var ol;
function gT() {
  return ol;
}
function _Z(e, t) {
  return {
    drafts_: [],
    parent_: e,
    immer_: t,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function CL(e, t) {
  t && (Ds("Patches"), e.patches_ = [], e.inversePatches_ = [], e.patchListener_ = t);
}
function _g(e) {
  Ig(e), e.drafts_.forEach(IZ), e.drafts_ = null;
}
function Ig(e) {
  e === ol && (ol = e.parent_);
}
function EL(e) {
  return ol = _Z(ol, e);
}
function IZ(e) {
  const t = e[to];
  t.type_ === 0 || t.type_ === 1 ? t.revoke_() : t.revoked_ = !0;
}
function xL(e, t) {
  t.unfinalizedDrafts_ = t.drafts_.length;
  const n = t.drafts_[0];
  return e !== void 0 && e !== n ? (n[to].modified_ && (_g(t), jr(4)), ks(e) && (e = $c(t, e), t.parent_ || Wc(t, e)), t.patches_ && Ds("Patches").generateReplacementPatches_(
    n[to].base_,
    e,
    t.patches_,
    t.inversePatches_
  )) : e = $c(t, n, []), _g(t), t.patches_ && t.patchListener_(t.patches_, t.inversePatches_), e !== dT ? e : void 0;
}
function $c(e, t, n) {
  if (pd(t))
    return t;
  const r = t[to];
  if (!r)
    return Uc(
      t,
      (o, i) => LL(e, r, t, o, i, n)
    ), t;
  if (r.scope_ !== e)
    return t;
  if (!r.modified_)
    return Wc(e, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, s = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), s = !0), Uc(
      i,
      (a, l) => LL(e, r, o, a, l, n, s)
    ), Wc(e, o, !1), n && e.patches_ && Ds("Patches").generatePatches_(
      r,
      n,
      e.patches_,
      e.inversePatches_
    );
  }
  return r.copy_;
}
function LL(e, t, n, r, o, i, s) {
  if (process.env.NODE_ENV !== "production" && o === n && jr(5), Ls(o)) {
    const a = i && t && t.type_ !== 3 && // Set objects are atomic since they have no keys.
    !Ag(t.assigned_, r) ? i.concat(r) : void 0, l = $c(e, o, a);
    if (hT(n, r, l), Ls(l))
      e.canAutoFreeze_ = !1;
    else
      return;
  } else s && n.add(o);
  if (ks(o) && !pd(o)) {
    if (!e.immer_.autoFreeze_ && e.unfinalizedDrafts_ < 1)
      return;
    $c(e, o), (!t || !t.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Wc(e, o);
  }
}
function Wc(e, t, n = !1) {
  !e.parent_ && e.immer_.autoFreeze_ && e.canAutoFreeze_ && Gv(t, n);
}
function jZ(e, t) {
  const n = Array.isArray(e), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: t ? t.scope_ : gT(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: t,
    // The base state.
    base_: e,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Kv;
  n && (o = [r], i = il);
  const { revoke: s, proxy: a } = Proxy.revocable(o, i);
  return r.draft_ = a, r.revoke_ = s, a;
}
var Kv = {
  get(e, t) {
    if (t === to)
      return e;
    const n = es(e);
    if (!Ag(n, t))
      return NZ(e, n, t);
    const r = n[t];
    return e.finalized_ || !ks(r) ? r : r === Jf(e.base_, t) ? (eh(e), e.copy_[t] = Ng(r, e)) : r;
  },
  has(e, t) {
    return t in es(e);
  },
  ownKeys(e) {
    return Reflect.ownKeys(es(e));
  },
  set(e, t, n) {
    const r = mT(es(e), t);
    if (r != null && r.set)
      return r.set.call(e.draft_, n), !0;
    if (!e.modified_) {
      const o = Jf(es(e), t), i = o == null ? void 0 : o[to];
      if (i && i.base_ === n)
        return e.copy_[t] = n, e.assigned_[t] = !1, !0;
      if (TZ(n, o) && (n !== void 0 || Ag(e.base_, t)))
        return !0;
      eh(e), jg(e);
    }
    return e.copy_[t] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || t in e.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(e.copy_[t]) || (e.copy_[t] = n, e.assigned_[t] = !0), !0;
  },
  deleteProperty(e, t) {
    return Jf(e.base_, t) !== void 0 || t in e.base_ ? (e.assigned_[t] = !1, eh(e), jg(e)) : delete e.assigned_[t], e.copy_ && delete e.copy_[t], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(e, t) {
    const n = es(e), r = Reflect.getOwnPropertyDescriptor(n, t);
    return r && {
      writable: !0,
      configurable: e.type_ !== 1 || t !== "length",
      enumerable: r.enumerable,
      value: n[t]
    };
  },
  defineProperty() {
    jr(11);
  },
  getPrototypeOf(e) {
    return Is(e.base_);
  },
  setPrototypeOf() {
    jr(12);
  }
}, il = {};
Uc(Kv, (e, t) => {
  il[e] = function() {
    return arguments[0] = arguments[0][0], t.apply(this, arguments);
  };
});
il.deleteProperty = function(e, t) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(t)) && jr(13), il.set.call(this, e, t, void 0);
};
il.set = function(e, t, n) {
  return process.env.NODE_ENV !== "production" && t !== "length" && isNaN(parseInt(t)) && jr(14), Kv.set.call(this, e[0], t, n, e[0]);
};
function Jf(e, t) {
  const n = e[to];
  return (n ? es(n) : e)[t];
}
function NZ(e, t, n) {
  var o;
  const r = mT(t, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(e.draft_)
  ) : void 0;
}
function mT(e, t) {
  if (!(t in e))
    return;
  let n = Is(e);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, t);
    if (r)
      return r;
    n = Is(n);
  }
}
function jg(e) {
  e.modified_ || (e.modified_ = !0, e.parent_ && jg(e.parent_));
}
function eh(e) {
  e.copy_ || (e.copy_ = Bg(
    e.base_,
    e.scope_.immer_.useStrictShallowCopy_
  ));
}
var FZ = class {
  constructor(e) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (t, n, r) => {
      if (typeof t == "function" && typeof n != "function") {
        const i = n;
        n = t;
        const s = this;
        return function(l = i, ...u) {
          return s.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && jr(6), r !== void 0 && typeof r != "function" && jr(7);
      let o;
      if (ks(t)) {
        const i = EL(this), s = Ng(t, void 0);
        let a = !0;
        try {
          o = n(s), a = !1;
        } finally {
          a ? _g(i) : Ig(i);
        }
        return CL(i, r), xL(o, i);
      } else if (!t || typeof t != "object") {
        if (o = n(t), o === void 0 && (o = t), o === dT && (o = void 0), this.autoFreeze_ && Gv(o, !0), r) {
          const i = [], s = [];
          Ds("Patches").generateReplacementPatches_(t, o, i, s), r(i, s);
        }
        return o;
      } else
        jr(1, t);
    }, this.produceWithPatches = (t, n) => {
      if (typeof t == "function")
        return (s, ...a) => this.produceWithPatches(s, (l) => t(l, ...a));
      let r, o;
      return [this.produce(t, n, (s, a) => {
        r = s, o = a;
      }), r, o];
    }, typeof (e == null ? void 0 : e.autoFreeze) == "boolean" && this.setAutoFreeze(e.autoFreeze), typeof (e == null ? void 0 : e.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(e.useStrictShallowCopy);
  }
  createDraft(e) {
    ks(e) || jr(8), Ls(e) && (e = RZ(e));
    const t = EL(this), n = Ng(e, void 0);
    return n[to].isManual_ = !0, Ig(t), n;
  }
  finishDraft(e, t) {
    const n = e && e[to];
    (!n || !n.isManual_) && jr(9);
    const { scope_: r } = n;
    return CL(r, t), xL(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(e) {
    this.autoFreeze_ = e;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(e) {
    this.useStrictShallowCopy_ = e;
  }
  applyPatches(e, t) {
    let n;
    for (n = t.length - 1; n >= 0; n--) {
      const o = t[n];
      if (o.path.length === 0 && o.op === "replace") {
        e = o.value;
        break;
      }
    }
    n > -1 && (t = t.slice(n + 1));
    const r = Ds("Patches").applyPatches_;
    return Ls(e) ? r(e, t) : this.produce(
      e,
      (o) => r(o, t)
    );
  }
};
function Ng(e, t) {
  const n = ud(e) ? Ds("MapSet").proxyMap_(e, t) : cd(e) ? Ds("MapSet").proxySet_(e, t) : jZ(e, t);
  return (t ? t.scope_ : gT()).drafts_.push(n), n;
}
function RZ(e) {
  return Ls(e) || jr(10, e), vT(e);
}
function vT(e) {
  if (!ks(e) || pd(e))
    return e;
  const t = e[to];
  let n;
  if (t) {
    if (!t.modified_)
      return t.base_;
    t.finalized_ = !0, n = Bg(e, t.scope_.immer_.useStrictShallowCopy_);
  } else
    n = Bg(e, !0);
  return Uc(n, (r, o) => {
    hT(n, r, vT(o));
  }), t && (t.finalized_ = !1), n;
}
var no = new FZ(), Yv = no.produce;
no.produceWithPatches.bind(
  no
);
no.setAutoFreeze.bind(no);
no.setUseStrictShallowCopy.bind(no);
no.applyPatches.bind(no);
var kL = no.createDraft.bind(no), DL = no.finishDraft.bind(no), zZ = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = oe.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, UZ = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = gt.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, $Z = {
  transform(e, t) {
    var {
      current: n,
      affinity: r
    } = e;
    if (n != null) {
      var o = ye.transform(n, t, {
        affinity: r
      });
      e.current = o, o == null && e.unref();
    }
  }
}, Hc = /* @__PURE__ */ new WeakMap(), Vc = /* @__PURE__ */ new WeakMap(), ja = /* @__PURE__ */ new WeakMap(), yT = /* @__PURE__ */ new WeakMap(), SL = /* @__PURE__ */ new WeakMap(), OL = /* @__PURE__ */ new WeakMap(), ML = /* @__PURE__ */ new WeakMap(), oe = {
  ancestors(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = oe.levels(e, t);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(e, t) {
    for (var n = [], r = 0; r < e.length && r < t.length; r++) {
      var o = e[r], i = t[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(e, t) {
    for (var n = Math.min(e.length, t.length), r = 0; r < n; r++) {
      if (e[r] < t[r]) return -1;
      if (e[r] > t[r]) return 1;
    }
    return 0;
  },
  endsAfter(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return oe.equals(r, o) && i > s;
  },
  endsAt(e, t) {
    var n = e.length, r = e.slice(0, n), o = t.slice(0, n);
    return oe.equals(r, o);
  },
  endsBefore(e, t) {
    var n = e.length - 1, r = e.slice(0, n), o = t.slice(0, n), i = e[n], s = t[n];
    return oe.equals(r, o) && i < s;
  },
  equals(e, t) {
    return e.length === t.length && e.every((n, r) => n === t[r]);
  },
  hasPrevious(e) {
    return e[e.length - 1] > 0;
  },
  isAfter(e, t) {
    return oe.compare(e, t) === 1;
  },
  isAncestor(e, t) {
    return e.length < t.length && oe.compare(e, t) === 0;
  },
  isBefore(e, t) {
    return oe.compare(e, t) === -1;
  },
  isChild(e, t) {
    return e.length === t.length + 1 && oe.compare(e, t) === 0;
  },
  isCommon(e, t) {
    return e.length <= t.length && oe.compare(e, t) === 0;
  },
  isDescendant(e, t) {
    return e.length > t.length && oe.compare(e, t) === 0;
  },
  isParent(e, t) {
    return e.length + 1 === t.length && oe.compare(e, t) === 0;
  },
  isPath(e) {
    return Array.isArray(e) && (e.length === 0 || typeof e[0] == "number");
  },
  isSibling(e, t) {
    if (e.length !== t.length)
      return !1;
    var n = e.slice(0, -1), r = t.slice(0, -1), o = e[e.length - 1], i = t[t.length - 1];
    return o !== i && oe.equals(n, r);
  },
  levels(e) {
    for (var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, r = [], o = 0; o <= e.length; o++)
      r.push(e.slice(0, o));
    return n && r.reverse(), r;
  },
  next(e) {
    if (e.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(e, "], because it has no next index."));
    var t = e[e.length - 1];
    return e.slice(0, -1).concat(t + 1);
  },
  operationCanTransformPath(e) {
    switch (e.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(e) {
    if (e.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(e, "]."));
    return e.slice(0, -1);
  },
  previous(e) {
    if (e.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(e, "], because it has no previous index."));
    var t = e[e.length - 1];
    if (t <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(e, "] because it would result in a negative index."));
    return e.slice(0, -1).concat(t - 1);
  },
  relative(e, t) {
    if (!oe.isAncestor(t, e) && !oe.equals(e, t))
      throw new Error("Cannot get the relative path of [".concat(e, "] inside ancestor [").concat(t, "], because it is not above or equal to the path."));
    return e.slice(t.length);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!e) return null;
    var r = [...e], {
      affinity: o = "forward"
    } = n;
    if (e.length === 0)
      return r;
    switch (t.type) {
      case "insert_node": {
        var {
          path: i
        } = t;
        (oe.equals(i, r) || oe.endsBefore(i, r) || oe.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: s
        } = t;
        if (oe.equals(s, r) || oe.isAncestor(s, r))
          return null;
        oe.endsBefore(s, r) && (r[s.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: a,
          position: l
        } = t;
        oe.equals(a, r) || oe.endsBefore(a, r) ? r[a.length - 1] -= 1 : oe.isAncestor(a, r) && (r[a.length - 1] -= 1, r[a.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = t;
        if (oe.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else oe.endsBefore(u, r) ? r[u.length - 1] += 1 : oe.isAncestor(u, r) && e[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: p,
          newPath: d
        } = t;
        if (oe.equals(p, d))
          return r;
        if (oe.isAncestor(p, r) || oe.equals(p, r)) {
          var g = d.slice();
          return oe.endsBefore(p, d) && p.length < d.length && (g[p.length - 1] -= 1), g.concat(r.slice(p.length));
        } else oe.isSibling(p, d) && (oe.isAncestor(d, r) || oe.equals(d, r)) ? oe.endsBefore(p, r) ? r[p.length - 1] -= 1 : r[p.length - 1] += 1 : oe.endsBefore(d, r) || oe.equals(d, r) || oe.isAncestor(d, r) ? (oe.endsBefore(p, r) && (r[p.length - 1] -= 1), r[d.length - 1] += 1) : oe.endsBefore(p, r) && (oe.equals(d, r) && (r[d.length - 1] += 1), r[p.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function sl(e) {
  "@babel/helpers - typeof";
  return sl = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, sl(e);
}
function WZ(e, t) {
  if (sl(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (sl(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function HZ(e) {
  var t = WZ(e, "string");
  return sl(t) === "symbol" ? t : String(t);
}
function Pr(e, t, n) {
  return t = HZ(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
function PL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fa(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? PL(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : PL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var VZ = (e, t, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Ae.parent(e, r), s = r[r.length - 1];
      if (s > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(s, 0, o), t)
        for (var [a, l] of ye.points(t))
          t[l] = gt.transform(a, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: p
      } = n;
      if (p.length === 0) break;
      var d = Ae.leaf(e, u), g = d.text.slice(0, c), m = d.text.slice(c);
      if (d.text = g + p + m, t)
        for (var [f, h] of ye.points(t))
          t[h] = gt.transform(f, n);
      break;
    }
    case "merge_node": {
      var {
        path: E
      } = n, L = Ae.get(e, E), x = oe.previous(E), T = Ae.get(e, x), w = Ae.parent(e, E), C = E[E.length - 1];
      if (We.isText(L) && We.isText(T))
        T.text += L.text;
      else if (!We.isText(L) && !We.isText(T))
        T.children.push(...L.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(E, "] to nodes of different interfaces: ").concat(dr.stringify(L), " ").concat(dr.stringify(T)));
      if (w.children.splice(C, 1), t)
        for (var [k, O] of ye.points(t))
          t[O] = gt.transform(k, n);
      break;
    }
    case "move_node": {
      var {
        path: U,
        newPath: M
      } = n;
      if (oe.isAncestor(U, M))
        throw new Error("Cannot move a path [".concat(U, "] to new path [").concat(M, "] because the destination is inside itself."));
      var V = Ae.get(e, U), $ = Ae.parent(e, U), W = U[U.length - 1];
      $.children.splice(W, 1);
      var R = oe.transform(U, n), H = Ae.get(e, oe.parent(R)), X = R[R.length - 1];
      if (H.children.splice(X, 0, V), t)
        for (var [I, J] of ye.points(t))
          t[J] = gt.transform(I, n);
      break;
    }
    case "remove_node": {
      var {
        path: te
      } = n, S = te[te.length - 1], P = Ae.parent(e, te);
      if (P.children.splice(S, 1), t)
        for (var [q, j] of ye.points(t)) {
          var Z = gt.transform(q, n);
          if (t != null && Z != null)
            t[j] = Z;
          else {
            var G = void 0, b = void 0;
            for (var [F, z] of Ae.texts(e))
              if (oe.compare(z, te) === -1)
                G = [F, z];
              else {
                b = [F, z];
                break;
              }
            var A = !1;
            G && b && (oe.equals(b[1], te) ? A = !oe.hasPrevious(b[1]) : A = oe.common(G[1], te).length < oe.common(b[1], te).length), G && !A ? (q.path = G[1], q.offset = G[0].text.length) : b ? (q.path = b[1], q.offset = 0) : t = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: Y,
        offset: ee,
        text: B
      } = n;
      if (B.length === 0) break;
      var se = Ae.leaf(e, Y), ue = se.text.slice(0, ee), ce = se.text.slice(ee + B.length);
      if (se.text = ue + ce, t)
        for (var [de, be] of ye.points(t))
          t[be] = gt.transform(de, n);
      break;
    }
    case "set_node": {
      var {
        path: ge,
        properties: me,
        newProperties: ae
      } = n;
      if (ge.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var xe = Ae.get(e, ge);
      for (var re in ae) {
        if (re === "children" || re === "text")
          throw new Error('Cannot set the "'.concat(re, '" property of nodes!'));
        var Te = ae[re];
        Te == null ? delete xe[re] : xe[re] = Te;
      }
      for (var ne in me)
        ae.hasOwnProperty(ne) || delete xe[ne];
      break;
    }
    case "set_selection": {
      var {
        newProperties: Ee
      } = n;
      if (Ee == null)
        t = Ee;
      else {
        if (t == null) {
          if (!ye.isRange(Ee))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(dr.stringify(Ee), " when there is no current selection."));
          t = fa({}, Ee);
        }
        for (var Ne in Ee) {
          var Fe = Ee[Ne];
          if (Fe == null) {
            if (Ne === "anchor" || Ne === "focus")
              throw new Error('Cannot remove the "'.concat(Ne, '" selection property'));
            delete t[Ne];
          } else
            t[Ne] = Fe;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Ue,
        position: he,
        properties: Xe
      } = n;
      if (Ue.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Ue, "] because the root node cannot be split."));
      var He = Ae.get(e, Ue), qt = Ae.parent(e, Ue), lt = Ue[Ue.length - 1], mt;
      if (We.isText(He)) {
        var on = He.text.slice(0, he), sn = He.text.slice(he);
        He.text = on, mt = fa(fa({}, Xe), {}, {
          text: sn
        });
      } else {
        var an = He.children.slice(0, he), ln = He.children.slice(he);
        He.children = an, mt = fa(fa({}, Xe), {}, {
          children: ln
        });
      }
      if (qt.children.splice(lt + 1, 0, mt), t)
        for (var [nt, Rt] of ye.points(t))
          t[Rt] = gt.transform(nt, n);
      break;
    }
  }
  return t;
}, ZZ = {
  transform(e, t) {
    e.children = kL(e.children);
    var n = e.selection && kL(e.selection);
    try {
      n = VZ(e, n, t);
    } finally {
      e.children = DL(e.children), n ? e.selection = Ls(n) ? DL(n) : n : e.selection = null;
    }
  }
}, qZ = {
  insertNodes(e, t, n) {
    e.insertNodes(t, n);
  },
  liftNodes(e, t) {
    e.liftNodes(t);
  },
  mergeNodes(e, t) {
    e.mergeNodes(t);
  },
  moveNodes(e, t) {
    e.moveNodes(t);
  },
  removeNodes(e, t) {
    e.removeNodes(t);
  },
  setNodes(e, t, n) {
    e.setNodes(t, n);
  },
  splitNodes(e, t) {
    e.splitNodes(t);
  },
  unsetNodes(e, t, n) {
    e.unsetNodes(t, n);
  },
  unwrapNodes(e, t) {
    e.unwrapNodes(t);
  },
  wrapNodes(e, t, n) {
    e.wrapNodes(t, n);
  }
}, GZ = {
  collapse(e, t) {
    e.collapse(t);
  },
  deselect(e) {
    e.deselect();
  },
  move(e, t) {
    e.move(t);
  },
  select(e, t) {
    e.select(t);
  },
  setPoint(e, t, n) {
    e.setPoint(t, n);
  },
  setSelection(e, t) {
    e.setSelection(t);
  }
}, bT = (e, t) => {
  for (var n in e) {
    var r = e[n], o = t[n];
    if (Er(r) && Er(o)) {
      if (!bT(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var s in t)
    if (e[s] === void 0 && t[s] !== void 0)
      return !1;
  return !0;
};
function KZ(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function Ho(e, t) {
  if (e == null) return {};
  var n = KZ(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
var YZ = ["anchor", "focus"];
function TL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function XZ(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? TL(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : TL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var ye = {
  edges(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = t, {
      anchor: r,
      focus: o
    } = e;
    return ye.isBackward(e) === n ? [r, o] : [o, r];
  },
  end(e) {
    var [, t] = ye.edges(e);
    return t;
  },
  equals(e, t) {
    return gt.equals(e.anchor, t.anchor) && gt.equals(e.focus, t.focus);
  },
  includes(e, t) {
    if (ye.isRange(t)) {
      if (ye.includes(e, t.anchor) || ye.includes(e, t.focus))
        return !0;
      var [n, r] = ye.edges(e), [o, i] = ye.edges(t);
      return gt.isBefore(n, o) && gt.isAfter(r, i);
    }
    var [s, a] = ye.edges(e), l = !1, u = !1;
    return gt.isPoint(t) ? (l = gt.compare(t, s) >= 0, u = gt.compare(t, a) <= 0) : (l = oe.compare(t, s.path) >= 0, u = oe.compare(t, a.path) <= 0), l && u;
  },
  intersection(e, t) {
    var n = Ho(e, YZ), [r, o] = ye.edges(e), [i, s] = ye.edges(t), a = gt.isBefore(r, i) ? i : r, l = gt.isBefore(o, s) ? o : s;
    return gt.isBefore(l, a) ? null : XZ({
      anchor: a,
      focus: l
    }, n);
  },
  isBackward(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return gt.isAfter(t, n);
  },
  isCollapsed(e) {
    var {
      anchor: t,
      focus: n
    } = e;
    return gt.equals(t, n);
  },
  isExpanded(e) {
    return !ye.isCollapsed(e);
  },
  isForward(e) {
    return !ye.isBackward(e);
  },
  isRange(e) {
    return Er(e) && gt.isPoint(e.anchor) && gt.isPoint(e.focus);
  },
  *points(e) {
    yield [e.anchor, "anchor"], yield [e.focus, "focus"];
  },
  start(e) {
    var [t] = ye.edges(e);
    return t;
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Yv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, s;
      if (o === "inward") {
        var a = ye.isCollapsed(r);
        ye.isForward(r) ? (i = "forward", s = a ? i : "backward") : (i = "backward", s = a ? i : "forward");
      } else o === "outward" ? ye.isForward(r) ? (i = "backward", s = "forward") : (i = "forward", s = "backward") : (i = o, s = o);
      var l = gt.transform(r.anchor, t, {
        affinity: i
      }), u = gt.transform(r.focus, t, {
        affinity: s
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, AL = (e) => Er(e) && Ae.isNodeList(e.children) && !N.isEditor(e), $e = {
  isAncestor(e) {
    return Er(e) && Ae.isNodeList(e.children);
  },
  isElement: AL,
  isElementList(e) {
    return Array.isArray(e) && e.every((t) => $e.isElement(t));
  },
  isElementProps(e) {
    return e.children !== void 0;
  },
  isElementType: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return AL(t) && t[r] === n;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "children" && e[n] !== t[n])
        return !1;
    return !0;
  }
}, QZ = ["children"], JZ = ["text"], BL = /* @__PURE__ */ new WeakMap(), Ae = {
  ancestor(e, t) {
    var n = Ae.get(e, t);
    if (We.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(t, "] because it refers to a text node instead: ").concat(dr.stringify(n)));
    return n;
  },
  ancestors(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of oe.ancestors(t, n)) {
        var o = Ae.ancestor(e, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(e, t) {
    if (We.isText(e))
      throw new Error("Cannot get the child of a text node: ".concat(dr.stringify(e)));
    var n = e.children[t];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(t, "` in node: ").concat(dr.stringify(e)));
    return n;
  },
  children(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Ae.ancestor(e, t), {
        children: i
      } = o, s = r ? i.length - 1 : 0; r ? s >= 0 : s < i.length; ) {
        var a = Ae.child(o, s), l = t.concat(s);
        yield [a, l], s = r ? s - 1 : s + 1;
      }
    }();
  },
  common(e, t, n) {
    var r = oe.common(t, n), o = Ae.get(e, r);
    return [o, r];
  },
  descendant(e, t) {
    var n = Ae.get(e, t);
    if (N.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(t, "] because it refers to the root editor node instead: ").concat(dr.stringify(n)));
    return n;
  },
  descendants(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ae.nodes(e, t))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ae.nodes(e, t))
        $e.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(e) {
    if ($e.isAncestor(e)) {
      var t = Ho(e, QZ);
      return t;
    } else {
      var t = Ho(e, JZ);
      return t;
    }
  },
  first(e, t) {
    for (var n = t.slice(), r = Ae.get(e, n); r && !(We.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(e, t) {
    if (We.isText(e))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(dr.stringify(e)));
    var n = Yv({
      children: e.children
    }, (r) => {
      var [o, i] = ye.edges(t), s = Ae.nodes(r, {
        reverse: !0,
        pass: (d) => {
          var [, g] = d;
          return !ye.includes(t, g);
        }
      });
      for (var [, a] of s) {
        if (!ye.includes(t, a)) {
          var l = Ae.parent(r, a), u = a[a.length - 1];
          l.children.splice(u, 1);
        }
        if (oe.equals(a, i.path)) {
          var c = Ae.leaf(r, a);
          c.text = c.text.slice(0, i.offset);
        }
        if (oe.equals(a, o.path)) {
          var p = Ae.leaf(r, a);
          p.text = p.text.slice(o.offset);
        }
      }
      N.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (We.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(t, "] in node: ").concat(dr.stringify(e)));
      n = n.children[o];
    }
    return n;
  },
  has(e, t) {
    for (var n = e, r = 0; r < t.length; r++) {
      var o = t[r];
      if (We.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(e) {
    return We.isText(e) || $e.isElement(e) || N.isEditor(e);
  },
  isNodeList(e) {
    if (!Array.isArray(e))
      return !1;
    var t = BL.get(e);
    if (t !== void 0)
      return t;
    var n = e.every((r) => Ae.isNode(r));
    return BL.set(e, n), n;
  },
  last(e, t) {
    for (var n = t.slice(), r = Ae.get(e, n); r && !(We.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(e, t) {
    var n = Ae.get(e, t);
    if (!We.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(t, "] because it refers to a non-leaf node: ").concat(dr.stringify(n)));
    return n;
  },
  levels(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of oe.levels(t, n)) {
        var o = Ae.get(e, r);
        yield [o, r];
      }
    }();
  },
  matches(e, t) {
    return $e.isElement(e) && $e.isElementProps(t) && $e.matches(e, t) || We.isText(e) && We.isTextProps(t) && We.matches(e, t);
  },
  nodes(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = t, {
        from: o = [],
        to: i
      } = t, s = /* @__PURE__ */ new Set(), a = [], l = e; !(i && (r ? oe.isBefore(a, i) : oe.isAfter(a, i))); ) {
        if (s.has(l) || (yield [l, a]), !s.has(l) && !We.isText(l) && l.children.length !== 0 && (n == null || n([l, a]) === !1)) {
          s.add(l);
          var u = r ? l.children.length - 1 : 0;
          oe.isAncestor(a, o) && (u = o[a.length]), a = a.concat(u), l = Ae.get(e, a);
          continue;
        }
        if (a.length === 0)
          break;
        if (!r) {
          var c = oe.next(a);
          if (Ae.has(e, c)) {
            a = c, l = Ae.get(e, a);
            continue;
          }
        }
        if (r && a[a.length - 1] !== 0) {
          var p = oe.previous(a);
          a = p, l = Ae.get(e, a);
          continue;
        }
        a = oe.parent(a), l = Ae.get(e, a), s.add(l);
      }
    }();
  },
  parent(e, t) {
    var n = oe.parent(t), r = Ae.get(e, n);
    if (We.isText(r))
      throw new Error("Cannot get the parent of path [".concat(t, "] because it does not exist in the root."));
    return r;
  },
  string(e) {
    return We.isText(e) ? e.text : e.children.map(Ae.string).join("");
  },
  texts(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Ae.nodes(e, t))
        We.isText(n) && (yield [n, r]);
    }();
  }
};
function _L(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Bn(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _L(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _L(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var wi = {
  isNodeOperation(e) {
    return wi.isOperation(e) && e.type.endsWith("_node");
  },
  isOperation(e) {
    if (!Er(e))
      return !1;
    switch (e.type) {
      case "insert_node":
        return oe.isPath(e.path) && Ae.isNode(e.node);
      case "insert_text":
        return typeof e.offset == "number" && typeof e.text == "string" && oe.isPath(e.path);
      case "merge_node":
        return typeof e.position == "number" && oe.isPath(e.path) && Er(e.properties);
      case "move_node":
        return oe.isPath(e.path) && oe.isPath(e.newPath);
      case "remove_node":
        return oe.isPath(e.path) && Ae.isNode(e.node);
      case "remove_text":
        return typeof e.offset == "number" && typeof e.text == "string" && oe.isPath(e.path);
      case "set_node":
        return oe.isPath(e.path) && Er(e.properties) && Er(e.newProperties);
      case "set_selection":
        return e.properties === null && ye.isRange(e.newProperties) || e.newProperties === null && ye.isRange(e.properties) || Er(e.properties) && Er(e.newProperties);
      case "split_node":
        return oe.isPath(e.path) && typeof e.position == "number" && Er(e.properties);
      default:
        return !1;
    }
  },
  isOperationList(e) {
    return Array.isArray(e) && e.every((t) => wi.isOperation(t));
  },
  isSelectionOperation(e) {
    return wi.isOperation(e) && e.type.endsWith("_selection");
  },
  isTextOperation(e) {
    return wi.isOperation(e) && e.type.endsWith("_text");
  },
  inverse(e) {
    switch (e.type) {
      case "insert_node":
        return Bn(Bn({}, e), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Bn(Bn({}, e), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Bn(Bn({}, e), {}, {
          type: "split_node",
          path: oe.previous(e.path)
        });
      case "move_node": {
        var {
          newPath: t,
          path: n
        } = e;
        if (oe.equals(t, n))
          return e;
        if (oe.isSibling(n, t))
          return Bn(Bn({}, e), {}, {
            path: t,
            newPath: n
          });
        var r = oe.transform(n, e), o = oe.transform(oe.next(n), e);
        return Bn(Bn({}, e), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Bn(Bn({}, e), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Bn(Bn({}, e), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: s
        } = e;
        return Bn(Bn({}, e), {}, {
          properties: s,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: a,
          newProperties: l
        } = e;
        return a == null ? Bn(Bn({}, e), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Bn(Bn({}, e), {}, {
          properties: null,
          newProperties: a
        }) : Bn(Bn({}, e), {}, {
          properties: l,
          newProperties: a
        });
      }
      case "split_node":
        return Bn(Bn({}, e), {}, {
          type: "merge_node",
          path: oe.next(e.path)
        });
    }
  }
}, IL = /* @__PURE__ */ new WeakMap(), eq = (e) => {
  var t = IL.get(e);
  if (t !== void 0)
    return t;
  if (!Er(e))
    return !1;
  var n = typeof e.addMark == "function" && typeof e.apply == "function" && typeof e.deleteFragment == "function" && typeof e.insertBreak == "function" && typeof e.insertSoftBreak == "function" && typeof e.insertFragment == "function" && typeof e.insertNode == "function" && typeof e.insertText == "function" && typeof e.isElementReadOnly == "function" && typeof e.isInline == "function" && typeof e.isSelectable == "function" && typeof e.isVoid == "function" && typeof e.normalizeNode == "function" && typeof e.onChange == "function" && typeof e.removeMark == "function" && typeof e.getDirtyPaths == "function" && (e.marks === null || Er(e.marks)) && (e.selection === null || ye.isRange(e.selection)) && Ae.isNodeList(e.children) && wi.isOperationList(e.operations);
  return IL.set(e, n), n;
}, N = {
  above(e, t) {
    return e.above(t);
  },
  addMark(e, t, n) {
    e.addMark(t, n);
  },
  after(e, t, n) {
    return e.after(t, n);
  },
  before(e, t, n) {
    return e.before(t, n);
  },
  deleteBackward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteBackward(n);
  },
  deleteForward(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = t;
    e.deleteForward(n);
  },
  deleteFragment(e, t) {
    e.deleteFragment(t);
  },
  edges(e, t) {
    return e.edges(t);
  },
  elementReadOnly(e) {
    var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return e.elementReadOnly(t);
  },
  end(e, t) {
    return e.end(t);
  },
  first(e, t) {
    return e.first(t);
  },
  fragment(e, t) {
    return e.fragment(t);
  },
  hasBlocks(e, t) {
    return e.hasBlocks(t);
  },
  hasInlines(e, t) {
    return e.hasInlines(t);
  },
  hasPath(e, t) {
    return e.hasPath(t);
  },
  hasTexts(e, t) {
    return e.hasTexts(t);
  },
  insertBreak(e) {
    e.insertBreak();
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertNode(e, t) {
    e.insertNode(t);
  },
  insertSoftBreak(e) {
    e.insertSoftBreak();
  },
  insertText(e, t) {
    e.insertText(t);
  },
  isBlock(e, t) {
    return e.isBlock(t);
  },
  isEdge(e, t, n) {
    return e.isEdge(t, n);
  },
  isEditor(e) {
    return eq(e);
  },
  isElementReadOnly(e, t) {
    return e.isElementReadOnly(t);
  },
  isEmpty(e, t) {
    return e.isEmpty(t);
  },
  isEnd(e, t, n) {
    return e.isEnd(t, n);
  },
  isInline(e, t) {
    return e.isInline(t);
  },
  isNormalizing(e) {
    return e.isNormalizing();
  },
  isSelectable(e, t) {
    return e.isSelectable(t);
  },
  isStart(e, t, n) {
    return e.isStart(t, n);
  },
  isVoid(e, t) {
    return e.isVoid(t);
  },
  last(e, t) {
    return e.last(t);
  },
  leaf(e, t, n) {
    return e.leaf(t, n);
  },
  levels(e, t) {
    return e.levels(t);
  },
  marks(e) {
    return e.getMarks();
  },
  next(e, t) {
    return e.next(t);
  },
  node(e, t, n) {
    return e.node(t, n);
  },
  nodes(e, t) {
    return e.nodes(t);
  },
  normalize(e, t) {
    e.normalize(t);
  },
  parent(e, t, n) {
    return e.parent(t, n);
  },
  path(e, t, n) {
    return e.path(t, n);
  },
  pathRef(e, t, n) {
    return e.pathRef(t, n);
  },
  pathRefs(e) {
    return e.pathRefs();
  },
  point(e, t, n) {
    return e.point(t, n);
  },
  pointRef(e, t, n) {
    return e.pointRef(t, n);
  },
  pointRefs(e) {
    return e.pointRefs();
  },
  positions(e, t) {
    return e.positions(t);
  },
  previous(e, t) {
    return e.previous(t);
  },
  range(e, t, n) {
    return e.range(t, n);
  },
  rangeRef(e, t, n) {
    return e.rangeRef(t, n);
  },
  rangeRefs(e) {
    return e.rangeRefs();
  },
  removeMark(e, t) {
    e.removeMark(t);
  },
  setNormalizing(e, t) {
    e.setNormalizing(t);
  },
  start(e, t) {
    return e.start(t);
  },
  string(e, t, n) {
    return e.string(t, n);
  },
  unhangRange(e, t, n) {
    return e.unhangRange(t, n);
  },
  void(e, t) {
    return e.void(t);
  },
  withoutNormalizing(e, t) {
    e.withoutNormalizing(t);
  },
  shouldMergeNodesRemovePrevNode: (e, t, n) => e.shouldMergeNodesRemovePrevNode(t, n)
}, tq = {
  isSpan(e) {
    return Array.isArray(e) && e.length === 2 && e.every(oe.isPath);
  }
};
function jL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function NL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? jL(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : jL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var gt = {
  compare(e, t) {
    var n = oe.compare(e.path, t.path);
    return n === 0 ? e.offset < t.offset ? -1 : e.offset > t.offset ? 1 : 0 : n;
  },
  isAfter(e, t) {
    return gt.compare(e, t) === 1;
  },
  isBefore(e, t) {
    return gt.compare(e, t) === -1;
  },
  equals(e, t) {
    return e.offset === t.offset && oe.equals(e.path, t.path);
  },
  isPoint(e) {
    return Er(e) && typeof e.offset == "number" && oe.isPath(e.path);
  },
  transform(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Yv(e, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: s
      } = r;
      switch (t.type) {
        case "insert_node":
        case "move_node": {
          r.path = oe.transform(i, t, n);
          break;
        }
        case "insert_text": {
          oe.equals(t.path, i) && (t.offset < s || t.offset === s && o === "forward") && (r.offset += t.text.length);
          break;
        }
        case "merge_node": {
          oe.equals(t.path, i) && (r.offset += t.position), r.path = oe.transform(i, t, n);
          break;
        }
        case "remove_text": {
          oe.equals(t.path, i) && t.offset <= s && (r.offset -= Math.min(s - t.offset, t.text.length));
          break;
        }
        case "remove_node": {
          if (oe.equals(t.path, i) || oe.isAncestor(t.path, i))
            return null;
          r.path = oe.transform(i, t, n);
          break;
        }
        case "split_node": {
          if (oe.equals(t.path, i)) {
            if (t.position === s && o == null)
              return null;
            (t.position < s || t.position === s && o === "forward") && (r.offset -= t.position, r.path = oe.transform(i, t, NL(NL({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = oe.transform(i, t, n);
          break;
        }
      }
    });
  }
}, FL = void 0, dr = {
  setScrubber(e) {
    FL = e;
  },
  stringify(e) {
    return JSON.stringify(e, FL);
  }
}, nq = ["text"], rq = ["anchor", "focus"];
function RL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Io(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? RL(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : RL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var We = {
  equals(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var s = Ho(i, nq);
      return s;
    }
    return bT(r ? o(e) : e, r ? o(t) : t);
  },
  isText(e) {
    return Er(e) && typeof e.text == "string";
  },
  isTextList(e) {
    return Array.isArray(e) && e.every((t) => We.isText(t));
  },
  isTextProps(e) {
    return e.text !== void 0;
  },
  matches(e, t) {
    for (var n in t)
      if (n !== "text" && (!e.hasOwnProperty(n) || e[n] !== t[n]))
        return !1;
    return !0;
  },
  decorations(e, t) {
    var n = [Io({}, e)];
    for (var r of t) {
      var o = Ho(r, rq), [i, s] = ye.edges(r), a = [], l = 0, u = i.offset, c = s.offset;
      for (var p of n) {
        var {
          length: d
        } = p.text, g = l;
        if (l += d, u <= g && l <= c) {
          Object.assign(p, o), a.push(p);
          continue;
        }
        if (u !== c && (u === l || c === g) || u > l || c < g || c === g && g !== 0) {
          a.push(p);
          continue;
        }
        var m = p, f = void 0, h = void 0;
        if (c < l) {
          var E = c - g;
          h = Io(Io({}, m), {}, {
            text: m.text.slice(E)
          }), m = Io(Io({}, m), {}, {
            text: m.text.slice(0, E)
          });
        }
        if (u > g) {
          var L = u - g;
          f = Io(Io({}, m), {}, {
            text: m.text.slice(0, L)
          }), m = Io(Io({}, m), {}, {
            text: m.text.slice(L)
          });
        }
        Object.assign(m, o), f && a.push(f), a.push(m), h && a.push(h);
      }
      n = a;
    }
    return n;
  }
}, Xv = (e) => e.selection ? e.selection : e.children.length > 0 ? N.end(e, []) : [0], Vs = (e, t) => {
  var [n] = N.node(e, t);
  return (r) => r === n;
}, Qv = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? uq(t) : t, i = Qe.None, s = Qe.None, a = 0, l = null, u = null;
  for (var c of o) {
    var p = c.codePointAt(0);
    if (!p) break;
    var d = Cq(c, p);
    if ([i, s] = r ? [s, d] : [d, i], Ms(i, Qe.ZWJ) && Ms(s, Qe.ExtPict) && (r ? l = zL(t.substring(0, a)) : l = zL(t.substring(0, t.length - a)), !l) || Ms(i, Qe.RI) && Ms(s, Qe.RI) && (u !== null ? u = !u : r ? u = !0 : u = Dq(t.substring(0, t.length - a)), !u) || i !== Qe.None && s !== Qe.None && xq(i, s))
      break;
    a += c.length;
  }
  return a || 1;
}, oq = /\s/, iq = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, sq = /['\u2018\u2019]/, aq = function(t) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; t.length > 0; ) {
    var i = Qv(t, n), [s, a] = Jv(t, i, n);
    if (lq(s, a, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    t = a;
  }
  return r;
}, Jv = (e, t, n) => {
  if (n) {
    var r = e.length - t;
    return [e.slice(r, e.length), e.slice(0, r)];
  }
  return [e.slice(0, t), e.slice(t)];
}, lq = function e(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (oq.test(t))
    return !1;
  if (sq.test(t)) {
    var o = Qv(n, r), [i, s] = Jv(n, o, r);
    if (e(i, s, r))
      return !0;
  }
  return !iq.test(t);
}, uq = function* (t) {
  for (var n = t.length - 1, r = 0; r < t.length; r++) {
    var o = t.charAt(n - r);
    if (pq(o.charCodeAt(0))) {
      var i = t.charAt(n - r - 1);
      if (cq(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, cq = (e) => e >= 55296 && e <= 56319, pq = (e) => e >= 56320 && e <= 57343, Qe;
(function(e) {
  e[e.None = 0] = "None", e[e.Extend = 1] = "Extend", e[e.ZWJ = 2] = "ZWJ", e[e.RI = 4] = "RI", e[e.Prepend = 8] = "Prepend", e[e.SpacingMark = 16] = "SpacingMark", e[e.L = 32] = "L", e[e.V = 64] = "V", e[e.T = 128] = "T", e[e.LV = 256] = "LV", e[e.LVT = 512] = "LVT", e[e.ExtPict = 1024] = "ExtPict", e[e.Any = 2048] = "Any";
})(Qe || (Qe = {}));
var dq = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, fq = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, hq = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, gq = /^[\u1100-\u115F\uA960-\uA97C]$/, mq = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, vq = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, yq = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, bq = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, wq = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, Cq = (e, t) => {
  var n = Qe.Any;
  return e.search(dq) !== -1 && (n |= Qe.Extend), t === 8205 && (n |= Qe.ZWJ), t >= 127462 && t <= 127487 && (n |= Qe.RI), e.search(fq) !== -1 && (n |= Qe.Prepend), e.search(hq) !== -1 && (n |= Qe.SpacingMark), e.search(gq) !== -1 && (n |= Qe.L), e.search(mq) !== -1 && (n |= Qe.V), e.search(vq) !== -1 && (n |= Qe.T), e.search(yq) !== -1 && (n |= Qe.LV), e.search(bq) !== -1 && (n |= Qe.LVT), e.search(wq) !== -1 && (n |= Qe.ExtPict), n;
};
function Ms(e, t) {
  return (e & t) !== 0;
}
var Eq = [
  // GB6
  [Qe.L, Qe.L | Qe.V | Qe.LV | Qe.LVT],
  // GB7
  [Qe.LV | Qe.V, Qe.V | Qe.T],
  // GB8
  [Qe.LVT | Qe.T, Qe.T],
  // GB9
  [Qe.Any, Qe.Extend | Qe.ZWJ],
  // GB9a
  [Qe.Any, Qe.SpacingMark],
  // GB9b
  [Qe.Prepend, Qe.Any],
  // GB11
  [Qe.ZWJ, Qe.ExtPict],
  // GB12 and GB13
  [Qe.RI, Qe.RI]
];
function xq(e, t) {
  return Eq.findIndex((n) => Ms(e, n[0]) && Ms(t, n[1])) === -1;
}
var Lq = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, zL = (e) => e.search(Lq) !== -1, kq = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, Dq = (e) => {
  var t = e.match(kq);
  if (t === null)
    return !1;
  var n = t[0].length / 2;
  return n % 2 === 1;
}, Sq = {
  delete(e, t) {
    e.delete(t);
  },
  insertFragment(e, t, n) {
    e.insertFragment(t, n);
  },
  insertText(e, t) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    N.withoutNormalizing(e, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = Xv(e)
      } = n;
      if (oe.isPath(o) && (o = N.range(e, o)), ye.isRange(o))
        if (ye.isCollapsed(o))
          o = o.anchor;
        else {
          var i = ye.end(o);
          if (!r && N.void(e, {
            at: i
          }))
            return;
          var s = ye.start(o), a = N.pointRef(e, s), l = N.pointRef(e, i);
          Le.delete(e, {
            at: o,
            voids: r
          });
          var u = a.unref(), c = l.unref();
          o = u || c, Le.setSelection(e, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && N.void(e, {
        at: o
      }) || N.elementReadOnly(e, {
        at: o
      }))) {
        var {
          path: p,
          offset: d
        } = o;
        t.length > 0 && e.apply({
          type: "insert_text",
          path: p,
          offset: d,
          text: t
        });
      }
    });
  }
};
function UL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ru(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? UL(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : UL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Le = Ru(Ru(Ru(Ru({}, ZZ), qZ), GZ), Sq), sc = /* @__PURE__ */ new WeakMap(), Oq = (e) => sc.get(e) || !1, Mq = (e, t, n) => {
  var r = sc.get(e) || !1;
  sc.set(e, !0);
  try {
    t(), n();
  } finally {
    sc.set(e, r);
  }
};
function wT(e, t, n) {
  var r = Hc.get(e) || [], o = Vc.get(e) || /* @__PURE__ */ new Set(), i, s, a = (p) => {
    if (p) {
      var d = p.join(",");
      s.has(d) || (s.add(d), i.push(p));
    }
  };
  if (n) {
    i = [], s = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      a(u);
    }
  } else
    i = r, s = o;
  for (var c of t)
    a(c);
  Hc.set(e, i), Vc.set(e, s);
}
var Pq = (e, t) => {
  for (var n of N.pathRefs(e))
    zZ.transform(n, t);
  for (var r of N.pointRefs(e))
    UZ.transform(r, t);
  for (var o of N.rangeRefs(e))
    $Z.transform(o, t);
  if (!Oq(e)) {
    var i = oe.operationCanTransformPath(t) ? (s) => oe.transform(s, t) : void 0;
    wT(e, e.getDirtyPaths(t), i);
  }
  Le.transform(e, t), e.operations.push(t), N.normalize(e, {
    operation: t
  }), t.type === "set_selection" && (e.marks = null), ja.get(e) || (ja.set(e, !0), Promise.resolve().then(() => {
    ja.set(e, !1), e.onChange({
      operation: t
    }), e.operations = [];
  }));
}, Tq = (e, t) => {
  switch (t.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = t;
      return oe.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = t, i = oe.levels(o), s = We.isText(r) ? [] : Array.from(Ae.nodes(r), (M) => {
        var [, V] = M;
        return o.concat(V);
      });
      return [...i, ...s];
    }
    case "merge_node": {
      var {
        path: a
      } = t, l = oe.ancestors(a), u = oe.previous(a);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: p
      } = t;
      if (oe.equals(c, p))
        return [];
      var d = [], g = [];
      for (var m of oe.ancestors(c)) {
        var f = oe.transform(m, t);
        d.push(f);
      }
      for (var h of oe.ancestors(p)) {
        var E = oe.transform(h, t);
        g.push(E);
      }
      var L = g[g.length - 1], x = p[p.length - 1], T = L.concat(x);
      return [...d, ...g, T];
    }
    case "remove_node": {
      var {
        path: w
      } = t, C = oe.ancestors(w);
      return [...C];
    }
    case "split_node": {
      var {
        path: k
      } = t, O = oe.levels(k), U = oe.next(k);
      return [...O, U];
    }
    default:
      return [];
  }
}, Aq = (e) => {
  var {
    selection: t
  } = e;
  return t ? Ae.fragment(e, t) : [];
}, Bq = (e, t) => {
  var [n, r] = t;
  if (!We.isText(n)) {
    if ($e.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      Le.insertNodes(e, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = N.isEditor(n) ? !1 : $e.isElement(n) && (e.isInline(n) || n.children.length === 0 || We.isText(n.children[0]) || e.isInline(n.children[0])), s = 0, a = 0; a < n.children.length; a++, s++) {
      var l = Ae.get(e, r);
      if (!We.isText(l)) {
        var u = l.children[s], c = l.children[s - 1], p = a === n.children.length - 1, d = We.isText(u) || $e.isElement(u) && e.isInline(u);
        if (d !== i)
          Le.removeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--;
        else if ($e.isElement(u)) {
          if (e.isInline(u)) {
            if (c == null || !We.isText(c)) {
              var g = {
                text: ""
              };
              Le.insertNodes(e, g, {
                at: r.concat(s),
                voids: !0
              }), s++;
            } else if (p) {
              var m = {
                text: ""
              };
              Le.insertNodes(e, m, {
                at: r.concat(s + 1),
                voids: !0
              }), s++;
            }
          }
        } else {
          if (!We.isText(u) && !("children" in u)) {
            var f = u;
            f.children = [];
          }
          c != null && We.isText(c) && (We.equals(u, c, {
            loose: !0
          }) ? (Le.mergeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--) : c.text === "" ? (Le.removeNodes(e, {
            at: r.concat(s - 1),
            voids: !0
          }), s--) : u.text === "" && (Le.removeNodes(e, {
            at: r.concat(s),
            voids: !0
          }), s--));
        }
      }
    }
  }
}, _q = (e, t) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = t, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, Iq = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = t.selection,
    match: s
  } = n;
  if (i) {
    var a = N.path(t, i), l = o === "lowest";
    for (var [u, c] of N.levels(t, {
      at: a,
      voids: r,
      match: s,
      reverse: l
    }))
      if (!We.isText(u)) {
        if (ye.isRange(i)) {
          if (oe.isAncestor(c, i.anchor.path) && oe.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!oe.equals(a, c))
          return [u, c];
      }
  }
};
function $L(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function WL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? $L(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : $L(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var jq = (e, t, n) => {
  var {
    selection: r
  } = e;
  if (r) {
    var o = (p, d) => {
      if (!We.isText(p))
        return !1;
      var [g, m] = N.parent(e, d);
      return !e.isVoid(g) || e.markableVoid(g);
    }, i = ye.isExpanded(r), s = !1;
    if (!i) {
      var [a, l] = N.node(e, r);
      if (a && o(a, l)) {
        var [u] = N.parent(e, l);
        s = u && e.markableVoid(u);
      }
    }
    if (i || s)
      Le.setNodes(e, {
        [t]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = WL(WL({}, N.marks(e) || {}), {}, {
        [t]: n
      });
      e.marks = c, ja.get(e) || e.onChange();
    }
  }
};
function HL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function VL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? HL(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : HL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Nq = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = N.point(t, n, {
    edge: "end"
  }), i = N.end(t, []), s = {
    anchor: o,
    focus: i
  }, {
    distance: a = 1
  } = r, l = 0, u;
  for (var c of N.positions(t, VL(VL({}, r), {}, {
    at: s
  }))) {
    if (l > a)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function ZL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ZL(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ZL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Fq = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = N.start(t, []), i = N.point(t, n, {
    edge: "start"
  }), s = {
    anchor: o,
    focus: i
  }, {
    distance: a = 1
  } = r, l = 0, u;
  for (var c of N.positions(t, qL(qL({}, r), {}, {
    at: s,
    reverse: !0
  }))) {
    if (l > a)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, Rq = (e, t) => {
  var {
    selection: n
  } = e;
  n && ye.isCollapsed(n) && Le.delete(e, {
    unit: t,
    reverse: !0
  });
}, zq = (e, t) => {
  var {
    selection: n
  } = e;
  n && ye.isCollapsed(n) && Le.delete(e, {
    unit: t
  });
}, Uq = function(t) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t;
  r && ye.isExpanded(r) && Le.delete(t, {
    reverse: n === "backward"
  });
}, $q = (e, t) => [N.start(e, t), N.end(e, t)];
function GL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? GL(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : GL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var Wq = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return N.above(t, KL(KL({}, n), {}, {
    match: (r) => $e.isElement(r) && N.isElementReadOnly(t, r)
  }));
}, Hq = (e, t) => N.point(e, t, {
  edge: "end"
}), Vq = (e, t) => {
  var n = N.path(e, t, {
    edge: "start"
  });
  return N.node(e, n);
}, Zq = (e, t) => {
  var n = N.range(e, t);
  return Ae.fragment(e, n);
};
function YL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function XL(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? YL(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : YL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var qq = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return N.above(t, XL(XL({}, n), {}, {
    match: (r) => $e.isElement(r) && N.isVoid(t, r)
  }));
}, Gq = (e, t) => t.children.some((n) => $e.isElement(n) && N.isBlock(e, n)), Kq = (e, t) => t.children.some((n) => We.isText(n) || N.isInline(e, n)), Yq = (e, t) => Ae.has(e, t), Xq = (e, t) => t.children.every((n) => We.isText(n)), Qq = (e) => {
  Le.splitNodes(e, {
    always: !0
  });
}, Jq = (e, t, n) => {
  Le.insertNodes(e, t, n);
}, eG = (e) => {
  Le.splitNodes(e, {
    always: !0
  });
};
function QL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tG(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? QL(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : QL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var nG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = t;
  if (o) {
    if (i) {
      var s = tG({
        text: n
      }, i);
      Le.insertNodes(t, s, {
        at: r.at,
        voids: r.voids
      });
    } else
      Le.insertText(t, n, r);
    t.marks = null;
  }
}, rG = (e, t) => !e.isInline(t), oG = (e, t, n) => N.isStart(e, t, n) || N.isEnd(e, t, n), iG = (e, t) => {
  var {
    children: n
  } = t, [r] = n;
  return n.length === 0 || n.length === 1 && We.isText(r) && r.text === "" && !e.isVoid(t);
}, sG = (e, t, n) => {
  var r = N.end(e, n);
  return gt.equals(t, r);
}, aG = (e) => {
  var t = yT.get(e);
  return t === void 0 ? !0 : t;
}, lG = (e, t, n) => {
  if (t.offset !== 0)
    return !1;
  var r = N.start(e, n);
  return gt.equals(t, r);
}, uG = (e, t) => {
  var n = N.path(e, t, {
    edge: "end"
  });
  return N.node(e, n);
}, cG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = N.path(t, n, r), i = Ae.leaf(t, o);
  return [i, o];
};
function pG(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      reverse: r = !1,
      voids: o = !1
    } = t, {
      match: i
    } = t;
    if (i == null && (i = () => !0), !!n) {
      var s = [], a = N.path(e, n);
      for (var [l, u] of Ae.levels(e, a))
        if (i(l, u) && (s.push([l, u]), !o && $e.isElement(l) && N.isVoid(e, l)))
          break;
      r && s.reverse(), yield* s;
    }
  }();
}
var dG = ["text"], fG = ["text"], hG = function(t) {
  var {
    marks: n,
    selection: r
  } = t;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (ye.isExpanded(r)) {
    var s = N.isEnd(t, o, o.path);
    if (s) {
      var a = N.after(t, o);
      a && (o = a);
    }
    var [l] = N.nodes(t, {
      match: We.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = Ho(u, dG);
      return c;
    } else
      return {};
  }
  var {
    path: p
  } = o, [d] = N.leaf(t, p);
  if (o.offset === 0) {
    var g = N.previous(t, {
      at: p,
      match: We.isText
    }), m = N.above(t, {
      match: (T) => $e.isElement(T) && N.isVoid(t, T) && t.markableVoid(T)
    });
    if (!m) {
      var f = N.above(t, {
        match: (T) => $e.isElement(T) && N.isBlock(t, T)
      });
      if (g && f) {
        var [h, E] = g, [, L] = f;
        oe.isAncestor(L, E) && (d = h);
      }
    }
  }
  var x = Ho(d, fG);
  return x;
}, gG = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: s = t.selection
  } = n;
  if (s) {
    var a = N.after(t, s, {
      voids: o
    });
    if (a) {
      var [, l] = N.last(t, []), u = [a.path, l];
      if (oe.isPath(s) && s.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (oe.isPath(s)) {
          var [c] = N.parent(t, s);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = N.nodes(t, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, mG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = N.path(t, n, r), i = Ae.get(t, o);
  return [i, o];
};
function vG(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: s = !1,
      ignoreNonSelectable: a = !1
    } = t, {
      match: l
    } = t;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (tq.isSpan(n))
        u = n[0], c = n[1];
      else {
        var p = N.path(e, n, {
          edge: "start"
        }), d = N.path(e, n, {
          edge: "end"
        });
        u = i ? d : p, c = i ? p : d;
      }
      var g = Ae.nodes(e, {
        reverse: i,
        from: u,
        to: c,
        pass: (T) => {
          var [w] = T;
          return $e.isElement(w) ? !!(!s && (N.isVoid(e, w) || N.isElementReadOnly(e, w)) || a && !N.isSelectable(e, w)) : !1;
        }
      }), m = [], f;
      for (var [h, E] of g)
        if (!(a && $e.isElement(h) && !N.isSelectable(e, h))) {
          var L = f && oe.compare(E, f[1]) === 0;
          if (!(r === "highest" && L)) {
            if (!l(h, E)) {
              if (o && !L && We.isText(h))
                return;
              continue;
            }
            if (r === "lowest" && L) {
              f = [h, E];
              continue;
            }
            var x = r === "lowest" ? f : [h, E];
            x && (o ? m.push(x) : yield x), f = [h, E];
          }
        }
      r === "lowest" && f && (o ? m.push(f) : yield f), o && (yield* m);
    }
  }();
}
var yG = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => Hc.get(c) || [], s = (c) => Vc.get(c) || /* @__PURE__ */ new Set(), a = (c) => {
    var p = i(c).pop(), d = p.join(",");
    return s(c).delete(d), p;
  };
  if (N.isNormalizing(t)) {
    if (r) {
      var l = Array.from(Ae.nodes(t), (c) => {
        var [, p] = c;
        return p;
      }), u = new Set(l.map((c) => c.join(",")));
      Hc.set(t, l), Vc.set(t, u);
    }
    i(t).length !== 0 && N.withoutNormalizing(t, () => {
      for (var c of i(t))
        if (Ae.has(t, c)) {
          var p = N.node(t, c), [d, g] = p;
          $e.isElement(d) && d.children.length === 0 && t.normalizeNode(p, {
            operation: o
          });
        }
      for (var m = i(t), f = m.length, h = 0; m.length !== 0; ) {
        if (!t.shouldNormalize({
          dirtyPaths: m,
          iteration: h,
          initialDirtyPathsLength: f,
          operation: o
        }))
          return;
        var E = a(t);
        if (Ae.has(t, E)) {
          var L = N.node(t, E);
          t.normalizeNode(L, {
            operation: o
          });
        }
        h++, m = i(t);
      }
    });
  }
}, bG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = N.path(t, n, r), i = oe.parent(o), s = N.node(t, i);
  return s;
}, wG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = N.pathRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = N.pathRefs(t);
  return s.add(i), i;
}, CG = (e) => {
  var t = SL.get(e);
  return t || (t = /* @__PURE__ */ new Set(), SL.set(e, t)), t;
}, EG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (oe.isPath(n)) {
    if (i === "start") {
      var [, s] = Ae.first(t, n);
      n = s;
    } else if (i === "end") {
      var [, a] = Ae.last(t, n);
      n = a;
    }
  }
  return ye.isRange(n) && (i === "start" ? n = ye.start(n) : i === "end" ? n = ye.end(n) : n = oe.common(n.anchor.path, n.focus.path)), gt.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, xG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = N.pointRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = N.pointRefs(t);
  return s.add(i), i;
}, LG = (e) => {
  var t = OL.get(e);
  return t || (t = /* @__PURE__ */ new Set(), OL.set(e, t)), t;
}, kG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (oe.isPath(n)) {
    var i;
    if (o === "end") {
      var [, s] = Ae.last(t, n);
      i = s;
    } else {
      var [, a] = Ae.first(t, n);
      i = a;
    }
    var l = Ae.get(t, i);
    if (!We.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (ye.isRange(n)) {
    var [u, c] = ye.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function DG(e) {
  var t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = e.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: s = !1
    } = t;
    if (!n)
      return;
    var a = N.range(e, n), [l, u] = ye.edges(a), c = o ? u : l, p = !1, d = "", g = 0, m = 0, f = 0;
    for (var [h, E] of N.nodes(e, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: s
    })) {
      if ($e.isElement(h)) {
        if (!i && (e.isVoid(h) || e.isElementReadOnly(h))) {
          yield N.start(e, E);
          continue;
        }
        if (e.isInline(h)) continue;
        if (N.hasInlines(e, h)) {
          var L = oe.isAncestor(E, u.path) ? u : N.end(e, E), x = oe.isAncestor(E, l.path) ? l : N.start(e, E);
          d = N.string(e, {
            anchor: x,
            focus: L
          }, {
            voids: i
          }), p = !0;
        }
      }
      if (We.isText(h)) {
        var T = oe.equals(E, c.path);
        for (T ? (m = o ? c.offset : h.text.length - c.offset, f = c.offset) : (m = h.text.length, f = o ? m : 0), (T || p || r === "offset") && (yield {
          path: E,
          offset: f
        }, p = !1); ; ) {
          if (g === 0) {
            if (d === "") break;
            g = w(d, r, o), d = Jv(d, g, o)[1];
          }
          if (f = o ? f - g : f + g, m = m - g, m < 0) {
            g = -m;
            break;
          }
          g = 0, yield {
            path: E,
            offset: f
          };
        }
      }
    }
    function w(C, k, O) {
      return k === "character" ? Qv(C, O) : k === "word" ? aq(C, O) : k === "line" || k === "block" ? C.length : 1;
    }
  }();
}
var SG = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: s = t.selection
  } = n;
  if (s) {
    var a = N.before(t, s, {
      voids: o
    });
    if (a) {
      var [, l] = N.first(t, []), u = [a.path, l];
      if (oe.isPath(s) && s.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (oe.isPath(s)) {
          var [c] = N.parent(t, s);
          i = (d) => c.children.includes(d);
        } else
          i = () => !0;
      var [p] = N.nodes(t, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return p;
    }
  }
}, OG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: a
      } = i, l = N.rangeRefs(t);
      return l.delete(i), i.current = null, a;
    }
  }, s = N.rangeRefs(t);
  return s.add(i), i;
}, MG = (e) => {
  var t = ML.get(e);
  return t || (t = /* @__PURE__ */ new Set(), ML.set(e, t)), t;
}, PG = (e, t, n) => {
  if (ye.isRange(t) && !n)
    return t;
  var r = N.start(e, t), o = N.end(e, n || t);
  return {
    anchor: r,
    focus: o
  };
};
function JL(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function TG(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? JL(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : JL(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var AG = (e, t) => {
  var {
    selection: n
  } = e;
  if (n) {
    var r = (c, p) => {
      if (!We.isText(c))
        return !1;
      var [d, g] = N.parent(e, p);
      return !e.isVoid(d) || e.markableVoid(d);
    }, o = ye.isExpanded(n), i = !1;
    if (!o) {
      var [s, a] = N.node(e, n);
      if (s && r(s, a)) {
        var [l] = N.parent(e, a);
        i = l && e.markableVoid(l);
      }
    }
    if (o || i)
      Le.unsetNodes(e, t, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = TG({}, N.marks(e) || {});
      delete u[t], e.marks = u, ja.get(e) || e.onChange();
    }
  }
}, BG = (e, t) => {
  yT.set(e, t);
}, _G = (e, t) => N.point(e, t, {
  edge: "start"
}), IG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = N.range(t, n), [s, a] = ye.edges(i), l = "";
  for (var [u, c] of N.nodes(t, {
    at: i,
    match: We.isText,
    voids: o
  })) {
    var p = u.text;
    oe.equals(c, a.path) && (p = p.slice(0, a.offset)), oe.equals(c, s.path) && (p = p.slice(s.offset)), l += p;
  }
  return l;
}, jG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, s] = ye.edges(n);
  if (i.offset !== 0 || s.offset !== 0 || ye.isCollapsed(n) || oe.hasPrevious(s.path))
    return n;
  var a = N.above(t, {
    at: s,
    match: (m) => $e.isElement(m) && N.isBlock(t, m),
    voids: o
  }), l = a ? a[1] : [], u = N.start(t, i), c = {
    anchor: u,
    focus: s
  }, p = !0;
  for (var [d, g] of N.nodes(t, {
    at: c,
    match: We.isText,
    reverse: !0,
    voids: o
  })) {
    if (p) {
      p = !1;
      continue;
    }
    if (d.text !== "" || oe.isBefore(g, l)) {
      s = {
        path: g,
        offset: d.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: s
  };
}, NG = (e, t) => {
  var n = N.isNormalizing(e);
  N.setNormalizing(e, !1);
  try {
    t();
  } finally {
    N.setNormalizing(e, n);
  }
  N.normalize(e);
}, FG = (e, t, n) => {
  var [r, o] = t;
  return $e.isElement(r) && N.isEmpty(e, r) || We.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, RG = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  N.withoutNormalizing(t, () => {
    var r, o, {
      reverse: i = !1,
      unit: s = "character",
      distance: a = 1,
      voids: l = !1
    } = n, {
      at: u = t.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var p = !1;
      if (ye.isRange(u) && ye.isCollapsed(u) && (p = !0, u = u.anchor), gt.isPoint(u)) {
        var d = N.void(t, {
          at: u,
          mode: "highest"
        });
        if (!l && d) {
          var [, g] = d;
          u = g;
        } else {
          var m = {
            unit: s,
            distance: a
          }, f = i ? N.before(t, u, m) || N.start(t, []) : N.after(t, u, m) || N.end(t, []);
          u = {
            anchor: u,
            focus: f
          }, c = !0;
        }
      }
      if (oe.isPath(u)) {
        Le.removeNodes(t, {
          at: u,
          voids: l
        });
        return;
      }
      if (!ye.isCollapsed(u)) {
        if (!c) {
          var [, h] = ye.edges(u), E = N.end(t, []);
          gt.equals(h, E) || (u = N.unhangRange(t, u, {
            voids: l
          }));
        }
        var [L, x] = ye.edges(u), T = N.above(t, {
          match: (ue) => $e.isElement(ue) && N.isBlock(t, ue),
          at: L,
          voids: l
        }), w = N.above(t, {
          match: (ue) => $e.isElement(ue) && N.isBlock(t, ue),
          at: x,
          voids: l
        }), C = T && w && !oe.equals(T[1], w[1]), k = oe.equals(L.path, x.path), O = l ? null : (r = N.void(t, {
          at: L,
          mode: "highest"
        })) !== null && r !== void 0 ? r : N.elementReadOnly(t, {
          at: L,
          mode: "highest"
        }), U = l ? null : (o = N.void(t, {
          at: x,
          mode: "highest"
        })) !== null && o !== void 0 ? o : N.elementReadOnly(t, {
          at: x,
          mode: "highest"
        });
        if (O) {
          var M = N.before(t, L);
          M && T && oe.isAncestor(T[1], M.path) && (L = M);
        }
        if (U) {
          var V = N.after(t, x);
          V && w && oe.isAncestor(w[1], V.path) && (x = V);
        }
        var $ = [], W;
        for (var R of N.nodes(t, {
          at: u,
          voids: l
        })) {
          var [H, X] = R;
          W && oe.compare(X, W) === 0 || (!l && $e.isElement(H) && (N.isVoid(t, H) || N.isElementReadOnly(t, H)) || !oe.isCommon(X, L.path) && !oe.isCommon(X, x.path)) && ($.push(R), W = X);
        }
        var I = Array.from($, (ue) => {
          var [, ce] = ue;
          return N.pathRef(t, ce);
        }), J = N.pointRef(t, L), te = N.pointRef(t, x), S = "";
        if (!k && !O) {
          var P = J.current, [q] = N.leaf(t, P), {
            path: j
          } = P, {
            offset: Z
          } = L, G = q.text.slice(Z);
          G.length > 0 && (t.apply({
            type: "remove_text",
            path: j,
            offset: Z,
            text: G
          }), S = G);
        }
        if (I.reverse().map((ue) => ue.unref()).filter((ue) => ue !== null).forEach((ue) => Le.removeNodes(t, {
          at: ue,
          voids: l
        })), !U) {
          var b = te.current, [F] = N.leaf(t, b), {
            path: z
          } = b, A = k ? L.offset : 0, Y = F.text.slice(A, x.offset);
          Y.length > 0 && (t.apply({
            type: "remove_text",
            path: z,
            offset: A,
            text: Y
          }), S = Y);
        }
        !k && C && te.current && J.current && Le.mergeNodes(t, {
          at: te.current,
          hanging: !0,
          voids: l
        }), p && i && s === "character" && S.length > 1 && S.match(/[\u0E00-\u0E7F]+/) && Le.insertText(t, S.slice(0, S.length - a));
        var ee = J.unref(), B = te.unref(), se = i ? ee || B : B || ee;
        n.at == null && se && Le.select(t, se);
      }
    }
  });
}, zG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  N.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: s = Xv(t),
      batchDirty: a = !0
    } = r;
    if (n.length) {
      if (ye.isRange(s))
        if (o || (s = N.unhangRange(t, s, {
          voids: i
        })), ye.isCollapsed(s))
          s = s.anchor;
        else {
          var [, l] = ye.edges(s);
          if (!i && N.void(t, {
            at: l
          }))
            return;
          var u = N.pointRef(t, l);
          Le.delete(t, {
            at: s
          }), s = u.unref();
        }
      else oe.isPath(s) && (s = N.start(t, s));
      if (!(!i && N.void(t, {
        at: s
      }))) {
        var c = N.above(t, {
          at: s,
          match: (G) => $e.isElement(G) && N.isInline(t, G),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, p] = c;
          if (N.isEnd(t, s, p)) {
            var d = N.after(t, p);
            s = d;
          } else if (N.isStart(t, s, p)) {
            var g = N.before(t, p);
            s = g;
          }
        }
        var m = N.above(t, {
          match: (G) => $e.isElement(G) && N.isBlock(t, G),
          at: s,
          voids: i
        }), [, f] = m, h = N.isStart(t, s, f), E = N.isEnd(t, s, f), L = h && E, x = !h || h && E, T = !E, [, w] = Ae.first({
          children: n
        }, []), [, C] = Ae.last({
          children: n
        }, []), k = [], O = (G) => {
          var [b, F] = G, z = F.length === 0;
          return z ? !1 : L ? !0 : !(x && oe.isAncestor(F, w) && $e.isElement(b) && !t.isVoid(b) && !t.isInline(b) || T && oe.isAncestor(F, C) && $e.isElement(b) && !t.isVoid(b) && !t.isInline(b));
        };
        for (var U of Ae.nodes({
          children: n
        }, {
          pass: O
        }))
          O(U) && k.push(U);
        var M = [], V = [], $ = [], W = !0, R = !1;
        for (var [H] of k)
          $e.isElement(H) && !t.isInline(H) ? (W = !1, R = !0, V.push(H)) : W ? M.push(H) : $.push(H);
        var [X] = N.nodes(t, {
          at: s,
          match: (G) => We.isText(G) || N.isInline(t, G),
          mode: "highest",
          voids: i
        }), [, I] = X, J = N.isStart(t, s, I), te = N.isEnd(t, s, I), S = N.pathRef(t, E && !$.length ? oe.next(f) : f), P = N.pathRef(t, te ? oe.next(I) : I);
        Le.splitNodes(t, {
          at: s,
          match: (G) => R ? $e.isElement(G) && N.isBlock(t, G) : We.isText(G) || N.isInline(t, G),
          mode: R ? "lowest" : "highest",
          always: R && (!h || M.length > 0) && (!E || $.length > 0),
          voids: i
        });
        var q = N.pathRef(t, !J || J && te ? oe.next(I) : I);
        if (Le.insertNodes(t, M, {
          at: q.current,
          match: (G) => We.isText(G) || N.isInline(t, G),
          mode: "highest",
          voids: i,
          batchDirty: a
        }), L && !M.length && V.length && !$.length && Le.delete(t, {
          at: f,
          voids: i
        }), Le.insertNodes(t, V, {
          at: S.current,
          match: (G) => $e.isElement(G) && N.isBlock(t, G),
          mode: "lowest",
          voids: i,
          batchDirty: a
        }), Le.insertNodes(t, $, {
          at: P.current,
          match: (G) => We.isText(G) || N.isInline(t, G),
          mode: "highest",
          voids: i,
          batchDirty: a
        }), !r.at) {
          var j;
          if ($.length > 0 && P.current ? j = oe.previous(P.current) : V.length > 0 && S.current ? j = oe.previous(S.current) : q.current && (j = oe.previous(q.current)), j) {
            var Z = N.end(t, j);
            Le.select(t, Z);
          }
        }
        q.unref(), S.unref(), P.unref();
      }
    }
  });
}, UG = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = t;
  if (o) {
    if (r === "anchor")
      Le.select(t, o.anchor);
    else if (r === "focus")
      Le.select(t, o.focus);
    else if (r === "start") {
      var [i] = ye.edges(o);
      Le.select(t, i);
    } else if (r === "end") {
      var [, s] = ye.edges(o);
      Le.select(t, s);
    }
  } else return;
}, $G = (e) => {
  var {
    selection: t
  } = e;
  t && e.apply({
    type: "set_selection",
    properties: t,
    newProperties: null
  });
}, WG = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = t, {
    distance: o = 1,
    unit: i = "character",
    reverse: s = !1
  } = n, {
    edge: a = null
  } = n;
  if (r) {
    a === "start" && (a = ye.isBackward(r) ? "focus" : "anchor"), a === "end" && (a = ye.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, p = {};
    if (a == null || a === "anchor") {
      var d = s ? N.before(t, l, c) : N.after(t, l, c);
      d && (p.anchor = d);
    }
    if (a == null || a === "focus") {
      var g = s ? N.before(t, u, c) : N.after(t, u, c);
      g && (p.focus = g);
    }
    Le.setSelection(t, p);
  }
}, HG = (e, t) => {
  var {
    selection: n
  } = e;
  if (t = N.range(e, t), n) {
    Le.setSelection(e, t);
    return;
  }
  if (!ye.isRange(t))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(dr.stringify(t)));
  e.apply({
    type: "set_selection",
    properties: n,
    newProperties: t
  });
};
function ek(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tk(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? ek(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : ek(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var VG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = t, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = ye.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = ye.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: s,
      focus: a
    } = o, l = i === "anchor" ? s : a;
    Le.setSelection(t, {
      [i === "anchor" ? "anchor" : "focus"]: tk(tk({}, l), n)
    });
  }
}, ZG = (e, t) => {
  var {
    selection: n
  } = e, r = {}, o = {};
  if (n) {
    for (var i in t)
      (i === "anchor" && t.anchor != null && !gt.equals(t.anchor, n.anchor) || i === "focus" && t.focus != null && !gt.equals(t.focus, n.focus) || i !== "anchor" && i !== "focus" && t[i] !== n[i]) && (r[i] = n[i], o[i] = t[i]);
    Object.keys(r).length > 0 && e.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, qG = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  N.withoutNormalizing(t, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: s = "lowest",
      batchDirty: a = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (Ae.isNode(n) && (n = [n]), n.length !== 0) {
      var [p] = n;
      if (l || (l = Xv(t), c !== !1 && (c = !0)), c == null && (c = !1), ye.isRange(l))
        if (o || (l = N.unhangRange(t, l, {
          voids: i
        })), ye.isCollapsed(l))
          l = l.anchor;
        else {
          var [, d] = ye.edges(l), g = N.pointRef(t, d);
          Le.delete(t, {
            at: l
          }), l = g.unref();
        }
      if (gt.isPoint(l)) {
        u == null && (We.isText(p) ? u = (M) => We.isText(M) : t.isInline(p) ? u = (M) => We.isText(M) || N.isInline(t, M) : u = (M) => $e.isElement(M) && N.isBlock(t, M));
        var [m] = N.nodes(t, {
          at: l.path,
          match: u,
          mode: s,
          voids: i
        });
        if (m) {
          var [, f] = m, h = N.pathRef(t, f), E = N.isEnd(t, l, f);
          Le.splitNodes(t, {
            at: l,
            match: u,
            mode: s,
            voids: i
          });
          var L = h.unref();
          l = E ? oe.next(L) : L;
        } else
          return;
      }
      var x = oe.parent(l), T = l[l.length - 1];
      if (!(!i && N.void(t, {
        at: x
      }))) {
        if (a) {
          var w = [], C = oe.levels(x);
          Mq(t, () => {
            var M = function() {
              var W = x.concat(T);
              T++;
              var R = {
                type: "insert_node",
                path: W,
                node: V
              };
              t.apply(R), l = oe.next(l), w.push(R), We.isText ? C.push(...Array.from(Ae.nodes(V), (H) => {
                var [, X] = H;
                return W.concat(X);
              })) : C.push(W);
            };
            for (var V of n)
              M();
          }, () => {
            wT(t, C, (M) => {
              var V = M;
              for (var $ of w)
                if (oe.operationCanTransformPath($) && (V = oe.transform(V, $), !V))
                  return null;
              return V;
            });
          });
        } else
          for (var k of n) {
            var O = x.concat(T);
            T++, t.apply({
              type: "insert_node",
              path: O,
              node: k
            }), l = oe.next(l);
          }
        if (l = oe.previous(l), c) {
          var U = N.end(t, l);
          U && Le.select(t, U);
        }
      }
    }
  });
}, GG = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  N.withoutNormalizing(t, () => {
    var {
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: s
    } = n;
    if (s == null && (s = oe.isPath(r) ? Vs(t, r) : (T) => $e.isElement(T) && N.isBlock(t, T)), !!r) {
      var a = N.nodes(t, {
        at: r,
        match: s,
        mode: o,
        voids: i
      }), l = Array.from(a, (T) => {
        var [, w] = T;
        return N.pathRef(t, w);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var p = N.node(t, oe.parent(c)), [d, g] = p, m = c[c.length - 1], {
          length: f
        } = d.children;
        if (f === 1) {
          var h = oe.next(g);
          Le.moveNodes(t, {
            at: c,
            to: h,
            voids: i
          }), Le.removeNodes(t, {
            at: g,
            voids: i
          });
        } else if (m === 0)
          Le.moveNodes(t, {
            at: c,
            to: g,
            voids: i
          });
        else if (m === f - 1) {
          var E = oe.next(g);
          Le.moveNodes(t, {
            at: c,
            to: E,
            voids: i
          });
        } else {
          var L = oe.next(c), x = oe.next(g);
          Le.splitNodes(t, {
            at: L,
            voids: i
          }), Le.moveNodes(t, {
            at: c,
            to: x,
            voids: i
          });
        }
      }
    }
  });
}, KG = ["text"], YG = ["children"], CT = (e, t) => {
  if ($e.isElement(t)) {
    var n = t;
    return N.isVoid(e, t) ? !0 : n.children.length === 1 ? CT(e, n.children[0]) : !1;
  } else return !N.isEditor(t);
}, XG = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  N.withoutNormalizing(t, () => {
    var {
      match: r,
      at: o = t.selection
    } = n, {
      hanging: i = !1,
      voids: s = !1,
      mode: a = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (oe.isPath(o)) {
          var [l] = N.parent(t, o);
          r = (M) => l.children.includes(M);
        } else
          r = (M) => $e.isElement(M) && N.isBlock(t, M);
      if (!i && ye.isRange(o) && (o = N.unhangRange(t, o, {
        voids: s
      })), ye.isRange(o))
        if (ye.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = ye.edges(o), c = N.pointRef(t, u);
          Le.delete(t, {
            at: o
          }), o = c.unref(), n.at == null && Le.select(t, o);
        }
      var [p] = N.nodes(t, {
        at: o,
        match: r,
        voids: s,
        mode: a
      }), d = N.previous(t, {
        at: o,
        match: r,
        voids: s,
        mode: a
      });
      if (!(!p || !d)) {
        var [g, m] = p, [f, h] = d;
        if (!(m.length === 0 || h.length === 0)) {
          var E = oe.next(h), L = oe.common(m, h), x = oe.isSibling(m, h), T = Array.from(N.levels(t, {
            at: m
          }), (M) => {
            var [V] = M;
            return V;
          }).slice(L.length).slice(0, -1), w = N.above(t, {
            at: m,
            mode: "highest",
            match: (M) => T.includes(M) && CT(t, M)
          }), C = w && N.pathRef(t, w[1]), k, O;
          if (We.isText(g) && We.isText(f)) {
            var U = Ho(g, KG);
            O = f.text.length, k = U;
          } else if ($e.isElement(g) && $e.isElement(f)) {
            var U = Ho(g, YG);
            O = f.children.length, k = U;
          } else
            throw new Error("Cannot merge the node at path [".concat(m, "] with the previous sibling because it is not the same kind: ").concat(dr.stringify(g), " ").concat(dr.stringify(f)));
          x || Le.moveNodes(t, {
            at: m,
            to: E,
            voids: s
          }), C && Le.removeNodes(t, {
            at: C.current,
            voids: s
          }), N.shouldMergeNodesRemovePrevNode(t, d, p) ? Le.removeNodes(t, {
            at: h,
            voids: s
          }) : t.apply({
            type: "merge_node",
            path: E,
            position: O,
            properties: k
          }), C && C.unref();
        }
      }
    }
  });
}, QG = (e, t) => {
  N.withoutNormalizing(e, () => {
    var {
      to: n,
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = t, {
      match: s
    } = t;
    if (r) {
      s == null && (s = oe.isPath(r) ? Vs(e, r) : (g) => $e.isElement(g) && N.isBlock(e, g));
      var a = N.pathRef(e, n), l = N.nodes(e, {
        at: r,
        match: s,
        mode: o,
        voids: i
      }), u = Array.from(l, (g) => {
        var [, m] = g;
        return N.pathRef(e, m);
      });
      for (var c of u) {
        var p = c.unref(), d = a.current;
        p.length !== 0 && e.apply({
          type: "move_node",
          path: p,
          newPath: d
        }), a.current && oe.isSibling(d, p) && oe.isAfter(d, p) && (a.current = oe.next(a.current));
      }
      a.unref();
    }
  });
}, JG = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  N.withoutNormalizing(t, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: s = t.selection,
      match: a
    } = n;
    if (s) {
      a == null && (a = oe.isPath(s) ? Vs(t, s) : (g) => $e.isElement(g) && N.isBlock(t, g)), !r && ye.isRange(s) && (s = N.unhangRange(t, s, {
        voids: o
      }));
      var l = N.nodes(t, {
        at: s,
        match: a,
        mode: i,
        voids: o
      }), u = Array.from(l, (g) => {
        var [, m] = g;
        return N.pathRef(t, m);
      });
      for (var c of u) {
        var p = c.unref();
        if (p) {
          var [d] = N.node(t, p);
          t.apply({
            type: "remove_node",
            path: p,
            node: d
          });
        }
      }
    }
  });
}, eK = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  N.withoutNormalizing(t, () => {
    var {
      match: o,
      at: i = t.selection,
      compare: s,
      merge: a
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: p = !1
    } = r;
    if (i) {
      if (o == null && (o = oe.isPath(i) ? Vs(t, i) : (O) => $e.isElement(O) && N.isBlock(t, O)), !l && ye.isRange(i) && (i = N.unhangRange(t, i, {
        voids: p
      })), c && ye.isRange(i)) {
        if (ye.isCollapsed(i) && N.leaf(t, i.anchor)[0].text.length > 0)
          return;
        var d = N.rangeRef(t, i, {
          affinity: "inward"
        }), [g, m] = ye.edges(i), f = u === "lowest" ? "lowest" : "highest", h = N.isEnd(t, m, m.path);
        Le.splitNodes(t, {
          at: m,
          match: o,
          mode: f,
          voids: p,
          always: !h
        });
        var E = N.isStart(t, g, g.path);
        Le.splitNodes(t, {
          at: g,
          match: o,
          mode: f,
          voids: p,
          always: !E
        }), i = d.unref(), r.at == null && Le.select(t, i);
      }
      s || (s = (O, U) => O !== U);
      for (var [L, x] of N.nodes(t, {
        at: i,
        match: o,
        mode: u,
        voids: p
      })) {
        var T = {}, w = {};
        if (x.length !== 0) {
          var C = !1;
          for (var k in n)
            k === "children" || k === "text" || s(n[k], L[k]) && (C = !0, L.hasOwnProperty(k) && (T[k] = L[k]), a ? n[k] != null && (w[k] = a(L[k], n[k])) : n[k] != null && (w[k] = n[k]));
          C && t.apply({
            type: "set_node",
            path: x,
            properties: T,
            newProperties: w
          });
        }
      }
    }
  });
}, tK = (e, t) => {
  if (ye.isCollapsed(t))
    return t.anchor;
  var [, n] = ye.edges(t), r = N.pointRef(e, n);
  return Le.delete(e, {
    at: t
  }), r.unref();
}, nK = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  N.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: s = t.selection,
      height: a = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (te) => $e.isElement(te) && N.isBlock(t, te)), ye.isRange(s) && (s = tK(t, s)), oe.isPath(s)) {
      var u = s, c = N.point(t, u), [p] = N.parent(t, u);
      i = (te) => te === p, a = c.path.length - u.length + 1, s = c, l = !0;
    }
    if (s) {
      var d = N.pointRef(t, s, {
        affinity: "backward"
      }), g;
      try {
        var [m] = N.nodes(t, {
          at: s,
          match: i,
          mode: r,
          voids: o
        });
        if (!m)
          return;
        var f = N.void(t, {
          at: s,
          mode: "highest"
        }), h = 0;
        if (!o && f) {
          var [E, L] = f;
          if ($e.isElement(E) && t.isInline(E)) {
            var x = N.after(t, L);
            if (!x) {
              var T = {
                text: ""
              }, w = oe.next(L);
              Le.insertNodes(t, T, {
                at: w,
                voids: o
              }), x = N.point(t, w);
            }
            s = x, l = !0;
          }
          var C = s.path.length - L.length;
          a = C + 1, l = !0;
        }
        g = N.pointRef(t, s);
        var k = s.path.length - a, [, O] = m, U = s.path.slice(0, k), M = a === 0 ? s.offset : s.path[k] + h;
        for (var [V, $] of N.levels(t, {
          at: U,
          reverse: !0,
          voids: o
        })) {
          var W = !1;
          if ($.length < O.length || $.length === 0 || !o && $e.isElement(V) && N.isVoid(t, V))
            break;
          var R = d.current, H = N.isEnd(t, R, $);
          if (l || !d || !N.isEdge(t, R, $)) {
            W = !0;
            var X = Ae.extractProps(V);
            t.apply({
              type: "split_node",
              path: $,
              position: M,
              properties: X
            });
          }
          M = $[$.length - 1] + (W || H ? 1 : 0);
        }
        if (n.at == null) {
          var I = g.current || N.end(t, []);
          Le.select(t, I);
        }
      } finally {
        var J;
        d.unref(), (J = g) === null || J === void 0 || J.unref();
      }
    }
  });
}, rK = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  Le.setNodes(t, o, r);
}, oK = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  N.withoutNormalizing(t, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: s = t.selection,
      match: a
    } = n;
    if (s) {
      a == null && (a = oe.isPath(s) ? Vs(t, s) : (g) => $e.isElement(g) && N.isBlock(t, g)), oe.isPath(s) && (s = N.range(t, s));
      var l = ye.isRange(s) ? N.rangeRef(t, s) : null, u = N.nodes(t, {
        at: s,
        match: a,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (g) => {
          var [, m] = g;
          return N.pathRef(t, m);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), p = function() {
        var m = d.unref(), [f] = N.node(t, m), h = N.range(t, m);
        o && l && (h = ye.intersection(l.current, h)), Le.liftNodes(t, {
          at: h,
          match: (E) => $e.isAncestor(f) && f.children.includes(E),
          voids: i
        });
      };
      for (var d of c)
        p();
      l && l.unref();
    }
  });
};
function nk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rk(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? nk(Object(n), !0).forEach(function(r) {
      Pr(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : nk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var iK = function(t, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  N.withoutNormalizing(t, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: s = !1
    } = r, {
      match: a,
      at: l = t.selection
    } = r;
    if (l) {
      if (a == null && (oe.isPath(l) ? a = Vs(t, l) : t.isInline(n) ? a = (h) => $e.isElement(h) && N.isInline(t, h) || We.isText(h) : a = (h) => $e.isElement(h) && N.isBlock(t, h)), i && ye.isRange(l)) {
        var [u, c] = ye.edges(l), p = N.rangeRef(t, l, {
          affinity: "inward"
        });
        Le.splitNodes(t, {
          at: c,
          match: a,
          voids: s
        }), Le.splitNodes(t, {
          at: u,
          match: a,
          voids: s
        }), l = p.unref(), r.at == null && Le.select(t, l);
      }
      var d = Array.from(N.nodes(t, {
        at: l,
        match: t.isInline(n) ? (h) => $e.isElement(h) && N.isBlock(t, h) : (h) => N.isEditor(h),
        mode: "lowest",
        voids: s
      })), g = function() {
        var E = ye.isRange(l) ? ye.intersection(l, N.range(t, f)) : l;
        if (!E)
          return 0;
        var L = Array.from(N.nodes(t, {
          at: E,
          match: a,
          mode: o,
          voids: s
        }));
        if (L.length > 0) {
          var [x] = L, T = L[L.length - 1], [, w] = x, [, C] = T;
          if (w.length === 0 && C.length === 0)
            return 0;
          var k = oe.equals(w, C) ? oe.parent(w) : oe.common(w, C), O = N.range(t, w, C), U = N.node(t, k), [M] = U, V = k.length + 1, $ = oe.next(C.slice(0, V)), W = rk(rk({}, n), {}, {
            children: []
          });
          Le.insertNodes(t, W, {
            at: $,
            voids: s
          }), Le.moveNodes(t, {
            at: O,
            match: (R) => $e.isAncestor(M) && M.children.includes(R),
            to: $.concat(0),
            voids: s
          });
        }
      }, m;
      for (var [, f] of d)
        m = g();
    }
  });
}, sK = () => {
  var e = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Pq(e, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jq(e, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Rq(e, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zq(e, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Uq(e, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Aq(e, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Qq(e, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eG(e, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zG(e, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Jq(e, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nG(e, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Bq(e, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return AG(e, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Tq(e, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _q(e, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Iq(e, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Nq(e, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Fq(e, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return UG(e, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return RG(e, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $G(e, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $q(e, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Wq(e, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Hq(e, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Vq(e, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Zq(e, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hG(e, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Gq(e, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Kq(e, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Yq(e, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return Xq(e, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qG(e, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rG(e, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return oG(e, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iG(e, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sG(e, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return aG(e, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lG(e, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uG(e, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cG(e, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pG(e, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return GG(e, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return XG(e, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return WG(e, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return QG(e, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gG(e, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mG(e, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vG(e, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yG(e, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bG(e, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return EG(e, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wG(e, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return CG(e, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kG(e, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xG(e, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LG(e, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DG(e, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SG(e, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PG(e, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return OG(e, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return MG(e, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return JG(e, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return HG(e, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eK(e, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return BG(e, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return VG(e, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ZG(e, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return nK(e, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _G(e, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return IG(e, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jG(e, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rK(e, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return oK(e, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qq(e, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return NG(e, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iK(e, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return FG(e, ...r);
    }
  };
  return e;
};
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function ok(e) {
  return Object.prototype.toString.call(e) === "[object Object]";
}
function aK(e) {
  var t, n;
  return ok(e) === !1 ? !1 : (t = e.constructor, t === void 0 ? !0 : (n = t.prototype, !(ok(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var lK = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(e) {
    return aK(e) && Array.isArray(e.redos) && Array.isArray(e.undos) && (e.redos.length === 0 || wi.isOperationList(e.redos[0].operations)) && (e.undos.length === 0 || wi.isOperationList(e.undos[0].operations));
  }
}, th = /* @__PURE__ */ new WeakMap(), ha = /* @__PURE__ */ new WeakMap(), cs = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(e) {
    return lK.isHistory(e.history) && N.isEditor(e);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(e) {
    return ha.get(e);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(e) {
    return th.get(e);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(e) {
    e.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(e) {
    e.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(e, t) {
    var n = cs.isMerging(e);
    ha.set(e, !0), t(), ha.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(e, t) {
    var n = cs.isMerging(e);
    ha.set(e, !1), t(), ha.set(e, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(e, t) {
    var n = cs.isSaving(e);
    th.set(e, !1), t(), th.set(e, n);
  }
}, uK = (e) => {
  var t = e, {
    apply: n
  } = t;
  return t.history = {
    undos: [],
    redos: []
  }, t.redo = () => {
    var {
      history: r
    } = t, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && Le.setSelection(t, i.selectionBefore), cs.withoutSaving(t, () => {
        N.withoutNormalizing(t, () => {
          for (var s of i.operations)
            t.apply(s);
        });
      }), r.redos.pop(), t.writeHistory("undos", i);
    }
  }, t.undo = () => {
    var {
      history: r
    } = t, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      cs.withoutSaving(t, () => {
        N.withoutNormalizing(t, () => {
          var s = i.operations.map(wi.inverse).reverse();
          for (var a of s)
            t.apply(a);
          i.selectionBefore && Le.setSelection(t, i.selectionBefore);
        });
      }), t.writeHistory("redos", i), r.undos.pop();
    }
  }, t.apply = (r) => {
    var {
      operations: o,
      history: i
    } = t, {
      undos: s
    } = i, a = s[s.length - 1], l = a && a.operations[a.operations.length - 1], u = cs.isSaving(t), c = cs.isMerging(t);
    if (u == null && (u = pK(r)), u) {
      if (c == null && (a == null ? c = !1 : o.length !== 0 ? c = !0 : c = cK(r, l)), a && c)
        a.operations.push(r);
      else {
        var p = {
          operations: [r],
          selectionBefore: t.selection
        };
        t.writeHistory("undos", p);
      }
      for (; s.length > 100; )
        s.shift();
      i.redos = [];
    }
    n(r);
  }, t.writeHistory = (r, o) => {
    t.history[r].push(o);
  }, t;
}, cK = (e, t) => !!(t && e.type === "insert_text" && t.type === "insert_text" && e.offset === t.offset + t.text.length && oe.equals(e.path, t.path) || t && e.type === "remove_text" && t.type === "remove_text" && e.offset + e.text.length === t.offset && oe.equals(e.path, t.path)), pK = (e, t) => e.type !== "set_selection", dK = gK, ET = "---", xT = "A-Za-z--------", fK = new RegExp("^[^" + xT + "]*[" + ET + "]"), hK = new RegExp("^[^" + ET + "]*[" + xT + "]");
function gK(e) {
  return e = String(e || ""), fK.test(e) ? "rtl" : hK.test(e) ? "ltr" : "neutral";
}
const LT = /* @__PURE__ */ Xc(dK);
function mK(e) {
  var t = typeof e;
  return e != null && (t == "object" || t == "function");
}
var ey = mK, vK = typeof en == "object" && en && en.Object === Object && en, yK = vK, bK = yK, wK = typeof self == "object" && self && self.Object === Object && self, CK = bK || wK || Function("return this")(), kT = CK, EK = kT, xK = function() {
  return EK.Date.now();
}, LK = xK, kK = /\s/;
function DK(e) {
  for (var t = e.length; t-- && kK.test(e.charAt(t)); )
    ;
  return t;
}
var SK = DK, OK = SK, MK = /^\s+/;
function PK(e) {
  return e && e.slice(0, OK(e) + 1).replace(MK, "");
}
var TK = PK, AK = kT, BK = AK.Symbol, DT = BK, ik = DT, ST = Object.prototype, _K = ST.hasOwnProperty, IK = ST.toString, ga = ik ? ik.toStringTag : void 0;
function jK(e) {
  var t = _K.call(e, ga), n = e[ga];
  try {
    e[ga] = void 0;
    var r = !0;
  } catch {
  }
  var o = IK.call(e);
  return r && (t ? e[ga] = n : delete e[ga]), o;
}
var NK = jK, FK = Object.prototype, RK = FK.toString;
function zK(e) {
  return RK.call(e);
}
var UK = zK, sk = DT, $K = NK, WK = UK, HK = "[object Null]", VK = "[object Undefined]", ak = sk ? sk.toStringTag : void 0;
function ZK(e) {
  return e == null ? e === void 0 ? VK : HK : ak && ak in Object(e) ? $K(e) : WK(e);
}
var qK = ZK;
function GK(e) {
  return e != null && typeof e == "object";
}
var KK = GK, YK = qK, XK = KK, QK = "[object Symbol]";
function JK(e) {
  return typeof e == "symbol" || XK(e) && YK(e) == QK;
}
var eY = JK, tY = TK, lk = ey, nY = eY, uk = NaN, rY = /^[-+]0x[0-9a-f]+$/i, oY = /^0b[01]+$/i, iY = /^0o[0-7]+$/i, sY = parseInt;
function aY(e) {
  if (typeof e == "number")
    return e;
  if (nY(e))
    return uk;
  if (lk(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = lk(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = tY(e);
  var n = oY.test(e);
  return n || iY.test(e) ? sY(e.slice(2), n ? 2 : 8) : rY.test(e) ? uk : +e;
}
var lY = aY, uY = ey, nh = LK, ck = lY, cY = "Expected a function", pY = Math.max, dY = Math.min;
function fY(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(cY);
  t = ck(t) || 0, uY(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? pY(ck(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var k = r, O = o;
    return r = o = void 0, u = C, s = e.apply(O, k), s;
  }
  function m(C) {
    return u = C, a = setTimeout(E, t), c ? g(C) : s;
  }
  function f(C) {
    var k = C - l, O = C - u, U = t - k;
    return p ? dY(U, i - O) : U;
  }
  function h(C) {
    var k = C - l, O = C - u;
    return l === void 0 || k >= t || k < 0 || p && O >= i;
  }
  function E() {
    var C = nh();
    if (h(C))
      return L(C);
    a = setTimeout(E, f(C));
  }
  function L(C) {
    return a = void 0, d && r ? g(C) : (r = o = void 0, s);
  }
  function x() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function T() {
    return a === void 0 ? s : L(nh());
  }
  function w() {
    var C = nh(), k = h(C);
    if (r = arguments, o = this, l = C, k) {
      if (a === void 0)
        return m(l);
      if (p)
        return clearTimeout(a), a = setTimeout(E, t), g(l);
    }
    return a === void 0 && (a = setTimeout(E, t)), s;
  }
  return w.cancel = x, w.flush = T, w;
}
var OT = fY;
const hY = /* @__PURE__ */ Xc(OT);
var gY = OT, mY = ey, vY = "Expected a function";
function yY(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(vY);
  return mY(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), gY(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
var bY = yY;
const wY = /* @__PURE__ */ Xc(bY), pk = (e) => typeof e == "object" && e != null && e.nodeType === 1, dk = (e, t) => (!t || e !== "hidden") && e !== "visible" && e !== "clip", rh = (e, t) => {
  if (e.clientHeight < e.scrollHeight || e.clientWidth < e.scrollWidth) {
    const n = getComputedStyle(e, null);
    return dk(n.overflowY, t) || dk(n.overflowX, t) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(e);
  }
  return !1;
}, zu = (e, t, n, r, o, i, s, a) => i < e && s > t || i > e && s < t ? 0 : i <= e && a <= n || s >= t && a >= n ? i - e - r : s > t && a < n || i < e && a > n ? s - t + o : 0, CY = (e) => {
  const t = e.parentElement;
  return t ?? (e.getRootNode().host || null);
}, fk = (e, t) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: s, block: a, inline: l, boundary: u, skipOverflowHiddenElements: c } = t, p = typeof u == "function" ? u : (X) => X !== u;
  if (!pk(e)) throw new TypeError("Invalid target");
  const d = document.scrollingElement || document.documentElement, g = [];
  let m = e;
  for (; pk(m) && p(m); ) {
    if (m = CY(m), m === d) {
      g.push(m);
      break;
    }
    m != null && m === document.body && rh(m) && !rh(document.documentElement) || m != null && rh(m, c) && g.push(m);
  }
  const f = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, h = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: E, scrollY: L } = window, { height: x, width: T, top: w, right: C, bottom: k, left: O } = e.getBoundingClientRect(), { top: U, right: M, bottom: V, left: $ } = ((X) => {
    const I = window.getComputedStyle(X);
    return { top: parseFloat(I.scrollMarginTop) || 0, right: parseFloat(I.scrollMarginRight) || 0, bottom: parseFloat(I.scrollMarginBottom) || 0, left: parseFloat(I.scrollMarginLeft) || 0 };
  })(e);
  let W = a === "start" || a === "nearest" ? w - U : a === "end" ? k + V : w + x / 2 - U + V, R = l === "center" ? O + T / 2 - $ + M : l === "end" ? C + M : O - $;
  const H = [];
  for (let X = 0; X < g.length; X++) {
    const I = g[X], { height: J, width: te, top: S, right: P, bottom: q, left: j } = I.getBoundingClientRect();
    if (s === "if-needed" && w >= 0 && O >= 0 && k <= h && C <= f && w >= S && k <= q && O >= j && C <= P) return H;
    const Z = getComputedStyle(I), G = parseInt(Z.borderLeftWidth, 10), b = parseInt(Z.borderTopWidth, 10), F = parseInt(Z.borderRightWidth, 10), z = parseInt(Z.borderBottomWidth, 10);
    let A = 0, Y = 0;
    const ee = "offsetWidth" in I ? I.offsetWidth - I.clientWidth - G - F : 0, B = "offsetHeight" in I ? I.offsetHeight - I.clientHeight - b - z : 0, se = "offsetWidth" in I ? I.offsetWidth === 0 ? 0 : te / I.offsetWidth : 0, ue = "offsetHeight" in I ? I.offsetHeight === 0 ? 0 : J / I.offsetHeight : 0;
    if (d === I) A = a === "start" ? W : a === "end" ? W - h : a === "nearest" ? zu(L, L + h, h, b, z, L + W, L + W + x, x) : W - h / 2, Y = l === "start" ? R : l === "center" ? R - f / 2 : l === "end" ? R - f : zu(E, E + f, f, G, F, E + R, E + R + T, T), A = Math.max(0, A + L), Y = Math.max(0, Y + E);
    else {
      A = a === "start" ? W - S - b : a === "end" ? W - q + z + B : a === "nearest" ? zu(S, q, J, b, z + B, W, W + x, x) : W - (S + J / 2) + B / 2, Y = l === "start" ? R - j - G : l === "center" ? R - (j + te / 2) + ee / 2 : l === "end" ? R - P + F + ee : zu(j, P, te, G, F + ee, R, R + T, T);
      const { scrollLeft: ce, scrollTop: de } = I;
      A = ue === 0 ? 0 : Math.max(0, Math.min(de + A / ue, I.scrollHeight - J / ue + B)), Y = se === 0 ? 0 : Math.max(0, Math.min(ce + Y / se, I.scrollWidth - te / se + ee)), W += de - A, R += ce - Y;
    }
    H.push({ el: I, top: A, left: Y });
  }
  return H;
}, EY = (e) => e === !1 ? { block: "end", inline: "nearest" } : ((t) => t === Object(t) && Object.keys(t).length !== 0)(e) ? e : { block: "start", inline: "nearest" };
function xY(e, t) {
  if (!e.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(e)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(e);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(t)) return t.behavior(fk(e, t));
  const r = typeof t == "boolean" || t == null ? void 0 : t.behavior;
  for (const { el: o, top: i, left: s } of fk(e, EY(t))) {
    const a = i - n.top + n.bottom, l = s - n.left + n.right;
    o.scroll({ top: a, left: l, behavior: r });
  }
}
var ds = [], LY = function() {
  return ds.some(function(e) {
    return e.activeTargets.length > 0;
  });
}, kY = function() {
  return ds.some(function(e) {
    return e.skippedTargets.length > 0;
  });
}, hk = "ResizeObserver loop completed with undelivered notifications.", DY = function() {
  var e;
  typeof ErrorEvent == "function" ? e = new ErrorEvent("error", {
    message: hk
  }) : (e = document.createEvent("Event"), e.initEvent("error", !1, !1), e.message = hk), window.dispatchEvent(e);
}, al;
(function(e) {
  e.BORDER_BOX = "border-box", e.CONTENT_BOX = "content-box", e.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(al || (al = {}));
var fs = function(e) {
  return Object.freeze(e);
}, SY = /* @__PURE__ */ function() {
  function e(t, n) {
    this.inlineSize = t, this.blockSize = n, fs(this);
  }
  return e;
}(), MT = function() {
  function e(t, n, r, o) {
    return this.x = t, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, fs(this);
  }
  return e.prototype.toJSON = function() {
    var t = this, n = t.x, r = t.y, o = t.top, i = t.right, s = t.bottom, a = t.left, l = t.width, u = t.height;
    return { x: n, y: r, top: o, right: i, bottom: s, left: a, width: l, height: u };
  }, e.fromRect = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e;
}(), ty = function(e) {
  return e instanceof SVGElement && "getBBox" in e;
}, PT = function(e) {
  if (ty(e)) {
    var t = e.getBBox(), n = t.width, r = t.height;
    return !n && !r;
  }
  var o = e, i = o.offsetWidth, s = o.offsetHeight;
  return !(i || s || e.getClientRects().length);
}, gk = function(e) {
  var t;
  if (e instanceof Element)
    return !0;
  var n = (t = e == null ? void 0 : e.ownerDocument) === null || t === void 0 ? void 0 : t.defaultView;
  return !!(n && e instanceof n.Element);
}, OY = function(e) {
  switch (e.tagName) {
    case "INPUT":
      if (e.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, Na = typeof window < "u" ? window : {}, Uu = /* @__PURE__ */ new WeakMap(), mk = /auto|scroll/, MY = /^tb|vertical/, PY = /msie|trident/i.test(Na.navigator && Na.navigator.userAgent), mo = function(e) {
  return parseFloat(e || "0");
}, Ts = function(e, t, n) {
  return e === void 0 && (e = 0), t === void 0 && (t = 0), n === void 0 && (n = !1), new SY((n ? t : e) || 0, (n ? e : t) || 0);
}, vk = fs({
  devicePixelContentBoxSize: Ts(),
  borderBoxSize: Ts(),
  contentBoxSize: Ts(),
  contentRect: new MT(0, 0, 0, 0)
}), TT = function(e, t) {
  if (t === void 0 && (t = !1), Uu.has(e) && !t)
    return Uu.get(e);
  if (PT(e))
    return Uu.set(e, vk), vk;
  var n = getComputedStyle(e), r = ty(e) && e.ownerSVGElement && e.getBBox(), o = !PY && n.boxSizing === "border-box", i = MY.test(n.writingMode || ""), s = !r && mk.test(n.overflowY || ""), a = !r && mk.test(n.overflowX || ""), l = r ? 0 : mo(n.paddingTop), u = r ? 0 : mo(n.paddingRight), c = r ? 0 : mo(n.paddingBottom), p = r ? 0 : mo(n.paddingLeft), d = r ? 0 : mo(n.borderTopWidth), g = r ? 0 : mo(n.borderRightWidth), m = r ? 0 : mo(n.borderBottomWidth), f = r ? 0 : mo(n.borderLeftWidth), h = p + u, E = l + c, L = f + g, x = d + m, T = a ? e.offsetHeight - x - e.clientHeight : 0, w = s ? e.offsetWidth - L - e.clientWidth : 0, C = o ? h + L : 0, k = o ? E + x : 0, O = r ? r.width : mo(n.width) - C - w, U = r ? r.height : mo(n.height) - k - T, M = O + h + w + L, V = U + E + T + x, $ = fs({
    devicePixelContentBoxSize: Ts(Math.round(O * devicePixelRatio), Math.round(U * devicePixelRatio), i),
    borderBoxSize: Ts(M, V, i),
    contentBoxSize: Ts(O, U, i),
    contentRect: new MT(p, l, O, U)
  });
  return Uu.set(e, $), $;
}, AT = function(e, t, n) {
  var r = TT(e, n), o = r.borderBoxSize, i = r.contentBoxSize, s = r.devicePixelContentBoxSize;
  switch (t) {
    case al.DEVICE_PIXEL_CONTENT_BOX:
      return s;
    case al.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, TY = /* @__PURE__ */ function() {
  function e(t) {
    var n = TT(t);
    this.target = t, this.contentRect = n.contentRect, this.borderBoxSize = fs([n.borderBoxSize]), this.contentBoxSize = fs([n.contentBoxSize]), this.devicePixelContentBoxSize = fs([n.devicePixelContentBoxSize]);
  }
  return e;
}(), BT = function(e) {
  if (PT(e))
    return 1 / 0;
  for (var t = 0, n = e.parentNode; n; )
    t += 1, n = n.parentNode;
  return t;
}, AY = function() {
  var e = 1 / 0, t = [];
  ds.forEach(function(s) {
    if (s.activeTargets.length !== 0) {
      var a = [];
      s.activeTargets.forEach(function(u) {
        var c = new TY(u.target), p = BT(u.target);
        a.push(c), u.lastReportedSize = AT(u.target, u.observedBox), p < e && (e = p);
      }), t.push(function() {
        s.callback.call(s.observer, a, s.observer);
      }), s.activeTargets.splice(0, s.activeTargets.length);
    }
  });
  for (var n = 0, r = t; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return e;
}, yk = function(e) {
  ds.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (BT(o.target) > e ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, BY = function() {
  var e = 0;
  for (yk(e); LY(); )
    e = AY(), yk(e);
  return kY() && DY(), e > 0;
}, oh, _T = [], _Y = function() {
  return _T.splice(0).forEach(function(e) {
    return e();
  });
}, IY = function(e) {
  if (!oh) {
    var t = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return _Y();
    }).observe(n, r), oh = function() {
      n.textContent = "".concat(t ? t-- : t++);
    };
  }
  _T.push(e), oh();
}, jY = function(e) {
  IY(function() {
    requestAnimationFrame(e);
  });
}, ac = 0, NY = function() {
  return !!ac;
}, FY = 250, RY = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, bk = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], wk = function(e) {
  return e === void 0 && (e = 0), Date.now() + e;
}, ih = !1, zY = function() {
  function e() {
    var t = this;
    this.stopped = !0, this.listener = function() {
      return t.schedule();
    };
  }
  return e.prototype.run = function(t) {
    var n = this;
    if (t === void 0 && (t = FY), !ih) {
      ih = !0;
      var r = wk(t);
      jY(function() {
        var o = !1;
        try {
          o = BY();
        } finally {
          if (ih = !1, t = r - wk(), !NY())
            return;
          o ? n.run(1e3) : t > 0 ? n.run(t) : n.start();
        }
      });
    }
  }, e.prototype.schedule = function() {
    this.stop(), this.run();
  }, e.prototype.observe = function() {
    var t = this, n = function() {
      return t.observer && t.observer.observe(document.body, RY);
    };
    document.body ? n() : Na.addEventListener("DOMContentLoaded", n);
  }, e.prototype.start = function() {
    var t = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), bk.forEach(function(n) {
      return Na.addEventListener(n, t.listener, !0);
    }));
  }, e.prototype.stop = function() {
    var t = this;
    this.stopped || (this.observer && this.observer.disconnect(), bk.forEach(function(n) {
      return Na.removeEventListener(n, t.listener, !0);
    }), this.stopped = !0);
  }, e;
}(), Fg = new zY(), Ck = function(e) {
  !ac && e > 0 && Fg.start(), ac += e, !ac && Fg.stop();
}, UY = function(e) {
  return !ty(e) && !OY(e) && getComputedStyle(e).display === "inline";
}, $Y = function() {
  function e(t, n) {
    this.target = t, this.observedBox = n || al.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return e.prototype.isActive = function() {
    var t = AT(this.target, this.observedBox, !0);
    return UY(this.target) && (this.lastReportedSize = t), this.lastReportedSize.inlineSize !== t.inlineSize || this.lastReportedSize.blockSize !== t.blockSize;
  }, e;
}(), WY = /* @__PURE__ */ function() {
  function e(t, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = t, this.callback = n;
  }
  return e;
}(), $u = /* @__PURE__ */ new WeakMap(), Ek = function(e, t) {
  for (var n = 0; n < e.length; n += 1)
    if (e[n].target === t)
      return n;
  return -1;
}, Wu = function() {
  function e() {
  }
  return e.connect = function(t, n) {
    var r = new WY(t, n);
    $u.set(t, r);
  }, e.observe = function(t, n, r) {
    var o = $u.get(t), i = o.observationTargets.length === 0;
    Ek(o.observationTargets, n) < 0 && (i && ds.push(o), o.observationTargets.push(new $Y(n, r && r.box)), Ck(1), Fg.schedule());
  }, e.unobserve = function(t, n) {
    var r = $u.get(t), o = Ek(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && ds.splice(ds.indexOf(r), 1), r.observationTargets.splice(o, 1), Ck(-1));
  }, e.disconnect = function(t) {
    var n = this, r = $u.get(t);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(t, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, e;
}(), HY = function() {
  function e(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof t != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Wu.connect(this, t);
  }
  return e.prototype.observe = function(t, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!gk(t))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Wu.observe(this, t, n);
  }, e.prototype.unobserve = function(t) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!gk(t))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Wu.unobserve(this, t);
  }, e.prototype.disconnect = function() {
    Wu.disconnect(this);
  }, e.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, e;
}();
function VY(e, t) {
  if (e == null) return {};
  var n = {}, r = Object.keys(e), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(t.indexOf(o) >= 0) && (n[o] = e[o]);
  return n;
}
function js(e, t) {
  if (e == null) return {};
  var n = VY(e, t), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(e);
    for (o = 0; o < i.length; o++)
      r = i[o], !(t.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(e, r) && (n[r] = e[r]);
  }
  return n;
}
function ll(e) {
  "@babel/helpers - typeof";
  return ll = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(t) {
    return typeof t;
  } : function(t) {
    return t && typeof Symbol == "function" && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t;
  }, ll(e);
}
function ZY(e, t) {
  if (ll(e) !== "object" || e === null) return e;
  var n = e[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(e, t || "default");
    if (ll(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (t === "string" ? String : Number)(e);
}
function qY(e) {
  var t = ZY(e, "string");
  return ll(t) === "symbol" ? t : String(t);
}
function uo(e, t, n) {
  return t = qY(t), t in e ? Object.defineProperty(e, t, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : e[t] = n, e;
}
var ny = /* @__PURE__ */ Ye(null), ji = () => {
  var e = _e(ny);
  if (!e)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return e;
}, sh, ah, IT = parseInt(Be.version.split(".")[0], 10), jT = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, xk = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), Dr = typeof navigator < "u" && /Android/.test(navigator.userAgent), Ps = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), ts = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), GY = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), NT = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), KY = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), YY = Dr && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), XY = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), QY = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), JY = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), lc = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((sh = navigator.userAgent.match(/Version\/(\d+)/)) !== null && sh !== void 0 && sh[1] && parseInt((ah = navigator.userAgent.match(/Version\/(\d+)/)) === null || ah === void 0 ? void 0 : ah[1], 10) < 17);
var ri = (!KY || !YY) && !GY && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", ry = /* @__PURE__ */ new WeakMap(), oy = /* @__PURE__ */ new WeakMap(), FT = /* @__PURE__ */ new WeakMap(), uc = /* @__PURE__ */ new WeakMap(), Rg = /* @__PURE__ */ new WeakMap(), ul = /* @__PURE__ */ new WeakMap(), hs = /* @__PURE__ */ new WeakMap(), Zc = /* @__PURE__ */ new WeakMap(), dd = /* @__PURE__ */ new WeakMap(), zg = /* @__PURE__ */ new WeakMap(), Ci = /* @__PURE__ */ new WeakMap(), ps = /* @__PURE__ */ new WeakMap(), Fa = /* @__PURE__ */ new WeakMap(), Ug = /* @__PURE__ */ new WeakMap(), iy = /* @__PURE__ */ new WeakMap(), co = /* @__PURE__ */ new WeakMap(), zo = /* @__PURE__ */ new WeakMap(), Ar = /* @__PURE__ */ new WeakMap(), hi = /* @__PURE__ */ new WeakMap(), gi = /* @__PURE__ */ new WeakMap(), RT = /* @__PURE__ */ new WeakMap(), Ns = Symbol("placeholder"), zT = Symbol("mark-placeholder"), UT = globalThis.Node, eX = globalThis.Text, sy = (e) => e && e.ownerDocument && e.ownerDocument.defaultView || null, tX = (e) => xi(e) && e.nodeType === 8, lo = (e) => xi(e) && e.nodeType === 1, xi = (e) => {
  var t = sy(e);
  return !!t && e instanceof t.Node;
}, $g = (e) => {
  var t = e && e.anchorNode && sy(e.anchorNode);
  return !!t && e instanceof t.Selection;
}, $T = (e) => xi(e) && e.nodeType === 3, nX = (e) => e.clipboardData && e.clipboardData.getData("text/plain") !== "" && e.clipboardData.types.length === 1, rX = (e) => {
  var [t, n] = e;
  if (lo(t) && t.childNodes.length) {
    var r = n === t.childNodes.length, o = r ? n - 1 : n;
    for ([t, o] = WT(t, o, r ? "backward" : "forward"), r = o < n; lo(t) && t.childNodes.length; ) {
      var i = r ? t.childNodes.length - 1 : 0;
      t = iX(t, i, r ? "backward" : "forward");
    }
    n = r && t.textContent != null ? t.textContent.length : 0;
  }
  return [t, n];
}, oX = (e) => {
  for (var t = e && e.parentNode; t; ) {
    if (t.toString() === "[object ShadowRoot]")
      return !0;
    t = t.parentNode;
  }
  return !1;
}, WT = (e, t, n) => {
  for (var {
    childNodes: r
  } = e, o = r[t], i = t, s = !1, a = !1; (tX(o) || lo(o) && o.childNodes.length === 0 || lo(o) && o.getAttribute("contenteditable") === "false") && !(s && a); ) {
    if (i >= r.length) {
      s = !0, i = t - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      a = !0, i = t + 1, n = "forward";
      continue;
    }
    o = r[i], t = i, i += n === "forward" ? 1 : -1;
  }
  return [o, t];
}, iX = (e, t, n) => {
  var [r] = WT(e, t, n);
  return r;
}, HT = (e) => {
  var t = "";
  if ($T(e) && e.nodeValue)
    return e.nodeValue;
  if (lo(e)) {
    for (var n of Array.from(e.childNodes))
      t += HT(n);
    var r = getComputedStyle(e).getPropertyValue("display");
    (r === "block" || r === "list" || e.tagName === "BR") && (t += `
`);
  }
  return t;
}, sX = /data-slate-fragment="(.+?)"/m, aX = (e) => {
  var t = e.getData("text/html"), [, n] = t.match(sX) || [];
  return n;
}, Ra = (e) => e.getSelection != null ? e.getSelection() : document.getSelection(), ay = (e, t, n) => {
  var {
    target: r
  } = t;
  if (lo(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Ce.getWindow(e);
  if (o.contains(r))
    return Ce.hasDOMNode(e, r, {
      editable: !0
    });
  var i = n.find((s) => {
    var {
      addedNodes: a,
      removedNodes: l
    } = s;
    for (var u of a)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === t ? !1 : ay(e, i, n);
}, lX = () => {
  for (var e = document.activeElement; (t = e) !== null && t !== void 0 && t.shadowRoot && (n = e.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var t, n, r;
    e = (r = e) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return e;
}, Lk = (e, t) => !!(e.compareDocumentPosition(t) & UT.DOCUMENT_POSITION_PRECEDING), uX = (e, t) => !!(e.compareDocumentPosition(t) & UT.DOCUMENT_POSITION_FOLLOWING), cX = 0;
class pX {
  constructor() {
    uo(this, "id", void 0), this.id = "".concat(cX++);
  }
}
var Ce = {
  androidPendingDiffs: (e) => Ar.get(e),
  androidScheduleFlush: (e) => {
    var t;
    (t = iy.get(e)) === null || t === void 0 || t();
  },
  blur: (e) => {
    var t = Ce.toDOMNode(e, e), n = Ce.findDocumentOrShadowRoot(e);
    Ci.set(e, !1), n.activeElement === t && t.blur();
  },
  deselect: (e) => {
    var {
      selection: t
    } = e, n = Ce.findDocumentOrShadowRoot(e), r = Ra(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), t && Le.deselect(e);
  },
  findDocumentOrShadowRoot: (e) => {
    var t = Ce.toDOMNode(e, e), n = t.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : t.ownerDocument;
  },
  findEventRange: (e, t) => {
    "nativeEvent" in t && (t = t.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = t;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var i = Ce.toSlateNode(e, t.target), s = Ce.findPath(e, i);
    if ($e.isElement(i) && N.isVoid(e, i)) {
      var a = o.getBoundingClientRect(), l = e.isInline(i) ? n - a.left < a.left + a.width - n : r - a.top < a.top + a.height - r, u = N.point(e, s, {
        edge: l ? "start" : "end"
      }), c = l ? N.before(e, u) : N.after(e, u);
      if (c) {
        var p = N.range(e, c);
        return p;
      }
    }
    var d, {
      document: g
    } = Ce.getWindow(e);
    if (g.caretRangeFromPoint)
      d = g.caretRangeFromPoint(n, r);
    else {
      var m = g.caretPositionFromPoint(n, r);
      m && (d = g.createRange(), d.setStart(m.offsetNode, m.offset), d.setEnd(m.offsetNode, m.offset));
    }
    if (!d)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(t));
    var f = Ce.toSlateRange(e, d, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return f;
  },
  findKey: (e, t) => {
    var n = Zc.get(t);
    return n || (n = new pX(), Zc.set(t, n)), n;
  },
  findPath: (e, t) => {
    for (var n = [], r = t; ; ) {
      var o = oy.get(r);
      if (o == null) {
        if (N.isEditor(r))
          return n;
        break;
      }
      var i = ry.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(dr.stringify(t)));
  },
  focus: function(t) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!Ci.get(t)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          Ce.focus(t, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = Ce.toDOMNode(t, t), o = Ce.findDocumentOrShadowRoot(t);
      if (o.activeElement !== r) {
        if (t.selection && o instanceof Document) {
          var i = Ra(o), s = Ce.toDOMRange(t, t.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(s);
        }
        t.selection || Le.select(t, N.start(t, [])), Ci.set(t, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (e) => {
    var t = FT.get(e);
    if (!t)
      throw new Error("Unable to find a host window element for this editor");
    return t;
  },
  hasDOMNode: function(t, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = Ce.toDOMNode(t, t), s;
    try {
      s = lo(n) ? n : n.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return s ? s.closest("[data-slate-editor]") === i && (!o || s.isContentEditable ? !0 : typeof s.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    s.closest('[contenteditable="false"]') === i || !!s.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (e, t) => xi(t) && Ce.hasDOMNode(e, t, {
    editable: !0
  }),
  hasRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t;
    return N.hasPath(e, n.path) && N.hasPath(e, r.path);
  },
  hasSelectableTarget: (e, t) => Ce.hasEditableTarget(e, t) || Ce.isTargetInsideNonReadonlyVoid(e, t),
  hasTarget: (e, t) => xi(t) && Ce.hasDOMNode(e, t),
  insertData: (e, t) => {
    e.insertData(t);
  },
  insertFragmentData: (e, t) => e.insertFragmentData(t),
  insertTextData: (e, t) => e.insertTextData(t),
  isComposing: (e) => !!ps.get(e),
  isFocused: (e) => !!Ci.get(e),
  isReadOnly: (e) => !!zg.get(e),
  isTargetInsideNonReadonlyVoid: (e, t) => {
    if (zg.get(e)) return !1;
    var n = Ce.hasTarget(e, t) && Ce.toSlateNode(e, t);
    return $e.isElement(n) && N.isVoid(e, n);
  },
  setFragmentData: (e, t, n) => e.setFragmentData(t, n),
  toDOMNode: (e, t) => {
    var n = dd.get(e), r = N.isEditor(t) ? uc.get(e) : n == null ? void 0 : n.get(Ce.findKey(e, t));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(dr.stringify(t)));
    return r;
  },
  toDOMPoint: (e, t) => {
    var [n] = N.node(e, t.path), r = Ce.toDOMNode(e, n), o;
    N.void(e, {
      at: t
    }) && (t = {
      path: t.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", s = Array.from(r.querySelectorAll(i)), a = 0, l = 0; l < s.length; l++) {
      var u = s[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: p
        } = c.textContent, d = u.getAttribute("data-slate-length"), g = d == null ? p : parseInt(d, 10), m = a + g, f = s[l + 1];
        if (t.offset === m && f !== null && f !== void 0 && f.hasAttribute("data-slate-mark-placeholder")) {
          var h, E = f.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            E instanceof eX ? E : f,
            (h = f.textContent) !== null && h !== void 0 && h.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (t.offset <= m) {
          var L = Math.min(p, Math.max(0, t.offset - a));
          o = [c, L];
          break;
        }
        a = m;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(dr.stringify(t)));
    return o;
  },
  toDOMRange: (e, t) => {
    var {
      anchor: n,
      focus: r
    } = t, o = ye.isBackward(t), i = Ce.toDOMPoint(e, n), s = ye.isCollapsed(t) ? i : Ce.toDOMPoint(e, r), a = Ce.getWindow(e), l = a.document.createRange(), [u, c] = o ? s : i, [p, d] = o ? i : s, g = lo(u) ? u : u.parentElement, m = !!g.getAttribute("data-slate-zero-width"), f = lo(p) ? p : p.parentElement, h = !!f.getAttribute("data-slate-zero-width");
    return l.setStart(u, m ? 1 : c), l.setEnd(p, h ? 1 : d), l;
  },
  toSlateNode: (e, t) => {
    var n = lo(t) ? t : t.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? ul.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (e, t, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [s, a] = r ? t : rX(t), l = s.parentNode, u = null, c = 0;
    if (l) {
      var p, d, g = Ce.toDOMNode(e, e), m = l.closest('[data-slate-void="true"]'), f = m && g.contains(m) ? m : null, h = l.closest('[contenteditable="false"]'), E = h && g.contains(h) ? h : null, L = l.closest("[data-slate-leaf]"), x = null;
      if (L) {
        if (u = L.closest('[data-slate-node="text"]'), u) {
          var T = Ce.getWindow(e), w = T.document.createRange();
          w.setStart(u, 0), w.setEnd(s, a);
          var C = w.cloneContents(), k = [...Array.prototype.slice.call(C.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(C.querySelectorAll("[contenteditable=false]"))];
          k.forEach((j) => {
            if (Dr && !r && j.hasAttribute("data-slate-zero-width") && j.textContent.length > 0 && j.textContext !== "\uFEFF") {
              j.textContent.startsWith("\uFEFF") && (j.textContent = j.textContent.slice(1));
              return;
            }
            j.parentNode.removeChild(j);
          }), c = C.textContent.length, x = u;
        }
      } else if (f) {
        for (var O = f.querySelectorAll("[data-slate-leaf]"), U = 0; U < O.length; U++) {
          var M = O[U];
          if (Ce.hasDOMNode(e, M)) {
            L = M;
            break;
          }
        }
        L ? (u = L.closest('[data-slate-node="text"]'), x = L, c = x.textContent.length, x.querySelectorAll("[data-slate-zero-width]").forEach((j) => {
          c -= j.textContent.length;
        })) : c = 1;
      } else if (E) {
        var V = (j) => j ? j.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], $ = E.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var W, R = [...V($), ...V($ == null ? void 0 : $.nextElementSibling)];
          L = (W = R.find((j) => uX(E, j))) !== null && W !== void 0 ? W : null;
        } else {
          var H, X = [...V($ == null ? void 0 : $.previousElementSibling), ...V($)];
          L = (H = X.findLast((j) => Lk(E, j))) !== null && H !== void 0 ? H : null;
        }
        L && (u = L.closest('[data-slate-node="text"]'), x = L, i === "forward" ? c = 0 : (c = x.textContent.length, x.querySelectorAll("[data-slate-zero-width]").forEach((j) => {
          c -= j.textContent.length;
        })));
      }
      x && c === x.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      Dr && x.getAttribute("data-slate-zero-width") === "z" && (p = x.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Ps && (d = x.textContent) !== null && d !== void 0 && d.endsWith(`

`)) && c--;
    }
    if (Dr && !u && !r) {
      var I = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (I && Ce.hasDOMNode(e, I, {
        editable: !0
      })) {
        var J = Ce.toSlateNode(e, I), {
          path: te,
          offset: S
        } = N.start(e, Ce.findPath(e, J));
        return I.querySelector("[data-slate-leaf]") || (S = a), {
          path: te,
          offset: S
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(t));
    }
    var P = Ce.toSlateNode(e, u), q = Ce.findPath(e, P);
    return {
      path: q,
      offset: c
    };
  },
  toSlateRange: (e, t, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, s = $g(t) ? t.anchorNode : t.startContainer, a, l, u, c, p;
    if (s)
      if ($g(t)) {
        if (Ps && t.rangeCount > 1) {
          u = t.focusNode;
          var d = t.getRangeAt(0), g = t.getRangeAt(t.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && d.startContainer instanceof HTMLTableRowElement && g.startContainer instanceof HTMLTableRowElement) {
            let C = function(k) {
              return k.childElementCount > 0 ? C(k.children[0]) : k;
            };
            var m = d.startContainer, f = g.startContainer, h = C(m.children[d.startOffset]), E = C(f.children[g.startOffset]);
            c = 0, E.childNodes.length > 0 ? a = E.childNodes[0] : a = E, h.childNodes.length > 0 ? u = h.childNodes[0] : u = h, E instanceof HTMLElement ? l = E.innerHTML.length : l = 0;
          } else
            d.startContainer === u ? (a = g.endContainer, l = g.endOffset, c = d.startOffset) : (a = d.startContainer, l = d.endOffset, c = g.startOffset);
        } else
          a = t.anchorNode, l = t.anchorOffset, u = t.focusNode, c = t.focusOffset;
        NT && oX(a) || Ps ? p = t.anchorNode === t.focusNode && t.anchorOffset === t.focusOffset : p = t.isCollapsed;
      } else
        a = t.startContainer, l = t.startOffset, u = t.endContainer, c = t.endOffset, p = t.collapsed;
    if (a == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(t));
    Ps && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var L = Ce.toSlatePoint(e, [a, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!L)
      return null;
    var x = Lk(a, u) || a === u && c < l, T = p ? L : Ce.toSlatePoint(e, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: x ? "forward" : "backward"
    });
    if (!T)
      return null;
    var w = {
      anchor: L,
      focus: T
    };
    return ye.isExpanded(w) && ye.isForward(w) && lo(u) && N.void(e, {
      at: w.focus,
      mode: "highest"
    }) && (w = N.unhangRange(e, w, {
      voids: !0
    })), w;
  }
};
function dX(e, t) {
  var {
    path: n,
    diff: r
  } = t;
  if (!N.hasPath(e, n))
    return !1;
  var o = Ae.get(e, n);
  if (!We.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = oe.next(n);
  if (!N.hasPath(e, i))
    return !1;
  var s = Ae.get(e, i);
  return We.isText(s) && s.text.startsWith(r.text);
}
function VT(e) {
  for (var t = arguments.length, n = new Array(t > 1 ? t - 1 : 0), r = 1; r < t; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), e);
}
function fX(e, t) {
  for (var n = Math.min(e.length, t.length), r = 0; r < n; r++)
    if (e.charAt(r) !== t.charAt(r))
      return r;
  return n;
}
function hX(e, t, n) {
  for (var r = Math.min(e.length, t.length, n), o = 0; o < r; o++)
    if (e.charAt(e.length - o - 1) !== t.charAt(t.length - o - 1))
      return o;
  return r;
}
function ZT(e, t) {
  var {
    start: n,
    end: r,
    text: o
  } = t, i = e.slice(n, r), s = fX(i, o), a = Math.min(i.length - s, o.length - s), l = hX(i, o, a), u = {
    start: n + s,
    end: r - l,
    text: o.slice(s, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function gX(e, t, n) {
  var r = Math.min(t.start, n.start), o = Math.max(0, Math.min(t.start + t.text.length, n.end) - n.start), i = VT(e, t, n), s = Math.max(n.start + n.text.length, t.start + t.text.length + (t.start + t.text.length > n.start ? n.text.length : 0) - o), a = i.slice(r, s), l = Math.max(t.end, n.end - t.text.length + (t.end - t.start));
  return ZT(e, {
    start: r,
    end: l,
    text: a
  });
}
function mX(e) {
  var {
    path: t,
    diff: n
  } = e;
  return {
    anchor: {
      path: t,
      offset: n.start
    },
    focus: {
      path: t,
      offset: n.end
    }
  };
}
function Wg(e, t) {
  var {
    path: n,
    offset: r
  } = t;
  if (!N.hasPath(e, n))
    return null;
  var o = Ae.get(e, n);
  if (!We.isText(o))
    return null;
  var i = N.above(e, {
    match: (a) => $e.isElement(a) && N.isBlock(e, a),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var s = N.next(e, {
      at: n,
      match: We.isText
    });
    if (!s || !oe.isDescendant(s[1], i[1]))
      return null;
    r -= o.text.length, o = s[0], n = s[1];
  }
  return {
    path: n,
    offset: r
  };
}
function kk(e, t) {
  var n = Wg(e, t.anchor);
  if (!n)
    return null;
  if (ye.isCollapsed(t))
    return {
      anchor: n,
      focus: n
    };
  var r = Wg(e, t.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function Hg(e, t, n) {
  var r = Ar.get(e), o = r == null ? void 0 : r.find((c) => {
    var {
      path: p
    } = c;
    return oe.equals(p, t.path);
  });
  if (!o || t.offset <= o.diff.start)
    return gt.transform(t, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (t.offset <= i.start + i.text.length) {
    var s = {
      path: t.path,
      offset: i.start
    }, a = gt.transform(s, n, {
      affinity: "backward"
    });
    return a ? {
      path: a.path,
      offset: a.offset + t.offset - i.start
    } : null;
  }
  var l = {
    path: t.path,
    offset: t.offset - i.text.length + i.end - i.start
  }, u = gt.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && oe.equals(n.path, t.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function Dk(e, t, n) {
  var r = Hg(e, t.anchor, n);
  if (!r)
    return null;
  if (ye.isCollapsed(t))
    return {
      anchor: r,
      focus: r
    };
  var o = Hg(e, t.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function vX(e, t) {
  var {
    path: n,
    diff: r,
    id: o
  } = e;
  switch (t.type) {
    case "insert_text":
      return !oe.equals(t.path, n) || t.offset >= r.end ? e : t.offset <= r.start ? {
        diff: {
          start: t.text.length + r.start,
          end: t.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !oe.equals(t.path, n) || t.offset >= r.end ? e : t.offset + t.text.length <= r.start ? {
        diff: {
          start: r.start - t.text.length,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - t.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !oe.equals(t.path, n) || t.position >= r.end ? {
        diff: r,
        id: o,
        path: oe.transform(n, t, {
          affinity: "backward"
        })
      } : t.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(t.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - t.position,
          end: r.end - t.position,
          text: r.text
        },
        id: o,
        path: oe.transform(n, t, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return oe.equals(t.path, n) ? {
        diff: {
          start: r.start + t.position,
          end: r.end + t.position,
          text: r.text
        },
        id: o,
        path: oe.transform(n, t)
      } : {
        diff: r,
        id: o,
        path: oe.transform(n, t)
      };
  }
  var i = oe.transform(n, t);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function Sk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Hu(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Sk(Object(n), !0).forEach(function(r) {
      uo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Sk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yX = 25, bX = 200, wX = function() {
}, CX = (e) => (e == null ? void 0 : e.constructor.name) === "DataTransfer";
function EX(e) {
  var {
    editor: t,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = e, o = !1, i = null, s = null, a = null, l = 0, u = !1, c = () => {
    var $ = gi.get(t);
    if (gi.delete(t), $) {
      var {
        selection: W
      } = t, R = kk(t, $);
      R && (!W || !ye.equals(R, W)) && Le.select(t, R);
    }
  }, p = () => {
    var $ = hi.get(t);
    if (hi.delete(t), !!$) {
      if ($.at) {
        var W = gt.isPoint($.at) ? Wg(t, $.at) : kk(t, $.at);
        if (!W)
          return;
        var R = N.range(t, W);
        (!t.selection || !ye.equals(t.selection, R)) && Le.select(t, W);
      }
      $.run();
    }
  }, d = () => {
    if (s && (clearTimeout(s), s = null), a && (clearTimeout(a), a = null), !T() && !x()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), x() && (o = "action");
    var $ = t.selection && N.rangeRef(t, t.selection, {
      affinity: "forward"
    });
    zo.set(t, t.marks), wX("flush", hi.get(t), Ar.get(t));
    for (var W = T(), R; R = (H = Ar.get(t)) === null || H === void 0 ? void 0 : H[0]; ) {
      var H, X, I = co.get(t);
      I !== void 0 && (co.delete(t), t.marks = I), I && u === !1 && (u = null);
      var J = mX(R);
      (!t.selection || !ye.equals(t.selection, J)) && Le.select(t, J), R.diff.text ? N.insertText(t, R.diff.text) : N.deleteFragment(t), Ar.set(t, (X = Ar.get(t)) === null || X === void 0 ? void 0 : X.filter((P) => {
        var {
          id: q
        } = P;
        return q !== R.id;
      })), dX(t, R) || (W = !1, hi.delete(t), zo.delete(t), o = "action", gi.delete(t), n.cancel(), r.cancel(), $ == null || $.unref());
    }
    var te = $ == null ? void 0 : $.unref();
    if (te && !gi.get(t) && (!t.selection || !ye.equals(te, t.selection)) && Le.select(t, te), x()) {
      p();
      return;
    }
    W && n(), n.flush(), r.flush(), c();
    var S = zo.get(t);
    zo.delete(t), S !== void 0 && (t.marks = S, t.onChange());
  }, g = ($) => {
    i && clearTimeout(i), i = setTimeout(() => {
      ps.set(t, !1), d();
    }, yX);
  }, m = ($) => {
    ps.set(t, !0), i && (clearTimeout(i), i = null);
  }, f = function() {
    var W = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, R = Rg.get(t);
    if (R) {
      if (T() || W) {
        R.style.display = "none";
        return;
      }
      R.style.removeProperty("display");
    }
  }, h = ($, W) => {
    var R, H = (R = Ar.get(t)) !== null && R !== void 0 ? R : [];
    Ar.set(t, H);
    var X = Ae.leaf(t, $), I = H.findIndex((S) => oe.equals(S.path, $));
    if (I < 0) {
      var J = ZT(X.text, W);
      J && H.push({
        path: $,
        diff: W,
        id: l++
      }), f();
      return;
    }
    var te = gX(X.text, H[I].diff, W);
    if (!te) {
      H.splice(I, 1), f();
      return;
    }
    H[I] = Hu(Hu({}, H[I]), {}, {
      diff: te
    });
  }, E = function(W) {
    var {
      at: R
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, gi.delete(t), n.cancel(), r.cancel(), x() && d(), hi.set(t, {
      at: R,
      run: W
    }), a = setTimeout(d);
  }, L = ($) => {
    var W;
    s && (clearTimeout(s), s = null);
    var {
      inputType: R
    } = $, H = null, X = $.dataTransfer || $.data || void 0;
    u !== !1 && R !== "insertText" && R !== "insertCompositionText" && (u = !1);
    var [I] = $.getTargetRanges();
    I && (H = Ce.toSlateRange(t, I, {
      exactMatch: !1,
      suppressThrow: !0
    }));
    var J = Ce.getWindow(t), te = J.getSelection();
    if (!H && te && (I = te, H = Ce.toSlateRange(t, te, {
      exactMatch: !1,
      suppressThrow: !0
    })), H = (W = H) !== null && W !== void 0 ? W : t.selection, !!H) {
      var S = !0;
      if (R.startsWith("delete")) {
        if (ye.isExpanded(H)) {
          var [P, q] = ye.edges(H), j = Ae.leaf(t, P.path);
          if (j.text.length === P.offset && q.offset === 0) {
            var Z = N.next(t, {
              at: P.path,
              match: We.isText
            });
            Z && oe.equals(Z[1], q.path) && (H = {
              anchor: q,
              focus: q
            });
          }
        }
        var G = R.endsWith("Backward") ? "backward" : "forward", [b, F] = ye.edges(H), [z, A] = N.leaf(t, b.path), Y = {
          text: "",
          start: b.offset,
          end: F.offset
        }, ee = Ar.get(t), B = ee == null ? void 0 : ee.find((Ue) => oe.equals(Ue.path, A)), se = B ? [B.diff, Y] : [Y], ue = VT(z.text, ...se);
        if (ue.length === 0 && (S = !1), ye.isExpanded(H)) {
          if (S && oe.equals(H.anchor.path, H.focus.path)) {
            var ce = {
              path: H.anchor.path,
              offset: b.offset
            }, de = N.range(t, ce, ce);
            return k(de), h(H.anchor.path, {
              text: "",
              end: F.offset,
              start: b.offset
            });
          }
          return E(() => N.deleteFragment(t, {
            direction: G
          }), {
            at: H
          });
        }
      }
      switch (R) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag":
          return E(() => N.deleteFragment(t), {
            at: H
          });
        case "deleteContent":
        case "deleteContentForward": {
          var {
            anchor: be
          } = H;
          if (S && ye.isCollapsed(H)) {
            var ge = Ae.leaf(t, be.path);
            if (be.offset < ge.text.length)
              return h(be.path, {
                text: "",
                start: be.offset,
                end: be.offset + 1
              });
          }
          return E(() => N.deleteForward(t), {
            at: H
          });
        }
        case "deleteContentBackward": {
          var me, {
            anchor: ae
          } = H, xe = $g(I) ? I.isCollapsed : !!((me = I) !== null && me !== void 0 && me.collapsed);
          return S && xe && ye.isCollapsed(H) && ae.offset > 0 ? h(ae.path, {
            text: "",
            start: ae.offset - 1,
            end: ae.offset
          }) : E(() => N.deleteBackward(t), {
            at: H
          });
        }
        case "deleteEntireSoftLine":
          return E(() => {
            N.deleteBackward(t, {
              unit: "line"
            }), N.deleteForward(t, {
              unit: "line"
            });
          }, {
            at: H
          });
        case "deleteHardLineBackward":
          return E(() => N.deleteBackward(t, {
            unit: "block"
          }), {
            at: H
          });
        case "deleteSoftLineBackward":
          return E(() => N.deleteBackward(t, {
            unit: "line"
          }), {
            at: H
          });
        case "deleteHardLineForward":
          return E(() => N.deleteForward(t, {
            unit: "block"
          }), {
            at: H
          });
        case "deleteSoftLineForward":
          return E(() => N.deleteForward(t, {
            unit: "line"
          }), {
            at: H
          });
        case "deleteWordBackward":
          return E(() => N.deleteBackward(t, {
            unit: "word"
          }), {
            at: H
          });
        case "deleteWordForward":
          return E(() => N.deleteForward(t, {
            unit: "word"
          }), {
            at: H
          });
        case "insertLineBreak":
          return E(() => N.insertSoftBreak(t), {
            at: H
          });
        case "insertParagraph":
          return E(() => N.insertBreak(t), {
            at: H
          });
        case "insertCompositionText":
        case "deleteCompositionText":
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          if (CX(X))
            return E(() => Ce.insertData(t, X), {
              at: H
            });
          var re = X ?? "";
          if (co.get(t) && (re = re.replace("\uFEFF", "")), R === "insertText" && /.*\n.*\n$/.test(re) && (re = re.slice(0, -1)), re.includes(`
`))
            return E(() => {
              var Ue = re.split(`
`);
              Ue.forEach((he, Xe) => {
                he && N.insertText(t, he), Xe !== Ue.length - 1 && N.insertSoftBreak(t);
              });
            }, {
              at: H
            });
          if (oe.equals(H.anchor.path, H.focus.path)) {
            var [Te, ne] = ye.edges(H), Ee = {
              start: Te.offset,
              end: ne.offset,
              text: re
            };
            if (re && u && R === "insertCompositionText") {
              var Ne = u.start + u.text.search(/\S|$/), Fe = Ee.start + Ee.text.search(/\S|$/);
              Fe === Ne + 1 && Ee.end === u.start + u.text.length ? (Ee.start -= 1, u = null, M()) : u = !1;
            } else R === "insertText" ? u === null ? u = Ee : u && ye.isCollapsed(H) && u.end + u.text.length === Te.offset ? u = Hu(Hu({}, u), {}, {
              text: u.text + re
            }) : u = !1 : u = !1;
            if (S) {
              h(Te.path, Ee);
              return;
            }
          }
          return E(() => N.insertText(t, re), {
            at: H
          });
        }
      }
    }
  }, x = () => !!hi.get(t), T = () => {
    var $;
    return !!(($ = Ar.get(t)) !== null && $ !== void 0 && $.length);
  }, w = () => x() || T(), C = () => o, k = ($) => {
    gi.set(t, $), s && (clearTimeout(s), s = null);
    var {
      selection: W
    } = t;
    if ($) {
      var R = !W || !oe.equals(W.anchor.path, $.anchor.path), H = !W || !oe.equals(W.anchor.path.slice(0, -1), $.anchor.path.slice(0, -1));
      (R && u || H) && (u = !1), (R || T()) && (s = setTimeout(d, bX));
    }
  }, O = () => {
    (x() || !T()) && d();
  }, U = ($) => {
    T() || (f(!0), setTimeout(f));
  }, M = () => {
    x() || (a = setTimeout(d));
  }, V = ($) => {
    if (!(T() || x()) && $.some((R) => ay(t, R, $))) {
      var W;
      (W = RT.get(t)) === null || W === void 0 || W();
    }
  };
  return {
    flush: d,
    scheduleFlush: M,
    hasPendingDiffs: T,
    hasPendingAction: x,
    hasPendingChanges: w,
    isFlushing: C,
    handleUserSelect: k,
    handleCompositionEnd: g,
    handleCompositionStart: m,
    handleDOMBeforeInput: L,
    handleKeyDown: U,
    handleDomMutations: V,
    handleInput: O
  };
}
function xX() {
  var e = rt(!1);
  return v(() => (e.current = !0, () => {
    e.current = !1;
  }), []), e.current;
}
var cl = lc ? nB : v;
function LX(e, t, n) {
  var [r] = D(() => new MutationObserver(t));
  cl(() => {
    r.takeRecords();
  }), v(() => {
    if (!e.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(e.current, n), () => r.disconnect();
  }, [r, e, n]);
}
var kX = ["node"];
function Ok(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function DX(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Ok(Object(n), !0).forEach(function(r) {
      uo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Ok(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var SX = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, OX = Dr ? (e) => {
  var {
    node: t
  } = e, n = js(e, kX);
  if (!Dr)
    return null;
  var r = ji(), o = xX(), [i] = D(() => EX(DX({
    editor: r
  }, n)));
  return LX(t, i.handleDomMutations, SX), iy.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, MX = ["anchor", "focus"], PX = ["anchor", "focus"], TX = (e, t) => Object.keys(e).length === Object.keys(t).length && Object.keys(e).every((n) => t.hasOwnProperty(n) && e[n] === t[n]), qT = (e, t) => {
  var n = js(e, MX), r = js(t, PX);
  return e[Ns] === t[Ns] && TX(n, r);
}, AX = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (!ye.equals(r, o) || !qT(r, o))
      return !1;
  }
  return !0;
}, BX = (e, t) => {
  if (e.length !== t.length)
    return !1;
  for (var n = 0; n < e.length; n++) {
    var r = e[n], o = t[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !qT(r, o))
      return !1;
  }
  return !0;
};
function Mk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _X(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Mk(Object(n), !0).forEach(function(r) {
      uo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Mk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var IX = (e) => {
  var {
    isLast: t,
    leaf: n,
    parent: r,
    text: o
  } = e, i = ji(), s = Ce.findPath(i, o), a = oe.parent(s), l = !!n[zT];
  return i.isVoid(r) ? /* @__PURE__ */ Be.createElement(lh, {
    length: Ae.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && N.string(i, a) === "" ? /* @__PURE__ */ Be.createElement(lh, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ Be.createElement(lh, {
    isMarkPlaceholder: l
  }) : t && n.text.slice(-1) === `
` ? /* @__PURE__ */ Be.createElement(Pk, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ Be.createElement(Pk, {
    text: n.text
  });
}, Pk = (e) => {
  var {
    text: t,
    isTrailing: n = !1
  } = e, r = rt(null), o = () => "".concat(t ?? "").concat(n ? `
` : ""), [i] = D(o);
  return cl(() => {
    var s = o();
    r.current && r.current.textContent !== s && (r.current.textContent = s);
  }), /* @__PURE__ */ Be.createElement(jX, {
    ref: r
  }, i);
}, jX = /* @__PURE__ */ Re(/* @__PURE__ */ Fs((e, t) => /* @__PURE__ */ Be.createElement("span", {
  "data-slate-string": !0,
  ref: t
}, e.children))), lh = (e) => {
  var {
    length: t = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = e, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": t
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ Be.createElement("span", _X({}, o), !(Dr || jT) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ Be.createElement("br", null) : null);
};
function Tk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function GT(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Tk(Object(n), !0).forEach(function(r) {
      uo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Tk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var NX = Dr ? 300 : 0;
function FX(e, t) {
  e.current && (e.current.disconnect(), t && (e.current = null));
}
function Ak(e) {
  e.current && (clearTimeout(e.current), e.current = null);
}
var RX = (e) => {
  var {
    leaf: t,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: s = (L) => /* @__PURE__ */ Be.createElement(UX, GT({}, L))
  } = e, a = ji(), l = rt(null), u = rt(null), [c, p] = D(!1), d = rt(null), g = Zt((L) => {
    if (FX(l, L == null), L == null) {
      var x;
      Rg.delete(a), (x = t.onPlaceholderResize) === null || x === void 0 || x.call(t, null);
    } else {
      if (Rg.set(a, L), !l.current) {
        var T = window.ResizeObserver || HY;
        l.current = new T(() => {
          var w;
          (w = t.onPlaceholderResize) === null || w === void 0 || w.call(t, L);
        });
      }
      l.current.observe(L), u.current = L;
    }
  }, [u, t, a]), m = /* @__PURE__ */ Be.createElement(IX, {
    isLast: n,
    leaf: t,
    parent: o,
    text: r
  }), f = !!t[Ns];
  if (v(() => (f ? d.current || (d.current = setTimeout(() => {
    p(!0), d.current = null;
  }, NX)) : (Ak(d), p(!1)), () => Ak(d)), [f, p]), f && c) {
    var h = {
      children: t.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: ts ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: g
      }
    };
    m = /* @__PURE__ */ Be.createElement(Be.Fragment, null, i(h), m);
  }
  var E = {
    "data-slate-leaf": !0
  };
  return s({
    attributes: E,
    children: m,
    leaf: t,
    text: r
  });
}, zX = /* @__PURE__ */ Be.memo(RX, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && We.equals(t.leaf, e.leaf) && t.leaf[Ns] === e.leaf[Ns]), UX = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return /* @__PURE__ */ Be.createElement("span", GT({}, t), n);
}, $X = (e) => {
  for (var {
    decorations: t,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: s
  } = e, a = ji(), l = rt(null), u = We.decorations(s, t), c = Ce.findKey(a, s), p = [], d = 0; d < u.length; d++) {
    var g = u[d];
    p.push(/* @__PURE__ */ Be.createElement(zX, {
      isLast: n && d === u.length - 1,
      key: "".concat(c.id, "-").concat(d),
      renderPlaceholder: o,
      leaf: g,
      text: s,
      parent: r,
      renderLeaf: i
    }));
  }
  var m = Zt((f) => {
    var h = dd.get(a);
    f ? (h == null || h.set(c, f), hs.set(s, f), ul.set(f, s)) : (h == null || h.delete(c), hs.delete(s), l.current && ul.delete(l.current)), l.current = f;
  }, [l, a, c, s]);
  return /* @__PURE__ */ Be.createElement("span", {
    "data-slate-node": "text",
    ref: m
  }, p);
}, KT = /* @__PURE__ */ Be.memo($X, (e, t) => t.parent === e.parent && t.isLast === e.isLast && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && t.text === e.text && BX(t.decorations, e.decorations));
function Bk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Vg(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Bk(Object(n), !0).forEach(function(r) {
      uo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Bk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var WX = (e) => {
  var {
    decorations: t,
    element: n,
    renderElement: r = (L) => /* @__PURE__ */ Be.createElement(VX, Vg({}, L)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  } = e, a = ji(), l = GX(), u = a.isInline(n), c = Ce.findKey(a, n), p = Zt((L) => {
    var x = dd.get(a);
    L ? (x == null || x.set(c, L), hs.set(n, L), ul.set(L, n)) : (x == null || x.delete(c), hs.delete(n));
  }, [a, c, n]), d = XT({
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  }), g = {
    "data-slate-node": "element",
    ref: p
  };
  if (u && (g["data-slate-inline"] = !0), !u && N.hasInlines(a, n)) {
    var m = Ae.string(n), f = LT(m);
    f === "rtl" && (g.dir = f);
  }
  if (N.isVoid(a, n)) {
    g["data-slate-void"] = !0, !l && u && (g.contentEditable = !1);
    var h = u ? "span" : "div", [[E]] = Ae.texts(n);
    d = /* @__PURE__ */ Be.createElement(h, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ Be.createElement(KT, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: E
    })), ry.set(E, 0), oy.set(E, n);
  }
  return r({
    attributes: g,
    children: d,
    element: n
  });
}, HX = /* @__PURE__ */ Be.memo(WX, (e, t) => e.element === t.element && e.renderElement === t.renderElement && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && AX(e.decorations, t.decorations) && (e.selection === t.selection || !!e.selection && !!t.selection && ye.equals(e.selection, t.selection))), VX = (e) => {
  var {
    attributes: t,
    children: n,
    element: r
  } = e, o = ji(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ Be.createElement(i, Vg(Vg({}, t), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, YT = /* @__PURE__ */ Ye(() => []), ZX = () => _e(YT), qX = /* @__PURE__ */ Ye(!1), XT = (e) => {
  for (var {
    decorations: t,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: s
  } = e, a = ZX(), l = ji(), u = Ce.findPath(l, n), c = [], p = $e.isElement(n) && !l.isInline(n) && N.hasInlines(l, n), d = 0; d < n.children.length; d++) {
    var g = u.concat(d), m = n.children[d], f = Ce.findKey(l, m), h = N.range(l, g), E = s && ye.intersection(h, s), L = a([m, g]);
    for (var x of t) {
      var T = ye.intersection(x, h);
      T && L.push(T);
    }
    $e.isElement(m) ? c.push(/* @__PURE__ */ Be.createElement(qX.Provider, {
      key: "provider-".concat(f.id),
      value: !!E
    }, /* @__PURE__ */ Be.createElement(HX, {
      decorations: L,
      element: m,
      key: f.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: E
    }))) : c.push(/* @__PURE__ */ Be.createElement(KT, {
      decorations: L,
      key: f.id,
      isLast: p && d === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: m
    })), ry.set(m, d), oy.set(m, n);
  }
  return c;
}, QT = /* @__PURE__ */ Ye(!1), GX = () => _e(QT), JT = /* @__PURE__ */ Ye(null), ly = () => {
  var e = _e(JT);
  if (!e)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: t
  } = e;
  return t;
};
function KX() {
  var e = ji(), t = rt(!1), n = rt(0), r = Zt(() => {
    if (!t.current) {
      t.current = !0;
      var o = Ce.getWindow(e);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        t.current = !1;
      });
    }
  }, [e]);
  return v(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: t,
    onUserInput: r
  };
}
var YX = 3, XX = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, QX = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, JX = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, _n = (e) => {
  var t = XX[e], n = QX[e], r = JX[e], o = t && Qf(t), i = n && Qf(n), s = r && Qf(r);
  return (a) => !!(o && o(a) || xk && i && i(a) || !xk && s && s(a));
}, Un = {
  isBold: _n("bold"),
  isCompose: _n("compose"),
  isMoveBackward: _n("moveBackward"),
  isMoveForward: _n("moveForward"),
  isDeleteBackward: _n("deleteBackward"),
  isDeleteForward: _n("deleteForward"),
  isDeleteLineBackward: _n("deleteLineBackward"),
  isDeleteLineForward: _n("deleteLineForward"),
  isDeleteWordBackward: _n("deleteWordBackward"),
  isDeleteWordForward: _n("deleteWordForward"),
  isExtendBackward: _n("extendBackward"),
  isExtendForward: _n("extendForward"),
  isExtendLineBackward: _n("extendLineBackward"),
  isExtendLineForward: _n("extendLineForward"),
  isItalic: _n("italic"),
  isMoveLineBackward: _n("moveLineBackward"),
  isMoveLineForward: _n("moveLineForward"),
  isMoveWordBackward: _n("moveWordBackward"),
  isMoveWordForward: _n("moveWordForward"),
  isRedo: _n("redo"),
  isSoftBreak: _n("insertSoftBreak"),
  isSplitBlock: _n("splitBlock"),
  isTransposeCharacter: _n("transposeCharacter"),
  isUndo: _n("undo")
}, eQ = (e, t) => {
  var n = [], r = () => {
    n = [];
  }, o = (s) => {
    if (t.current) {
      var a = s.filter((l) => ay(e, l, s));
      n.push(...a);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((s) => {
      s.type !== "characterData" && (s.removedNodes.forEach((a) => {
        s.target.insertBefore(a, s.nextSibling);
      }), s.addedNodes.forEach((a) => {
        s.target.removeChild(a);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, tQ = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class eA extends Yc {
  constructor() {
    super(...arguments), uo(this, "context", null), uo(this, "manager", null), uo(this, "mutationObserver", null);
  }
  observe() {
    var t, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (t = this.mutationObserver) === null || t === void 0 || t.observe(n.current, tQ);
  }
  componentDidMount() {
    var {
      receivedUserInput: t
    } = this.props, n = this.context;
    this.manager = eQ(n, t), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var t, n, r, o = (t = this.mutationObserver) === null || t === void 0 ? void 0 : t.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var t;
    (t = this.manager) === null || t === void 0 || t.clear(), this.observe();
  }
  componentWillUnmount() {
    var t;
    (t = this.mutationObserver) === null || t === void 0 || t.disconnect();
  }
  render() {
    return this.props.children;
  }
}
uo(eA, "contextType", ny);
var nQ = Dr ? eA : (e) => {
  var {
    children: t
  } = e;
  return /* @__PURE__ */ Be.createElement(Be.Fragment, null, t);
}, rQ = /* @__PURE__ */ Ye(!1), oQ = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], iQ = ["text"];
function _k(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vo(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? _k(Object(n), !0).forEach(function(r) {
      uo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : _k(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var sQ = (e) => /* @__PURE__ */ Be.createElement(Be.Fragment, null, XT(e)), aQ = /* @__PURE__ */ Fs((e, t) => {
  var n = Zt((b) => /* @__PURE__ */ Be.createElement(lQ, vo({}, b)), []), {
    autoFocus: r,
    decorate: o = uQ,
    onDOMBeforeInput: i,
    placeholder: s,
    readOnly: a = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: p = cQ,
    style: d = {},
    as: g = "div",
    disableDefaultStyles: m = !1
  } = e, f = js(e, oQ), h = ly(), [E, L] = D(!1), x = rt(null), T = rt([]), [w, C] = D(), k = rt(!1), {
    onUserInput: O,
    receivedUserInput: U
  } = KX(), [, M] = tB((b) => b + 1, 0);
  RT.set(h, M), zg.set(h, a);
  var V = rr(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  v(() => {
    x.current && r && x.current.focus();
  }, [r]);
  var $ = rt(), W = rr(() => wY(() => {
    var b = Ce.toDOMNode(h, h), F = b.getRootNode();
    if (!k.current && ts && F instanceof ShadowRoot) {
      k.current = !0;
      var z = lX();
      z ? document.execCommand("indent") : Le.deselect(h), k.current = !1;
      return;
    }
    var A = $.current;
    if ((Dr || !Ce.isComposing(h)) && (!V.isUpdatingSelection || A != null && A.isFlushing()) && !V.isDraggingInternally) {
      var Y = Ce.findDocumentOrShadowRoot(h), {
        activeElement: ee
      } = Y, B = Ce.toDOMNode(h, h), se = Ra(Y);
      if (ee === B ? (V.latestElement = ee, Ci.set(h, !0)) : Ci.delete(h), !se)
        return Le.deselect(h);
      var {
        anchorNode: ue,
        focusNode: ce
      } = se, de = Ce.hasEditableTarget(h, ue) || Ce.isTargetInsideNonReadonlyVoid(h, ue), be = Ce.hasTarget(h, ce);
      if (de && be) {
        var ge = Ce.toSlateRange(h, se, {
          exactMatch: !1,
          suppressThrow: !0
        });
        ge && (!Ce.isComposing(h) && !(A != null && A.hasPendingChanges()) && !(A != null && A.isFlushing()) ? Le.select(h, ge) : A == null || A.handleUserSelect(ge));
      }
      a && (!de || !be) && Le.deselect(h);
    }
  }, 100), [h, a, V]), R = rr(() => hY(W, 0), [W]);
  $.current = OX({
    node: x,
    onDOMSelectionChange: W,
    scheduleOnDOMSelectionChange: R
  }), cl(() => {
    var b, F, z;
    x.current && (z = sy(x.current)) ? (FT.set(h, z), uc.set(h, x.current), hs.set(h, x.current), ul.set(x.current, h)) : hs.delete(h);
    var {
      selection: A
    } = h, Y = Ce.findDocumentOrShadowRoot(h), ee = Ra(Y);
    if (!(!ee || !Ce.isFocused(h) || (b = $.current) !== null && b !== void 0 && b.hasPendingAction())) {
      var B = (de) => {
        var be = ee.type !== "None";
        if (!(!A && !be)) {
          var ge = ee.focusNode, me;
          if (Ps && ee.rangeCount > 1) {
            var ae = ee.getRangeAt(0), xe = ee.getRangeAt(ee.rangeCount - 1);
            ae.startContainer === ge ? me = xe.endContainer : me = ae.startContainer;
          } else
            me = ee.anchorNode;
          var re = uc.get(h), Te = !1;
          if (re.contains(me) && re.contains(ge) && (Te = !0), be && Te && A && !de) {
            var ne = Ce.toSlateRange(h, ee, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (ne && ye.equals(ne, A)) {
              var Ee;
              if (!V.hasMarkPlaceholder || (Ee = me) !== null && Ee !== void 0 && (Ee = Ee.parentElement) !== null && Ee !== void 0 && Ee.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (A && !Ce.hasRange(h, A)) {
            h.selection = Ce.toSlateRange(h, ee, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          V.isUpdatingSelection = !0;
          var Ne = A && Ce.toDOMRange(h, A);
          return Ne ? (Ce.isComposing(h) && !Dr ? ee.collapseToEnd() : ye.isBackward(A) ? ee.setBaseAndExtent(Ne.endContainer, Ne.endOffset, Ne.startContainer, Ne.startOffset) : ee.setBaseAndExtent(Ne.startContainer, Ne.startOffset, Ne.endContainer, Ne.endOffset), p(h, Ne)) : ee.removeAllRanges(), Ne;
        }
      };
      ee.rangeCount <= 1 && B();
      var se = ((F = $.current) === null || F === void 0 ? void 0 : F.isFlushing()) === "action";
      if (!Dr || !se) {
        setTimeout(() => {
          V.isUpdatingSelection = !1;
        });
        return;
      }
      var ue = null, ce = requestAnimationFrame(() => {
        if (se) {
          var de = (be) => {
            try {
              var ge = Ce.toDOMNode(h, h);
              ge.focus(), B(be);
            } catch {
            }
          };
          de(), ue = setTimeout(() => {
            de(!0), V.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(ce), ue && clearTimeout(ue);
      };
    }
  });
  var H = Zt((b) => {
    var F = Ce.toDOMNode(h, h), z = F.getRootNode();
    if (k != null && k.current && ts && z instanceof ShadowRoot) {
      var A = b.getTargetRanges(), Y = A[0], ee = new window.Range();
      ee.setStart(Y.startContainer, Y.startOffset), ee.setEnd(Y.endContainer, Y.endOffset);
      var B = Ce.toSlateRange(h, ee, {
        exactMatch: !1,
        suppressThrow: !1
      });
      Le.select(h, B), b.preventDefault(), b.stopImmediatePropagation();
      return;
    }
    if (O(), !a && Ce.hasEditableTarget(h, b.target) && !pQ(b, i)) {
      var se;
      if ($.current)
        return $.current.handleDOMBeforeInput(b);
      R.flush(), W.flush();
      var {
        selection: ue
      } = h, {
        inputType: ce
      } = b, de = b.dataTransfer || b.data || void 0, be = ce === "insertCompositionText" || ce === "deleteCompositionText";
      if (be && Ce.isComposing(h))
        return;
      var ge = !1;
      if (ce === "insertText" && ue && ye.isCollapsed(ue) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ) to choose a special character otherwise
      // causes duplicate inserts.
      b.data && b.data.length === 1 && /[a-z ]/i.test(b.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      ue.anchor.offset !== 0) {
        var me, ae;
        ge = !0, h.marks && (ge = !1);
        var {
          anchor: xe
        } = ue, [re, Te] = Ce.toDOMPoint(h, xe), ne = (me = re.parentElement) === null || me === void 0 ? void 0 : me.closest("a"), Ee = Ce.getWindow(h);
        if (ge && ne && Ce.hasDOMNode(h, ne)) {
          var Ne, Fe = Ee == null ? void 0 : Ee.document.createTreeWalker(ne, NodeFilter.SHOW_TEXT).lastChild();
          Fe === re && ((Ne = Fe.textContent) === null || Ne === void 0 ? void 0 : Ne.length) === Te && (ge = !1);
        }
        if (ge && re.parentElement && (Ee == null || (ae = Ee.getComputedStyle(re.parentElement)) === null || ae === void 0 ? void 0 : ae.whiteSpace) === "pre") {
          var Ue = N.above(h, {
            at: xe.path,
            match: (mt) => $e.isElement(mt) && N.isBlock(h, mt)
          });
          Ue && Ae.string(Ue[0]).includes("	") && (ge = !1);
        }
      }
      if (!ce.startsWith("delete") || ce.startsWith("deleteBy")) {
        var [he] = b.getTargetRanges();
        if (he) {
          var Xe = Ce.toSlateRange(h, he, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!ue || !ye.equals(ue, Xe)) {
            ge = !1;
            var He = !be && h.selection && N.rangeRef(h, h.selection);
            Le.select(h, Xe), He && Fa.set(h, He);
          }
        }
      }
      if (be)
        return;
      if (ge || b.preventDefault(), ue && ye.isExpanded(ue) && ce.startsWith("delete")) {
        var qt = ce.endsWith("Backward") ? "backward" : "forward";
        N.deleteFragment(h, {
          direction: qt
        });
        return;
      }
      switch (ce) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          N.deleteFragment(h);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          N.deleteForward(h);
          break;
        }
        case "deleteContentBackward": {
          N.deleteBackward(h);
          break;
        }
        case "deleteEntireSoftLine": {
          N.deleteBackward(h, {
            unit: "line"
          }), N.deleteForward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          N.deleteBackward(h, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          N.deleteBackward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          N.deleteForward(h, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          N.deleteForward(h, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          N.deleteBackward(h, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          N.deleteForward(h, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          N.insertSoftBreak(h);
          break;
        case "insertParagraph": {
          N.insertBreak(h);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          ce === "insertFromComposition" && Ce.isComposing(h) && (L(!1), ps.set(h, !1)), (de == null ? void 0 : de.constructor.name) === "DataTransfer" ? Ce.insertData(h, de) : typeof de == "string" && (ge ? T.current.push(() => N.insertText(h, de)) : N.insertText(h, de));
          break;
        }
      }
      var lt = (se = Fa.get(h)) === null || se === void 0 ? void 0 : se.unref();
      Fa.delete(h), lt && (!h.selection || !ye.equals(h.selection, lt)) && Le.select(h, lt);
    }
  }, [h, W, O, i, a, R]), X = Zt((b) => {
    b == null ? (W.cancel(), R.cancel(), uc.delete(h), hs.delete(h), x.current && ri && x.current.removeEventListener("beforeinput", H)) : ri && b.addEventListener("beforeinput", H), x.current = b, typeof t == "function" ? t(b) : t && (t.current = b);
  }, [W, R, h, H, t]);
  cl(() => {
    var b = Ce.getWindow(h);
    b.document.addEventListener("selectionchange", R);
    var F = () => {
      V.isDraggingInternally = !1;
    };
    return b.document.addEventListener("dragend", F), b.document.addEventListener("drop", F), () => {
      b.document.removeEventListener("selectionchange", R), b.document.removeEventListener("dragend", F), b.document.removeEventListener("drop", F);
    };
  }, [R, V]);
  var I = o([h, []]), J = s && h.children.length === 1 && Array.from(Ae.texts(h)).length === 1 && Ae.string(h) === "" && !E, te = Zt((b) => {
    if (b && J) {
      var F;
      C((F = b.getBoundingClientRect()) === null || F === void 0 ? void 0 : F.height);
    } else
      C(void 0);
  }, [J]);
  if (J) {
    var S = N.start(h, []);
    I.push({
      [Ns]: !0,
      placeholder: s,
      onPlaceholderResize: te,
      anchor: S,
      focus: S
    });
  }
  var {
    marks: P
  } = h;
  if (V.hasMarkPlaceholder = !1, h.selection && ye.isCollapsed(h.selection) && P) {
    var {
      anchor: q
    } = h.selection, j = Ae.leaf(h, q.path), Z = js(j, iQ);
    if (!We.equals(j, P, {
      loose: !0
    })) {
      V.hasMarkPlaceholder = !0;
      var G = Object.fromEntries(Object.keys(Z).map((b) => [b, null]));
      I.push(vo(vo(vo({
        [zT]: !0
      }, G), P), {}, {
        anchor: q,
        focus: q
      }));
    }
  }
  return v(() => {
    setTimeout(() => {
      var {
        selection: b
      } = h;
      if (b) {
        var {
          anchor: F
        } = b, z = Ae.leaf(h, F.path);
        if (P && !We.equals(z, P, {
          loose: !0
        })) {
          co.set(h, P);
          return;
        }
      }
      co.delete(h);
    });
  }), /* @__PURE__ */ Be.createElement(QT.Provider, {
    value: a
  }, /* @__PURE__ */ Be.createElement(rQ.Provider, {
    value: E
  }, /* @__PURE__ */ Be.createElement(YT.Provider, {
    value: o
  }, /* @__PURE__ */ Be.createElement(nQ, {
    node: x,
    receivedUserInput: U
  }, /* @__PURE__ */ Be.createElement(g, vo(vo({
    role: a ? void 0 : "textbox",
    "aria-multiline": a ? void 0 : !0
  }, f), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: ri || !lc ? f.spellCheck : !1,
    autoCorrect: ri || !lc ? f.autoCorrect : "false",
    autoCapitalize: ri || !lc ? f.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !a,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: X,
    style: vo(vo({}, m ? {} : vo({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, w ? {
      minHeight: w
    } : {})), d),
    onBeforeInput: Zt((b) => {
      if (!ri && !a && !kr(b, f.onBeforeInput) && Ce.hasSelectableTarget(h, b.target) && (b.preventDefault(), !Ce.isComposing(h))) {
        var F = b.data;
        N.insertText(h, F);
      }
    }, [f.onBeforeInput, h, a]),
    onInput: Zt((b) => {
      if (!kr(b, f.onInput)) {
        if ($.current) {
          $.current.handleInput();
          return;
        }
        for (var F of T.current)
          F();
        T.current = [];
      }
    }, [f.onInput]),
    onBlur: Zt((b) => {
      if (!(a || V.isUpdatingSelection || !Ce.hasSelectableTarget(h, b.target) || kr(b, f.onBlur))) {
        var F = Ce.findDocumentOrShadowRoot(h);
        if (V.latestElement !== F.activeElement) {
          var {
            relatedTarget: z
          } = b, A = Ce.toDOMNode(h, h);
          if (z !== A && !(lo(z) && z.hasAttribute("data-slate-spacer"))) {
            if (z != null && xi(z) && Ce.hasDOMNode(h, z)) {
              var Y = Ce.toSlateNode(h, z);
              if ($e.isElement(Y) && !h.isVoid(Y))
                return;
            }
            if (ts) {
              var ee = Ra(F);
              ee == null || ee.removeAllRanges();
            }
            Ci.delete(h);
          }
        }
      }
    }, [a, V.isUpdatingSelection, V.latestElement, h, f.onBlur]),
    onClick: Zt((b) => {
      if (Ce.hasTarget(h, b.target) && !kr(b, f.onClick) && xi(b.target)) {
        var F = Ce.toSlateNode(h, b.target), z = Ce.findPath(h, F);
        if (!N.hasPath(h, z) || Ae.get(h, z) !== F)
          return;
        if (b.detail === YX && z.length >= 1) {
          var A = z;
          if (!($e.isElement(F) && N.isBlock(h, F))) {
            var Y, ee = N.above(h, {
              match: (ge) => $e.isElement(ge) && N.isBlock(h, ge),
              at: z
            });
            A = (Y = ee == null ? void 0 : ee[1]) !== null && Y !== void 0 ? Y : z.slice(0, 1);
          }
          var B = N.range(h, A);
          Le.select(h, B);
          return;
        }
        if (a)
          return;
        var se = N.start(h, z), ue = N.end(h, z), ce = N.void(h, {
          at: se
        }), de = N.void(h, {
          at: ue
        });
        if (ce && de && oe.equals(ce[1], de[1])) {
          var be = N.range(h, se);
          Le.select(h, be);
        }
      }
    }, [h, f.onClick, a]),
    onCompositionEnd: Zt((b) => {
      if (Ce.hasSelectableTarget(h, b.target)) {
        var F;
        if (Ce.isComposing(h) && Promise.resolve().then(() => {
          L(!1), ps.set(h, !1);
        }), (F = $.current) === null || F === void 0 || F.handleCompositionEnd(b), kr(b, f.onCompositionEnd) || Dr)
          return;
        if (!ts && !XY && !jT && !JY && !QY && b.data) {
          var z = co.get(h);
          co.delete(h), z !== void 0 && (zo.set(h, h.marks), h.marks = z), N.insertText(h, b.data);
          var A = zo.get(h);
          zo.delete(h), A !== void 0 && (h.marks = A);
        }
      }
    }, [f.onCompositionEnd, h]),
    onCompositionUpdate: Zt((b) => {
      Ce.hasSelectableTarget(h, b.target) && !kr(b, f.onCompositionUpdate) && (Ce.isComposing(h) || (L(!0), ps.set(h, !0)));
    }, [f.onCompositionUpdate, h]),
    onCompositionStart: Zt((b) => {
      if (Ce.hasSelectableTarget(h, b.target)) {
        var F;
        if ((F = $.current) === null || F === void 0 || F.handleCompositionStart(b), kr(b, f.onCompositionStart) || Dr)
          return;
        L(!0);
        var {
          selection: z
        } = h;
        if (z && ye.isExpanded(z)) {
          N.deleteFragment(h);
          return;
        }
      }
    }, [f.onCompositionStart, h]),
    onCopy: Zt((b) => {
      Ce.hasSelectableTarget(h, b.target) && !kr(b, f.onCopy) && !Ik(b) && (b.preventDefault(), Ce.setFragmentData(h, b.clipboardData, "copy"));
    }, [f.onCopy, h]),
    onCut: Zt((b) => {
      if (!a && Ce.hasSelectableTarget(h, b.target) && !kr(b, f.onCut) && !Ik(b)) {
        b.preventDefault(), Ce.setFragmentData(h, b.clipboardData, "cut");
        var {
          selection: F
        } = h;
        if (F)
          if (ye.isExpanded(F))
            N.deleteFragment(h);
          else {
            var z = Ae.parent(h, F.anchor.path);
            N.isVoid(h, z) && Le.delete(h);
          }
      }
    }, [a, h, f.onCut]),
    onDragOver: Zt((b) => {
      if (Ce.hasTarget(h, b.target) && !kr(b, f.onDragOver)) {
        var F = Ce.toSlateNode(h, b.target);
        $e.isElement(F) && N.isVoid(h, F) && b.preventDefault();
      }
    }, [f.onDragOver, h]),
    onDragStart: Zt((b) => {
      if (!a && Ce.hasTarget(h, b.target) && !kr(b, f.onDragStart)) {
        var F = Ce.toSlateNode(h, b.target), z = Ce.findPath(h, F), A = $e.isElement(F) && N.isVoid(h, F) || N.void(h, {
          at: z,
          voids: !0
        });
        if (A) {
          var Y = N.range(h, z);
          Le.select(h, Y);
        }
        V.isDraggingInternally = !0, Ce.setFragmentData(h, b.dataTransfer, "drag");
      }
    }, [a, h, f.onDragStart, V]),
    onDrop: Zt((b) => {
      if (!a && Ce.hasTarget(h, b.target) && !kr(b, f.onDrop)) {
        b.preventDefault();
        var F = h.selection, z = Ce.findEventRange(h, b), A = b.dataTransfer;
        Le.select(h, z), V.isDraggingInternally && F && !ye.equals(F, z) && !N.void(h, {
          at: z,
          voids: !0
        }) && Le.delete(h, {
          at: F
        }), Ce.insertData(h, A), Ce.isFocused(h) || Ce.focus(h);
      }
    }, [a, h, f.onDrop, V]),
    onDragEnd: Zt((b) => {
      !a && V.isDraggingInternally && f.onDragEnd && Ce.hasTarget(h, b.target) && f.onDragEnd(b);
    }, [a, V, f, h]),
    onFocus: Zt((b) => {
      if (!a && !V.isUpdatingSelection && Ce.hasEditableTarget(h, b.target) && !kr(b, f.onFocus)) {
        var F = Ce.toDOMNode(h, h), z = Ce.findDocumentOrShadowRoot(h);
        if (V.latestElement = z.activeElement, Ps && b.target !== F) {
          F.focus();
          return;
        }
        Ci.set(h, !0);
      }
    }, [a, V, h, f.onFocus]),
    onKeyDown: Zt((b) => {
      if (!a && Ce.hasEditableTarget(h, b.target)) {
        var F;
        (F = $.current) === null || F === void 0 || F.handleKeyDown(b);
        var {
          nativeEvent: z
        } = b;
        if (Ce.isComposing(h) && z.isComposing === !1 && (ps.set(h, !1), L(!1)), kr(b, f.onKeyDown) || Ce.isComposing(h))
          return;
        var {
          selection: A
        } = h, Y = h.children[A !== null ? A.focus.path[0] : 0], ee = LT(Ae.string(Y)) === "rtl";
        if (Un.isRedo(z)) {
          b.preventDefault();
          var B = h;
          typeof B.redo == "function" && B.redo();
          return;
        }
        if (Un.isUndo(z)) {
          b.preventDefault();
          var se = h;
          typeof se.undo == "function" && se.undo();
          return;
        }
        if (Un.isMoveLineBackward(z)) {
          b.preventDefault(), Le.move(h, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (Un.isMoveLineForward(z)) {
          b.preventDefault(), Le.move(h, {
            unit: "line"
          });
          return;
        }
        if (Un.isExtendLineBackward(z)) {
          b.preventDefault(), Le.move(h, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (Un.isExtendLineForward(z)) {
          b.preventDefault(), Le.move(h, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (Un.isMoveBackward(z)) {
          b.preventDefault(), A && ye.isCollapsed(A) ? Le.move(h, {
            reverse: !ee
          }) : Le.collapse(h, {
            edge: ee ? "end" : "start"
          });
          return;
        }
        if (Un.isMoveForward(z)) {
          b.preventDefault(), A && ye.isCollapsed(A) ? Le.move(h, {
            reverse: ee
          }) : Le.collapse(h, {
            edge: ee ? "start" : "end"
          });
          return;
        }
        if (Un.isMoveWordBackward(z)) {
          b.preventDefault(), A && ye.isExpanded(A) && Le.collapse(h, {
            edge: "focus"
          }), Le.move(h, {
            unit: "word",
            reverse: !ee
          });
          return;
        }
        if (Un.isMoveWordForward(z)) {
          b.preventDefault(), A && ye.isExpanded(A) && Le.collapse(h, {
            edge: "focus"
          }), Le.move(h, {
            unit: "word",
            reverse: ee
          });
          return;
        }
        if (ri) {
          if ((NT || ts) && A && (Un.isDeleteBackward(z) || Un.isDeleteForward(z)) && ye.isCollapsed(A)) {
            var ue = Ae.parent(h, A.anchor.path);
            if ($e.isElement(ue) && N.isVoid(h, ue) && (N.isInline(h, ue) || N.isBlock(h, ue))) {
              b.preventDefault(), N.deleteBackward(h, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (Un.isBold(z) || Un.isItalic(z) || Un.isTransposeCharacter(z)) {
            b.preventDefault();
            return;
          }
          if (Un.isSoftBreak(z)) {
            b.preventDefault(), N.insertSoftBreak(h);
            return;
          }
          if (Un.isSplitBlock(z)) {
            b.preventDefault(), N.insertBreak(h);
            return;
          }
          if (Un.isDeleteBackward(z)) {
            b.preventDefault(), A && ye.isExpanded(A) ? N.deleteFragment(h, {
              direction: "backward"
            }) : N.deleteBackward(h);
            return;
          }
          if (Un.isDeleteForward(z)) {
            b.preventDefault(), A && ye.isExpanded(A) ? N.deleteFragment(h, {
              direction: "forward"
            }) : N.deleteForward(h);
            return;
          }
          if (Un.isDeleteLineBackward(z)) {
            b.preventDefault(), A && ye.isExpanded(A) ? N.deleteFragment(h, {
              direction: "backward"
            }) : N.deleteBackward(h, {
              unit: "line"
            });
            return;
          }
          if (Un.isDeleteLineForward(z)) {
            b.preventDefault(), A && ye.isExpanded(A) ? N.deleteFragment(h, {
              direction: "forward"
            }) : N.deleteForward(h, {
              unit: "line"
            });
            return;
          }
          if (Un.isDeleteWordBackward(z)) {
            b.preventDefault(), A && ye.isExpanded(A) ? N.deleteFragment(h, {
              direction: "backward"
            }) : N.deleteBackward(h, {
              unit: "word"
            });
            return;
          }
          if (Un.isDeleteWordForward(z)) {
            b.preventDefault(), A && ye.isExpanded(A) ? N.deleteFragment(h, {
              direction: "forward"
            }) : N.deleteForward(h, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [a, h, f.onKeyDown]),
    onPaste: Zt((b) => {
      !a && Ce.hasEditableTarget(h, b.target) && !kr(b, f.onPaste) && (!ri || nX(b.nativeEvent) || ts) && (b.preventDefault(), Ce.insertData(h, b.clipboardData));
    }, [a, h, f.onPaste])
  }), /* @__PURE__ */ Be.createElement(sQ, {
    decorations: I,
    node: h,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: h.selection
  }))))));
}), lQ = (e) => {
  var {
    attributes: t,
    children: n
  } = e;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ Be.createElement("span", vo({}, t), n, Dr && /* @__PURE__ */ Be.createElement("br", null))
  );
}, uQ = () => [], cQ = (e, t) => {
  if (t.getBoundingClientRect && (!e.selection || e.selection && ye.isCollapsed(e.selection))) {
    var n = t.startContainer.parentElement;
    n.getBoundingClientRect = t.getBoundingClientRect.bind(t), xY(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, kr = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? (e.isDefaultPrevented() || e.isPropagationStopped());
}, Ik = (e) => xi(e.target) && (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement), pQ = (e, t) => {
  if (!t)
    return !1;
  var n = t(e);
  return n ?? e.defaultPrevented;
}, dQ = /* @__PURE__ */ Ye(!1), fQ = /* @__PURE__ */ Ye({});
function hQ(e) {
  var t = rt([]).current, n = rt({
    editor: e
  }).current, r = Zt((i) => {
    n.editor = i, t.forEach((s) => s(i));
  }, [t, n]), o = rr(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (t.push(i), () => {
      t.splice(t.indexOf(i), 1);
    })
  }), [t, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var gQ = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], mQ = (e) => {
  var {
    editor: t,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: s
  } = e, a = js(e, gQ), [l, u] = Be.useState(() => {
    if (!Ae.isNodeList(s))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(dr.stringify(s)));
    if (!N.isEditor(t))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(dr.stringify(t)));
    return t.children = s, Object.assign(t, a), {
      v: 0,
      editor: t
    };
  }), {
    selectorContext: c,
    onChange: p
  } = hQ(t), d = Zt((f) => {
    var h;
    switch (r && r(t.children), f == null || (h = f.operation) === null || h === void 0 ? void 0 : h.type) {
      case "set_selection":
        o == null || o(t.selection);
        break;
      default:
        i == null || i(t.children);
    }
    u((E) => ({
      v: E.v + 1,
      editor: t
    })), p(t);
  }, [t, p, r, o, i]);
  v(() => (Ug.set(t, d), () => {
    Ug.set(t, () => {
    });
  }), [t, d]);
  var [g, m] = D(Ce.isFocused(t));
  return v(() => {
    m(Ce.isFocused(t));
  }, [t]), cl(() => {
    var f = () => m(Ce.isFocused(t));
    return IT >= 17 ? (document.addEventListener("focusin", f), document.addEventListener("focusout", f), () => {
      document.removeEventListener("focusin", f), document.removeEventListener("focusout", f);
    }) : (document.addEventListener("focus", f, !0), document.addEventListener("blur", f, !0), () => {
      document.removeEventListener("focus", f, !0), document.removeEventListener("blur", f, !0);
    });
  }, []), /* @__PURE__ */ Be.createElement(fQ.Provider, {
    value: c
  }, /* @__PURE__ */ Be.createElement(JT.Provider, {
    value: l
  }, /* @__PURE__ */ Be.createElement(ny.Provider, {
    value: l.editor
  }, /* @__PURE__ */ Be.createElement(dQ.Provider, {
    value: g
  }, n))));
}, jk = (e, t) => {
  var n = (t.top + t.bottom) / 2;
  return e.top <= n && e.bottom >= n;
}, Nk = (e, t, n) => {
  var r = Ce.toDOMRange(e, t).getBoundingClientRect(), o = Ce.toDOMRange(e, n).getBoundingClientRect();
  return jk(r, o) && jk(o, r);
}, vQ = (e, t) => {
  var n = N.range(e, ye.end(t)), r = Array.from(N.positions(e, {
    at: t
  })), o = 0, i = r.length, s = Math.floor(i / 2);
  if (Nk(e, N.range(e, r[o]), n))
    return N.range(e, r[o], n);
  if (r.length < 2)
    return N.range(e, r[r.length - 1], n);
  for (; s !== r.length && s !== o; )
    Nk(e, N.range(e, r[s]), n) ? i = s : o = s, s = Math.floor((o + i) / 2);
  return N.range(e, r[i], n);
};
function Fk(e, t) {
  var n = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(e);
    t && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(e, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rk(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t] != null ? arguments[t] : {};
    t % 2 ? Fk(Object(n), !0).forEach(function(r) {
      uo(e, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(n)) : Fk(Object(n)).forEach(function(r) {
      Object.defineProperty(e, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return e;
}
var yQ = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = t, {
    apply: o,
    onChange: i,
    deleteBackward: s,
    addMark: a,
    removeMark: l
  } = r;
  return dd.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var p, d;
    (p = iy.get(r)) === null || p === void 0 || p(), !co.get(r) && (d = Ar.get(r)) !== null && d !== void 0 && d.length && co.set(r, null), zo.delete(r), a(u, c);
  }, r.removeMark = (u) => {
    var c;
    !co.get(r) && (c = Ar.get(r)) !== null && c !== void 0 && c.length && co.set(r, null), zo.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return s(u);
    if (r.selection && ye.isCollapsed(r.selection)) {
      var c = N.above(r, {
        match: (m) => $e.isElement(m) && N.isBlock(r, m),
        at: r.selection
      });
      if (c) {
        var [, p] = c, d = N.range(r, p, r.selection.anchor), g = vQ(r, d);
        ye.isCollapsed(g) || Le.delete(r, {
          at: g
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], p = [], d = Ar.get(r);
    if (d != null && d.length) {
      var g = d.map((R) => vX(R, u)).filter(Boolean);
      Ar.set(r, g);
    }
    var m = gi.get(r);
    m && gi.set(r, Dk(r, m, u));
    var f = hi.get(r);
    if (f != null && f.at) {
      var h = gt.isPoint(f == null ? void 0 : f.at) ? Hg(r, f.at, u) : Dk(r, f.at, u);
      hi.set(r, h ? Rk(Rk({}, f), {}, {
        at: h
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...Os(r, u.path));
        break;
      }
      case "set_selection": {
        var E;
        (E = Fa.get(r)) === null || E === void 0 || E.unref(), Fa.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...Os(r, oe.parent(u.path)));
        break;
      }
      case "merge_node": {
        var L = oe.previous(u.path);
        c.push(...Os(r, L));
        break;
      }
      case "move_node": {
        var x = oe.common(oe.parent(u.path), oe.parent(u.newPath));
        c.push(...Os(r, x));
        var T;
        oe.isBefore(u.path, u.newPath) ? (c.push(...Os(r, oe.parent(u.path))), T = u.newPath) : (c.push(...Os(r, oe.parent(u.newPath))), T = u.path);
        var w = Ae.get(t, oe.parent(T)), C = Ce.findKey(r, w), k = N.pathRef(r, oe.parent(T));
        p.push([k, C]);
        break;
      }
    }
    o(u);
    for (var [O, U] of c) {
      var [M] = N.node(r, O);
      Zc.set(M, U);
    }
    for (var [V, $] of p)
      if (V.current) {
        var [W] = N.node(r, V.current);
        Zc.set(W, $);
      }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [p, d] = ye.edges(c), g = N.void(r, {
        at: p.path
      }), m = N.void(r, {
        at: d.path
      });
      if (!(ye.isCollapsed(c) && !g)) {
        var f = Ce.toDOMRange(r, c), h = f.cloneContents(), E = h.childNodes[0];
        if (h.childNodes.forEach((M) => {
          M.textContent && M.textContent.trim() !== "" && (E = M);
        }), m) {
          var [L] = m, x = f.cloneRange(), T = Ce.toDOMNode(r, L);
          x.setEndAfter(T), h = x.cloneContents();
        }
        if (g && (E = h.querySelector("[data-slate-spacer]")), Array.from(h.querySelectorAll("[data-slate-zero-width]")).forEach((M) => {
          var V = M.getAttribute("data-slate-zero-width") === "n";
          M.textContent = V ? `
` : "";
        }), $T(E)) {
          var w = E.ownerDocument.createElement("span");
          w.style.whiteSpace = "pre", w.appendChild(E), h.appendChild(w), E = w;
        }
        var C = r.getFragment(), k = JSON.stringify(C), O = window.btoa(encodeURIComponent(k));
        E.setAttribute("data-slate-fragment", O), u.setData("application/".concat(n), O);
        var U = h.ownerDocument.createElement("div");
        return U.appendChild(h), U.setAttribute("hidden", "true"), h.ownerDocument.body.appendChild(U), u.setData("text/html", U.innerHTML), u.setData("text/plain", HT(U)), h.ownerDocument.body.removeChild(U), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || aX(u);
    if (c) {
      var p = decodeURIComponent(window.atob(c)), d = JSON.parse(p);
      return r.insertFragment(d), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var p = c.split(/\r\n|\r|\n/), d = !1;
      for (var g of p)
        d && Le.splitNodes(r, {
          always: !0
        }), r.insertText(g), d = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = IT < 18 ? pl.unstable_batchedUpdates : (p) => p();
    c(() => {
      var p = Ug.get(r);
      p && p(u), i(u);
    });
  }, r;
}, Os = (e, t) => {
  var n = [];
  for (var [r, o] of N.levels(e, {
    at: t
  })) {
    var i = Ce.findKey(e, r);
    n.push([o, i]);
  }
  return n;
};
function tA(e, t, n = "type") {
  const { selection: r } = e;
  if (!r) return !1;
  const [o] = Array.from(
    N.nodes(e, {
      at: N.unhangRange(e, r),
      match: (i) => !N.isEditor(i) && $e.isElement(i) && i[n] === t
    })
  );
  return !!o;
}
const zk = ["listItem", "numberedList"], cc = ["left", "center", "right", "justify"];
function bQ(e, t) {
  const n = cc.includes(t) ? "align" : "type", r = tA(e, t, n), o = zk.includes(t);
  Le.unwrapNodes(e, {
    match: (s) => !N.isEditor(s) && $e.isElement(s) && zk.includes(s.type) && !cc.includes(t),
    split: !0
  });
  let i;
  if (cc.includes(t) ? i = { align: r ? void 0 : t } : i = {
    type: r ? "paragraph" : o ? "listItem" : t
  }, Le.setNodes(e, i), !r && o) {
    const s = { type: t, children: [] };
    Le.wrapNodes(e, s);
  }
}
function Ki({ format: e, icon: t }) {
  const n = ly(), r = cc.includes(e) ? "align" : "type", i = tA(n, e, r) ? "activeTrue" : "activeFalse";
  function s(a) {
    a.preventDefault(), bQ(n, e);
  }
  return /* @__PURE__ */ Q.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: s,
      children: /* @__PURE__ */ Q.jsx(t, {})
    }
  );
}
function wQ({ attributes: e, children: t, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ Q.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...e,
          children: t
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ Q.jsx("ul", { className: "arkynElementBulletList", style: r, ...e, children: t });
    case "headingOne":
      return /* @__PURE__ */ Q.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...e, children: t });
    case "headingTwo":
      return /* @__PURE__ */ Q.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...e, children: t });
    case "listItem":
      return /* @__PURE__ */ Q.jsx("li", { className: "arkynElementListItem", style: r, ...e, children: t });
    case "numberedList":
      return /* @__PURE__ */ Q.jsx("ol", { className: "arkynElementNumberedList", style: r, ...e, children: t });
    default:
      return /* @__PURE__ */ Q.jsx("p", { className: "arkynElementParagraph", style: r, ...e, children: t });
  }
}
function CQ({ attributes: e, children: t, leaf: n }) {
  return n.bold && (t = /* @__PURE__ */ Q.jsx("strong", { children: t })), n.code && (t = /* @__PURE__ */ Q.jsx("code", { children: t })), n.italic && (t = /* @__PURE__ */ Q.jsx("em", { children: t })), n.underline && (t = /* @__PURE__ */ Q.jsx("u", { children: t })), /* @__PURE__ */ Q.jsx("span", { ...e, children: t });
}
function nA(e, t) {
  const n = N.marks(e);
  return n ? n[t] === !0 : !1;
}
function rA(e, t) {
  nA(e, t) ? N.removeMark(e, t) : N.addMark(e, t, !0);
}
function Vu({ format: e, icon: t }) {
  const n = ly(), o = nA(n, e) ? "activeTrue" : "activeFalse";
  function i(s) {
    s.preventDefault(), rA(n, e);
  }
  return /* @__PURE__ */ Q.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ Q.jsx(t, {})
    }
  );
}
function EQ({ children: e }) {
  return /* @__PURE__ */ Q.jsx("div", { className: "arkynRichTextToolbar", children: e });
}
const Uk = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, xQ = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
var oA = {}, uy = {}, cy = {};
Object.defineProperty(cy, "__esModule", { value: !0 });
cy.default = SQ;
var $k = "html", Wk = "head", Zu = "body", LQ = /<([a-zA-Z]+[0-9]?)/, Hk = /<head[^]*>/i, Vk = /<body[^]*>/i, qc = function(e, t) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Zg = function(e, t) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, Zk = typeof window == "object" && window.DOMParser;
if (typeof Zk == "function") {
  var kQ = new Zk(), DQ = "text/html";
  Zg = function(e, t) {
    return t && (e = "<".concat(t, ">").concat(e, "</").concat(t, ">")), kQ.parseFromString(e, DQ);
  }, qc = Zg;
}
if (typeof document == "object" && document.implementation) {
  var qu = document.implementation.createHTMLDocument();
  qc = function(e, t) {
    if (t) {
      var n = qu.documentElement.querySelector(t);
      return n && (n.innerHTML = e), qu;
    }
    return qu.documentElement.innerHTML = e, qu;
  };
}
var Gu = typeof document == "object" && document.createElement("template"), qg;
Gu && Gu.content && (qg = function(e) {
  return Gu.innerHTML = e, Gu.content.childNodes;
});
function SQ(e) {
  var t, n, r = e.match(LQ), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case $k: {
      var i = Zg(e);
      if (!Hk.test(e)) {
        var s = i.querySelector(Wk);
        (t = s == null ? void 0 : s.parentNode) === null || t === void 0 || t.removeChild(s);
      }
      if (!Vk.test(e)) {
        var s = i.querySelector(Zu);
        (n = s == null ? void 0 : s.parentNode) === null || n === void 0 || n.removeChild(s);
      }
      return i.querySelectorAll($k);
    }
    case Wk:
    case Zu: {
      var a = qc(e).querySelectorAll(o);
      return Vk.test(e) && Hk.test(e) ? a[0].parentNode.childNodes : a;
    }
    default: {
      if (qg)
        return qg(e);
      var s = qc(e, Zu).querySelector(Zu);
      return s.childNodes;
    }
  }
}
var fd = {}, py = {}, dy = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.Doctype = e.CDATA = e.Tag = e.Style = e.Script = e.Comment = e.Directive = e.Text = e.Root = e.isTag = e.ElementType = void 0;
  var t;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(t = e.ElementType || (e.ElementType = {}));
  function n(r) {
    return r.type === t.Tag || r.type === t.Script || r.type === t.Style;
  }
  e.isTag = n, e.Root = t.Root, e.Text = t.Text, e.Directive = t.Directive, e.Comment = t.Comment, e.Script = t.Script, e.Style = t.Style, e.Tag = t.Tag, e.CDATA = t.CDATA, e.Doctype = t.Doctype;
})(dy);
var Lt = {}, Ni = en && en.__extends || /* @__PURE__ */ function() {
  var e = function(t, n) {
    return e = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, e(t, n);
  };
  return function(t, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    e(t, n);
    function r() {
      this.constructor = t;
    }
    t.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), za = en && en.__assign || function() {
  return za = Object.assign || function(e) {
    for (var t, n = 1, r = arguments.length; n < r; n++) {
      t = arguments[n];
      for (var o in t) Object.prototype.hasOwnProperty.call(t, o) && (e[o] = t[o]);
    }
    return e;
  }, za.apply(this, arguments);
};
Object.defineProperty(Lt, "__esModule", { value: !0 });
Lt.cloneNode = Lt.hasChildren = Lt.isDocument = Lt.isDirective = Lt.isComment = Lt.isText = Lt.isCDATA = Lt.isTag = Lt.Element = Lt.Document = Lt.CDATA = Lt.NodeWithChildren = Lt.ProcessingInstruction = Lt.Comment = Lt.Text = Lt.DataNode = Lt.Node = void 0;
var zr = dy, fy = (
  /** @class */
  function() {
    function e() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(e.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(t) {
        this.parent = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(t) {
        this.prev = t;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(t) {
        this.next = t;
      },
      enumerable: !1,
      configurable: !0
    }), e.prototype.cloneNode = function(t) {
      return t === void 0 && (t = !1), hy(this, t);
    }, e;
  }()
);
Lt.Node = fy;
var hd = (
  /** @class */
  function(e) {
    Ni(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(t.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(fy)
);
Lt.DataNode = hd;
var iA = (
  /** @class */
  function(e) {
    Ni(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = zr.ElementType.Text, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(hd)
);
Lt.Text = iA;
var sA = (
  /** @class */
  function(e) {
    Ni(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = zr.ElementType.Comment, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(hd)
);
Lt.Comment = sA;
var aA = (
  /** @class */
  function(e) {
    Ni(t, e);
    function t(n, r) {
      var o = e.call(this, r) || this;
      return o.name = n, o.type = zr.ElementType.Directive, o;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(hd)
);
Lt.ProcessingInstruction = aA;
var gd = (
  /** @class */
  function(e) {
    Ni(t, e);
    function t(n) {
      var r = e.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(t.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(fy)
);
Lt.NodeWithChildren = gd;
var lA = (
  /** @class */
  function(e) {
    Ni(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = zr.ElementType.CDATA, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gd)
);
Lt.CDATA = lA;
var uA = (
  /** @class */
  function(e) {
    Ni(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = zr.ElementType.Root, n;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gd)
);
Lt.Document = uA;
var cA = (
  /** @class */
  function(e) {
    Ni(t, e);
    function t(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? zr.ElementType.Script : n === "style" ? zr.ElementType.Style : zr.ElementType.Tag);
      var s = e.call(this, o) || this;
      return s.name = n, s.attribs = r, s.type = i, s;
    }
    return Object.defineProperty(t.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), t;
  }(gd)
);
Lt.Element = cA;
function pA(e) {
  return (0, zr.isTag)(e);
}
Lt.isTag = pA;
function dA(e) {
  return e.type === zr.ElementType.CDATA;
}
Lt.isCDATA = dA;
function fA(e) {
  return e.type === zr.ElementType.Text;
}
Lt.isText = fA;
function hA(e) {
  return e.type === zr.ElementType.Comment;
}
Lt.isComment = hA;
function gA(e) {
  return e.type === zr.ElementType.Directive;
}
Lt.isDirective = gA;
function mA(e) {
  return e.type === zr.ElementType.Root;
}
Lt.isDocument = mA;
function OQ(e) {
  return Object.prototype.hasOwnProperty.call(e, "children");
}
Lt.hasChildren = OQ;
function hy(e, t) {
  t === void 0 && (t = !1);
  var n;
  if (fA(e))
    n = new iA(e.data);
  else if (hA(e))
    n = new sA(e.data);
  else if (pA(e)) {
    var r = t ? uh(e.children) : [], o = new cA(e.name, za({}, e.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), e.namespace != null && (o.namespace = e.namespace), e["x-attribsNamespace"] && (o["x-attribsNamespace"] = za({}, e["x-attribsNamespace"])), e["x-attribsPrefix"] && (o["x-attribsPrefix"] = za({}, e["x-attribsPrefix"])), n = o;
  } else if (dA(e)) {
    var r = t ? uh(e.children) : [], i = new lA(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (mA(e)) {
    var r = t ? uh(e.children) : [], s = new uA(r);
    r.forEach(function(u) {
      return u.parent = s;
    }), e["x-mode"] && (s["x-mode"] = e["x-mode"]), n = s;
  } else if (gA(e)) {
    var a = new aA(e.name, e.data);
    e["x-name"] != null && (a["x-name"] = e["x-name"], a["x-publicId"] = e["x-publicId"], a["x-systemId"] = e["x-systemId"]), n = a;
  } else
    throw new Error("Not implemented yet: ".concat(e.type));
  return n.startIndex = e.startIndex, n.endIndex = e.endIndex, e.sourceCodeLocation != null && (n.sourceCodeLocation = e.sourceCodeLocation), n;
}
Lt.cloneNode = hy;
function uh(e) {
  for (var t = e.map(function(r) {
    return hy(r, !0);
  }), n = 1; n < t.length; n++)
    t[n].prev = t[n - 1], t[n - 1].next = t[n];
  return t;
}
(function(e) {
  var t = en && en.__createBinding || (Object.create ? function(a, l, u, c) {
    c === void 0 && (c = u);
    var p = Object.getOwnPropertyDescriptor(l, u);
    (!p || ("get" in p ? !l.__esModule : p.writable || p.configurable)) && (p = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(a, c, p);
  } : function(a, l, u, c) {
    c === void 0 && (c = u), a[c] = l[u];
  }), n = en && en.__exportStar || function(a, l) {
    for (var u in a) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && t(l, a, u);
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.DomHandler = void 0;
  var r = dy, o = Lt;
  n(Lt, e);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, s = (
    /** @class */
    function() {
      function a(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return a.prototype.onparserinit = function(l) {
        this.parser = l;
      }, a.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, a.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, a.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, a.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, a.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, p = new o.Element(l, u, void 0, c);
        this.addNode(p), this.tagStack.push(p);
      }, a.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, a.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, a.prototype.oncommentend = function() {
        this.lastNode = null;
      }, a.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, a.prototype.oncdataend = function() {
        this.lastNode = null;
      }, a.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, a.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, a.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, a;
    }()
  );
  e.DomHandler = s, e.default = s;
})(py);
var vA = {};
(function(e) {
  Object.defineProperty(e, "__esModule", { value: !0 }), e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES = void 0, e.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], e.CASE_SENSITIVE_TAG_NAMES_MAP = e.CASE_SENSITIVE_TAG_NAMES.reduce(function(t, n) {
    return t[n.toLowerCase()] = n, t;
  }, {});
})(vA);
Object.defineProperty(fd, "__esModule", { value: !0 });
fd.formatAttributes = yA;
fd.formatDOM = bA;
var Ku = py, MQ = vA;
function PQ(e) {
  return MQ.CASE_SENSITIVE_TAG_NAMES_MAP[e];
}
function yA(e) {
  for (var t = {}, n = 0, r = e.length; n < r; n++) {
    var o = e[n];
    t[o.name] = o.value;
  }
  return t;
}
function TQ(e) {
  e = e.toLowerCase();
  var t = PQ(e);
  return t || e;
}
function bA(e, t, n) {
  t === void 0 && (t = null);
  for (var r = [], o, i = 0, s = e.length; i < s; i++) {
    var a = e[i];
    switch (a.nodeType) {
      case 1: {
        var l = TQ(a.nodeName);
        o = new Ku.Element(l, yA(a.attributes)), o.children = bA(
          // template children are on content
          l === "template" ? a.content.childNodes : a.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Ku.Text(a.nodeValue);
        break;
      case 8:
        o = new Ku.Comment(a.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = t, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Ku.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = t, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var AQ = en && en.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(uy, "__esModule", { value: !0 });
uy.default = jQ;
var BQ = AQ(cy), _Q = fd, IQ = /<(![a-zA-Z\s]+)>/;
function jQ(e) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e)
    return [];
  var t = e.match(IQ), n = t ? t[1] : void 0;
  return (0, _Q.formatDOM)((0, BQ.default)(e), null, n);
}
var md = {}, go = {}, vd = {}, NQ = 0;
vd.SAME = NQ;
var FQ = 1;
vd.CAMELCASE = FQ;
vd.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const wA = 0, Fi = 1, yd = 2, bd = 3, gy = 4, CA = 5, EA = 6;
function RQ(e) {
  return yr.hasOwnProperty(e) ? yr[e] : null;
}
function Tr(e, t, n, r, o, i, s) {
  this.acceptsBooleans = t === yd || t === bd || t === gy, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = i, this.removeEmptyString = s;
}
const yr = {}, zQ = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
zQ.forEach((e) => {
  yr[e] = new Tr(
    e,
    wA,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([e, t]) => {
  yr[e] = new Tr(
    e,
    Fi,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((e) => {
  yr[e] = new Tr(
    e,
    yd,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((e) => {
  yr[e] = new Tr(
    e,
    yd,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((e) => {
  yr[e] = new Tr(
    e,
    bd,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  yr[e] = new Tr(
    e,
    bd,
    !0,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  yr[e] = new Tr(
    e,
    gy,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  yr[e] = new Tr(
    e,
    EA,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((e) => {
  yr[e] = new Tr(
    e,
    CA,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const my = /[\-\:]([a-z])/g, vy = (e) => e[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(my, vy);
  yr[t] = new Tr(
    t,
    Fi,
    !1,
    // mustUseProperty
    e,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(my, vy);
  yr[t] = new Tr(
    t,
    Fi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((e) => {
  const t = e.replace(my, vy);
  yr[t] = new Tr(
    t,
    Fi,
    !1,
    // mustUseProperty
    e,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((e) => {
  yr[e] = new Tr(
    e,
    Fi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const UQ = "xlinkHref";
yr[UQ] = new Tr(
  "xlinkHref",
  Fi,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((e) => {
  yr[e] = new Tr(
    e,
    Fi,
    !1,
    // mustUseProperty
    e.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: $Q,
  SAME: WQ,
  possibleStandardNames: qk
} = vd, HQ = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", VQ = HQ + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", ZQ = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + VQ + "]*$")
), qQ = Object.keys(
  qk
).reduce((e, t) => {
  const n = qk[t];
  return n === WQ ? e[t] = t : n === $Q ? e[t.toLowerCase()] = t : e[t] = n, e;
}, {});
go.BOOLEAN = bd;
go.BOOLEANISH_STRING = yd;
go.NUMERIC = CA;
go.OVERLOADED_BOOLEAN = gy;
go.POSITIVE_NUMERIC = EA;
go.RESERVED = wA;
go.STRING = Fi;
go.getPropertyInfo = RQ;
go.isCustomAttribute = ZQ;
go.possibleStandardNames = qQ;
var yy = {}, by = {}, Gk = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, GQ = /\n/g, KQ = /^\s*/, YQ = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, XQ = /^:\s*/, QQ = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, JQ = /^[;\s]*/, eJ = /^\s+|\s+$/g, tJ = `
`, Kk = "/", Yk = "*", is = "", nJ = "comment", rJ = "declaration", oJ = function(e, t) {
  if (typeof e != "string")
    throw new TypeError("First argument must be a string");
  if (!e) return [];
  t = t || {};
  var n = 1, r = 1;
  function o(m) {
    var f = m.match(GQ);
    f && (n += f.length);
    var h = m.lastIndexOf(tJ);
    r = ~h ? m.length - h : r + m.length;
  }
  function i() {
    var m = { line: n, column: r };
    return function(f) {
      return f.position = new s(m), u(), f;
    };
  }
  function s(m) {
    this.start = m, this.end = { line: n, column: r }, this.source = t.source;
  }
  s.prototype.content = e;
  function a(m) {
    var f = new Error(
      t.source + ":" + n + ":" + r + ": " + m
    );
    if (f.reason = m, f.filename = t.source, f.line = n, f.column = r, f.source = e, !t.silent) throw f;
  }
  function l(m) {
    var f = m.exec(e);
    if (f) {
      var h = f[0];
      return o(h), e = e.slice(h.length), f;
    }
  }
  function u() {
    l(KQ);
  }
  function c(m) {
    var f;
    for (m = m || []; f = p(); )
      f !== !1 && m.push(f);
    return m;
  }
  function p() {
    var m = i();
    if (!(Kk != e.charAt(0) || Yk != e.charAt(1))) {
      for (var f = 2; is != e.charAt(f) && (Yk != e.charAt(f) || Kk != e.charAt(f + 1)); )
        ++f;
      if (f += 2, is === e.charAt(f - 1))
        return a("End of comment missing");
      var h = e.slice(2, f - 2);
      return r += 2, o(h), e = e.slice(f), r += 2, m({
        type: nJ,
        comment: h
      });
    }
  }
  function d() {
    var m = i(), f = l(YQ);
    if (f) {
      if (p(), !l(XQ)) return a("property missing ':'");
      var h = l(QQ), E = m({
        type: rJ,
        property: Xk(f[0].replace(Gk, is)),
        value: h ? Xk(h[0].replace(Gk, is)) : is
      });
      return l(JQ), E;
    }
  }
  function g() {
    var m = [];
    c(m);
    for (var f; f = d(); )
      f !== !1 && (m.push(f), c(m));
    return m;
  }
  return u(), g();
};
function Xk(e) {
  return e ? e.replace(eJ, is) : is;
}
var iJ = en && en.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(by, "__esModule", { value: !0 });
by.default = aJ;
var sJ = iJ(oJ);
function aJ(e, t) {
  var n = null;
  if (!e || typeof e != "string")
    return n;
  var r = (0, sJ.default)(e), o = typeof t == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var s = i.property, a = i.value;
      o ? t(s, a, i) : a && (n = n || {}, n[s] = a);
    }
  }), n;
}
var wd = {};
Object.defineProperty(wd, "__esModule", { value: !0 });
wd.camelCase = void 0;
var lJ = /^--[a-zA-Z0-9-]+$/, uJ = /-([a-z])/g, cJ = /^[^-]+$/, pJ = /^-(webkit|moz|ms|o|khtml)-/, dJ = /^-(ms)-/, fJ = function(e) {
  return !e || cJ.test(e) || lJ.test(e);
}, hJ = function(e, t) {
  return t.toUpperCase();
}, Qk = function(e, t) {
  return "".concat(t, "-");
}, gJ = function(e, t) {
  return t === void 0 && (t = {}), fJ(e) ? e : (e = e.toLowerCase(), t.reactCompat ? e = e.replace(dJ, Qk) : e = e.replace(pJ, Qk), e.replace(uJ, hJ));
};
wd.camelCase = gJ;
var mJ = en && en.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
}, vJ = mJ(by), yJ = wd;
function Gg(e, t) {
  var n = {};
  return !e || typeof e != "string" || (0, vJ.default)(e, function(r, o) {
    r && o && (n[(0, yJ.camelCase)(r, t)] = o);
  }), n;
}
Gg.default = Gg;
var bJ = Gg;
(function(e) {
  var t = en && en.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.returnFirstArg = e.canTextBeChildOfNode = e.ELEMENTS_WITH_NO_TEXT_CHILDREN = e.PRESERVE_CUSTOM_ATTRIBUTES = void 0, e.isCustomComponent = i, e.setStyleProp = a;
  var n = Be, r = t(bJ), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, p) {
    return c.includes("-") ? !o.has(c) : !!(p && typeof p.is == "string");
  }
  var s = {
    reactCompat: !0
  };
  function a(c, p) {
    if (typeof c == "string") {
      if (!c.trim()) {
        p.style = {};
        return;
      }
      try {
        p.style = (0, r.default)(c, s);
      } catch {
        p.style = {};
      }
    }
  }
  e.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, e.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !e.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  e.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  e.returnFirstArg = u;
})(yy);
Object.defineProperty(md, "__esModule", { value: !0 });
md.default = xJ;
var Ea = go, Jk = yy, wJ = ["checked", "value"], CJ = ["input", "select", "textarea"], EJ = {
  reset: !0,
  submit: !0
};
function xJ(e, t) {
  e === void 0 && (e = {});
  var n = {}, r = !!(e.type && EJ[e.type]);
  for (var o in e) {
    var i = e[o];
    if ((0, Ea.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var s = o.toLowerCase(), a = eD(s);
    if (a) {
      var l = (0, Ea.getPropertyInfo)(a);
      switch (wJ.includes(a) && CJ.includes(t) && !r && (a = eD("default" + s)), n[a] = i, l && l.type) {
        case Ea.BOOLEAN:
          n[a] = !0;
          break;
        case Ea.OVERLOADED_BOOLEAN:
          i === "" && (n[a] = !0);
          break;
      }
      continue;
    }
    Jk.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, Jk.setStyleProp)(e.style, n), n;
}
function eD(e) {
  return Ea.possibleStandardNames[e];
}
var wy = {}, LJ = en && en.__importDefault || function(e) {
  return e && e.__esModule ? e : { default: e };
};
Object.defineProperty(wy, "__esModule", { value: !0 });
wy.default = xA;
var ch = Be, kJ = LJ(md), Ua = yy, DJ = {
  cloneElement: ch.cloneElement,
  createElement: ch.createElement,
  isValidElement: ch.isValidElement
};
function xA(e, t) {
  t === void 0 && (t = {});
  for (var n = [], r = typeof t.replace == "function", o = t.transform || Ua.returnFirstArg, i = t.library || DJ, s = i.cloneElement, a = i.createElement, l = i.isValidElement, u = e.length, c = 0; c < u; c++) {
    var p = e[c];
    if (r) {
      var d = t.replace(p, c);
      if (l(d)) {
        u > 1 && (d = s(d, {
          key: d.key || c
        })), n.push(o(d, p, c));
        continue;
      }
    }
    if (p.type === "text") {
      var g = !p.data.trim().length;
      if (g && p.parent && !(0, Ua.canTextBeChildOfNode)(p.parent) || t.trim && g)
        continue;
      n.push(o(p.data, p, c));
      continue;
    }
    var m = p, f = {};
    SJ(m) ? ((0, Ua.setStyleProp)(m.attribs.style, m.attribs), f = m.attribs) : m.attribs && (f = (0, kJ.default)(m.attribs, m.name));
    var h = void 0;
    switch (p.type) {
      case "script":
      case "style":
        p.children[0] && (f.dangerouslySetInnerHTML = {
          __html: p.children[0].data
        });
        break;
      case "tag":
        p.name === "textarea" && p.children[0] ? f.defaultValue = p.children[0].data : p.children && p.children.length && (h = xA(p.children, t));
        break;
      default:
        continue;
    }
    u > 1 && (f.key = c), n.push(o(a(p.name, f, h), p, c));
  }
  return n.length === 1 ? n[0] : n;
}
function SJ(e) {
  return Ua.PRESERVE_CUSTOM_ATTRIBUTES && e.type === "tag" && (0, Ua.isCustomComponent)(e.name, e.attribs);
}
(function(e) {
  var t = en && en.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(e, "__esModule", { value: !0 }), e.htmlToDOM = e.domToReact = e.attributesToProps = e.Text = e.ProcessingInstruction = e.Element = e.Comment = void 0, e.default = a;
  var n = t(uy);
  e.htmlToDOM = n.default;
  var r = t(md);
  e.attributesToProps = r.default;
  var o = t(wy);
  e.domToReact = o.default;
  var i = py;
  Object.defineProperty(e, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(e, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(e, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(e, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var s = { lowerCaseAttributeNames: !1 };
  function a(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || s), u) : [];
  }
})(oA);
const tD = /* @__PURE__ */ Xc(oA), OJ = tD.default || tD, Kg = (e) => {
  if (typeof e == "string") return { text: e || "" };
  function t(o) {
    return o.map((i) => Kg(i));
  }
  const n = Array.isArray(e.props.children) ? t(e.props.children) : [{ text: e.props.children }], r = typeof e.props.children == "string" ? e.props.children : "";
  switch (e.type) {
    case "p":
      return { type: "paragraph", children: n };
    case "blockquote":
      return { type: "blockQuote", children: n };
    case "ul":
      return { type: "bulletedList", children: n };
    case "h1":
      return { type: "headingOne", children: n };
    case "h2":
      return { type: "headingTwo", children: n };
    case "li":
      return { type: "listItem", children: n };
    case "ol":
      return { type: "numberedList", children: n };
    case "strong":
      return { type: "paragraph", text: r, bold: !0 };
    case "code":
      return { text: r, code: !0 };
    case "em":
      return { text: r, italic: !0 };
    case "u":
      return { text: r, underline: !0 };
    default:
      return { text: r };
  }
}, MJ = (e) => {
  const t = OJ(e);
  return Array.isArray(t) ? t.flatMap((n) => typeof n == "string" ? { text: n } : Kg(n)) : typeof t == "string" ? [{ text: t }] : [Kg(t)];
};
function nD(e) {
  return e.map((t) => Ae.string(t)).join("");
}
const LA = (e) => {
  if (We.isText(e)) {
    let t = e.text;
    return e.bold && (t = `<strong>${t}</strong>`), e.code && (t = `<code>${t}</code>`), e.italic && (t = `<em>${t}</em>`), e.underline && (t = `<u>${t}</u>`), t;
  }
  if ($e.isElement(e)) {
    const t = e.children.map((n) => LA(n)).join("");
    switch (e.type) {
      case "paragraph":
        return `<p>${t}</p>`;
      case "blockQuote":
        return `<blockquote>${t}</blockquote>`;
      case "bulletedList":
        return `<ul>${t}</ul>`;
      case "headingOne":
        return `<h1>${t}</h1>`;
      case "headingTwo":
        return `<h2>${t}</h2>`;
      case "listItem":
        return `<li>${t}</li>`;
      case "numberedList":
        return `<ol>${t}</ol>`;
      default:
        return t;
    }
  }
  return "";
}, rD = (e) => e.children.map((t) => LA(t)).join(""), oD = (e) => /<\/?[a-z][\s\S]*>/i.test(e);
function sre({
  name: e,
  defaultValue: t,
  enforceCharacterLimit: n = !1,
  onChangeCharactersCount: r,
  maxLimit: o = 2e3,
  onValueChange: i,
  onChange: s,
  isError: a
}) {
  const l = rr(() => uK(yQ(sK())), []), { id: u, inputRef: c, error: p } = ro(), d = rt(null), g = oD(t) ? MJ(t) : xQ, m = nD(g), [f, h] = D(m.length), [E, L] = D(
    oD(t) ? t : ""
  ), [x, T] = D(!1), w = c || d, C = a || !!p, k = Zt(CQ, []), O = Zt(wQ, []);
  function U(R) {
    const H = nD(R);
    h(H.length), r && r(H.length), !(n && H.length >= o) && (L(rD(l)), s && s(R), i && i(rD(l)), l.children = R, Le.setNodes(l, { children: R }));
  }
  const M = x ? "focusTrue" : "focusFalse", $ = `arkynRichText ${C || o < f ? "errorTrue" : "errorFalse"} ${M}`, W = o - f;
  return /* @__PURE__ */ Q.jsxs(
    mQ,
    {
      editor: l,
      initialValue: g,
      onChange: U,
      onValueChange: U,
      children: [
        /* @__PURE__ */ Q.jsxs("div", { className: $, children: [
          /* @__PURE__ */ Q.jsxs(EQ, { children: [
            /* @__PURE__ */ Q.jsx(Ki, { format: "headingOne", icon: sB }),
            /* @__PURE__ */ Q.jsx(Ki, { format: "headingTwo", icon: aB }),
            /* @__PURE__ */ Q.jsx(Ki, { format: "blockQuote", icon: lB }),
            /* @__PURE__ */ Q.jsx(Vu, { format: "bold", icon: uB }),
            /* @__PURE__ */ Q.jsx(Vu, { format: "italic", icon: cB }),
            /* @__PURE__ */ Q.jsx(Vu, { format: "underline", icon: pB }),
            /* @__PURE__ */ Q.jsx(Vu, { format: "code", icon: dB }),
            /* @__PURE__ */ Q.jsx(Ki, { format: "left", icon: fB }),
            /* @__PURE__ */ Q.jsx(Ki, { format: "right", icon: hB }),
            /* @__PURE__ */ Q.jsx(Ki, { format: "center", icon: gB }),
            /* @__PURE__ */ Q.jsx(Ki, { format: "justify", icon: mB })
          ] }),
          /* @__PURE__ */ Q.jsx(
            aQ,
            {
              className: "editorContainer",
              renderElement: O,
              renderLeaf: k,
              spellCheck: !0,
              id: u,
              onFocus: () => T(!0),
              onBlur: () => T(!1),
              onKeyDown: (R) => {
                for (const H in Uk)
                  if (OZ(H, R)) {
                    R.preventDefault();
                    const X = Uk[H];
                    rA(l, X);
                  }
              }
            }
          ),
          W < 0 && /* @__PURE__ */ Q.jsx("div", { className: "restatesCharacters", children: W })
        ] }),
        /* @__PURE__ */ Q.jsx("input", { ref: w, type: "hidden", name: e, value: E }),
        /* @__PURE__ */ Q.jsx("input", { type: "hidden", name: `${e}Count`, value: f })
      ]
    }
  );
}
function PJ(e, t) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: s = "solid",
    prefix: a,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: p,
    onBlur: d,
    title: g,
    style: m,
    closeOnSelect: f = !0,
    ...h
  } = e, w = `arkyn_select ${a ? "hasPrefix" : ""} ${s} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${t ? "focused" : ""} ${i}`, k = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: w,
    prefix: OB(a, k, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: p,
    onBlur: d,
    title: g,
    closeOnSelect: f,
    style: m,
    iconSize: k,
    Spinner: /* @__PURE__ */ Q.jsx(Zo, { className: "spinner", size: k, strokeWidth: 2.5 }),
    ...h
  };
}
function are(e) {
  var b;
  const [t, n] = D(""), [r, o] = D(!1), { inputRef: i, id: s, error: a } = ro(), l = rt(null), u = i || l, c = e.isError || !!a, {
    disabled: p,
    title: d,
    style: g,
    className: m,
    prefix: f,
    iconSize: h,
    isLoading: E,
    LeftIcon: L,
    value: x = null,
    defaultValue: T = "",
    onFocus: w,
    onBlur: C,
    Spinner: k,
    name: O,
    placeholder: U,
    onSelect: M,
    options: V,
    optionMaxHeight: $,
    closeOnSelect: W,
    isSearchable: R,
    onSearch: H,
    ...X
  } = PJ({ ...e, id: s, isError: c }, r), [I, J] = D(T);
  function te() {
    p || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function S(F) {
    r || (o(!0), w && w(F));
  }
  function P() {
    o(!1), C && u.current && u.current.blur();
  }
  function q(F) {
    const { label: z, value: A } = F;
    J(I !== A ? A : ""), M && M({ label: z, value: A }), W && P();
  }
  const j = typeof x == "string" ? x : I, Z = ((b = V.find((F) => F.value === j)) == null ? void 0 : b.label) || "", G = () => {
    if (!r && Z) return !0;
    if (!r && !Z) return !1;
    if (r && Z) return !0;
    if (r && !Z) return !1;
  };
  return /* @__PURE__ */ Q.jsxs(Q.Fragment, { children: [
    /* @__PURE__ */ Q.jsxs(
      "section",
      {
        title: d,
        style: g,
        onClick: te,
        className: `${m} placeholder_dark_${G()}`,
        children: [
          f,
          L && /* @__PURE__ */ Q.jsx(L, { size: h, strokeWidth: 2.5 }),
          /* @__PURE__ */ Q.jsx(
            "input",
            {
              disabled: p,
              readOnly: !0,
              placeholder: Z || U,
              onFocus: S,
              ...X
            }
          ),
          /* @__PURE__ */ Q.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: O,
              value: j || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ Q.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: $ },
              children: [
                R && /* @__PURE__ */ Q.jsx(
                  pS,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: vB,
                    onChange: (F) => n(F.target.value)
                  }
                ),
                V.filter((F) => !!(e.onSearch || !e.isSearchable || F.label.toLowerCase().includes(t.toLowerCase()))).map(({ label: F, value: z }) => /* @__PURE__ */ Q.jsxs(
                  "div",
                  {
                    onClick: () => q({ label: F, value: z }),
                    className: j === z ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      F,
                      " ",
                      /* @__PURE__ */ Q.jsx(UD, {})
                    ]
                  },
                  z
                )),
                V.length <= 0 && /* @__PURE__ */ Q.jsx("p", { children: "Sem opes disponveis" })
              ]
            }
          ),
          !E && /* @__PURE__ */ Q.jsx(
            yB,
            {
              className: "arkyn_select_arrow",
              size: h,
              strokeWidth: 2.5
            }
          ),
          E && k
        ]
      }
    ),
    r && /* @__PURE__ */ Q.jsx("aside", { className: "arkyn_select_overlay", onClick: P })
  ] });
}
function lre(e) {
  const {
    size: t = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: s,
    className: a = "",
    onCheck: l,
    ...u
  } = e, [c, p] = D(n), { id: d, inputRef: g } = ro(), m = typeof r == "boolean" ? r : c;
  function f() {
    p(!c), l && l(m ? i : o || "checked");
  }
  const E = `arkynSwitch ${m ? "checkedTrue" : "checkedFalse"} ${t} ${a}`;
  return /* @__PURE__ */ Q.jsx("button", { type: "button", onClick: f, className: E, ...u, children: /* @__PURE__ */ Q.jsx(
    "input",
    {
      id: d,
      type: "hidden",
      name: s,
      ref: g,
      onClick: f,
      value: m ? o || "checked" : i
    }
  ) });
}
function ure(e) {
  const {
    variant: t = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: s,
    onBlur: a,
    title: l,
    style: u,
    ...c
  } = e, [p, d] = D(!1), { inputRef: g, id: m, error: f } = ro(), h = rt(null), E = g || h, x = e.isError || !!f ? "errorTrue" : "errorFalse", C = `arkynTextarea ${t} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${x} ${p ? "focusedTrue" : "focusedFalse"} ${r}`;
  function k() {
    o || !(E != null && E.current) || (d(!0), E.current.focus());
  }
  function O(M) {
    d(!0), s && s(M);
  }
  function U(M) {
    d(!1), a && a(M);
  }
  return /* @__PURE__ */ Q.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: k,
      className: C,
      children: /* @__PURE__ */ Q.jsx(
        "textarea",
        {
          id: m,
          disabled: o,
          readOnly: i,
          ref: E,
          onFocus: O,
          onBlur: U,
          ...c
        }
      )
    }
  );
}
function cre(e) {
  const { className: t = "", ...n } = e, r = `arkynBreadcrumbContainer ${t}`;
  return /* @__PURE__ */ Q.jsx("nav", { className: r, ...n });
}
function pre(e) {
  const { pathname: t } = om(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...s
  } = e, l = `arkynBreadcrumbLink ${t === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ Q.jsxs("p", { className: l, children: [
    /* @__PURE__ */ Q.jsx(Eh, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ Q.jsxs(wB, { to: i, className: l, ...s, children: [
    /* @__PURE__ */ Q.jsx(Eh, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function kA(e = "") {
  const t = om(), n = new URLSearchParams(t.search), r = e ? `${e}:` : "", o = (i) => {
    Object.entries(i).forEach(([s, a]) => {
      a === void 0 ? n.delete(`${r}${s}`) : n.set(`${r}${s}`, String(a));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let s = n.toString();
      return s && (s = "?" + s), s;
    }
  };
}
function dre(e) {
  const {
    scope: t,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    ...s
  } = e, a = VD(), { getParam: l, getScopedSearch: u } = kA(t), c = Number(l(o)) || 1, p = Number(l(r)) || 20, d = Math.ceil(n / p), g = SB(c, i), m = DB(c, i, d);
  function f(h) {
    a(u({ page: h }));
  }
  return /* @__PURE__ */ Q.jsxs("div", { className: "arkynPagination", ...s, children: [
    /* @__PURE__ */ Q.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: c <= 1,
        onClick: () => f(c - 1),
        children: /* @__PURE__ */ Q.jsx(bB, {})
      }
    ),
    c > 1 + i && /* @__PURE__ */ Q.jsxs(Q.Fragment, { children: [
      /* @__PURE__ */ Q.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => f(1),
          children: "1"
        }
      ),
      c > 2 + i && /* @__PURE__ */ Q.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ Q.jsx(Ty, {}) })
    ] }),
    g.map((h, E) => /* @__PURE__ */ Q.jsx(
      "button",
      {
        onClick: () => f(h),
        className: "arkynPaginationPageButton",
        children: h
      },
      E
    )),
    /* @__PURE__ */ Q.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: c }),
    m.map((h, E) => /* @__PURE__ */ Q.jsx(
      "button",
      {
        onClick: () => f(h),
        className: "arkynPaginationPageButton",
        children: h
      },
      E
    )),
    c + i < d && /* @__PURE__ */ Q.jsxs(Q.Fragment, { children: [
      c + 1 + i < d && /* @__PURE__ */ Q.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ Q.jsx(Ty, {}) }),
      /* @__PURE__ */ Q.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => f(d),
          children: d
        }
      )
    ] }),
    /* @__PURE__ */ Q.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: c >= d,
        onClick: () => f(c + 1),
        children: /* @__PURE__ */ Q.jsx(Eh, {})
      }
    )
  ] });
}
const Yg = Ye({});
function TJ() {
  if (!Yg)
    throw new Error("useTabContext must be used within a TabProvider");
  return _e(Yg);
}
function fre(e) {
  const {
    children: t,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = e, [s, a] = D(r || ""), [l, u] = D(!0), c = rt(null), p = `arkynTabContainer ${o || ""}`, [d, g] = D({
    width: "0px",
    left: "0px",
    transition: "none"
  }), m = (h, E) => {
    const L = h.getBoundingClientRect(), x = c.current.getBoundingClientRect(), T = E ? void 0 : "none";
    u(!1), g({
      transition: T,
      width: `${L.width}px`,
      left: `${L.left - x.left}px`
    });
  };
  v(() => {
    const h = c.current;
    if (!h) return;
    let E = null;
    E = h.querySelector("button.activeTrue"), E && m(E);
  }, []);
  const f = (h) => {
    const E = h.target;
    E && (a(E.value), E.classList.add("activeTrue"), m(E, !0), n && n(E.value));
  };
  return /* @__PURE__ */ Q.jsxs("nav", { ref: c, className: p.trim(), ...i, children: [
    /* @__PURE__ */ Q.jsx(Yg.Provider, { value: { handleTabClick: f, showInitialTab: l, value: s }, children: t }),
    /* @__PURE__ */ Q.jsx("div", { className: "activeLine", style: d })
  ] });
}
function hre(e) {
  const { children: t, className: n = "", onClick: r, ...o } = e, { value: i, showInitialTab: s, handleTabClick: a } = TJ(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && s ? "showBorderBottom" : ""} ${l} ${n}`;
  function p(d) {
    a(d), r && r(d);
  }
  return /* @__PURE__ */ Q.jsx("button", { onClick: p, className: c.trim(), ...o, children: t });
}
const DA = Ye({});
function gre(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...s
  } = e, a = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${t ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ Q.jsx(DA.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ Q.jsx(ZD, { children: t && /* @__PURE__ */ Q.jsxs("aside", { className: u.trim(), ...s, children: [
    /* @__PURE__ */ Q.jsx(
      $a.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ Q.jsx(
      $a.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${a})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${a})` },
        children: o
      }
    )
  ] }) }) });
}
function mre(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = _e(DA), s = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ Q.jsxs("header", { className: s.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ Q.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ Q.jsx($D, { size: 24 })
      }
    )
  ] });
}
const SA = Ye({});
function vre(e) {
  const {
    isVisibled: t,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = e, a = `arkynModalContainer ${t ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ Q.jsx(SA.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ Q.jsx(ZD, { children: t && /* @__PURE__ */ Q.jsxs("aside", { className: a.trim(), ...i, children: [
    /* @__PURE__ */ Q.jsx(
      $a.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ Q.jsx(
      $a.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function yre(e) {
  const { alignment: t = "right", className: n, ...r } = e, o = `arkynModalFooter ${t} ${n}`;
  return /* @__PURE__ */ Q.jsx("footer", { className: o.trim(), ...r });
}
function bre(e) {
  const {
    showCloseButton: t = !0,
    className: n,
    children: r,
    ...o
  } = e, { makeInvisible: i } = _e(SA), s = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ Q.jsxs("header", { className: s.trim(), ...o, children: [
    r,
    t && /* @__PURE__ */ Q.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ Q.jsx($D, { size: 24 })
      }
    )
  ] });
}
function wre(e) {
  const { children: t, button: n, closeOnClick: r, orientation: o = "bottomLeft" } = e, [i, s] = D(!1), l = `arkynPopover ${o} ${i ? "visibleTrue" : "visibleFalse"}`;
  function u() {
    i || s(!0);
  }
  return /* @__PURE__ */ Q.jsxs("div", { className: l, onClick: u, children: [
    n,
    /* @__PURE__ */ Q.jsx(
      $a.div,
      {
        style: { visibility: i ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: i ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && s(!1),
        className: "arkynPopoverContent",
        children: t
      }
    ),
    i && /* @__PURE__ */ Q.jsx("div", { onClick: () => s(!1), className: "arkynPopoverOverlay" })
  ] });
}
function Cre(e) {
  const { message: t, type: n } = e, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ Q.jsx(zD, {});
      case "danger":
        return /* @__PURE__ */ Q.jsx(RD, {});
      default:
        return /* @__PURE__ */ Q.jsx(FD, {});
    }
  }
  return /* @__PURE__ */ Q.jsxs("div", { className: r, children: [
    /* @__PURE__ */ Q.jsxs("div", { children: [
      /* @__PURE__ */ Q.jsx("div", { className: "bg" }),
      /* @__PURE__ */ Q.jsx(o, {})
    ] }),
    /* @__PURE__ */ Q.jsx("p", { children: /* @__PURE__ */ Q.jsx("span", { children: t }) })
  ] });
}
function Ere(e) {
  const {
    text: t,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...s
  } = e, a = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ Q.jsxs("div", { className: a.trim(), ...s, children: [
    r,
    /* @__PURE__ */ Q.jsx("div", { className: "arkynTooltipText", children: t })
  ] });
}
var nr = {}, Cy = {}, Bl = {}, _l = {}, OA = "Expected a function", iD = NaN, AJ = "[object Symbol]", BJ = /^\s+|\s+$/g, _J = /^[-+]0x[0-9a-f]+$/i, IJ = /^0b[01]+$/i, jJ = /^0o[0-7]+$/i, NJ = parseInt, FJ = typeof en == "object" && en && en.Object === Object && en, RJ = typeof self == "object" && self && self.Object === Object && self, zJ = FJ || RJ || Function("return this")(), UJ = Object.prototype, $J = UJ.toString, WJ = Math.max, HJ = Math.min, ph = function() {
  return zJ.Date.now();
};
function VJ(e, t, n) {
  var r, o, i, s, a, l, u = 0, c = !1, p = !1, d = !0;
  if (typeof e != "function")
    throw new TypeError(OA);
  t = sD(t) || 0, Gc(n) && (c = !!n.leading, p = "maxWait" in n, i = p ? WJ(sD(n.maxWait) || 0, t) : i, d = "trailing" in n ? !!n.trailing : d);
  function g(C) {
    var k = r, O = o;
    return r = o = void 0, u = C, s = e.apply(O, k), s;
  }
  function m(C) {
    return u = C, a = setTimeout(E, t), c ? g(C) : s;
  }
  function f(C) {
    var k = C - l, O = C - u, U = t - k;
    return p ? HJ(U, i - O) : U;
  }
  function h(C) {
    var k = C - l, O = C - u;
    return l === void 0 || k >= t || k < 0 || p && O >= i;
  }
  function E() {
    var C = ph();
    if (h(C))
      return L(C);
    a = setTimeout(E, f(C));
  }
  function L(C) {
    return a = void 0, d && r ? g(C) : (r = o = void 0, s);
  }
  function x() {
    a !== void 0 && clearTimeout(a), u = 0, r = l = o = a = void 0;
  }
  function T() {
    return a === void 0 ? s : L(ph());
  }
  function w() {
    var C = ph(), k = h(C);
    if (r = arguments, o = this, l = C, k) {
      if (a === void 0)
        return m(l);
      if (p)
        return a = setTimeout(E, t), g(l);
    }
    return a === void 0 && (a = setTimeout(E, t)), s;
  }
  return w.cancel = x, w.flush = T, w;
}
function ZJ(e, t, n) {
  var r = !0, o = !0;
  if (typeof e != "function")
    throw new TypeError(OA);
  return Gc(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), VJ(e, t, {
    leading: r,
    maxWait: t,
    trailing: o
  });
}
function Gc(e) {
  var t = typeof e;
  return !!e && (t == "object" || t == "function");
}
function qJ(e) {
  return !!e && typeof e == "object";
}
function GJ(e) {
  return typeof e == "symbol" || qJ(e) && $J.call(e) == AJ;
}
function sD(e) {
  if (typeof e == "number")
    return e;
  if (GJ(e))
    return iD;
  if (Gc(e)) {
    var t = typeof e.valueOf == "function" ? e.valueOf() : e;
    e = Gc(t) ? t + "" : t;
  }
  if (typeof e != "string")
    return e === 0 ? e : +e;
  e = e.replace(BJ, "");
  var n = IJ.test(e);
  return n || jJ.test(e) ? NJ(e.slice(2), n ? 2 : 8) : _J.test(e) ? iD : +e;
}
var KJ = ZJ, Il = {};
Object.defineProperty(Il, "__esModule", {
  value: !0
});
Il.addPassiveEventListener = function(t, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), pc.has(n) || pc.set(n, /* @__PURE__ */ new Set());
  var i = pc.get(n);
  if (!i.has(o)) {
    var s = function() {
      var a = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return a;
    }();
    t.addEventListener(n, r, s ? { passive: !0 } : !1), i.add(o);
  }
};
Il.removePassiveEventListener = function(t, n, r) {
  t.removeEventListener(n, r), pc.get(n).delete(r.name || n);
};
var pc = /* @__PURE__ */ new Map();
Object.defineProperty(_l, "__esModule", {
  value: !0
});
var YJ = KJ, XJ = JJ(YJ), QJ = Il;
function JJ(e) {
  return e && e.__esModule ? e : { default: e };
}
var eee = function(t) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, XJ.default)(t, n);
}, Vn = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, n) {
    if (t) {
      var r = eee(function(o) {
        Vn.scrollHandler(t);
      }, n);
      Vn.scrollSpyContainers.push(t), (0, QJ.addPassiveEventListener)(t, "scroll", r);
    }
  },
  isMounted: function(t) {
    return Vn.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var n = window.pageYOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var n = Vn.scrollSpyContainers[Vn.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(Vn.currentPositionX(t), Vn.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    Vn.spySetState.push(t);
  },
  addSpyHandler: function(t, n) {
    var r = Vn.scrollSpyContainers[Vn.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(t), t(Vn.currentPositionX(n), Vn.currentPositionY(n));
  },
  updateStates: function() {
    Vn.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, n) {
    Vn.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), Vn.spySetState && Vn.spySetState.length && Vn.spySetState.indexOf(t) > -1 && Vn.spySetState.splice(Vn.spySetState.indexOf(t), 1), document.removeEventListener("scroll", Vn.scrollHandler);
  },
  update: function() {
    return Vn.scrollSpyContainers.forEach(function(t) {
      return Vn.scrollHandler(t);
    });
  }
};
_l.default = Vn;
var Zs = {}, jl = {};
Object.defineProperty(jl, "__esModule", {
  value: !0
});
var tee = function(t, n) {
  var r = t.indexOf("#") === 0 ? t.substring(1) : t, o = r ? "#" + r : "", i = window && window.location, s = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", s) : history.replaceState(history.state, "", s);
}, nee = function() {
  return window.location.hash.replace(/^#/, "");
}, ree = function(t) {
  return function(n) {
    return t.contains ? t != n && t.contains(n) : !!(t.compareDocumentPosition(n) & 16);
  };
}, oee = function(t) {
  return getComputedStyle(t).position !== "static";
}, dh = function(t, n) {
  for (var r = t.offsetTop, o = t.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, iee = function(t, n, r) {
  if (r)
    return t === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? n.offsetLeft : n.offsetLeft - t.offsetLeft;
  if (t === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (oee(t)) {
    if (n.offsetParent !== t) {
      var o = function(c) {
        return c === t || c === document;
      }, i = dh(n, o), s = i.offsetTop, a = i.offsetParent;
      if (a !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return s;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === t.offsetParent)
    return n.offsetTop - t.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return dh(n, l).offsetTop - dh(t, l).offsetTop;
};
jl.default = {
  updateHash: tee,
  getHash: nee,
  filterElementInContainer: ree,
  scrollOffset: iee
};
var Cd = {}, Ey = {};
Object.defineProperty(Ey, "__esModule", {
  value: !0
});
Ey.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity 
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var xy = {};
Object.defineProperty(xy, "__esModule", {
  value: !0
});
var see = Il, aee = ["mousedown", "mousewheel", "touchmove", "keydown"];
xy.default = {
  subscribe: function(t) {
    return typeof document < "u" && aee.forEach(function(n) {
      return (0, see.addPassiveEventListener)(document, n, t);
    });
  }
};
var Nl = {};
Object.defineProperty(Nl, "__esModule", {
  value: !0
});
var Xg = {
  registered: {},
  scrollEvent: {
    register: function(t, n) {
      Xg.registered[t] = n;
    },
    remove: function(t) {
      Xg.registered[t] = null;
    }
  }
};
Nl.default = Xg;
Object.defineProperty(Cd, "__esModule", {
  value: !0
});
var lee = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, uee = jl;
Ed(uee);
var cee = Ey, aD = Ed(cee), pee = xy, dee = Ed(pee), fee = Nl, Co = Ed(fee);
function Ed(e) {
  return e && e.__esModule ? e : { default: e };
}
var MA = function(t) {
  return aD.default[t.smooth] || aD.default.defaultEasing;
}, hee = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, gee = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Qg = function() {
  return gee() || function(e, t, n) {
    window.setTimeout(e, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), PA = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, TA = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, AA = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, mee = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, vee = function(t) {
  var n = t.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, yee = function e(t, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Co.default.registered.end && Co.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : t(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = e.bind(null, t, n);
    Qg.call(window, i);
    return;
  }
  Co.default.registered.end && Co.default.registered.end(o.to, o.target, o.currentPosition);
}, Ly = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, Fl = function(t, n, r, o) {
  n.data = n.data || PA(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (dee.default.subscribe(i), Ly(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? TA(n) : AA(n), n.data.targetPosition = n.absolute ? t : t + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    Co.default.registered.end && Co.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = hee(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var s = MA(n), a = yee.bind(null, s, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      Co.default.registered.begin && Co.default.registered.begin(n.data.to, n.data.target), Qg.call(window, a);
    }, n.delay);
    return;
  }
  Co.default.registered.begin && Co.default.registered.begin(n.data.to, n.data.target), Qg.call(window, a);
}, xd = function(t) {
  return t = lee({}, t), t.data = t.data || PA(), t.absolute = !0, t;
}, bee = function(t) {
  Fl(0, xd(t));
}, wee = function(t, n) {
  Fl(t, xd(n));
}, Cee = function(t) {
  t = xd(t), Ly(t), Fl(t.horizontal ? mee(t) : vee(t), t);
}, Eee = function(t, n) {
  n = xd(n), Ly(n);
  var r = n.horizontal ? TA(n) : AA(n);
  Fl(t + r, n);
};
Cd.default = {
  animateTopScroll: Fl,
  getAnimationType: MA,
  scrollToTop: bee,
  scrollToBottom: Cee,
  scrollTo: wee,
  scrollMore: Eee
};
Object.defineProperty(Zs, "__esModule", {
  value: !0
});
var xee = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, Lee = jl, kee = ky(Lee), Dee = Cd, See = ky(Dee), Oee = Nl, Yu = ky(Oee);
function ky(e) {
  return e && e.__esModule ? e : { default: e };
}
var Xu = {}, lD = void 0;
Zs.default = {
  unmount: function() {
    Xu = {};
  },
  register: function(t, n) {
    Xu[t] = n;
  },
  unregister: function(t) {
    delete Xu[t];
  },
  get: function(t) {
    return Xu[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return lD = t;
  },
  getActiveLink: function() {
    return lD;
  },
  scrollTo: function(t, n) {
    var r = this.get(t);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = xee({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, s = void 0;
    o ? s = document.getElementById(o) : i && i.nodeType ? s = i : s = document, n.absolute = !0;
    var a = n.horizontal, l = kee.default.scrollOffset(s, r, a) + (n.offset || 0);
    if (!n.smooth) {
      Yu.default.registered.begin && Yu.default.registered.begin(t, r), s === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : s.scrollTop = l, Yu.default.registered.end && Yu.default.registered.end(t, r);
      return;
    }
    See.default.animateTopScroll(l, n, t, r);
  }
};
var Jg = { exports: {} }, Qu = { exports: {} }, Ht = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var uD;
function Mee() {
  if (uD) return Ht;
  uD = 1;
  var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
  function x(w) {
    if (typeof w == "object" && w !== null) {
      var C = w.$$typeof;
      switch (C) {
        case t:
          switch (w = w.type, w) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case p:
              return w;
            default:
              switch (w = w && w.$$typeof, w) {
                case a:
                case c:
                case m:
                case g:
                case s:
                  return w;
                default:
                  return C;
              }
          }
        case n:
          return C;
      }
    }
  }
  function T(w) {
    return x(w) === u;
  }
  return Ht.AsyncMode = l, Ht.ConcurrentMode = u, Ht.ContextConsumer = a, Ht.ContextProvider = s, Ht.Element = t, Ht.ForwardRef = c, Ht.Fragment = r, Ht.Lazy = m, Ht.Memo = g, Ht.Portal = n, Ht.Profiler = i, Ht.StrictMode = o, Ht.Suspense = p, Ht.isAsyncMode = function(w) {
    return T(w) || x(w) === l;
  }, Ht.isConcurrentMode = T, Ht.isContextConsumer = function(w) {
    return x(w) === a;
  }, Ht.isContextProvider = function(w) {
    return x(w) === s;
  }, Ht.isElement = function(w) {
    return typeof w == "object" && w !== null && w.$$typeof === t;
  }, Ht.isForwardRef = function(w) {
    return x(w) === c;
  }, Ht.isFragment = function(w) {
    return x(w) === r;
  }, Ht.isLazy = function(w) {
    return x(w) === m;
  }, Ht.isMemo = function(w) {
    return x(w) === g;
  }, Ht.isPortal = function(w) {
    return x(w) === n;
  }, Ht.isProfiler = function(w) {
    return x(w) === i;
  }, Ht.isStrictMode = function(w) {
    return x(w) === o;
  }, Ht.isSuspense = function(w) {
    return x(w) === p;
  }, Ht.isValidElementType = function(w) {
    return typeof w == "string" || typeof w == "function" || w === r || w === u || w === i || w === o || w === p || w === d || typeof w == "object" && w !== null && (w.$$typeof === m || w.$$typeof === g || w.$$typeof === s || w.$$typeof === a || w.$$typeof === c || w.$$typeof === h || w.$$typeof === E || w.$$typeof === L || w.$$typeof === f);
  }, Ht.typeOf = x, Ht;
}
var Vt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var cD;
function Pee() {
  return cD || (cD = 1, process.env.NODE_ENV !== "production" && function() {
    var e = typeof Symbol == "function" && Symbol.for, t = e ? Symbol.for("react.element") : 60103, n = e ? Symbol.for("react.portal") : 60106, r = e ? Symbol.for("react.fragment") : 60107, o = e ? Symbol.for("react.strict_mode") : 60108, i = e ? Symbol.for("react.profiler") : 60114, s = e ? Symbol.for("react.provider") : 60109, a = e ? Symbol.for("react.context") : 60110, l = e ? Symbol.for("react.async_mode") : 60111, u = e ? Symbol.for("react.concurrent_mode") : 60111, c = e ? Symbol.for("react.forward_ref") : 60112, p = e ? Symbol.for("react.suspense") : 60113, d = e ? Symbol.for("react.suspense_list") : 60120, g = e ? Symbol.for("react.memo") : 60115, m = e ? Symbol.for("react.lazy") : 60116, f = e ? Symbol.for("react.block") : 60121, h = e ? Symbol.for("react.fundamental") : 60117, E = e ? Symbol.for("react.responder") : 60118, L = e ? Symbol.for("react.scope") : 60119;
    function x(B) {
      return typeof B == "string" || typeof B == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      B === r || B === u || B === i || B === o || B === p || B === d || typeof B == "object" && B !== null && (B.$$typeof === m || B.$$typeof === g || B.$$typeof === s || B.$$typeof === a || B.$$typeof === c || B.$$typeof === h || B.$$typeof === E || B.$$typeof === L || B.$$typeof === f);
    }
    function T(B) {
      if (typeof B == "object" && B !== null) {
        var se = B.$$typeof;
        switch (se) {
          case t:
            var ue = B.type;
            switch (ue) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case p:
                return ue;
              default:
                var ce = ue && ue.$$typeof;
                switch (ce) {
                  case a:
                  case c:
                  case m:
                  case g:
                  case s:
                    return ce;
                  default:
                    return se;
                }
            }
          case n:
            return se;
        }
      }
    }
    var w = l, C = u, k = a, O = s, U = t, M = c, V = r, $ = m, W = g, R = n, H = i, X = o, I = p, J = !1;
    function te(B) {
      return J || (J = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), S(B) || T(B) === l;
    }
    function S(B) {
      return T(B) === u;
    }
    function P(B) {
      return T(B) === a;
    }
    function q(B) {
      return T(B) === s;
    }
    function j(B) {
      return typeof B == "object" && B !== null && B.$$typeof === t;
    }
    function Z(B) {
      return T(B) === c;
    }
    function G(B) {
      return T(B) === r;
    }
    function b(B) {
      return T(B) === m;
    }
    function F(B) {
      return T(B) === g;
    }
    function z(B) {
      return T(B) === n;
    }
    function A(B) {
      return T(B) === i;
    }
    function Y(B) {
      return T(B) === o;
    }
    function ee(B) {
      return T(B) === p;
    }
    Vt.AsyncMode = w, Vt.ConcurrentMode = C, Vt.ContextConsumer = k, Vt.ContextProvider = O, Vt.Element = U, Vt.ForwardRef = M, Vt.Fragment = V, Vt.Lazy = $, Vt.Memo = W, Vt.Portal = R, Vt.Profiler = H, Vt.StrictMode = X, Vt.Suspense = I, Vt.isAsyncMode = te, Vt.isConcurrentMode = S, Vt.isContextConsumer = P, Vt.isContextProvider = q, Vt.isElement = j, Vt.isForwardRef = Z, Vt.isFragment = G, Vt.isLazy = b, Vt.isMemo = F, Vt.isPortal = z, Vt.isProfiler = A, Vt.isStrictMode = Y, Vt.isSuspense = ee, Vt.isValidElementType = x, Vt.typeOf = T;
  }()), Vt;
}
var pD;
function BA() {
  return pD || (pD = 1, process.env.NODE_ENV === "production" ? Qu.exports = Mee() : Qu.exports = Pee()), Qu.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var fh, dD;
function Tee() {
  if (dD) return fh;
  dD = 1;
  var e = Object.getOwnPropertySymbols, t = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var s = {}, a = 0; a < 10; a++)
        s["_" + String.fromCharCode(a)] = a;
      var l = Object.getOwnPropertyNames(s).map(function(c) {
        return s[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return fh = o() ? Object.assign : function(i, s) {
    for (var a, l = r(i), u, c = 1; c < arguments.length; c++) {
      a = Object(arguments[c]);
      for (var p in a)
        t.call(a, p) && (l[p] = a[p]);
      if (e) {
        u = e(a);
        for (var d = 0; d < u.length; d++)
          n.call(a, u[d]) && (l[u[d]] = a[u[d]]);
      }
    }
    return l;
  }, fh;
}
var hh, fD;
function Dy() {
  if (fD) return hh;
  fD = 1;
  var e = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return hh = e, hh;
}
var gh, hD;
function _A() {
  return hD || (hD = 1, gh = Function.call.bind(Object.prototype.hasOwnProperty)), gh;
}
var mh, gD;
function Aee() {
  if (gD) return mh;
  gD = 1;
  var e = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var t = Dy(), n = {}, r = _A();
    e = function(i) {
      var s = "Warning: " + i;
      typeof console < "u" && console.error(s);
      try {
        throw new Error(s);
      } catch {
      }
    };
  }
  function o(i, s, a, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var p;
          try {
            if (typeof i[c] != "function") {
              var d = Error(
                (l || "React class") + ": " + a + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw d.name = "Invariant Violation", d;
            }
            p = i[c](s, c, l, a, null, t);
          } catch (m) {
            p = m;
          }
          if (p && !(p instanceof Error) && e(
            (l || "React class") + ": type specification of " + a + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof p + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), p instanceof Error && !(p.message in n)) {
            n[p.message] = !0;
            var g = u ? u() : "";
            e(
              "Failed " + a + " type: " + p.message + (g ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, mh = o, mh;
}
var vh, mD;
function Bee() {
  if (mD) return vh;
  mD = 1;
  var e = BA(), t = Tee(), n = Dy(), r = _A(), o = Aee(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(a) {
    var l = "Warning: " + a;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function s() {
    return null;
  }
  return vh = function(a, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function p(S) {
      var P = S && (u && S[u] || S[c]);
      if (typeof P == "function")
        return P;
    }
    var d = "<<anonymous>>", g = {
      array: E("array"),
      bigint: E("bigint"),
      bool: E("boolean"),
      func: E("function"),
      number: E("number"),
      object: E("object"),
      string: E("string"),
      symbol: E("symbol"),
      any: L(),
      arrayOf: x,
      element: T(),
      elementType: w(),
      instanceOf: C,
      node: M(),
      objectOf: O,
      oneOf: k,
      oneOfType: U,
      shape: $,
      exact: W
    };
    function m(S, P) {
      return S === P ? S !== 0 || 1 / S === 1 / P : S !== S && P !== P;
    }
    function f(S, P) {
      this.message = S, this.data = P && typeof P == "object" ? P : {}, this.stack = "";
    }
    f.prototype = Error.prototype;
    function h(S) {
      if (process.env.NODE_ENV !== "production")
        var P = {}, q = 0;
      function j(G, b, F, z, A, Y, ee) {
        if (z = z || d, Y = Y || F, ee !== n) {
          if (l) {
            var B = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw B.name = "Invariant Violation", B;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var se = z + ":" + F;
            !P[se] && // Avoid spamming the console because they are often not actionable except for lib authors
            q < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + Y + "` prop on `" + z + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), P[se] = !0, q++);
          }
        }
        return b[F] == null ? G ? b[F] === null ? new f("The " + A + " `" + Y + "` is marked as required " + ("in `" + z + "`, but its value is `null`.")) : new f("The " + A + " `" + Y + "` is marked as required in " + ("`" + z + "`, but its value is `undefined`.")) : null : S(b, F, z, A, Y);
      }
      var Z = j.bind(null, !1);
      return Z.isRequired = j.bind(null, !0), Z;
    }
    function E(S) {
      function P(q, j, Z, G, b, F) {
        var z = q[j], A = X(z);
        if (A !== S) {
          var Y = I(z);
          return new f(
            "Invalid " + G + " `" + b + "` of type " + ("`" + Y + "` supplied to `" + Z + "`, expected ") + ("`" + S + "`."),
            { expectedType: S }
          );
        }
        return null;
      }
      return h(P);
    }
    function L() {
      return h(s);
    }
    function x(S) {
      function P(q, j, Z, G, b) {
        if (typeof S != "function")
          return new f("Property `" + b + "` of component `" + Z + "` has invalid PropType notation inside arrayOf.");
        var F = q[j];
        if (!Array.isArray(F)) {
          var z = X(F);
          return new f("Invalid " + G + " `" + b + "` of type " + ("`" + z + "` supplied to `" + Z + "`, expected an array."));
        }
        for (var A = 0; A < F.length; A++) {
          var Y = S(F, A, Z, G, b + "[" + A + "]", n);
          if (Y instanceof Error)
            return Y;
        }
        return null;
      }
      return h(P);
    }
    function T() {
      function S(P, q, j, Z, G) {
        var b = P[q];
        if (!a(b)) {
          var F = X(b);
          return new f("Invalid " + Z + " `" + G + "` of type " + ("`" + F + "` supplied to `" + j + "`, expected a single ReactElement."));
        }
        return null;
      }
      return h(S);
    }
    function w() {
      function S(P, q, j, Z, G) {
        var b = P[q];
        if (!e.isValidElementType(b)) {
          var F = X(b);
          return new f("Invalid " + Z + " `" + G + "` of type " + ("`" + F + "` supplied to `" + j + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return h(S);
    }
    function C(S) {
      function P(q, j, Z, G, b) {
        if (!(q[j] instanceof S)) {
          var F = S.name || d, z = te(q[j]);
          return new f("Invalid " + G + " `" + b + "` of type " + ("`" + z + "` supplied to `" + Z + "`, expected ") + ("instance of `" + F + "`."));
        }
        return null;
      }
      return h(P);
    }
    function k(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), s;
      function P(q, j, Z, G, b) {
        for (var F = q[j], z = 0; z < S.length; z++)
          if (m(F, S[z]))
            return null;
        var A = JSON.stringify(S, function(ee, B) {
          var se = I(B);
          return se === "symbol" ? String(B) : B;
        });
        return new f("Invalid " + G + " `" + b + "` of value `" + String(F) + "` " + ("supplied to `" + Z + "`, expected one of " + A + "."));
      }
      return h(P);
    }
    function O(S) {
      function P(q, j, Z, G, b) {
        if (typeof S != "function")
          return new f("Property `" + b + "` of component `" + Z + "` has invalid PropType notation inside objectOf.");
        var F = q[j], z = X(F);
        if (z !== "object")
          return new f("Invalid " + G + " `" + b + "` of type " + ("`" + z + "` supplied to `" + Z + "`, expected an object."));
        for (var A in F)
          if (r(F, A)) {
            var Y = S(F, A, Z, G, b + "." + A, n);
            if (Y instanceof Error)
              return Y;
          }
        return null;
      }
      return h(P);
    }
    function U(S) {
      if (!Array.isArray(S))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), s;
      for (var P = 0; P < S.length; P++) {
        var q = S[P];
        if (typeof q != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + J(q) + " at index " + P + "."
          ), s;
      }
      function j(Z, G, b, F, z) {
        for (var A = [], Y = 0; Y < S.length; Y++) {
          var ee = S[Y], B = ee(Z, G, b, F, z, n);
          if (B == null)
            return null;
          B.data && r(B.data, "expectedType") && A.push(B.data.expectedType);
        }
        var se = A.length > 0 ? ", expected one of type [" + A.join(", ") + "]" : "";
        return new f("Invalid " + F + " `" + z + "` supplied to " + ("`" + b + "`" + se + "."));
      }
      return h(j);
    }
    function M() {
      function S(P, q, j, Z, G) {
        return R(P[q]) ? null : new f("Invalid " + Z + " `" + G + "` supplied to " + ("`" + j + "`, expected a ReactNode."));
      }
      return h(S);
    }
    function V(S, P, q, j, Z) {
      return new f(
        (S || "React class") + ": " + P + " type `" + q + "." + j + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + Z + "`."
      );
    }
    function $(S) {
      function P(q, j, Z, G, b) {
        var F = q[j], z = X(F);
        if (z !== "object")
          return new f("Invalid " + G + " `" + b + "` of type `" + z + "` " + ("supplied to `" + Z + "`, expected `object`."));
        for (var A in S) {
          var Y = S[A];
          if (typeof Y != "function")
            return V(Z, G, b, A, I(Y));
          var ee = Y(F, A, Z, G, b + "." + A, n);
          if (ee)
            return ee;
        }
        return null;
      }
      return h(P);
    }
    function W(S) {
      function P(q, j, Z, G, b) {
        var F = q[j], z = X(F);
        if (z !== "object")
          return new f("Invalid " + G + " `" + b + "` of type `" + z + "` " + ("supplied to `" + Z + "`, expected `object`."));
        var A = t({}, q[j], S);
        for (var Y in A) {
          var ee = S[Y];
          if (r(S, Y) && typeof ee != "function")
            return V(Z, G, b, Y, I(ee));
          if (!ee)
            return new f(
              "Invalid " + G + " `" + b + "` key `" + Y + "` supplied to `" + Z + "`.\nBad object: " + JSON.stringify(q[j], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(S), null, "  ")
            );
          var B = ee(F, Y, Z, G, b + "." + Y, n);
          if (B)
            return B;
        }
        return null;
      }
      return h(P);
    }
    function R(S) {
      switch (typeof S) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !S;
        case "object":
          if (Array.isArray(S))
            return S.every(R);
          if (S === null || a(S))
            return !0;
          var P = p(S);
          if (P) {
            var q = P.call(S), j;
            if (P !== S.entries) {
              for (; !(j = q.next()).done; )
                if (!R(j.value))
                  return !1;
            } else
              for (; !(j = q.next()).done; ) {
                var Z = j.value;
                if (Z && !R(Z[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function H(S, P) {
      return S === "symbol" ? !0 : P ? P["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && P instanceof Symbol : !1;
    }
    function X(S) {
      var P = typeof S;
      return Array.isArray(S) ? "array" : S instanceof RegExp ? "object" : H(P, S) ? "symbol" : P;
    }
    function I(S) {
      if (typeof S > "u" || S === null)
        return "" + S;
      var P = X(S);
      if (P === "object") {
        if (S instanceof Date)
          return "date";
        if (S instanceof RegExp)
          return "regexp";
      }
      return P;
    }
    function J(S) {
      var P = I(S);
      switch (P) {
        case "array":
        case "object":
          return "an " + P;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + P;
        default:
          return P;
      }
    }
    function te(S) {
      return !S.constructor || !S.constructor.name ? d : S.constructor.name;
    }
    return g.checkPropTypes = o, g.resetWarningCache = o.resetWarningCache, g.PropTypes = g, g;
  }, vh;
}
var yh, vD;
function _ee() {
  if (vD) return yh;
  vD = 1;
  var e = Dy();
  function t() {
  }
  function n() {
  }
  return n.resetWarningCache = t, yh = function() {
    function r(s, a, l, u, c, p) {
      if (p !== e) {
        var d = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw d.name = "Invariant Violation", d;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: t
    };
    return i.PropTypes = i, i;
  }, yh;
}
if (process.env.NODE_ENV !== "production") {
  var Iee = BA(), jee = !0;
  Jg.exports = Bee()(Iee.isElement, jee);
} else
  Jg.exports = _ee()();
var Ld = Jg.exports, kd = {};
Object.defineProperty(kd, "__esModule", {
  value: !0
});
var Nee = jl, bh = Fee(Nee);
function Fee(e) {
  return e && e.__esModule ? e : { default: e };
}
var Ree = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, n) {
    this.containers[t] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, n = this.getHash();
    n ? window.setTimeout(function() {
      t.scrollTo(n, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, n) {
    var r = this.scroller, o = r.get(t);
    if (o && (n || t !== r.getActiveLink())) {
      var i = this.containers[t] || document;
      r.scrollTo(t, { container: i });
    }
  },
  getHash: function() {
    return bh.default.getHash();
  },
  changeHash: function(t, n) {
    this.isInitialized() && bh.default.getHash() !== t && bh.default.updateHash(t, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
kd.default = Ree;
Object.defineProperty(Bl, "__esModule", {
  value: !0
});
var Ju = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, zee = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), Uee = Be, yD = Rl(Uee), $ee = _l, ec = Rl($ee), Wee = Zs, Hee = Rl(Wee), Vee = Ld, In = Rl(Vee), Zee = kd, oi = Rl(Zee);
function Rl(e) {
  return e && e.__esModule ? e : { default: e };
}
function qee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function Gee(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Kee(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var bD = {
  to: In.default.string.isRequired,
  containerId: In.default.string,
  container: In.default.object,
  activeClass: In.default.string,
  activeStyle: In.default.object,
  spy: In.default.bool,
  horizontal: In.default.bool,
  smooth: In.default.oneOfType([In.default.bool, In.default.string]),
  offset: In.default.number,
  delay: In.default.number,
  isDynamic: In.default.bool,
  onClick: In.default.func,
  duration: In.default.oneOfType([In.default.number, In.default.func]),
  absolute: In.default.bool,
  onSetActive: In.default.func,
  onSetInactive: In.default.func,
  ignoreCancelEvents: In.default.bool,
  hashSpy: In.default.bool,
  saveHashHistory: In.default.bool,
  spyThrottle: In.default.number
};
Bl.default = function(e, t) {
  var n = t || Hee.default, r = function(i) {
    Kee(s, i);
    function s(a) {
      qee(this, s);
      var l = Gee(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, a));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return zee(s, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          ec.default.isMounted(l) || ec.default.mount(l, this.props.spyThrottle), this.props.hashSpy && (oi.default.isMounted() || oi.default.mount(n), oi.default.mapContainer(this.props.to, l)), ec.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        ec.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = Ju({}, this.props.style, this.props.activeStyle) : u = Ju({}, this.props.style);
        var c = Ju({}, this.props);
        for (var p in bD)
          c.hasOwnProperty(p) && delete c[p];
        return c.className = l, c.style = u, c.onClick = this.handleClick, yD.default.createElement(e, c);
      }
    }]), s;
  }(yD.default.PureComponent), o = function() {
    var s = this;
    this.scrollTo = function(a, l) {
      n.scrollTo(a, Ju({}, s.state, l));
    }, this.handleClick = function(a) {
      s.props.onClick && s.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), s.scrollTo(s.props.to, s.props);
    }, this.spyHandler = function(a, l) {
      var u = s.getScrollSpyContainer();
      if (!(oi.default.isMounted() && !oi.default.isInitialized())) {
        var c = s.props.horizontal, p = s.props.to, d = null, g = void 0, m = void 0;
        if (c) {
          var f = 0, h = 0, E = 0;
          if (u.getBoundingClientRect) {
            var L = u.getBoundingClientRect();
            E = L.left;
          }
          if (!d || s.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var x = d.getBoundingClientRect();
            f = x.left - E + a, h = f + x.width;
          }
          var T = a - s.props.offset;
          g = T >= Math.floor(f) && T < Math.floor(h), m = T < Math.floor(f) || T >= Math.floor(h);
        } else {
          var w = 0, C = 0, k = 0;
          if (u.getBoundingClientRect) {
            var O = u.getBoundingClientRect();
            k = O.top;
          }
          if (!d || s.props.isDynamic) {
            if (d = n.get(p), !d)
              return;
            var U = d.getBoundingClientRect();
            w = U.top - k + l, C = w + U.height;
          }
          var M = l - s.props.offset;
          g = M >= Math.floor(w) && M < Math.floor(C), m = M < Math.floor(w) || M >= Math.floor(C);
        }
        var V = n.getActiveLink();
        if (m) {
          if (p === V && n.setActiveLink(void 0), s.props.hashSpy && oi.default.getHash() === p) {
            var $ = s.props.saveHashHistory, W = $ === void 0 ? !1 : $;
            oi.default.changeHash("", W);
          }
          s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive(p, d));
        }
        if (g && (V !== p || s.state.active === !1)) {
          n.setActiveLink(p);
          var R = s.props.saveHashHistory, H = R === void 0 ? !1 : R;
          s.props.hashSpy && oi.default.changeHash(p, H), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(p, d));
        }
      }
    };
  };
  return r.propTypes = bD, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Cy, "__esModule", {
  value: !0
});
var Yee = Be, wD = IA(Yee), Xee = Bl, Qee = IA(Xee);
function IA(e) {
  return e && e.__esModule ? e : { default: e };
}
function Jee(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function CD(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function ete(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var tte = function(e) {
  ete(t, e);
  function t() {
    var n, r, o, i;
    Jee(this, t);
    for (var s = arguments.length, a = Array(s), l = 0; l < s; l++)
      a[l] = arguments[l];
    return i = (r = (o = CD(this, (n = t.__proto__ || Object.getPrototypeOf(t)).call.apply(n, [this].concat(a))), o), o.render = function() {
      return wD.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), CD(o, i);
  }
  return t;
}(wD.default.Component);
Cy.default = (0, Qee.default)(tte);
var Sy = {};
Object.defineProperty(Sy, "__esModule", {
  value: !0
});
var nte = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), rte = Be, ED = jA(rte), ote = Bl, ite = jA(ote);
function jA(e) {
  return e && e.__esModule ? e : { default: e };
}
function ste(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function ate(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function lte(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var ute = function(e) {
  lte(t, e);
  function t() {
    return ste(this, t), ate(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return nte(t, [{
    key: "render",
    value: function() {
      return ED.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), t;
}(ED.default.Component);
Sy.default = (0, ite.default)(ute);
var Oy = {}, Dd = {};
Object.defineProperty(Dd, "__esModule", {
  value: !0
});
var cte = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, pte = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), dte = Be, xD = Sd(dte), fte = pl;
Sd(fte);
var hte = Zs, LD = Sd(hte), gte = Ld, kD = Sd(gte);
function Sd(e) {
  return e && e.__esModule ? e : { default: e };
}
function mte(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function vte(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function yte(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
Dd.default = function(e) {
  var t = function(n) {
    yte(r, n);
    function r(o) {
      mte(this, r);
      var i = vte(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return pte(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        LD.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        LD.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return xD.default.createElement(e, cte({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(xD.default.Component);
  return t.propTypes = {
    name: kD.default.string,
    id: kD.default.string
  }, t;
};
Object.defineProperty(Oy, "__esModule", {
  value: !0
});
var DD = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, bte = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}(), wte = Be, SD = My(wte), Cte = Dd, Ete = My(Cte), xte = Ld, OD = My(xte);
function My(e) {
  return e && e.__esModule ? e : { default: e };
}
function Lte(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function kte(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function Dte(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var NA = function(e) {
  Dte(t, e);
  function t() {
    return Lte(this, t), kte(this, (t.__proto__ || Object.getPrototypeOf(t)).apply(this, arguments));
  }
  return bte(t, [{
    key: "render",
    value: function() {
      var r = this, o = DD({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, SD.default.createElement(
        "div",
        DD({}, o, { ref: function(s) {
          r.props.parentBindings.domNode = s;
        } }),
        this.props.children
      );
    }
  }]), t;
}(SD.default.Component);
NA.propTypes = {
  name: OD.default.string,
  id: OD.default.string
};
Oy.default = (0, Ete.default)(NA);
var wh = Object.assign || function(e) {
  for (var t = 1; t < arguments.length; t++) {
    var n = arguments[t];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[r] = n[r]);
  }
  return e;
}, MD = /* @__PURE__ */ function() {
  function e(t, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(t, o.key, o);
    }
  }
  return function(t, n, r) {
    return n && e(t.prototype, n), r && e(t, r), t;
  };
}();
function PD(e, t) {
  if (!(e instanceof t))
    throw new TypeError("Cannot call a class as a function");
}
function TD(e, t) {
  if (!e)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return t && (typeof t == "object" || typeof t == "function") ? t : e;
}
function AD(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof t);
  e.prototype = Object.create(t && t.prototype, { constructor: { value: e, enumerable: !1, writable: !0, configurable: !0 } }), t && (Object.setPrototypeOf ? Object.setPrototypeOf(e, t) : e.__proto__ = t);
}
var tc = Be, Yi = _l, Ch = Zs, Kn = Ld, ii = kd, BD = {
  to: Kn.string.isRequired,
  containerId: Kn.string,
  container: Kn.object,
  activeClass: Kn.string,
  spy: Kn.bool,
  smooth: Kn.oneOfType([Kn.bool, Kn.string]),
  offset: Kn.number,
  delay: Kn.number,
  isDynamic: Kn.bool,
  onClick: Kn.func,
  duration: Kn.oneOfType([Kn.number, Kn.func]),
  absolute: Kn.bool,
  onSetActive: Kn.func,
  onSetInactive: Kn.func,
  ignoreCancelEvents: Kn.bool,
  hashSpy: Kn.bool,
  spyThrottle: Kn.number
}, Ste = {
  Scroll: function(t, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || Ch, o = function(s) {
      AD(a, s);
      function a(l) {
        PD(this, a);
        var u = TD(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return MD(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Yi.isMounted(u) || Yi.mount(u, this.props.spyThrottle), this.props.hashSpy && (ii.isMounted() || ii.mount(r), ii.mapContainer(this.props.to, u)), this.props.spy && Yi.addStateHandler(this.stateHandler), Yi.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Yi.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = wh({}, this.props);
          for (var p in BD)
            c.hasOwnProperty(p) && delete c[p];
          return c.className = u, c.onClick = this.handleClick, tc.createElement(t, c);
        }
      }]), a;
    }(tc.Component), i = function() {
      var a = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, wh({}, a.state, u));
      }, this.handleClick = function(l) {
        a.props.onClick && a.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), a.scrollTo(a.props.to, a.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== a.props.to && (a.state !== null && a.state.active && a.props.onSetInactive && a.props.onSetInactive(), a.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = a.getScrollSpyContainer();
        if (!(ii.isMounted() && !ii.isInitialized())) {
          var c = a.props.to, p = null, d = 0, g = 0, m = 0;
          if (u.getBoundingClientRect) {
            var f = u.getBoundingClientRect();
            m = f.top;
          }
          if (!p || a.props.isDynamic) {
            if (p = r.get(c), !p)
              return;
            var h = p.getBoundingClientRect();
            d = h.top - m + l, g = d + h.height;
          }
          var E = l - a.props.offset, L = E >= Math.floor(d) && E < Math.floor(g), x = E < Math.floor(d) || E >= Math.floor(g), T = r.getActiveLink();
          if (x)
            return c === T && r.setActiveLink(void 0), a.props.hashSpy && ii.getHash() === c && ii.changeHash(), a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive()), Yi.updateStates();
          if (L && T !== c)
            return r.setActiveLink(c), a.props.hashSpy && ii.changeHash(c), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(c)), Yi.updateStates();
        }
      };
    };
    return o.propTypes = BD, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      AD(o, r);
      function o(i) {
        PD(this, o);
        var s = TD(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return s.childBindings = {
          domNode: null
        }, s;
      }
      return MD(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(s) {
          this.props.name !== s.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Ch.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(s) {
          Ch.register(s, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return tc.createElement(t, wh({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(tc.Component);
    return n.propTypes = {
      name: Kn.string,
      id: Kn.string
    }, n;
  }
}, Ote = Ste;
Object.defineProperty(nr, "__esModule", {
  value: !0
});
nr.Helpers = nr.ScrollElement = nr.ScrollLink = GA = nr.animateScroll = nr.scrollSpy = nr.Events = nr.scroller = nr.Element = nr.Button = nr.Link = void 0;
var Mte = Cy, FA = Oo(Mte), Pte = Sy, RA = Oo(Pte), Tte = Oy, zA = Oo(Tte), Ate = Zs, UA = Oo(Ate), Bte = Nl, $A = Oo(Bte), _te = _l, WA = Oo(_te), Ite = Cd, HA = Oo(Ite), jte = Bl, VA = Oo(jte), Nte = Dd, ZA = Oo(Nte), Fte = Ote, qA = Oo(Fte);
function Oo(e) {
  return e && e.__esModule ? e : { default: e };
}
nr.Link = FA.default;
nr.Button = RA.default;
nr.Element = zA.default;
nr.scroller = UA.default;
nr.Events = $A.default;
nr.scrollSpy = WA.default;
var GA = nr.animateScroll = HA.default;
nr.ScrollLink = VA.default;
nr.ScrollElement = ZA.default;
nr.Helpers = qA.default;
nr.default = { Link: FA.default, Button: RA.default, Element: zA.default, scroller: UA.default, Events: $A.default, scrollSpy: WA.default, animateScroll: HA.default, ScrollLink: VA.default, ScrollElement: ZA.default, Helpers: qA.default };
const Py = Ye({}), KA = Ye({});
function Rte() {
  const e = _e(KA);
  if (Object.entries(e).length === 0)
    throw new Error("useToast must be used within a Provider");
  return e;
}
function _D(e) {
  return e && typeof e.title == "string" && typeof e.message == "string" && (e.size === void 0 || e.size === "md" || e.size === "lg") && (e.type === "success" || e.type === "danger");
}
function xre() {
  const e = rm(), { closeModal: t, closeAll: n } = _e(Py), { showToast: r } = Rte(), { getParam: o } = kA(), { pathname: i } = om(), s = VD(), a = o("closeAllModals");
  v(() => {
    a === "true" && (n(), s(i));
  }, [a]), v(() => {
    const l = e == null ? void 0 : e.closeModalKey;
    l && t(l);
  }, [e]), v(() => {
    const l = e == null ? void 0 : e.toast, u = e == null ? void 0 : e.message;
    _D(l) && r(l), !_D(l) && u && r({ message: u, type: "danger" });
  }, [e]), v(() => {
    var l, u;
    if (typeof ((l = e == null ? void 0 : e.data) == null ? void 0 : l.scrollTo) == "string") {
      const c = document.getElementById((u = e == null ? void 0 : e.data) == null ? void 0 : u.scrollTo);
      c && GA.scrollTo(c.offsetTop - 200);
    }
  }, [e]);
}
const YA = Ye({});
function Lre(e) {
  const t = _e(YA);
  if (Object.entries(t).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (e) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = t, s = r(e), a = n(e);
    return { drawerIsOpen: s, drawerData: a, openDrawer: (c) => o(e, c), closeDrawer: () => i(e) };
  } else
    return t;
}
function kre(e) {
  const t = _e(Py);
  if (Object.entries(t).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (e) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = t, s = r(e), a = n(e);
    return { modalIsOpen: s, modalData: a, openModal: (c) => o(e, c), closeModal: () => i(e) };
  } else
    return t;
}
function Dre(e) {
  const { children: t = !1 } = e, [n, r] = D([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function s(l, u) {
    const c = o(l);
    r(c ? (p) => [...p.filter((g) => g.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function a(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ Q.jsx(
    YA.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: s, closeDrawer: a },
      children: t
    }
  );
}
function Sre({
  googleMapsApiKey: e,
  children: t,
  ...n
}) {
  return /* @__PURE__ */ Q.jsx(
    $B,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: e,
      ...n,
      children: t
    }
  );
}
function Ore(e) {
  const { children: t = !1 } = e, [n, r] = D([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((p) => p.key === u)) == null ? void 0 : c.data;
  }
  function s(u, c) {
    const p = o(u);
    r(p ? (d) => [...d.filter((m) => m.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function a(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ Q.jsx(
    Py.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: s, closeModal: a, closeAll: l },
      children: t
    }
  );
}
let zte = { data: "" }, Ute = (e) => typeof window == "object" ? ((e ? e.querySelector("#_goober") : window._goober) || Object.assign((e || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : e || zte, $te = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, Wte = /\/\*[^]*?\*\/|  +/g, ID = /\n+/g, bi = (e, t) => {
  let n = "", r = "", o = "";
  for (let i in e) {
    let s = e[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + s + ";" : r += i[1] == "f" ? bi(s, i) : i + "{" + bi(s, i[1] == "k" ? "" : t) + "}" : typeof s == "object" ? r += bi(s, t ? t.replace(/([^,])+/g, (a) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, a) : a ? a + " " + l : l)) : i) : s != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += bi.p ? bi.p(i, s) : i + ":" + s + ";");
  }
  return n + (t && o ? t + "{" + o + "}" : o) + r;
}, jo = {}, XA = (e) => {
  if (typeof e == "object") {
    let t = "";
    for (let n in e) t += n + XA(e[n]);
    return t;
  }
  return e;
}, Hte = (e, t, n, r, o) => {
  let i = XA(e), s = jo[i] || (jo[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!jo[s]) {
    let l = i !== e ? e : ((u) => {
      let c, p, d = [{}];
      for (; c = $te.exec(u.replace(Wte, "")); ) c[4] ? d.shift() : c[3] ? (p = c[3].replace(ID, " ").trim(), d.unshift(d[0][p] = d[0][p] || {})) : d[0][c[1]] = c[2].replace(ID, " ").trim();
      return d[0];
    })(e);
    jo[s] = bi(o ? { ["@keyframes " + s]: l } : l, n ? "" : "." + s);
  }
  let a = n && jo.g ? jo.g : null;
  return n && (jo.g = jo[s]), ((l, u, c, p) => {
    p ? u.data = u.data.replace(p, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(jo[s], t, r, a), s;
}, Vte = (e, t, n) => e.reduce((r, o, i) => {
  let s = t[i];
  if (s && s.call) {
    let a = s(n), l = a && a.props && a.props.className || /^go/.test(a) && a;
    s = l ? "." + l : a && typeof a == "object" ? a.props ? "" : bi(a, "") : a === !1 ? "" : a;
  }
  return r + o + (s ?? "");
}, "");
function Od(e) {
  let t = this || {}, n = e.call ? e(t.p) : e;
  return Hte(n.unshift ? n.raw ? Vte(n, [].slice.call(arguments, 1), t.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(t.p) : o), {}) : n, Ute(t.target), t.g, t.o, t.k);
}
let QA, em, tm;
Od.bind({ g: 1 });
let Vo = Od.bind({ k: 1 });
function Zte(e, t, n, r) {
  bi.p = t, QA = e, em = n, tm = r;
}
function Ri(e, t) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, s) {
      let a = Object.assign({}, i), l = a.className || o.className;
      n.p = Object.assign({ theme: em && em() }, a), n.o = / *go\d+/.test(l), a.className = Od.apply(n, r) + (l ? " " + l : ""), t && (a.ref = s);
      let u = e;
      return e[0] && (u = a.as || e, delete a.as), tm && u[0] && tm(a), QA(u, a);
    }
    return t ? t(o) : o;
  };
}
var qte = (e) => typeof e == "function", Kc = (e, t) => qte(e) ? e(t) : e, Gte = /* @__PURE__ */ (() => {
  let e = 0;
  return () => (++e).toString();
})(), JA = /* @__PURE__ */ (() => {
  let e;
  return () => {
    if (e === void 0 && typeof window < "u") {
      let t = matchMedia("(prefers-reduced-motion: reduce)");
      e = !t || t.matches;
    }
    return e;
  };
})(), Kte = 20, dc = /* @__PURE__ */ new Map(), Yte = 1e3, jD = (e) => {
  if (dc.has(e)) return;
  let t = setTimeout(() => {
    dc.delete(e), Ss({ type: 4, toastId: e });
  }, Yte);
  dc.set(e, t);
}, Xte = (e) => {
  let t = dc.get(e);
  t && clearTimeout(t);
}, nm = (e, t) => {
  switch (t.type) {
    case 0:
      return { ...e, toasts: [t.toast, ...e.toasts].slice(0, Kte) };
    case 1:
      return t.toast.id && Xte(t.toast.id), { ...e, toasts: e.toasts.map((i) => i.id === t.toast.id ? { ...i, ...t.toast } : i) };
    case 2:
      let { toast: n } = t;
      return e.toasts.find((i) => i.id === n.id) ? nm(e, { type: 1, toast: n }) : nm(e, { type: 0, toast: n });
    case 3:
      let { toastId: r } = t;
      return r ? jD(r) : e.toasts.forEach((i) => {
        jD(i.id);
      }), { ...e, toasts: e.toasts.map((i) => i.id === r || r === void 0 ? { ...i, visible: !1 } : i) };
    case 4:
      return t.toastId === void 0 ? { ...e, toasts: [] } : { ...e, toasts: e.toasts.filter((i) => i.id !== t.toastId) };
    case 5:
      return { ...e, pausedAt: t.time };
    case 6:
      let o = t.time - (e.pausedAt || 0);
      return { ...e, pausedAt: void 0, toasts: e.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, fc = [], hc = { toasts: [], pausedAt: void 0 }, Ss = (e) => {
  hc = nm(hc, e), fc.forEach((t) => {
    t(hc);
  });
}, Qte = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, Jte = (e = {}) => {
  let [t, n] = D(hc);
  v(() => (fc.push(n), () => {
    let o = fc.indexOf(n);
    o > -1 && fc.splice(o, 1);
  }), [t]);
  let r = t.toasts.map((o) => {
    var i, s;
    return { ...e, ...e[o.type], ...o, duration: o.duration || ((i = e[o.type]) == null ? void 0 : i.duration) || (e == null ? void 0 : e.duration) || Qte[o.type], style: { ...e.style, ...(s = e[o.type]) == null ? void 0 : s.style, ...o.style } };
  });
  return { ...t, toasts: r };
}, ene = (e, t = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: t, ariaProps: { role: "status", "aria-live": "polite" }, message: e, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || Gte() }), zl = (e) => (t, n) => {
  let r = ene(t, e, n);
  return Ss({ type: 2, toast: r }), r.id;
}, Gr = (e, t) => zl("blank")(e, t);
Gr.error = zl("error");
Gr.success = zl("success");
Gr.loading = zl("loading");
Gr.custom = zl("custom");
Gr.dismiss = (e) => {
  Ss({ type: 3, toastId: e });
};
Gr.remove = (e) => Ss({ type: 4, toastId: e });
Gr.promise = (e, t, n) => {
  let r = Gr.loading(t.loading, { ...n, ...n == null ? void 0 : n.loading });
  return e.then((o) => (Gr.success(Kc(t.success, o), { id: r, ...n, ...n == null ? void 0 : n.success }), o)).catch((o) => {
    Gr.error(Kc(t.error, o), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), e;
};
var tne = (e, t) => {
  Ss({ type: 1, toast: { id: e, height: t } });
}, nne = () => {
  Ss({ type: 5, time: Date.now() });
}, rne = (e) => {
  let { toasts: t, pausedAt: n } = Jte(e);
  v(() => {
    if (n) return;
    let i = Date.now(), s = t.map((a) => {
      if (a.duration === 1 / 0) return;
      let l = (a.duration || 0) + a.pauseDuration - (i - a.createdAt);
      if (l < 0) {
        a.visible && Gr.dismiss(a.id);
        return;
      }
      return setTimeout(() => Gr.dismiss(a.id), l);
    });
    return () => {
      s.forEach((a) => a && clearTimeout(a));
    };
  }, [t, n]);
  let r = Zt(() => {
    n && Ss({ type: 6, time: Date.now() });
  }, [n]), o = Zt((i, s) => {
    let { reverseOrder: a = !1, gutter: l = 8, defaultPosition: u } = s || {}, c = t.filter((g) => (g.position || u) === (i.position || u) && g.height), p = c.findIndex((g) => g.id === i.id), d = c.filter((g, m) => m < p && g.visible).length;
    return c.filter((g) => g.visible).slice(...a ? [d + 1] : [0, d]).reduce((g, m) => g + (m.height || 0) + l, 0);
  }, [t]);
  return { toasts: t, handlers: { updateHeight: tne, startPause: nne, endPause: r, calculateOffset: o } };
}, one = Vo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, ine = Vo`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, sne = Vo`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, ane = Ri("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${one} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${ine} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(e) => e.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${sne} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, lne = Vo`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, une = Ri("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(e) => e.secondary || "#e0e0e0"};
  border-right-color: ${(e) => e.primary || "#616161"};
  animation: ${lne} 1s linear infinite;
`, cne = Vo`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, pne = Vo`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, dne = Ri("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(e) => e.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${cne} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${pne} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(e) => e.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, fne = Ri("div")`
  position: absolute;
`, hne = Ri("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, gne = Vo`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, mne = Ri("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${gne} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, vne = ({ toast: e }) => {
  let { icon: t, type: n, iconTheme: r } = e;
  return t !== void 0 ? typeof t == "string" ? Ve.createElement(mne, null, t) : t : n === "blank" ? null : Ve.createElement(hne, null, Ve.createElement(une, { ...r }), n !== "loading" && Ve.createElement(fne, null, n === "error" ? Ve.createElement(ane, { ...r }) : Ve.createElement(dne, { ...r })));
}, yne = (e) => `
0% {transform: translate3d(0,${e * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, bne = (e) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${e * -150}%,-1px) scale(.6); opacity:0;}
`, wne = "0%{opacity:0;} 100%{opacity:1;}", Cne = "0%{opacity:1;} 100%{opacity:0;}", Ene = Ri("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, xne = Ri("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, Lne = (e, t) => {
  let n = e.includes("top") ? 1 : -1, [r, o] = JA() ? [wne, Cne] : [yne(n), bne(n)];
  return { animation: t ? `${Vo(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Vo(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, kne = Ve.memo(({ toast: e, position: t, style: n, children: r }) => {
  let o = e.height ? Lne(e.position || t || "top-center", e.visible) : { opacity: 0 }, i = Ve.createElement(vne, { toast: e }), s = Ve.createElement(xne, { ...e.ariaProps }, Kc(e.message, e));
  return Ve.createElement(Ene, { className: e.className, style: { ...o, ...n, ...e.style } }, typeof r == "function" ? r({ icon: i, message: s }) : Ve.createElement(Ve.Fragment, null, i, s));
});
Zte(Ve.createElement);
var Dne = ({ id: e, className: t, style: n, onHeightUpdate: r, children: o }) => {
  let i = Ve.useCallback((s) => {
    if (s) {
      let a = () => {
        let l = s.getBoundingClientRect().height;
        r(e, l);
      };
      a(), new MutationObserver(a).observe(s, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [e, r]);
  return Ve.createElement("div", { ref: i, className: t, style: n }, o);
}, Sne = (e, t) => {
  let n = e.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = e.includes("center") ? { justifyContent: "center" } : e.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: JA() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${t * (n ? 1 : -1)}px)`, ...r, ...o };
}, One = Od`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, nc = 16, Mne = ({ reverseOrder: e, position: t = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: s }) => {
  let { toasts: a, handlers: l } = rne(n);
  return Ve.createElement("div", { style: { position: "fixed", zIndex: 9999, top: nc, left: nc, right: nc, bottom: nc, pointerEvents: "none", ...i }, className: s, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, a.map((u) => {
    let c = u.position || t, p = l.calculateOffset(u, { reverseOrder: e, gutter: r, defaultPosition: t }), d = Sne(c, p);
    return Ve.createElement(Dne, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? One : "", style: d }, u.type === "custom" ? Kc(u.message, u) : o ? o(u) : Ve.createElement(kne, { toast: u, position: c }));
  }));
}, ND = Gr;
function Mre({ children: e }) {
  function t(n) {
    switch (n.type) {
      case "success":
        return ND.success(n.message);
      case "danger":
        return ND.error(n.message);
    }
  }
  return /* @__PURE__ */ Q.jsxs(KA.Provider, { value: { showToast: t }, children: [
    /* @__PURE__ */ Q.jsx(
      Mne,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    e
  ] });
}
export {
  jne as AlertContainer,
  Nne as AlertContent,
  Fne as AlertDescription,
  Rne as AlertIcon,
  LB as AlertTitle,
  zne as Badge,
  cre as BreadcrumbContainer,
  pre as BreadcrumbLink,
  Yne as Button,
  Une as Card,
  Qne as Checkbox,
  $ne as Divider,
  gre as DrawerContainer,
  mre as DrawerHeader,
  Dre as DrawerProvider,
  Xne as FormController,
  Jne as FormError,
  ere as FormLabel,
  Wne as GoogleMap,
  Sre as GoogleProvider,
  tre as GoogleSearchPlaces,
  nre as IconButton,
  rre as ImageUpload,
  pS as Input,
  vre as ModalContainer,
  yre as ModalFooter,
  bre as ModalHeader,
  Ore as ModalProvider,
  dre as Pagination,
  wre as Popover,
  ire as RadioBox,
  ore as RadioGroup,
  sre as RichText,
  are as Select,
  Hne as Skeleton,
  lre as Switch,
  hre as TabButton,
  fre as TabContainer,
  Vne as TableBody,
  Zne as TableCaption,
  qne as TableContainer,
  Gne as TableFooter,
  Kne as TableHeader,
  ure as Textarea,
  Cre as Toast,
  Mre as ToastProvider,
  Ere as Tooltip,
  xre as useAutomation,
  Lre as useDrawer,
  G_ as useFieldErrors,
  kre as useModal,
  kA as useScopedParams,
  Rte as useToast
};
