import * as tt from "react";
import be, { createContext as ct, useContext as Ee, Children as zt, forwardRef as es, memo as Re, useState as B, useRef as qe, useEffect as y, useMemo as En, isValidElement as ts, cloneElement as ns, Component as Km, PureComponent as xe, createRef as Cr, useId as VC, useCallback as it, useReducer as qC, useLayoutEffect as GC, useSyncExternalStore as ZC } from "react";
import { Info as Ym, AlertTriangle as KC, XCircle as Xm, CheckCircle2 as Jm, Loader2 as Un, Pause as YC, Play as XC, RefreshCw as Qm, Check as Ju, ChevronDown as ey, X as Qu, Search as ty, Image as JC, Heading1 as QC, Heading2 as ew, Quote as tw, Bold as nw, Italic as rw, Underline as ow, Code as iw, AlignLeft as aw, AlignRight as sw, AlignCenter as lw, AlignJustify as uw, ChevronRight as ru, ChevronLeft as cw, Ellipsis as Ed, MapPinned as dw } from "lucide-react";
import { useActionData as ec, useNavigation as ny, useFetchers as ry, useLocation as tc, Link as fw, useNavigate as oy } from "@remix-run/react";
import { InputMask as pw } from "@react-input/mask";
import * as rs from "react-dom";
import nc, { createPortal as wr } from "react-dom";
import { AnimatePresence as iy, motion as Go } from "framer-motion";
var ht = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function os(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var ou = { exports: {} }, Co = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Dd;
function hw() {
  if (Dd) return Co;
  Dd = 1;
  var t = be, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, d = {}, f = null, v = null;
    u !== void 0 && (f = "" + u), l.key !== void 0 && (f = "" + l.key), l.ref !== void 0 && (v = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (d[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) d[c] === void 0 && (d[c] = l[c]);
    return { $$typeof: e, type: s, key: f, ref: v, props: d, _owner: o.current };
  }
  return Co.Fragment = n, Co.jsx = a, Co.jsxs = a, Co;
}
var wo = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Od;
function gw() {
  return Od || (Od = 1, process.env.NODE_ENV !== "production" && function() {
    var t = be, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), h = Symbol.iterator, g = "@@iterator";
    function p(C) {
      if (C === null || typeof C != "object")
        return null;
      var K = h && C[h] || C[g];
      return typeof K == "function" ? K : null;
    }
    var w = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function b(C) {
      {
        for (var K = arguments.length, ne = new Array(K > 1 ? K - 1 : 0), ce = 1; ce < K; ce++)
          ne[ce - 1] = arguments[ce];
        k("error", C, ne);
      }
    }
    function k(C, K, ne) {
      {
        var ce = w.ReactDebugCurrentFrame, Ce = ce.getStackAddendum();
        Ce !== "" && (K += "%s", ne = ne.concat([Ce]));
        var we = ne.map(function(ve) {
          return String(ve);
        });
        we.unshift("Warning: " + K), Function.prototype.apply.call(console[C], console, we);
      }
    }
    var E = !1, m = !1, O = !1, S = !1, W = !1, P;
    P = Symbol.for("react.module.reference");
    function $(C) {
      return !!(typeof C == "string" || typeof C == "function" || C === r || C === i || W || C === o || C === u || C === c || S || C === v || E || m || O || typeof C == "object" && C !== null && (C.$$typeof === f || C.$$typeof === d || C.$$typeof === a || C.$$typeof === s || C.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      C.$$typeof === P || C.getModuleId !== void 0));
    }
    function j(C, K, ne) {
      var ce = C.displayName;
      if (ce)
        return ce;
      var Ce = K.displayName || K.name || "";
      return Ce !== "" ? ne + "(" + Ce + ")" : ne;
    }
    function _(C) {
      return C.displayName || "Context";
    }
    function I(C) {
      if (C == null)
        return null;
      if (typeof C.tag == "number" && b("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof C == "function")
        return C.displayName || C.name || null;
      if (typeof C == "string")
        return C;
      switch (C) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof C == "object")
        switch (C.$$typeof) {
          case s:
            var K = C;
            return _(K) + ".Consumer";
          case a:
            var ne = C;
            return _(ne._context) + ".Provider";
          case l:
            return j(C, C.render, "ForwardRef");
          case d:
            var ce = C.displayName || null;
            return ce !== null ? ce : I(C.type) || "Memo";
          case f: {
            var Ce = C, we = Ce._payload, ve = Ce._init;
            try {
              return I(ve(we));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var R = Object.assign, V = 0, J, G, te, Q, T, N, Y;
    function F() {
    }
    F.__reactDisabledLog = !0;
    function X() {
      {
        if (V === 0) {
          J = console.log, G = console.info, te = console.warn, Q = console.error, T = console.group, N = console.groupCollapsed, Y = console.groupEnd;
          var C = {
            configurable: !0,
            enumerable: !0,
            value: F,
            writable: !0
          };
          Object.defineProperties(console, {
            info: C,
            log: C,
            warn: C,
            error: C,
            group: C,
            groupCollapsed: C,
            groupEnd: C
          });
        }
        V++;
      }
    }
    function L() {
      {
        if (V--, V === 0) {
          var C = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: R({}, C, {
              value: J
            }),
            info: R({}, C, {
              value: G
            }),
            warn: R({}, C, {
              value: te
            }),
            error: R({}, C, {
              value: Q
            }),
            group: R({}, C, {
              value: T
            }),
            groupCollapsed: R({}, C, {
              value: N
            }),
            groupEnd: R({}, C, {
              value: Y
            })
          });
        }
        V < 0 && b("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = w.ReactCurrentDispatcher, z;
    function A(C, K, ne) {
      {
        if (z === void 0)
          try {
            throw Error();
          } catch (Ce) {
            var ce = Ce.stack.trim().match(/\n( *(at )?)/);
            z = ce && ce[1] || "";
          }
        return `
` + z + C;
      }
    }
    var U = !1, H;
    {
      var ee = typeof WeakMap == "function" ? WeakMap : Map;
      H = new ee();
    }
    function Z(C, K) {
      if (!C || U)
        return "";
      {
        var ne = H.get(C);
        if (ne !== void 0)
          return ne;
      }
      var ce;
      U = !0;
      var Ce = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var we;
      we = M.current, M.current = null, X();
      try {
        if (K) {
          var ve = function() {
            throw Error();
          };
          if (Object.defineProperty(ve.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ve, []);
            } catch (st) {
              ce = st;
            }
            Reflect.construct(C, [], ve);
          } else {
            try {
              ve.call();
            } catch (st) {
              ce = st;
            }
            C.call(ve.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (st) {
            ce = st;
          }
          C();
        }
      } catch (st) {
        if (st && ce && typeof st.stack == "string") {
          for (var ge = st.stack.split(`
`), et = ce.stack.split(`
`), Me = ge.length - 1, Te = et.length - 1; Me >= 1 && Te >= 0 && ge[Me] !== et[Te]; )
            Te--;
          for (; Me >= 1 && Te >= 0; Me--, Te--)
            if (ge[Me] !== et[Te]) {
              if (Me !== 1 || Te !== 1)
                do
                  if (Me--, Te--, Te < 0 || ge[Me] !== et[Te]) {
                    var vt = `
` + ge[Me].replace(" at new ", " at ");
                    return C.displayName && vt.includes("<anonymous>") && (vt = vt.replace("<anonymous>", C.displayName)), typeof C == "function" && H.set(C, vt), vt;
                  }
                while (Me >= 1 && Te >= 0);
              break;
            }
        }
      } finally {
        U = !1, M.current = we, L(), Error.prepareStackTrace = Ce;
      }
      var mn = C ? C.displayName || C.name : "", Qt = mn ? A(mn) : "";
      return typeof C == "function" && H.set(C, Qt), Qt;
    }
    function pe(C, K, ne) {
      return Z(C, !1);
    }
    function he(C) {
      var K = C.prototype;
      return !!(K && K.isReactComponent);
    }
    function le(C, K, ne) {
      if (C == null)
        return "";
      if (typeof C == "function")
        return Z(C, he(C));
      if (typeof C == "string")
        return A(C);
      switch (C) {
        case u:
          return A("Suspense");
        case c:
          return A("SuspenseList");
      }
      if (typeof C == "object")
        switch (C.$$typeof) {
          case l:
            return pe(C.render);
          case d:
            return le(C.type, K, ne);
          case f: {
            var ce = C, Ce = ce._payload, we = ce._init;
            try {
              return le(we(Ce), K, ne);
            } catch {
            }
          }
        }
      return "";
    }
    var Le = Object.prototype.hasOwnProperty, Fe = {}, Be = w.ReactDebugCurrentFrame;
    function Ne(C) {
      if (C) {
        var K = C._owner, ne = le(C.type, C._source, K ? K.type : null);
        Be.setExtraStackFrame(ne);
      } else
        Be.setExtraStackFrame(null);
    }
    function at(C, K, ne, ce, Ce) {
      {
        var we = Function.call.bind(Le);
        for (var ve in C)
          if (we(C, ve)) {
            var ge = void 0;
            try {
              if (typeof C[ve] != "function") {
                var et = Error((ce || "React class") + ": " + ne + " type `" + ve + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof C[ve] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw et.name = "Invariant Violation", et;
              }
              ge = C[ve](K, ve, ce, ne, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Me) {
              ge = Me;
            }
            ge && !(ge instanceof Error) && (Ne(Ce), b("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ce || "React class", ne, ve, typeof ge), Ne(null)), ge instanceof Error && !(ge.message in Fe) && (Fe[ge.message] = !0, Ne(Ce), b("Failed %s type: %s", ne, ge.message), Ne(null));
          }
      }
    }
    var dt = Array.isArray;
    function Oe(C) {
      return dt(C);
    }
    function ft(C) {
      {
        var K = typeof Symbol == "function" && Symbol.toStringTag, ne = K && C[Symbol.toStringTag] || C.constructor.name || "Object";
        return ne;
      }
    }
    function bt(C) {
      try {
        return De(C), !1;
      } catch {
        return !0;
      }
    }
    function De(C) {
      return "" + C;
    }
    function ke(C) {
      if (bt(C))
        return b("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ft(C)), De(C);
    }
    var Ke = w.ReactCurrentOwner, Je = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Qe, Bt, He;
    He = {};
    function Yt(C) {
      if (Le.call(C, "ref")) {
        var K = Object.getOwnPropertyDescriptor(C, "ref").get;
        if (K && K.isReactWarning)
          return !1;
      }
      return C.ref !== void 0;
    }
    function Ft(C) {
      if (Le.call(C, "key")) {
        var K = Object.getOwnPropertyDescriptor(C, "key").get;
        if (K && K.isReactWarning)
          return !1;
      }
      return C.key !== void 0;
    }
    function It(C, K) {
      if (typeof C.ref == "string" && Ke.current && K && Ke.current.stateNode !== K) {
        var ne = I(Ke.current.type);
        He[ne] || (b('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', I(Ke.current.type), C.ref), He[ne] = !0);
      }
    }
    function Wt(C, K) {
      {
        var ne = function() {
          Qe || (Qe = !0, b("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", K));
        };
        ne.isReactWarning = !0, Object.defineProperty(C, "key", {
          get: ne,
          configurable: !0
        });
      }
    }
    function fn(C, K) {
      {
        var ne = function() {
          Bt || (Bt = !0, b("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", K));
        };
        ne.isReactWarning = !0, Object.defineProperty(C, "ref", {
          get: ne,
          configurable: !0
        });
      }
    }
    var Ht = function(C, K, ne, ce, Ce, we, ve) {
      var ge = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: C,
        key: K,
        ref: ne,
        props: ve,
        // Record the component responsible for creating this element.
        _owner: we
      };
      return ge._store = {}, Object.defineProperty(ge._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ge, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ce
      }), Object.defineProperty(ge, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ce
      }), Object.freeze && (Object.freeze(ge.props), Object.freeze(ge)), ge;
    };
    function pn(C, K, ne, ce, Ce) {
      {
        var we, ve = {}, ge = null, et = null;
        ne !== void 0 && (ke(ne), ge = "" + ne), Ft(K) && (ke(K.key), ge = "" + K.key), Yt(K) && (et = K.ref, It(K, Ce));
        for (we in K)
          Le.call(K, we) && !Je.hasOwnProperty(we) && (ve[we] = K[we]);
        if (C && C.defaultProps) {
          var Me = C.defaultProps;
          for (we in Me)
            ve[we] === void 0 && (ve[we] = Me[we]);
        }
        if (ge || et) {
          var Te = typeof C == "function" ? C.displayName || C.name || "Unknown" : C;
          ge && Wt(ve, Te), et && fn(ve, Te);
        }
        return Ht(C, ge, et, Ce, ce, Ke.current, ve);
      }
    }
    var _t = w.ReactCurrentOwner, Xt = w.ReactDebugCurrentFrame;
    function Rt(C) {
      if (C) {
        var K = C._owner, ne = le(C.type, C._source, K ? K.type : null);
        Xt.setExtraStackFrame(ne);
      } else
        Xt.setExtraStackFrame(null);
    }
    var hn;
    hn = !1;
    function Vt(C) {
      return typeof C == "object" && C !== null && C.$$typeof === e;
    }
    function Bn() {
      {
        if (_t.current) {
          var C = I(_t.current.type);
          if (C)
            return `

Check the render method of \`` + C + "`.";
        }
        return "";
      }
    }
    function gn(C) {
      return "";
    }
    var Tn = {};
    function vn(C) {
      {
        var K = Bn();
        if (!K) {
          var ne = typeof C == "string" ? C : C.displayName || C.name;
          ne && (K = `

Check the top-level render call using <` + ne + ">.");
        }
        return K;
      }
    }
    function An(C, K) {
      {
        if (!C._store || C._store.validated || C.key != null)
          return;
        C._store.validated = !0;
        var ne = vn(K);
        if (Tn[ne])
          return;
        Tn[ne] = !0;
        var ce = "";
        C && C._owner && C._owner !== _t.current && (ce = " It was passed a child from " + I(C._owner.type) + "."), Rt(C), b('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ne, ce), Rt(null);
      }
    }
    function Vn(C, K) {
      {
        if (typeof C != "object")
          return;
        if (Oe(C))
          for (var ne = 0; ne < C.length; ne++) {
            var ce = C[ne];
            Vt(ce) && An(ce, K);
          }
        else if (Vt(C))
          C._store && (C._store.validated = !0);
        else if (C) {
          var Ce = p(C);
          if (typeof Ce == "function" && Ce !== C.entries)
            for (var we = Ce.call(C), ve; !(ve = we.next()).done; )
              Vt(ve.value) && An(ve.value, K);
        }
      }
    }
    function Jt(C) {
      {
        var K = C.type;
        if (K == null || typeof K == "string")
          return;
        var ne;
        if (typeof K == "function")
          ne = K.propTypes;
        else if (typeof K == "object" && (K.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        K.$$typeof === d))
          ne = K.propTypes;
        else
          return;
        if (ne) {
          var ce = I(K);
          at(ne, C.props, "prop", ce, C);
        } else if (K.PropTypes !== void 0 && !hn) {
          hn = !0;
          var Ce = I(K);
          b("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ce || "Unknown");
        }
        typeof K.getDefaultProps == "function" && !K.getDefaultProps.isReactClassApproved && b("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function de(C) {
      {
        for (var K = Object.keys(C.props), ne = 0; ne < K.length; ne++) {
          var ce = K[ne];
          if (ce !== "children" && ce !== "key") {
            Rt(C), b("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ce), Rt(null);
            break;
          }
        }
        C.ref !== null && (Rt(C), b("Invalid attribute `ref` supplied to `React.Fragment`."), Rt(null));
      }
    }
    var yo = {};
    function bo(C, K, ne, ce, Ce, we) {
      {
        var ve = $(C);
        if (!ve) {
          var ge = "";
          (C === void 0 || typeof C == "object" && C !== null && Object.keys(C).length === 0) && (ge += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var et = gn();
          et ? ge += et : ge += Bn();
          var Me;
          C === null ? Me = "null" : Oe(C) ? Me = "array" : C !== void 0 && C.$$typeof === e ? (Me = "<" + (I(C.type) || "Unknown") + " />", ge = " Did you accidentally export a JSX literal instead of a component?") : Me = typeof C, b("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Me, ge);
        }
        var Te = pn(C, K, ne, Ce, we);
        if (Te == null)
          return Te;
        if (ve) {
          var vt = K.children;
          if (vt !== void 0)
            if (ce)
              if (Oe(vt)) {
                for (var mn = 0; mn < vt.length; mn++)
                  Vn(vt[mn], C);
                Object.freeze && Object.freeze(vt);
              } else
                b("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Vn(vt, C);
        }
        if (Le.call(K, "key")) {
          var Qt = I(C), st = Object.keys(K).filter(function(tl) {
            return tl !== "key";
          }), kr = st.length > 0 ? "{key: someKey, " + st.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!yo[Qt + kr]) {
            var el = st.length > 0 ? "{" + st.join(": ..., ") + ": ...}" : "{}";
            b(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, kr, Qt, el, Qt), yo[Qt + kr] = !0;
          }
        }
        return C === r ? de(Te) : Jt(Te), Te;
      }
    }
    function Ys(C, K, ne) {
      return bo(C, K, ne, !0);
    }
    function Xs(C, K, ne) {
      return bo(C, K, ne, !1);
    }
    var Js = Xs, Qs = Ys;
    wo.Fragment = r, wo.jsx = Js, wo.jsxs = Qs;
  }()), wo;
}
process.env.NODE_ENV === "production" ? ou.exports = hw() : ou.exports = gw();
var x = ou.exports;
function vw(t) {
  const { className: e, ...n } = t, r = `arkynAlertTitle ${e}`;
  return /* @__PURE__ */ x.jsx("div", { className: r.trim(), ...n });
}
const ay = ct({});
function mw() {
  return Ee(ay);
}
function e2(t) {
  const { schema: e, children: n, className: r, ...o } = t, s = !((u) => {
    let c = !1;
    const d = (f) => {
      Array.isArray(f) ? f.forEach(d) : f && typeof f == "object" && "type" in f && (f.type === vw ? c = !0 : f.props && f.props.children && d(f.props.children));
    };
    return d(u), c;
  })(n) ? "nonExistsAlertTitle" : "existsAlertTitle", l = `arkynAlertContainer ${e} ${s} ${r}`;
  return /* @__PURE__ */ x.jsx(ay.Provider, { value: t, children: /* @__PURE__ */ x.jsx("div", { className: l.trim(), ...o, children: n }) });
}
function t2(t) {
  const { className: e, ...n } = t, r = `arkynAlertContent ${e}`;
  return /* @__PURE__ */ x.jsx("div", { className: r.trim(), ...n });
}
function n2(t) {
  const { className: e, ...n } = t, r = `arkynAlertDescription ${e}`;
  return /* @__PURE__ */ x.jsx("div", { className: r.trim(), ...n });
}
function r2(t) {
  const { className: e, ...n } = t, { schema: r } = mw(), o = `arkynAlertIcon ${r} ${e}`;
  switch (r) {
    case "success":
      return /* @__PURE__ */ x.jsx(Jm, { className: o, ...n });
    case "danger":
      return /* @__PURE__ */ x.jsx(Xm, { className: o, ...n });
    case "warning":
      return /* @__PURE__ */ x.jsx(KC, { className: o, ...n });
    case "info":
      return /* @__PURE__ */ x.jsx(Ym, { className: o, ...n });
  }
}
function ya(t, e) {
  return e ? /* @__PURE__ */ x.jsx(e, { size: t, strokeWidth: 2.5 }) : /* @__PURE__ */ x.jsx(x.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function xd(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function Zt(t) {
  var e, n;
  return xd(t) === !1 ? !1 : (e = t.constructor, e === void 0 ? !0 : (n = e.prototype, !(xd(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var sy = Symbol.for("immer-nothing"), Ld = Symbol.for("immer-draftable"), Dn = Symbol.for("immer-state"), yw = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(t) {
    return `The plugin for '${t}' has not been loaded into Immer. To enable the plugin, import and call \`enable${t}()\` when initializing your application.`;
  },
  function(t) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${t}'`;
  },
  "This object has been frozen and should not be mutated",
  function(t) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + t;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(t) {
    return `'current' expects a draft, got: ${t}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(t) {
    return `'original' expects a draft, got: ${t}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function sn(t, ...e) {
  if (process.env.NODE_ENV !== "production") {
    const n = yw[t], r = typeof n == "function" ? n.apply(null, e) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${t}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var so = Object.getPrototypeOf;
function Gr(t) {
  return !!t && !!t[Dn];
}
function Zr(t) {
  var e;
  return t ? ly(t) || Array.isArray(t) || !!t[Ld] || !!((e = t.constructor) != null && e[Ld]) || as(t) || ss(t) : !1;
}
var bw = Object.prototype.constructor.toString();
function ly(t) {
  if (!t || typeof t != "object")
    return !1;
  const e = so(t);
  if (e === null)
    return !0;
  const n = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === bw;
}
function ba(t, e) {
  is(t) === 0 ? Reflect.ownKeys(t).forEach((n) => {
    e(n, t[n], t);
  }) : t.forEach((n, r) => e(r, n, t));
}
function is(t) {
  const e = t[Dn];
  return e ? e.type_ : Array.isArray(t) ? 1 : as(t) ? 2 : ss(t) ? 3 : 0;
}
function iu(t, e) {
  return is(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function uy(t, e, n) {
  const r = is(t);
  r === 2 ? t.set(e, n) : r === 3 ? t.add(n) : t[e] = n;
}
function Cw(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function as(t) {
  return t instanceof Map;
}
function ss(t) {
  return t instanceof Set;
}
function Fr(t) {
  return t.copy_ || t.base_;
}
function au(t, e) {
  if (as(t))
    return new Map(t);
  if (ss(t))
    return new Set(t);
  if (Array.isArray(t))
    return Array.prototype.slice.call(t);
  const n = ly(t);
  if (e === !0 || e === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(t);
    delete r[Dn];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: t[a]
      });
    }
    return Object.create(so(t), r);
  } else {
    const r = so(t);
    if (r !== null && n)
      return { ...t };
    const o = Object.create(r);
    return Object.assign(o, t);
  }
}
function rc(t, e = !1) {
  return ls(t) || Gr(t) || !Zr(t) || (is(t) > 1 && (t.set = t.add = t.clear = t.delete = ww), Object.freeze(t), e && Object.entries(t).forEach(([n, r]) => rc(r, !0))), t;
}
function ww() {
  sn(2);
}
function ls(t) {
  return Object.isFrozen(t);
}
var Ew = {};
function Kr(t) {
  const e = Ew[t];
  return e || sn(0, t), e;
}
var Zo;
function cy() {
  return Zo;
}
function Dw(t, e) {
  return {
    drafts_: [],
    parent_: t,
    immer_: e,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Sd(t, e) {
  e && (Kr("Patches"), t.patches_ = [], t.inversePatches_ = [], t.patchListener_ = e);
}
function su(t) {
  lu(t), t.drafts_.forEach(Ow), t.drafts_ = null;
}
function lu(t) {
  t === Zo && (Zo = t.parent_);
}
function Pd(t) {
  return Zo = Dw(Zo, t);
}
function Ow(t) {
  const e = t[Dn];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0;
}
function kd(t, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const n = e.drafts_[0];
  return t !== void 0 && t !== n ? (n[Dn].modified_ && (su(e), sn(4)), Zr(t) && (t = Ca(e, t), e.parent_ || wa(e, t)), e.patches_ && Kr("Patches").generateReplacementPatches_(
    n[Dn].base_,
    t,
    e.patches_,
    e.inversePatches_
  )) : t = Ca(e, n, []), su(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), t !== sy ? t : void 0;
}
function Ca(t, e, n) {
  if (ls(e))
    return e;
  const r = e[Dn];
  if (!r)
    return ba(
      e,
      (o, i) => Md(t, r, e, o, i, n)
    ), e;
  if (r.scope_ !== t)
    return e;
  if (!r.modified_)
    return wa(t, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), ba(
      i,
      (s, l) => Md(t, r, o, s, l, n, a)
    ), wa(t, o, !1), n && t.patches_ && Kr("Patches").generatePatches_(
      r,
      n,
      t.patches_,
      t.inversePatches_
    );
  }
  return r.copy_;
}
function Md(t, e, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && sn(5), Gr(o)) {
    const s = i && e && e.type_ !== 3 && // Set objects are atomic since they have no keys.
    !iu(e.assigned_, r) ? i.concat(r) : void 0, l = Ca(t, o, s);
    if (uy(n, r, l), Gr(l))
      t.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Zr(o) && !ls(o)) {
    if (!t.immer_.autoFreeze_ && t.unfinalizedDrafts_ < 1)
      return;
    Ca(t, o), (!e || !e.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && wa(t, o);
  }
}
function wa(t, e, n = !1) {
  !t.parent_ && t.immer_.autoFreeze_ && t.canAutoFreeze_ && rc(e, n);
}
function xw(t, e) {
  const n = Array.isArray(t), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: e ? e.scope_ : cy(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: e,
    // The base state.
    base_: t,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = oc;
  n && (o = [r], i = Ko);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var oc = {
  get(t, e) {
    if (e === Dn)
      return t;
    const n = Fr(t);
    if (!iu(n, e))
      return Lw(t, n, e);
    const r = n[e];
    return t.finalized_ || !Zr(r) ? r : r === nl(t.base_, e) ? (rl(t), t.copy_[e] = cu(r, t)) : r;
  },
  has(t, e) {
    return e in Fr(t);
  },
  ownKeys(t) {
    return Reflect.ownKeys(Fr(t));
  },
  set(t, e, n) {
    const r = dy(Fr(t), e);
    if (r != null && r.set)
      return r.set.call(t.draft_, n), !0;
    if (!t.modified_) {
      const o = nl(Fr(t), e), i = o == null ? void 0 : o[Dn];
      if (i && i.base_ === n)
        return t.copy_[e] = n, t.assigned_[e] = !1, !0;
      if (Cw(n, o) && (n !== void 0 || iu(t.base_, e)))
        return !0;
      rl(t), uu(t);
    }
    return t.copy_[e] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || e in t.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(t.copy_[e]) || (t.copy_[e] = n, t.assigned_[e] = !0), !0;
  },
  deleteProperty(t, e) {
    return nl(t.base_, e) !== void 0 || e in t.base_ ? (t.assigned_[e] = !1, rl(t), uu(t)) : delete t.assigned_[e], t.copy_ && delete t.copy_[e], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(t, e) {
    const n = Fr(t), r = Reflect.getOwnPropertyDescriptor(n, e);
    return r && {
      writable: !0,
      configurable: t.type_ !== 1 || e !== "length",
      enumerable: r.enumerable,
      value: n[e]
    };
  },
  defineProperty() {
    sn(11);
  },
  getPrototypeOf(t) {
    return so(t.base_);
  },
  setPrototypeOf() {
    sn(12);
  }
}, Ko = {};
ba(oc, (t, e) => {
  Ko[t] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
});
Ko.deleteProperty = function(t, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && sn(13), Ko.set.call(this, t, e, void 0);
};
Ko.set = function(t, e, n) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && sn(14), oc.set.call(this, t[0], e, n, t[0]);
};
function nl(t, e) {
  const n = t[Dn];
  return (n ? Fr(n) : t)[e];
}
function Lw(t, e, n) {
  var o;
  const r = dy(e, n);
  return r ? "value" in r ? r.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (o = r.get) == null ? void 0 : o.call(t.draft_)
  ) : void 0;
}
function dy(t, e) {
  if (!(e in t))
    return;
  let n = so(t);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, e);
    if (r)
      return r;
    n = so(n);
  }
}
function uu(t) {
  t.modified_ || (t.modified_ = !0, t.parent_ && uu(t.parent_));
}
function rl(t) {
  t.copy_ || (t.copy_ = au(
    t.base_,
    t.scope_.immer_.useStrictShallowCopy_
  ));
}
var Sw = class {
  constructor(t) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, n, r) => {
      if (typeof e == "function" && typeof n != "function") {
        const i = n;
        n = e;
        const a = this;
        return function(l = i, ...u) {
          return a.produce(l, (c) => n.call(this, c, ...u));
        };
      }
      typeof n != "function" && sn(6), r !== void 0 && typeof r != "function" && sn(7);
      let o;
      if (Zr(e)) {
        const i = Pd(this), a = cu(e, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? su(i) : lu(i);
        }
        return Sd(i, r), kd(o, i);
      } else if (!e || typeof e != "object") {
        if (o = n(e), o === void 0 && (o = e), o === sy && (o = void 0), this.autoFreeze_ && rc(o, !0), r) {
          const i = [], a = [];
          Kr("Patches").generateReplacementPatches_(e, o, i, a), r(i, a);
        }
        return o;
      } else
        sn(1, e);
    }, this.produceWithPatches = (e, n) => {
      if (typeof e == "function")
        return (a, ...s) => this.produceWithPatches(a, (l) => e(l, ...s));
      let r, o;
      return [this.produce(e, n, (a, s) => {
        r = a, o = s;
      }), r, o];
    }, typeof (t == null ? void 0 : t.autoFreeze) == "boolean" && this.setAutoFreeze(t.autoFreeze), typeof (t == null ? void 0 : t.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(t.useStrictShallowCopy);
  }
  createDraft(t) {
    Zr(t) || sn(8), Gr(t) && (t = Pw(t));
    const e = Pd(this), n = cu(t, void 0);
    return n[Dn].isManual_ = !0, lu(e), n;
  }
  finishDraft(t, e) {
    const n = t && t[Dn];
    (!n || !n.isManual_) && sn(9);
    const { scope_: r } = n;
    return Sd(r, e), kd(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(t) {
    this.autoFreeze_ = t;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(t) {
    this.useStrictShallowCopy_ = t;
  }
  applyPatches(t, e) {
    let n;
    for (n = e.length - 1; n >= 0; n--) {
      const o = e[n];
      if (o.path.length === 0 && o.op === "replace") {
        t = o.value;
        break;
      }
    }
    n > -1 && (e = e.slice(n + 1));
    const r = Kr("Patches").applyPatches_;
    return Gr(t) ? r(t, e) : this.produce(
      t,
      (o) => r(o, e)
    );
  }
};
function cu(t, e) {
  const n = as(t) ? Kr("MapSet").proxyMap_(t, e) : ss(t) ? Kr("MapSet").proxySet_(t, e) : xw(t, e);
  return (e ? e.scope_ : cy()).drafts_.push(n), n;
}
function Pw(t) {
  return Gr(t) || sn(10, t), fy(t);
}
function fy(t) {
  if (!Zr(t) || ls(t))
    return t;
  const e = t[Dn];
  let n;
  if (e) {
    if (!e.modified_)
      return e.base_;
    e.finalized_ = !0, n = au(t, e.scope_.immer_.useStrictShallowCopy_);
  } else
    n = au(t, !0);
  return ba(n, (r, o) => {
    uy(n, r, fy(o));
  }), e && (e.finalized_ = !1), n;
}
var On = new Sw(), ic = On.produce;
On.produceWithPatches.bind(
  On
);
On.setAutoFreeze.bind(On);
On.setUseStrictShallowCopy.bind(On);
On.applyPatches.bind(On);
var Bd = On.createDraft.bind(On), Td = On.finishDraft.bind(On), kw = {
  transform(t, e) {
    var {
      current: n,
      affinity: r
    } = t;
    if (n != null) {
      var o = q.transform(n, e, {
        affinity: r
      });
      t.current = o, o == null && t.unref();
    }
  }
}, Mw = {
  transform(t, e) {
    var {
      current: n,
      affinity: r
    } = t;
    if (n != null) {
      var o = _e.transform(n, e, {
        affinity: r
      });
      t.current = o, o == null && t.unref();
    }
  }
}, Bw = {
  transform(t, e) {
    var {
      current: n,
      affinity: r
    } = t;
    if (n != null) {
      var o = re.transform(n, e, {
        affinity: r
      });
      t.current = o, o == null && t.unref();
    }
  }
}, Ea = /* @__PURE__ */ new WeakMap(), Da = /* @__PURE__ */ new WeakMap(), _o = /* @__PURE__ */ new WeakMap(), py = /* @__PURE__ */ new WeakMap(), Ad = /* @__PURE__ */ new WeakMap(), jd = /* @__PURE__ */ new WeakMap(), Fd = /* @__PURE__ */ new WeakMap(), q = {
  ancestors(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = e, r = q.levels(t, e);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(t, e) {
    for (var n = [], r = 0; r < t.length && r < e.length; r++) {
      var o = t[r], i = e[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(t, e) {
    for (var n = Math.min(t.length, e.length), r = 0; r < n; r++) {
      if (t[r] < e[r]) return -1;
      if (t[r] > e[r]) return 1;
    }
    return 0;
  },
  endsAfter(t, e) {
    var n = t.length - 1, r = t.slice(0, n), o = e.slice(0, n), i = t[n], a = e[n];
    return q.equals(r, o) && i > a;
  },
  endsAt(t, e) {
    var n = t.length, r = t.slice(0, n), o = e.slice(0, n);
    return q.equals(r, o);
  },
  endsBefore(t, e) {
    var n = t.length - 1, r = t.slice(0, n), o = e.slice(0, n), i = t[n], a = e[n];
    return q.equals(r, o) && i < a;
  },
  equals(t, e) {
    return t.length === e.length && t.every((n, r) => n === e[r]);
  },
  hasPrevious(t) {
    return t[t.length - 1] > 0;
  },
  isAfter(t, e) {
    return q.compare(t, e) === 1;
  },
  isAncestor(t, e) {
    return t.length < e.length && q.compare(t, e) === 0;
  },
  isBefore(t, e) {
    return q.compare(t, e) === -1;
  },
  isChild(t, e) {
    return t.length === e.length + 1 && q.compare(t, e) === 0;
  },
  isCommon(t, e) {
    return t.length <= e.length && q.compare(t, e) === 0;
  },
  isDescendant(t, e) {
    return t.length > e.length && q.compare(t, e) === 0;
  },
  isParent(t, e) {
    return t.length + 1 === e.length && q.compare(t, e) === 0;
  },
  isPath(t) {
    return Array.isArray(t) && (t.length === 0 || typeof t[0] == "number");
  },
  isSibling(t, e) {
    if (t.length !== e.length)
      return !1;
    var n = t.slice(0, -1), r = e.slice(0, -1), o = t[t.length - 1], i = e[e.length - 1];
    return o !== i && q.equals(n, r);
  },
  levels(t) {
    for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = e, r = [], o = 0; o <= t.length; o++)
      r.push(t.slice(0, o));
    return n && r.reverse(), r;
  },
  next(t) {
    if (t.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(t, "], because it has no next index."));
    var e = t[t.length - 1];
    return t.slice(0, -1).concat(e + 1);
  },
  operationCanTransformPath(t) {
    switch (t.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(t) {
    if (t.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(t, "]."));
    return t.slice(0, -1);
  },
  previous(t) {
    if (t.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(t, "], because it has no previous index."));
    var e = t[t.length - 1];
    if (e <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(t, "] because it would result in a negative index."));
    return t.slice(0, -1).concat(e - 1);
  },
  relative(t, e) {
    if (!q.isAncestor(e, t) && !q.equals(t, e))
      throw new Error("Cannot get the relative path of [".concat(t, "] inside ancestor [").concat(e, "], because it is not above or equal to the path."));
    return t.slice(e.length);
  },
  transform(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!t) return null;
    var r = [...t], {
      affinity: o = "forward"
    } = n;
    if (t.length === 0)
      return r;
    switch (e.type) {
      case "insert_node": {
        var {
          path: i
        } = e;
        (q.equals(i, r) || q.endsBefore(i, r) || q.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = e;
        if (q.equals(a, r) || q.isAncestor(a, r))
          return null;
        q.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = e;
        q.equals(s, r) || q.endsBefore(s, r) ? r[s.length - 1] -= 1 : q.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = e;
        if (q.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else q.endsBefore(u, r) ? r[u.length - 1] += 1 : q.isAncestor(u, r) && t[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: d,
          newPath: f
        } = e;
        if (q.equals(d, f))
          return r;
        if (q.isAncestor(d, r) || q.equals(d, r)) {
          var v = f.slice();
          return q.endsBefore(d, f) && d.length < f.length && (v[d.length - 1] -= 1), v.concat(r.slice(d.length));
        } else q.isSibling(d, f) && (q.isAncestor(f, r) || q.equals(f, r)) ? q.endsBefore(d, r) ? r[d.length - 1] -= 1 : r[d.length - 1] += 1 : q.endsBefore(f, r) || q.equals(f, r) || q.isAncestor(f, r) ? (q.endsBefore(d, r) && (r[d.length - 1] -= 1), r[f.length - 1] += 1) : q.endsBefore(d, r) && (q.equals(f, r) && (r[f.length - 1] += 1), r[d.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Yo(t) {
  "@babel/helpers - typeof";
  return Yo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Yo(t);
}
function Tw(t, e) {
  if (Yo(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (Yo(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function Aw(t) {
  var e = Tw(t, "string");
  return Yo(e) === "symbol" ? e : String(e);
}
function nn(t, e, n) {
  return e = Aw(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function _d(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Eo(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? _d(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : _d(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var jw = (t, e, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = fe.parent(t, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), e)
        for (var [s, l] of re.points(e))
          e[l] = _e.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: d
      } = n;
      if (d.length === 0) break;
      var f = fe.leaf(t, u), v = f.text.slice(0, c), h = f.text.slice(c);
      if (f.text = v + d + h, e)
        for (var [g, p] of re.points(e))
          e[p] = _e.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: w
      } = n, b = fe.get(t, w), k = q.previous(w), E = fe.get(t, k), m = fe.parent(t, w), O = w[w.length - 1];
      if (ye.isText(b) && ye.isText(E))
        E.text += b.text;
      else if (!ye.isText(b) && !ye.isText(E))
        E.children.push(...b.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(w, "] to nodes of different interfaces: ").concat(Ut.stringify(b), " ").concat(Ut.stringify(E)));
      if (m.children.splice(O, 1), e)
        for (var [S, W] of re.points(e))
          e[W] = _e.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: P,
        newPath: $
      } = n;
      if (q.isAncestor(P, $))
        throw new Error("Cannot move a path [".concat(P, "] to new path [").concat($, "] because the destination is inside itself."));
      var j = fe.get(t, P), _ = fe.parent(t, P), I = P[P.length - 1];
      _.children.splice(I, 1);
      var R = q.transform(P, n), V = fe.get(t, q.parent(R)), J = R[R.length - 1];
      if (V.children.splice(J, 0, j), e)
        for (var [G, te] of re.points(e))
          e[te] = _e.transform(G, n);
      break;
    }
    case "remove_node": {
      var {
        path: Q
      } = n, T = Q[Q.length - 1], N = fe.parent(t, Q);
      if (N.children.splice(T, 1), e)
        for (var [Y, F] of re.points(e)) {
          var X = _e.transform(Y, n);
          if (e != null && X != null)
            e[F] = X;
          else {
            var L = void 0, M = void 0;
            for (var [z, A] of fe.texts(t))
              if (q.compare(A, Q) === -1)
                L = [z, A];
              else {
                M = [z, A];
                break;
              }
            var U = !1;
            L && M && (q.equals(M[1], Q) ? U = !q.hasPrevious(M[1]) : U = q.common(L[1], Q).length < q.common(M[1], Q).length), L && !U ? (Y.path = L[1], Y.offset = L[0].text.length) : M ? (Y.path = M[1], Y.offset = 0) : e = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: H,
        offset: ee,
        text: Z
      } = n;
      if (Z.length === 0) break;
      var pe = fe.leaf(t, H), he = pe.text.slice(0, ee), le = pe.text.slice(ee + Z.length);
      if (pe.text = he + le, e)
        for (var [Le, Fe] of re.points(e))
          e[Fe] = _e.transform(Le, n);
      break;
    }
    case "set_node": {
      var {
        path: Be,
        properties: Ne,
        newProperties: at
      } = n;
      if (Be.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var dt = fe.get(t, Be);
      for (var Oe in at) {
        if (Oe === "children" || Oe === "text")
          throw new Error('Cannot set the "'.concat(Oe, '" property of nodes!'));
        var ft = at[Oe];
        ft == null ? delete dt[Oe] : dt[Oe] = ft;
      }
      for (var bt in Ne)
        at.hasOwnProperty(bt) || delete dt[bt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: De
      } = n;
      if (De == null)
        e = De;
      else {
        if (e == null) {
          if (!re.isRange(De))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(Ut.stringify(De), " when there is no current selection."));
          e = Eo({}, De);
        }
        for (var ke in De) {
          var Ke = De[ke];
          if (Ke == null) {
            if (ke === "anchor" || ke === "focus")
              throw new Error('Cannot remove the "'.concat(ke, '" selection property'));
            delete e[ke];
          } else
            e[ke] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Je,
        position: Qe,
        properties: Bt
      } = n;
      if (Je.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Je, "] because the root node cannot be split."));
      var He = fe.get(t, Je), Yt = fe.parent(t, Je), Ft = Je[Je.length - 1], It;
      if (ye.isText(He)) {
        var Wt = He.text.slice(0, Qe), fn = He.text.slice(Qe);
        He.text = Wt, It = Eo(Eo({}, Bt), {}, {
          text: fn
        });
      } else {
        var Ht = He.children.slice(0, Qe), pn = He.children.slice(Qe);
        He.children = Ht, It = Eo(Eo({}, Bt), {}, {
          children: pn
        });
      }
      if (Yt.children.splice(Ft + 1, 0, It), e)
        for (var [_t, Xt] of re.points(e))
          e[Xt] = _e.transform(_t, n);
      break;
    }
  }
  return e;
}, Fw = {
  transform(t, e) {
    t.children = Bd(t.children);
    var n = t.selection && Bd(t.selection);
    try {
      n = jw(t, n, e);
    } finally {
      t.children = Td(t.children), n ? t.selection = Gr(n) ? Td(n) : n : t.selection = null;
    }
  }
}, _w = {
  insertNodes(t, e, n) {
    t.insertNodes(e, n);
  },
  liftNodes(t, e) {
    t.liftNodes(e);
  },
  mergeNodes(t, e) {
    t.mergeNodes(e);
  },
  moveNodes(t, e) {
    t.moveNodes(e);
  },
  removeNodes(t, e) {
    t.removeNodes(e);
  },
  setNodes(t, e, n) {
    t.setNodes(e, n);
  },
  splitNodes(t, e) {
    t.splitNodes(e);
  },
  unsetNodes(t, e, n) {
    t.unsetNodes(e, n);
  },
  unwrapNodes(t, e) {
    t.unwrapNodes(e);
  },
  wrapNodes(t, e, n) {
    t.wrapNodes(e, n);
  }
}, Iw = {
  collapse(t, e) {
    t.collapse(e);
  },
  deselect(t) {
    t.deselect();
  },
  move(t, e) {
    t.move(e);
  },
  select(t, e) {
    t.select(e);
  },
  setPoint(t, e, n) {
    t.setPoint(e, n);
  },
  setSelection(t, e) {
    t.setSelection(e);
  }
}, hy = (t, e) => {
  for (var n in t) {
    var r = t[n], o = e[n];
    if (Zt(r) && Zt(o)) {
      if (!hy(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in e)
    if (t[a] === void 0 && e[a] !== void 0)
      return !1;
  return !0;
};
function Rw(t, e) {
  if (t == null) return {};
  var n = {}, r = Object.keys(t), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(e.indexOf(o) >= 0) && (n[o] = t[o]);
  return n;
}
function Jn(t, e) {
  if (t == null) return {};
  var n = Rw(t, e), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    for (o = 0; o < i.length; o++)
      r = i[o], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]);
  }
  return n;
}
var Nw = ["anchor", "focus"];
function Id(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $w(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Id(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Id(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var re = {
  edges(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = e, {
      anchor: r,
      focus: o
    } = t;
    return re.isBackward(t) === n ? [r, o] : [o, r];
  },
  end(t) {
    var [, e] = re.edges(t);
    return e;
  },
  equals(t, e) {
    return _e.equals(t.anchor, e.anchor) && _e.equals(t.focus, e.focus);
  },
  includes(t, e) {
    if (re.isRange(e)) {
      if (re.includes(t, e.anchor) || re.includes(t, e.focus))
        return !0;
      var [n, r] = re.edges(t), [o, i] = re.edges(e);
      return _e.isBefore(n, o) && _e.isAfter(r, i);
    }
    var [a, s] = re.edges(t), l = !1, u = !1;
    return _e.isPoint(e) ? (l = _e.compare(e, a) >= 0, u = _e.compare(e, s) <= 0) : (l = q.compare(e, a.path) >= 0, u = q.compare(e, s.path) <= 0), l && u;
  },
  intersection(t, e) {
    var n = Jn(t, Nw), [r, o] = re.edges(t), [i, a] = re.edges(e), s = _e.isBefore(r, i) ? i : r, l = _e.isBefore(o, a) ? o : a;
    return _e.isBefore(l, s) ? null : $w({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(t) {
    var {
      anchor: e,
      focus: n
    } = t;
    return _e.isAfter(e, n);
  },
  isCollapsed(t) {
    var {
      anchor: e,
      focus: n
    } = t;
    return _e.equals(e, n);
  },
  isExpanded(t) {
    return !re.isCollapsed(t);
  },
  isForward(t) {
    return !re.isBackward(t);
  },
  isRange(t) {
    return Zt(t) && _e.isPoint(t.anchor) && _e.isPoint(t.focus);
  },
  *points(t) {
    yield [t.anchor, "anchor"], yield [t.focus, "focus"];
  },
  start(t) {
    var [e] = re.edges(t);
    return e;
  },
  transform(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ic(t, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = re.isCollapsed(r);
        re.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? re.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = _e.transform(r.anchor, e, {
        affinity: i
      }), u = _e.transform(r.focus, e, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, Rd = (t) => Zt(t) && fe.isNodeList(t.children) && !D.isEditor(t), me = {
  isAncestor(t) {
    return Zt(t) && fe.isNodeList(t.children);
  },
  isElement: Rd,
  isElementList(t) {
    return Array.isArray(t) && t.every((e) => me.isElement(e));
  },
  isElementProps(t) {
    return t.children !== void 0;
  },
  isElementType: function(e, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Rd(e) && e[r] === n;
  },
  matches(t, e) {
    for (var n in e)
      if (n !== "children" && t[n] !== e[n])
        return !1;
    return !0;
  }
}, zw = ["children"], Uw = ["text"], Nd = /* @__PURE__ */ new WeakMap(), fe = {
  ancestor(t, e) {
    var n = fe.get(t, e);
    if (ye.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(e, "] because it refers to a text node instead: ").concat(Ut.stringify(n)));
    return n;
  },
  ancestors(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of q.ancestors(e, n)) {
        var o = fe.ancestor(t, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(t, e) {
    if (ye.isText(t))
      throw new Error("Cannot get the child of a text node: ".concat(Ut.stringify(t)));
    var n = t.children[e];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(e, "` in node: ").concat(Ut.stringify(t)));
    return n;
  },
  children(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = fe.ancestor(t, e), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = fe.child(o, a), l = e.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(t, e, n) {
    var r = q.common(e, n), o = fe.get(t, r);
    return [o, r];
  },
  descendant(t, e) {
    var n = fe.get(t, e);
    if (D.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(e, "] because it refers to the root editor node instead: ").concat(Ut.stringify(n)));
    return n;
  },
  descendants(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of fe.nodes(t, e))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of fe.nodes(t, e))
        me.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(t) {
    if (me.isAncestor(t)) {
      var e = Jn(t, zw);
      return e;
    } else {
      var e = Jn(t, Uw);
      return e;
    }
  },
  first(t, e) {
    for (var n = e.slice(), r = fe.get(t, n); r && !(ye.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(t, e) {
    if (ye.isText(t))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(Ut.stringify(t)));
    var n = ic({
      children: t.children
    }, (r) => {
      var [o, i] = re.edges(e), a = fe.nodes(r, {
        reverse: !0,
        pass: (f) => {
          var [, v] = f;
          return !re.includes(e, v);
        }
      });
      for (var [, s] of a) {
        if (!re.includes(e, s)) {
          var l = fe.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (q.equals(s, i.path)) {
          var c = fe.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (q.equals(s, o.path)) {
          var d = fe.leaf(r, s);
          d.text = d.text.slice(o.offset);
        }
      }
      D.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(t, e) {
    for (var n = t, r = 0; r < e.length; r++) {
      var o = e[r];
      if (ye.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(e, "] in node: ").concat(Ut.stringify(t)));
      n = n.children[o];
    }
    return n;
  },
  has(t, e) {
    for (var n = t, r = 0; r < e.length; r++) {
      var o = e[r];
      if (ye.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(t) {
    return ye.isText(t) || me.isElement(t) || D.isEditor(t);
  },
  isNodeList(t) {
    if (!Array.isArray(t))
      return !1;
    var e = Nd.get(t);
    if (e !== void 0)
      return e;
    var n = t.every((r) => fe.isNode(r));
    return Nd.set(t, n), n;
  },
  last(t, e) {
    for (var n = e.slice(), r = fe.get(t, n); r && !(ye.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(t, e) {
    var n = fe.get(t, e);
    if (!ye.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(e, "] because it refers to a non-leaf node: ").concat(Ut.stringify(n)));
    return n;
  },
  levels(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of q.levels(e, n)) {
        var o = fe.get(t, r);
        yield [o, r];
      }
    }();
  },
  matches(t, e) {
    return me.isElement(t) && me.isElementProps(e) && me.matches(t, e) || ye.isText(t) && ye.isTextProps(e) && ye.matches(t, e);
  },
  nodes(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = e, {
        from: o = [],
        to: i
      } = e, a = /* @__PURE__ */ new Set(), s = [], l = t; !(i && (r ? q.isBefore(s, i) : q.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !ye.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          q.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = fe.get(t, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = q.next(s);
          if (fe.has(t, c)) {
            s = c, l = fe.get(t, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var d = q.previous(s);
          s = d, l = fe.get(t, s);
          continue;
        }
        s = q.parent(s), l = fe.get(t, s), a.add(l);
      }
    }();
  },
  parent(t, e) {
    var n = q.parent(e), r = fe.get(t, n);
    if (ye.isText(r))
      throw new Error("Cannot get the parent of path [".concat(e, "] because it does not exist in the root."));
    return r;
  },
  string(t) {
    return ye.isText(t) ? t.text : t.children.map(fe.string).join("");
  },
  texts(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of fe.nodes(t, e))
        ye.isText(n) && (yield [n, r]);
    }();
  }
};
function $d(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ct(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? $d(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : $d(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var vr = {
  isNodeOperation(t) {
    return vr.isOperation(t) && t.type.endsWith("_node");
  },
  isOperation(t) {
    if (!Zt(t))
      return !1;
    switch (t.type) {
      case "insert_node":
        return q.isPath(t.path) && fe.isNode(t.node);
      case "insert_text":
        return typeof t.offset == "number" && typeof t.text == "string" && q.isPath(t.path);
      case "merge_node":
        return typeof t.position == "number" && q.isPath(t.path) && Zt(t.properties);
      case "move_node":
        return q.isPath(t.path) && q.isPath(t.newPath);
      case "remove_node":
        return q.isPath(t.path) && fe.isNode(t.node);
      case "remove_text":
        return typeof t.offset == "number" && typeof t.text == "string" && q.isPath(t.path);
      case "set_node":
        return q.isPath(t.path) && Zt(t.properties) && Zt(t.newProperties);
      case "set_selection":
        return t.properties === null && re.isRange(t.newProperties) || t.newProperties === null && re.isRange(t.properties) || Zt(t.properties) && Zt(t.newProperties);
      case "split_node":
        return q.isPath(t.path) && typeof t.position == "number" && Zt(t.properties);
      default:
        return !1;
    }
  },
  isOperationList(t) {
    return Array.isArray(t) && t.every((e) => vr.isOperation(e));
  },
  isSelectionOperation(t) {
    return vr.isOperation(t) && t.type.endsWith("_selection");
  },
  isTextOperation(t) {
    return vr.isOperation(t) && t.type.endsWith("_text");
  },
  inverse(t) {
    switch (t.type) {
      case "insert_node":
        return Ct(Ct({}, t), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return Ct(Ct({}, t), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return Ct(Ct({}, t), {}, {
          type: "split_node",
          path: q.previous(t.path)
        });
      case "move_node": {
        var {
          newPath: e,
          path: n
        } = t;
        if (q.equals(e, n))
          return t;
        if (q.isSibling(n, e))
          return Ct(Ct({}, t), {}, {
            path: e,
            newPath: n
          });
        var r = q.transform(n, t), o = q.transform(q.next(n), t);
        return Ct(Ct({}, t), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return Ct(Ct({}, t), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return Ct(Ct({}, t), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = t;
        return Ct(Ct({}, t), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = t;
        return s == null ? Ct(Ct({}, t), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? Ct(Ct({}, t), {}, {
          properties: null,
          newProperties: s
        }) : Ct(Ct({}, t), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return Ct(Ct({}, t), {}, {
          type: "merge_node",
          path: q.next(t.path)
        });
    }
  }
}, zd = /* @__PURE__ */ new WeakMap(), Ww = (t) => {
  var e = zd.get(t);
  if (e !== void 0)
    return e;
  if (!Zt(t))
    return !1;
  var n = typeof t.addMark == "function" && typeof t.apply == "function" && typeof t.deleteFragment == "function" && typeof t.insertBreak == "function" && typeof t.insertSoftBreak == "function" && typeof t.insertFragment == "function" && typeof t.insertNode == "function" && typeof t.insertText == "function" && typeof t.isElementReadOnly == "function" && typeof t.isInline == "function" && typeof t.isSelectable == "function" && typeof t.isVoid == "function" && typeof t.normalizeNode == "function" && typeof t.onChange == "function" && typeof t.removeMark == "function" && typeof t.getDirtyPaths == "function" && (t.marks === null || Zt(t.marks)) && (t.selection === null || re.isRange(t.selection)) && fe.isNodeList(t.children) && vr.isOperationList(t.operations);
  return zd.set(t, n), n;
}, D = {
  above(t, e) {
    return t.above(e);
  },
  addMark(t, e, n) {
    t.addMark(e, n);
  },
  after(t, e, n) {
    return t.after(e, n);
  },
  before(t, e, n) {
    return t.before(e, n);
  },
  deleteBackward(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = e;
    t.deleteBackward(n);
  },
  deleteForward(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = e;
    t.deleteForward(n);
  },
  deleteFragment(t, e) {
    t.deleteFragment(e);
  },
  edges(t, e) {
    return t.edges(e);
  },
  elementReadOnly(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return t.elementReadOnly(e);
  },
  end(t, e) {
    return t.end(e);
  },
  first(t, e) {
    return t.first(e);
  },
  fragment(t, e) {
    return t.fragment(e);
  },
  hasBlocks(t, e) {
    return t.hasBlocks(e);
  },
  hasInlines(t, e) {
    return t.hasInlines(e);
  },
  hasPath(t, e) {
    return t.hasPath(e);
  },
  hasTexts(t, e) {
    return t.hasTexts(e);
  },
  insertBreak(t) {
    t.insertBreak();
  },
  insertFragment(t, e, n) {
    t.insertFragment(e, n);
  },
  insertNode(t, e) {
    t.insertNode(e);
  },
  insertSoftBreak(t) {
    t.insertSoftBreak();
  },
  insertText(t, e) {
    t.insertText(e);
  },
  isBlock(t, e) {
    return t.isBlock(e);
  },
  isEdge(t, e, n) {
    return t.isEdge(e, n);
  },
  isEditor(t) {
    return Ww(t);
  },
  isElementReadOnly(t, e) {
    return t.isElementReadOnly(e);
  },
  isEmpty(t, e) {
    return t.isEmpty(e);
  },
  isEnd(t, e, n) {
    return t.isEnd(e, n);
  },
  isInline(t, e) {
    return t.isInline(e);
  },
  isNormalizing(t) {
    return t.isNormalizing();
  },
  isSelectable(t, e) {
    return t.isSelectable(e);
  },
  isStart(t, e, n) {
    return t.isStart(e, n);
  },
  isVoid(t, e) {
    return t.isVoid(e);
  },
  last(t, e) {
    return t.last(e);
  },
  leaf(t, e, n) {
    return t.leaf(e, n);
  },
  levels(t, e) {
    return t.levels(e);
  },
  marks(t) {
    return t.getMarks();
  },
  next(t, e) {
    return t.next(e);
  },
  node(t, e, n) {
    return t.node(e, n);
  },
  nodes(t, e) {
    return t.nodes(e);
  },
  normalize(t, e) {
    t.normalize(e);
  },
  parent(t, e, n) {
    return t.parent(e, n);
  },
  path(t, e, n) {
    return t.path(e, n);
  },
  pathRef(t, e, n) {
    return t.pathRef(e, n);
  },
  pathRefs(t) {
    return t.pathRefs();
  },
  point(t, e, n) {
    return t.point(e, n);
  },
  pointRef(t, e, n) {
    return t.pointRef(e, n);
  },
  pointRefs(t) {
    return t.pointRefs();
  },
  positions(t, e) {
    return t.positions(e);
  },
  previous(t, e) {
    return t.previous(e);
  },
  range(t, e, n) {
    return t.range(e, n);
  },
  rangeRef(t, e, n) {
    return t.rangeRef(e, n);
  },
  rangeRefs(t) {
    return t.rangeRefs();
  },
  removeMark(t, e) {
    t.removeMark(e);
  },
  setNormalizing(t, e) {
    t.setNormalizing(e);
  },
  start(t, e) {
    return t.start(e);
  },
  string(t, e, n) {
    return t.string(e, n);
  },
  unhangRange(t, e, n) {
    return t.unhangRange(e, n);
  },
  void(t, e) {
    return t.void(e);
  },
  withoutNormalizing(t, e) {
    t.withoutNormalizing(e);
  },
  shouldMergeNodesRemovePrevNode: (t, e, n) => t.shouldMergeNodesRemovePrevNode(e, n)
}, Hw = {
  isSpan(t) {
    return Array.isArray(t) && t.length === 2 && t.every(q.isPath);
  }
};
function Ud(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wd(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Ud(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Ud(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var _e = {
  compare(t, e) {
    var n = q.compare(t.path, e.path);
    return n === 0 ? t.offset < e.offset ? -1 : t.offset > e.offset ? 1 : 0 : n;
  },
  isAfter(t, e) {
    return _e.compare(t, e) === 1;
  },
  isBefore(t, e) {
    return _e.compare(t, e) === -1;
  },
  equals(t, e) {
    return t.offset === e.offset && q.equals(t.path, e.path);
  },
  isPoint(t) {
    return Zt(t) && typeof t.offset == "number" && q.isPath(t.path);
  },
  transform(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return ic(t, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (e.type) {
        case "insert_node":
        case "move_node": {
          r.path = q.transform(i, e, n);
          break;
        }
        case "insert_text": {
          q.equals(e.path, i) && (e.offset < a || e.offset === a && o === "forward") && (r.offset += e.text.length);
          break;
        }
        case "merge_node": {
          q.equals(e.path, i) && (r.offset += e.position), r.path = q.transform(i, e, n);
          break;
        }
        case "remove_text": {
          q.equals(e.path, i) && e.offset <= a && (r.offset -= Math.min(a - e.offset, e.text.length));
          break;
        }
        case "remove_node": {
          if (q.equals(e.path, i) || q.isAncestor(e.path, i))
            return null;
          r.path = q.transform(i, e, n);
          break;
        }
        case "split_node": {
          if (q.equals(e.path, i)) {
            if (e.position === a && o == null)
              return null;
            (e.position < a || e.position === a && o === "forward") && (r.offset -= e.position, r.path = q.transform(i, e, Wd(Wd({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = q.transform(i, e, n);
          break;
        }
      }
    });
  }
}, Hd = void 0, Ut = {
  setScrubber(t) {
    Hd = t;
  },
  stringify(t) {
    return JSON.stringify(t, Hd);
  }
}, Vw = ["text"], qw = ["anchor", "focus"];
function Vd(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function qn(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Vd(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Vd(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var ye = {
  equals(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = Jn(i, Vw);
      return a;
    }
    return hy(r ? o(t) : t, r ? o(e) : e);
  },
  isText(t) {
    return Zt(t) && typeof t.text == "string";
  },
  isTextList(t) {
    return Array.isArray(t) && t.every((e) => ye.isText(e));
  },
  isTextProps(t) {
    return t.text !== void 0;
  },
  matches(t, e) {
    for (var n in e)
      if (n !== "text" && (!t.hasOwnProperty(n) || t[n] !== e[n]))
        return !1;
    return !0;
  },
  decorations(t, e) {
    var n = [qn({}, t)];
    for (var r of e) {
      var o = Jn(r, qw), [i, a] = re.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var d of n) {
        var {
          length: f
        } = d.text, v = l;
        if (l += f, u <= v && l <= c) {
          Object.assign(d, o), s.push(d);
          continue;
        }
        if (u !== c && (u === l || c === v) || u > l || c < v || c === v && v !== 0) {
          s.push(d);
          continue;
        }
        var h = d, g = void 0, p = void 0;
        if (c < l) {
          var w = c - v;
          p = qn(qn({}, h), {}, {
            text: h.text.slice(w)
          }), h = qn(qn({}, h), {}, {
            text: h.text.slice(0, w)
          });
        }
        if (u > v) {
          var b = u - v;
          g = qn(qn({}, h), {}, {
            text: h.text.slice(0, b)
          }), h = qn(qn({}, h), {}, {
            text: h.text.slice(b)
          });
        }
        Object.assign(h, o), g && s.push(g), s.push(h), p && s.push(p);
      }
      n = s;
    }
    return n;
  }
}, ac = (t) => t.selection ? t.selection : t.children.length > 0 ? D.end(t, []) : [0], fo = (t, e) => {
  var [n] = D.node(t, e);
  return (r) => r === n;
}, sc = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = !n, o = n ? Jw(e) : e, i = Se.None, a = Se.None, s = 0, l = null, u = null;
  for (var c of o) {
    var d = c.codePointAt(0);
    if (!d) break;
    var f = cE(c, d);
    if ([i, a] = r ? [a, f] : [f, i], to(i, Se.ZWJ) && to(a, Se.ExtPict) && (r ? l = qd(e.substring(0, s)) : l = qd(e.substring(0, e.length - s)), !l) || to(i, Se.RI) && to(a, Se.RI) && (u !== null ? u = !u : r ? u = !0 : u = gE(e.substring(0, e.length - s)), !u) || i !== Se.None && a !== Se.None && fE(i, a))
      break;
    s += c.length;
  }
  return s || 1;
}, Gw = /\s/, Zw = /[\u002B\u0021-\u0023\u0025-\u002A\u002C-\u002F\u003A\u003B\u003F\u0040\u005B-\u005D\u005F\u007B\u007D\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u0AF0\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166D\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E3B\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/, Kw = /['\u2018\u2019]/, Yw = function(e) {
  for (var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : !1, r = 0, o = !1; e.length > 0; ) {
    var i = sc(e, n), [a, s] = lc(e, i, n);
    if (Xw(a, s, n))
      o = !0, r += i;
    else if (!o)
      r += i;
    else
      break;
    e = s;
  }
  return r;
}, lc = (t, e, n) => {
  if (n) {
    var r = t.length - e;
    return [t.slice(r, t.length), t.slice(0, r)];
  }
  return [t.slice(0, e), t.slice(e)];
}, Xw = function t(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : !1;
  if (Gw.test(e))
    return !1;
  if (Kw.test(e)) {
    var o = sc(n, r), [i, a] = lc(n, o, r);
    if (t(i, a, r))
      return !0;
  }
  return !Zw.test(e);
}, Jw = function* (e) {
  for (var n = e.length - 1, r = 0; r < e.length; r++) {
    var o = e.charAt(n - r);
    if (eE(o.charCodeAt(0))) {
      var i = e.charAt(n - r - 1);
      if (Qw(i.charCodeAt(0))) {
        yield i + o, r++;
        continue;
      }
    }
    yield o;
  }
}, Qw = (t) => t >= 55296 && t <= 56319, eE = (t) => t >= 56320 && t <= 57343, Se;
(function(t) {
  t[t.None = 0] = "None", t[t.Extend = 1] = "Extend", t[t.ZWJ = 2] = "ZWJ", t[t.RI = 4] = "RI", t[t.Prepend = 8] = "Prepend", t[t.SpacingMark = 16] = "SpacingMark", t[t.L = 32] = "L", t[t.V = 64] = "V", t[t.T = 128] = "T", t[t.LV = 256] = "LV", t[t.LVT = 512] = "LVT", t[t.ExtPict = 1024] = "ExtPict", t[t.Any = 2048] = "Any";
})(Se || (Se = {}));
var tE = /^(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])$/, nE = /^(?:[\u0600-\u0605\u06DD\u070F\u0890\u0891\u08E2\u0D4E]|\uD804[\uDCBD\uDCCD\uDDC2\uDDC3]|\uD806[\uDD3F\uDD41\uDE3A\uDE84-\uDE89]|\uD807\uDD46)$/, rE = /^(?:[\u0903\u093B\u093E-\u0940\u0949-\u094C\u094E\u094F\u0982\u0983\u09BF\u09C0\u09C7\u09C8\u09CB\u09CC\u0A03\u0A3E-\u0A40\u0A83\u0ABE-\u0AC0\u0AC9\u0ACB\u0ACC\u0B02\u0B03\u0B40\u0B47\u0B48\u0B4B\u0B4C\u0BBF\u0BC1\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCC\u0C01-\u0C03\u0C41-\u0C44\u0C82\u0C83\u0CBE\u0CC0\u0CC1\u0CC3\u0CC4\u0CC7\u0CC8\u0CCA\u0CCB\u0D02\u0D03\u0D3F\u0D40\u0D46-\u0D48\u0D4A-\u0D4C\u0D82\u0D83\u0DD0\u0DD1\u0DD8-\u0DDE\u0DF2\u0DF3\u0E33\u0EB3\u0F3E\u0F3F\u0F7F\u1031\u103B\u103C\u1056\u1057\u1084\u1715\u1734\u17B6\u17BE-\u17C5\u17C7\u17C8\u1923-\u1926\u1929-\u192B\u1930\u1931\u1933-\u1938\u1A19\u1A1A\u1A55\u1A57\u1A6D-\u1A72\u1B04\u1B3B\u1B3D-\u1B41\u1B43\u1B44\u1B82\u1BA1\u1BA6\u1BA7\u1BAA\u1BE7\u1BEA-\u1BEC\u1BEE\u1BF2\u1BF3\u1C24-\u1C2B\u1C34\u1C35\u1CE1\u1CF7\uA823\uA824\uA827\uA880\uA881\uA8B4-\uA8C3\uA952\uA953\uA983\uA9B4\uA9B5\uA9BA\uA9BB\uA9BE-\uA9C0\uAA2F\uAA30\uAA33\uAA34\uAA4D\uAAEB\uAAEE\uAAEF\uAAF5\uABE3\uABE4\uABE6\uABE7\uABE9\uABEA\uABEC]|\uD804[\uDC00\uDC02\uDC82\uDCB0-\uDCB2\uDCB7\uDCB8\uDD2C\uDD45\uDD46\uDD82\uDDB3-\uDDB5\uDDBF\uDDC0\uDDCE\uDE2C-\uDE2E\uDE32\uDE33\uDE35\uDEE0-\uDEE2\uDF02\uDF03\uDF3F\uDF41-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF62\uDF63]|\uD805[\uDC35-\uDC37\uDC40\uDC41\uDC45\uDCB1\uDCB2\uDCB9\uDCBB\uDCBC\uDCBE\uDCC1\uDDB0\uDDB1\uDDB8-\uDDBB\uDDBE\uDE30-\uDE32\uDE3B\uDE3C\uDE3E\uDEAC\uDEAE\uDEAF\uDEB6\uDF26]|\uD806[\uDC2C-\uDC2E\uDC38\uDD31-\uDD35\uDD37\uDD38\uDD3D\uDD40\uDD42\uDDD1-\uDDD3\uDDDC-\uDDDF\uDDE4\uDE39\uDE57\uDE58\uDE97]|\uD807[\uDC2F\uDC3E\uDCA9\uDCB1\uDCB4\uDD8A-\uDD8E\uDD93\uDD94\uDD96\uDEF5\uDEF6]|\uD81B[\uDF51-\uDF87\uDFF0\uDFF1]|\uD834[\uDD66\uDD6D])$/, oE = /^[\u1100-\u115F\uA960-\uA97C]$/, iE = /^[\u1160-\u11A7\uD7B0-\uD7C6]$/, aE = /^[\u11A8-\u11FF\uD7CB-\uD7FB]$/, sE = /^[\uAC00\uAC1C\uAC38\uAC54\uAC70\uAC8C\uACA8\uACC4\uACE0\uACFC\uAD18\uAD34\uAD50\uAD6C\uAD88\uADA4\uADC0\uADDC\uADF8\uAE14\uAE30\uAE4C\uAE68\uAE84\uAEA0\uAEBC\uAED8\uAEF4\uAF10\uAF2C\uAF48\uAF64\uAF80\uAF9C\uAFB8\uAFD4\uAFF0\uB00C\uB028\uB044\uB060\uB07C\uB098\uB0B4\uB0D0\uB0EC\uB108\uB124\uB140\uB15C\uB178\uB194\uB1B0\uB1CC\uB1E8\uB204\uB220\uB23C\uB258\uB274\uB290\uB2AC\uB2C8\uB2E4\uB300\uB31C\uB338\uB354\uB370\uB38C\uB3A8\uB3C4\uB3E0\uB3FC\uB418\uB434\uB450\uB46C\uB488\uB4A4\uB4C0\uB4DC\uB4F8\uB514\uB530\uB54C\uB568\uB584\uB5A0\uB5BC\uB5D8\uB5F4\uB610\uB62C\uB648\uB664\uB680\uB69C\uB6B8\uB6D4\uB6F0\uB70C\uB728\uB744\uB760\uB77C\uB798\uB7B4\uB7D0\uB7EC\uB808\uB824\uB840\uB85C\uB878\uB894\uB8B0\uB8CC\uB8E8\uB904\uB920\uB93C\uB958\uB974\uB990\uB9AC\uB9C8\uB9E4\uBA00\uBA1C\uBA38\uBA54\uBA70\uBA8C\uBAA8\uBAC4\uBAE0\uBAFC\uBB18\uBB34\uBB50\uBB6C\uBB88\uBBA4\uBBC0\uBBDC\uBBF8\uBC14\uBC30\uBC4C\uBC68\uBC84\uBCA0\uBCBC\uBCD8\uBCF4\uBD10\uBD2C\uBD48\uBD64\uBD80\uBD9C\uBDB8\uBDD4\uBDF0\uBE0C\uBE28\uBE44\uBE60\uBE7C\uBE98\uBEB4\uBED0\uBEEC\uBF08\uBF24\uBF40\uBF5C\uBF78\uBF94\uBFB0\uBFCC\uBFE8\uC004\uC020\uC03C\uC058\uC074\uC090\uC0AC\uC0C8\uC0E4\uC100\uC11C\uC138\uC154\uC170\uC18C\uC1A8\uC1C4\uC1E0\uC1FC\uC218\uC234\uC250\uC26C\uC288\uC2A4\uC2C0\uC2DC\uC2F8\uC314\uC330\uC34C\uC368\uC384\uC3A0\uC3BC\uC3D8\uC3F4\uC410\uC42C\uC448\uC464\uC480\uC49C\uC4B8\uC4D4\uC4F0\uC50C\uC528\uC544\uC560\uC57C\uC598\uC5B4\uC5D0\uC5EC\uC608\uC624\uC640\uC65C\uC678\uC694\uC6B0\uC6CC\uC6E8\uC704\uC720\uC73C\uC758\uC774\uC790\uC7AC\uC7C8\uC7E4\uC800\uC81C\uC838\uC854\uC870\uC88C\uC8A8\uC8C4\uC8E0\uC8FC\uC918\uC934\uC950\uC96C\uC988\uC9A4\uC9C0\uC9DC\uC9F8\uCA14\uCA30\uCA4C\uCA68\uCA84\uCAA0\uCABC\uCAD8\uCAF4\uCB10\uCB2C\uCB48\uCB64\uCB80\uCB9C\uCBB8\uCBD4\uCBF0\uCC0C\uCC28\uCC44\uCC60\uCC7C\uCC98\uCCB4\uCCD0\uCCEC\uCD08\uCD24\uCD40\uCD5C\uCD78\uCD94\uCDB0\uCDCC\uCDE8\uCE04\uCE20\uCE3C\uCE58\uCE74\uCE90\uCEAC\uCEC8\uCEE4\uCF00\uCF1C\uCF38\uCF54\uCF70\uCF8C\uCFA8\uCFC4\uCFE0\uCFFC\uD018\uD034\uD050\uD06C\uD088\uD0A4\uD0C0\uD0DC\uD0F8\uD114\uD130\uD14C\uD168\uD184\uD1A0\uD1BC\uD1D8\uD1F4\uD210\uD22C\uD248\uD264\uD280\uD29C\uD2B8\uD2D4\uD2F0\uD30C\uD328\uD344\uD360\uD37C\uD398\uD3B4\uD3D0\uD3EC\uD408\uD424\uD440\uD45C\uD478\uD494\uD4B0\uD4CC\uD4E8\uD504\uD520\uD53C\uD558\uD574\uD590\uD5AC\uD5C8\uD5E4\uD600\uD61C\uD638\uD654\uD670\uD68C\uD6A8\uD6C4\uD6E0\uD6FC\uD718\uD734\uD750\uD76C\uD788]$/, lE = /^[\uAC01-\uAC1B\uAC1D-\uAC37\uAC39-\uAC53\uAC55-\uAC6F\uAC71-\uAC8B\uAC8D-\uACA7\uACA9-\uACC3\uACC5-\uACDF\uACE1-\uACFB\uACFD-\uAD17\uAD19-\uAD33\uAD35-\uAD4F\uAD51-\uAD6B\uAD6D-\uAD87\uAD89-\uADA3\uADA5-\uADBF\uADC1-\uADDB\uADDD-\uADF7\uADF9-\uAE13\uAE15-\uAE2F\uAE31-\uAE4B\uAE4D-\uAE67\uAE69-\uAE83\uAE85-\uAE9F\uAEA1-\uAEBB\uAEBD-\uAED7\uAED9-\uAEF3\uAEF5-\uAF0F\uAF11-\uAF2B\uAF2D-\uAF47\uAF49-\uAF63\uAF65-\uAF7F\uAF81-\uAF9B\uAF9D-\uAFB7\uAFB9-\uAFD3\uAFD5-\uAFEF\uAFF1-\uB00B\uB00D-\uB027\uB029-\uB043\uB045-\uB05F\uB061-\uB07B\uB07D-\uB097\uB099-\uB0B3\uB0B5-\uB0CF\uB0D1-\uB0EB\uB0ED-\uB107\uB109-\uB123\uB125-\uB13F\uB141-\uB15B\uB15D-\uB177\uB179-\uB193\uB195-\uB1AF\uB1B1-\uB1CB\uB1CD-\uB1E7\uB1E9-\uB203\uB205-\uB21F\uB221-\uB23B\uB23D-\uB257\uB259-\uB273\uB275-\uB28F\uB291-\uB2AB\uB2AD-\uB2C7\uB2C9-\uB2E3\uB2E5-\uB2FF\uB301-\uB31B\uB31D-\uB337\uB339-\uB353\uB355-\uB36F\uB371-\uB38B\uB38D-\uB3A7\uB3A9-\uB3C3\uB3C5-\uB3DF\uB3E1-\uB3FB\uB3FD-\uB417\uB419-\uB433\uB435-\uB44F\uB451-\uB46B\uB46D-\uB487\uB489-\uB4A3\uB4A5-\uB4BF\uB4C1-\uB4DB\uB4DD-\uB4F7\uB4F9-\uB513\uB515-\uB52F\uB531-\uB54B\uB54D-\uB567\uB569-\uB583\uB585-\uB59F\uB5A1-\uB5BB\uB5BD-\uB5D7\uB5D9-\uB5F3\uB5F5-\uB60F\uB611-\uB62B\uB62D-\uB647\uB649-\uB663\uB665-\uB67F\uB681-\uB69B\uB69D-\uB6B7\uB6B9-\uB6D3\uB6D5-\uB6EF\uB6F1-\uB70B\uB70D-\uB727\uB729-\uB743\uB745-\uB75F\uB761-\uB77B\uB77D-\uB797\uB799-\uB7B3\uB7B5-\uB7CF\uB7D1-\uB7EB\uB7ED-\uB807\uB809-\uB823\uB825-\uB83F\uB841-\uB85B\uB85D-\uB877\uB879-\uB893\uB895-\uB8AF\uB8B1-\uB8CB\uB8CD-\uB8E7\uB8E9-\uB903\uB905-\uB91F\uB921-\uB93B\uB93D-\uB957\uB959-\uB973\uB975-\uB98F\uB991-\uB9AB\uB9AD-\uB9C7\uB9C9-\uB9E3\uB9E5-\uB9FF\uBA01-\uBA1B\uBA1D-\uBA37\uBA39-\uBA53\uBA55-\uBA6F\uBA71-\uBA8B\uBA8D-\uBAA7\uBAA9-\uBAC3\uBAC5-\uBADF\uBAE1-\uBAFB\uBAFD-\uBB17\uBB19-\uBB33\uBB35-\uBB4F\uBB51-\uBB6B\uBB6D-\uBB87\uBB89-\uBBA3\uBBA5-\uBBBF\uBBC1-\uBBDB\uBBDD-\uBBF7\uBBF9-\uBC13\uBC15-\uBC2F\uBC31-\uBC4B\uBC4D-\uBC67\uBC69-\uBC83\uBC85-\uBC9F\uBCA1-\uBCBB\uBCBD-\uBCD7\uBCD9-\uBCF3\uBCF5-\uBD0F\uBD11-\uBD2B\uBD2D-\uBD47\uBD49-\uBD63\uBD65-\uBD7F\uBD81-\uBD9B\uBD9D-\uBDB7\uBDB9-\uBDD3\uBDD5-\uBDEF\uBDF1-\uBE0B\uBE0D-\uBE27\uBE29-\uBE43\uBE45-\uBE5F\uBE61-\uBE7B\uBE7D-\uBE97\uBE99-\uBEB3\uBEB5-\uBECF\uBED1-\uBEEB\uBEED-\uBF07\uBF09-\uBF23\uBF25-\uBF3F\uBF41-\uBF5B\uBF5D-\uBF77\uBF79-\uBF93\uBF95-\uBFAF\uBFB1-\uBFCB\uBFCD-\uBFE7\uBFE9-\uC003\uC005-\uC01F\uC021-\uC03B\uC03D-\uC057\uC059-\uC073\uC075-\uC08F\uC091-\uC0AB\uC0AD-\uC0C7\uC0C9-\uC0E3\uC0E5-\uC0FF\uC101-\uC11B\uC11D-\uC137\uC139-\uC153\uC155-\uC16F\uC171-\uC18B\uC18D-\uC1A7\uC1A9-\uC1C3\uC1C5-\uC1DF\uC1E1-\uC1FB\uC1FD-\uC217\uC219-\uC233\uC235-\uC24F\uC251-\uC26B\uC26D-\uC287\uC289-\uC2A3\uC2A5-\uC2BF\uC2C1-\uC2DB\uC2DD-\uC2F7\uC2F9-\uC313\uC315-\uC32F\uC331-\uC34B\uC34D-\uC367\uC369-\uC383\uC385-\uC39F\uC3A1-\uC3BB\uC3BD-\uC3D7\uC3D9-\uC3F3\uC3F5-\uC40F\uC411-\uC42B\uC42D-\uC447\uC449-\uC463\uC465-\uC47F\uC481-\uC49B\uC49D-\uC4B7\uC4B9-\uC4D3\uC4D5-\uC4EF\uC4F1-\uC50B\uC50D-\uC527\uC529-\uC543\uC545-\uC55F\uC561-\uC57B\uC57D-\uC597\uC599-\uC5B3\uC5B5-\uC5CF\uC5D1-\uC5EB\uC5ED-\uC607\uC609-\uC623\uC625-\uC63F\uC641-\uC65B\uC65D-\uC677\uC679-\uC693\uC695-\uC6AF\uC6B1-\uC6CB\uC6CD-\uC6E7\uC6E9-\uC703\uC705-\uC71F\uC721-\uC73B\uC73D-\uC757\uC759-\uC773\uC775-\uC78F\uC791-\uC7AB\uC7AD-\uC7C7\uC7C9-\uC7E3\uC7E5-\uC7FF\uC801-\uC81B\uC81D-\uC837\uC839-\uC853\uC855-\uC86F\uC871-\uC88B\uC88D-\uC8A7\uC8A9-\uC8C3\uC8C5-\uC8DF\uC8E1-\uC8FB\uC8FD-\uC917\uC919-\uC933\uC935-\uC94F\uC951-\uC96B\uC96D-\uC987\uC989-\uC9A3\uC9A5-\uC9BF\uC9C1-\uC9DB\uC9DD-\uC9F7\uC9F9-\uCA13\uCA15-\uCA2F\uCA31-\uCA4B\uCA4D-\uCA67\uCA69-\uCA83\uCA85-\uCA9F\uCAA1-\uCABB\uCABD-\uCAD7\uCAD9-\uCAF3\uCAF5-\uCB0F\uCB11-\uCB2B\uCB2D-\uCB47\uCB49-\uCB63\uCB65-\uCB7F\uCB81-\uCB9B\uCB9D-\uCBB7\uCBB9-\uCBD3\uCBD5-\uCBEF\uCBF1-\uCC0B\uCC0D-\uCC27\uCC29-\uCC43\uCC45-\uCC5F\uCC61-\uCC7B\uCC7D-\uCC97\uCC99-\uCCB3\uCCB5-\uCCCF\uCCD1-\uCCEB\uCCED-\uCD07\uCD09-\uCD23\uCD25-\uCD3F\uCD41-\uCD5B\uCD5D-\uCD77\uCD79-\uCD93\uCD95-\uCDAF\uCDB1-\uCDCB\uCDCD-\uCDE7\uCDE9-\uCE03\uCE05-\uCE1F\uCE21-\uCE3B\uCE3D-\uCE57\uCE59-\uCE73\uCE75-\uCE8F\uCE91-\uCEAB\uCEAD-\uCEC7\uCEC9-\uCEE3\uCEE5-\uCEFF\uCF01-\uCF1B\uCF1D-\uCF37\uCF39-\uCF53\uCF55-\uCF6F\uCF71-\uCF8B\uCF8D-\uCFA7\uCFA9-\uCFC3\uCFC5-\uCFDF\uCFE1-\uCFFB\uCFFD-\uD017\uD019-\uD033\uD035-\uD04F\uD051-\uD06B\uD06D-\uD087\uD089-\uD0A3\uD0A5-\uD0BF\uD0C1-\uD0DB\uD0DD-\uD0F7\uD0F9-\uD113\uD115-\uD12F\uD131-\uD14B\uD14D-\uD167\uD169-\uD183\uD185-\uD19F\uD1A1-\uD1BB\uD1BD-\uD1D7\uD1D9-\uD1F3\uD1F5-\uD20F\uD211-\uD22B\uD22D-\uD247\uD249-\uD263\uD265-\uD27F\uD281-\uD29B\uD29D-\uD2B7\uD2B9-\uD2D3\uD2D5-\uD2EF\uD2F1-\uD30B\uD30D-\uD327\uD329-\uD343\uD345-\uD35F\uD361-\uD37B\uD37D-\uD397\uD399-\uD3B3\uD3B5-\uD3CF\uD3D1-\uD3EB\uD3ED-\uD407\uD409-\uD423\uD425-\uD43F\uD441-\uD45B\uD45D-\uD477\uD479-\uD493\uD495-\uD4AF\uD4B1-\uD4CB\uD4CD-\uD4E7\uD4E9-\uD503\uD505-\uD51F\uD521-\uD53B\uD53D-\uD557\uD559-\uD573\uD575-\uD58F\uD591-\uD5AB\uD5AD-\uD5C7\uD5C9-\uD5E3\uD5E5-\uD5FF\uD601-\uD61B\uD61D-\uD637\uD639-\uD653\uD655-\uD66F\uD671-\uD68B\uD68D-\uD6A7\uD6A9-\uD6C3\uD6C5-\uD6DF\uD6E1-\uD6FB\uD6FD-\uD717\uD719-\uD733\uD735-\uD74F\uD751-\uD76B\uD76D-\uD787\uD789-\uD7A3]$/, uE = /^(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])$/, cE = (t, e) => {
  var n = Se.Any;
  return t.search(tE) !== -1 && (n |= Se.Extend), e === 8205 && (n |= Se.ZWJ), e >= 127462 && e <= 127487 && (n |= Se.RI), t.search(nE) !== -1 && (n |= Se.Prepend), t.search(rE) !== -1 && (n |= Se.SpacingMark), t.search(oE) !== -1 && (n |= Se.L), t.search(iE) !== -1 && (n |= Se.V), t.search(aE) !== -1 && (n |= Se.T), t.search(sE) !== -1 && (n |= Se.LV), t.search(lE) !== -1 && (n |= Se.LVT), t.search(uE) !== -1 && (n |= Se.ExtPict), n;
};
function to(t, e) {
  return (t & e) !== 0;
}
var dE = [
  // GB6
  [Se.L, Se.L | Se.V | Se.LV | Se.LVT],
  // GB7
  [Se.LV | Se.V, Se.V | Se.T],
  // GB8
  [Se.LVT | Se.T, Se.T],
  // GB9
  [Se.Any, Se.Extend | Se.ZWJ],
  // GB9a
  [Se.Any, Se.SpacingMark],
  // GB9b
  [Se.Prepend, Se.Any],
  // GB11
  [Se.ZWJ, Se.ExtPict],
  // GB12 and GB13
  [Se.RI, Se.RI]
];
function fE(t, e) {
  return dE.findIndex((n) => to(t, n[0]) && to(e, n[1])) === -1;
}
var pE = /(?:[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u2388\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2605\u2607-\u2612\u2614-\u2685\u2690-\u2705\u2708-\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763-\u2767\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC00-\uDCFF\uDD0D-\uDD0F\uDD2F\uDD6C-\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDAD-\uDDE5\uDE01-\uDE0F\uDE1A\uDE2F\uDE32-\uDE3A\uDE3C-\uDE3F\uDE49-\uDFFA]|\uD83D[\uDC00-\uDD3D\uDD46-\uDE4F\uDE80-\uDEFF\uDF74-\uDF7F\uDFD5-\uDFFF]|\uD83E[\uDC0C-\uDC0F\uDC48-\uDC4F\uDC5A-\uDC5F\uDC88-\uDC8F\uDCAE-\uDCFF\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDEFF]|\uD83F[\uDC00-\uDFFD])(?:[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0902\u093A\u093C\u0941-\u0948\u094D\u0951-\u0957\u0962\u0963\u0981\u09BC\u09BE\u09C1-\u09C4\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01\u0A02\u0A3C\u0A41\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81\u0A82\u0ABC\u0AC1-\u0AC5\u0AC7\u0AC8\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01\u0B3C\u0B3E\u0B3F\u0B41-\u0B44\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B82\u0BBE\u0BC0\u0BCD\u0BD7\u0C00\u0C04\u0C3C\u0C3E-\u0C40\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81\u0CBC\u0CBF\u0CC2\u0CC6\u0CCC\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00\u0D01\u0D3B\u0D3C\u0D3E\u0D41-\u0D44\u0D4D\u0D57\u0D62\u0D63\u0D81\u0DCA\u0DCF\u0DD2-\u0DD4\u0DD6\u0DDF\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0F18\u0F19\u0F35\u0F37\u0F39\u0F71-\u0F7E\u0F80-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102D-\u1030\u1032-\u1037\u1039\u103A\u103D\u103E\u1058\u1059\u105E-\u1060\u1071-\u1074\u1082\u1085\u1086\u108D\u109D\u135D-\u135F\u1712-\u1714\u1732\u1733\u1752\u1753\u1772\u1773\u17B4\u17B5\u17B7-\u17BD\u17C6\u17C9-\u17D3\u17DD\u180B-\u180D\u180F\u1885\u1886\u18A9\u1920-\u1922\u1927\u1928\u1932\u1939-\u193B\u1A17\u1A18\u1A1B\u1A56\u1A58-\u1A5E\u1A60\u1A62\u1A65-\u1A6C\u1A73-\u1A7C\u1A7F\u1AB0-\u1ACE\u1B00-\u1B03\u1B34-\u1B3A\u1B3C\u1B42\u1B6B-\u1B73\u1B80\u1B81\u1BA2-\u1BA5\u1BA8\u1BA9\u1BAB-\u1BAD\u1BE6\u1BE8\u1BE9\u1BED\u1BEF-\u1BF1\u1C2C-\u1C33\u1C36\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE0\u1CE2-\u1CE8\u1CED\u1CF4\u1CF8\u1CF9\u1DC0-\u1DFF\u200C\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA825\uA826\uA82C\uA8C4\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA951\uA980-\uA982\uA9B3\uA9B6-\uA9B9\uA9BC\uA9BD\uA9E5\uAA29-\uAA2E\uAA31\uAA32\uAA35\uAA36\uAA43\uAA4C\uAA7C\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEC\uAAED\uAAF6\uABE5\uABE8\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFF9E\uFF9F]|\uD800[\uDDFD\uDEE0\uDF76-\uDF7A]|\uD802[\uDE01-\uDE03\uDE05\uDE06\uDE0C-\uDE0F\uDE38-\uDE3A\uDE3F\uDEE5\uDEE6]|\uD803[\uDD24-\uDD27\uDEAB\uDEAC\uDEFD-\uDEFF\uDF46-\uDF50\uDF82-\uDF85]|\uD804[\uDC01\uDC38-\uDC46\uDC70\uDC73\uDC74\uDC7F-\uDC81\uDCB3-\uDCB6\uDCB9\uDCBA\uDCC2\uDD00-\uDD02\uDD27-\uDD2B\uDD2D-\uDD34\uDD73\uDD80\uDD81\uDDB6-\uDDBE\uDDC9-\uDDCC\uDDCF\uDE2F-\uDE31\uDE34\uDE36\uDE37\uDE3E\uDE41\uDEDF\uDEE3-\uDEEA\uDF00\uDF01\uDF3B\uDF3C\uDF3E\uDF40\uDF57\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC38-\uDC3F\uDC42-\uDC44\uDC46\uDC5E\uDCB0\uDCB3-\uDCB8\uDCBA\uDCBD\uDCBF\uDCC0\uDCC2\uDCC3\uDDAF\uDDB2-\uDDB5\uDDBC\uDDBD\uDDBF\uDDC0\uDDDC\uDDDD\uDE33-\uDE3A\uDE3D\uDE3F\uDE40\uDEAB\uDEAD\uDEB0-\uDEB5\uDEB7\uDF1D-\uDF1F\uDF22-\uDF25\uDF27-\uDF2B]|\uD806[\uDC2F-\uDC37\uDC39\uDC3A\uDD30\uDD3B\uDD3C\uDD3E\uDD43\uDDD4-\uDDD7\uDDDA\uDDDB\uDDE0\uDE01-\uDE0A\uDE33-\uDE38\uDE3B-\uDE3E\uDE47\uDE51-\uDE56\uDE59-\uDE5B\uDE8A-\uDE96\uDE98\uDE99]|\uD807[\uDC30-\uDC36\uDC38-\uDC3D\uDC3F\uDC92-\uDCA7\uDCAA-\uDCB0\uDCB2\uDCB3\uDCB5\uDCB6\uDD31-\uDD36\uDD3A\uDD3C\uDD3D\uDD3F-\uDD45\uDD47\uDD90\uDD91\uDD95\uDD97\uDEF3\uDEF4\uDF00\uDF01\uDF36-\uDF3A\uDF40\uDF42]|\uD80D[\uDC40\uDC47-\uDC55]|\uD81A[\uDEF0-\uDEF4\uDF30-\uDF36]|\uD81B[\uDF4F\uDF8F-\uDF92\uDFE4]|\uD82F[\uDC9D\uDC9E]|\uD833[\uDF00-\uDF2D\uDF30-\uDF46]|\uD834[\uDD65\uDD67-\uDD69\uDD6E-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A\uDC8F\uDD30-\uDD36\uDEAE\uDEEC-\uDEEF]|\uD839[\uDCEC-\uDCEF]|\uD83A[\uDCD0-\uDCD6\uDD44-\uDD4A]|\uD83C[\uDFFB-\uDFFF]|\uDB40[\uDC20-\uDC7F\uDD00-\uDDEF])*\u200D$/, qd = (t) => t.search(pE) !== -1, hE = /(?:\uD83C[\uDDE6-\uDDFF])+$/g, gE = (t) => {
  var e = t.match(hE);
  if (e === null)
    return !1;
  var n = e[0].length / 2;
  return n % 2 === 1;
}, vE = {
  delete(t, e) {
    t.delete(e);
  },
  insertFragment(t, e, n) {
    t.insertFragment(e, n);
  },
  insertText(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    D.withoutNormalizing(t, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = ac(t)
      } = n;
      if (q.isPath(o) && (o = D.range(t, o)), re.isRange(o))
        if (re.isCollapsed(o))
          o = o.anchor;
        else {
          var i = re.end(o);
          if (!r && D.void(t, {
            at: i
          }))
            return;
          var a = re.start(o), s = D.pointRef(t, a), l = D.pointRef(t, i);
          se.delete(t, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, se.setSelection(t, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && D.void(t, {
        at: o
      }) || D.elementReadOnly(t, {
        at: o
      }))) {
        var {
          path: d,
          offset: f
        } = o;
        e.length > 0 && t.apply({
          type: "insert_text",
          path: d,
          offset: f,
          text: e
        });
      }
    });
  }
};
function Gd(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Di(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Gd(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Gd(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var se = Di(Di(Di(Di({}, Fw), _w), Iw), vE), la = /* @__PURE__ */ new WeakMap(), mE = (t) => la.get(t) || !1, yE = (t, e, n) => {
  var r = la.get(t) || !1;
  la.set(t, !0);
  try {
    e(), n();
  } finally {
    la.set(t, r);
  }
};
function gy(t, e, n) {
  var r = Ea.get(t) || [], o = Da.get(t) || /* @__PURE__ */ new Set(), i, a, s = (d) => {
    if (d) {
      var f = d.join(",");
      a.has(f) || (a.add(f), i.push(d));
    }
  };
  if (n) {
    i = [], a = /* @__PURE__ */ new Set();
    for (var l of r) {
      var u = n(l);
      s(u);
    }
  } else
    i = r, a = o;
  for (var c of e)
    s(c);
  Ea.set(t, i), Da.set(t, a);
}
var bE = (t, e) => {
  for (var n of D.pathRefs(t))
    kw.transform(n, e);
  for (var r of D.pointRefs(t))
    Mw.transform(r, e);
  for (var o of D.rangeRefs(t))
    Bw.transform(o, e);
  if (!mE(t)) {
    var i = q.operationCanTransformPath(e) ? (a) => q.transform(a, e) : void 0;
    gy(t, t.getDirtyPaths(e), i);
  }
  se.transform(t, e), t.operations.push(e), D.normalize(t, {
    operation: e
  }), e.type === "set_selection" && (t.marks = null), _o.get(t) || (_o.set(t, !0), Promise.resolve().then(() => {
    _o.set(t, !1), t.onChange({
      operation: e
    }), t.operations = [];
  }));
}, CE = (t, e) => {
  switch (e.type) {
    case "insert_text":
    case "remove_text":
    case "set_node": {
      var {
        path: n
      } = e;
      return q.levels(n);
    }
    case "insert_node": {
      var {
        node: r,
        path: o
      } = e, i = q.levels(o), a = ye.isText(r) ? [] : Array.from(fe.nodes(r), ($) => {
        var [, j] = $;
        return o.concat(j);
      });
      return [...i, ...a];
    }
    case "merge_node": {
      var {
        path: s
      } = e, l = q.ancestors(s), u = q.previous(s);
      return [...l, u];
    }
    case "move_node": {
      var {
        path: c,
        newPath: d
      } = e;
      if (q.equals(c, d))
        return [];
      var f = [], v = [];
      for (var h of q.ancestors(c)) {
        var g = q.transform(h, e);
        f.push(g);
      }
      for (var p of q.ancestors(d)) {
        var w = q.transform(p, e);
        v.push(w);
      }
      var b = v[v.length - 1], k = d[d.length - 1], E = b.concat(k);
      return [...f, ...v, E];
    }
    case "remove_node": {
      var {
        path: m
      } = e, O = q.ancestors(m);
      return [...O];
    }
    case "split_node": {
      var {
        path: S
      } = e, W = q.levels(S), P = q.next(S);
      return [...W, P];
    }
    default:
      return [];
  }
}, wE = (t) => {
  var {
    selection: e
  } = t;
  return e ? fe.fragment(t, e) : [];
}, EE = (t, e) => {
  var [n, r] = e;
  if (!ye.isText(n)) {
    if (me.isElement(n) && n.children.length === 0) {
      var o = {
        text: ""
      };
      se.insertNodes(t, o, {
        at: r.concat(0),
        voids: !0
      });
      return;
    }
    for (var i = D.isEditor(n) ? !1 : me.isElement(n) && (t.isInline(n) || n.children.length === 0 || ye.isText(n.children[0]) || t.isInline(n.children[0])), a = 0, s = 0; s < n.children.length; s++, a++) {
      var l = fe.get(t, r);
      if (!ye.isText(l)) {
        var u = l.children[a], c = l.children[a - 1], d = s === n.children.length - 1, f = ye.isText(u) || me.isElement(u) && t.isInline(u);
        if (f !== i)
          se.removeNodes(t, {
            at: r.concat(a),
            voids: !0
          }), a--;
        else if (me.isElement(u)) {
          if (t.isInline(u)) {
            if (c == null || !ye.isText(c)) {
              var v = {
                text: ""
              };
              se.insertNodes(t, v, {
                at: r.concat(a),
                voids: !0
              }), a++;
            } else if (d) {
              var h = {
                text: ""
              };
              se.insertNodes(t, h, {
                at: r.concat(a + 1),
                voids: !0
              }), a++;
            }
          }
        } else {
          if (!ye.isText(u) && !("children" in u)) {
            var g = u;
            g.children = [];
          }
          c != null && ye.isText(c) && (ye.equals(u, c, {
            loose: !0
          }) ? (se.mergeNodes(t, {
            at: r.concat(a),
            voids: !0
          }), a--) : c.text === "" ? (se.removeNodes(t, {
            at: r.concat(a - 1),
            voids: !0
          }), a--) : u.text === "" && (se.removeNodes(t, {
            at: r.concat(a),
            voids: !0
          }), a--));
        }
      }
    }
  }
}, DE = (t, e) => {
  var {
    iteration: n,
    initialDirtyPathsLength: r
  } = e, o = r * 42;
  if (n > o)
    throw new Error("Could not completely normalize the editor after ".concat(o, " iterations! This is usually due to incorrect normalization logic that leaves a node in an invalid state."));
  return !0;
}, OE = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    voids: r = !1,
    mode: o = "lowest",
    at: i = e.selection,
    match: a
  } = n;
  if (i) {
    var s = D.path(e, i), l = o === "lowest";
    for (var [u, c] of D.levels(e, {
      at: s,
      voids: r,
      match: a,
      reverse: l
    }))
      if (!ye.isText(u)) {
        if (re.isRange(i)) {
          if (q.isAncestor(c, i.anchor.path) && q.isAncestor(c, i.focus.path))
            return [u, c];
        } else if (!q.equals(s, c))
          return [u, c];
      }
  }
};
function Zd(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Kd(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Zd(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Zd(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var xE = (t, e, n) => {
  var {
    selection: r
  } = t;
  if (r) {
    var o = (d, f) => {
      if (!ye.isText(d))
        return !1;
      var [v, h] = D.parent(t, f);
      return !t.isVoid(v) || t.markableVoid(v);
    }, i = re.isExpanded(r), a = !1;
    if (!i) {
      var [s, l] = D.node(t, r);
      if (s && o(s, l)) {
        var [u] = D.parent(t, l);
        a = u && t.markableVoid(u);
      }
    }
    if (i || a)
      se.setNodes(t, {
        [e]: n
      }, {
        match: o,
        split: !0,
        voids: !0
      });
    else {
      var c = Kd(Kd({}, D.marks(t) || {}), {}, {
        [e]: n
      });
      t.marks = c, _o.get(t) || t.onChange();
    }
  }
};
function Yd(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xd(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Yd(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Yd(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var LE = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = D.point(e, n, {
    edge: "end"
  }), i = D.end(e, []), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of D.positions(e, Xd(Xd({}, r), {}, {
    at: a
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
};
function Jd(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Qd(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Jd(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Jd(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var SE = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = D.start(e, []), i = D.point(e, n, {
    edge: "start"
  }), a = {
    anchor: o,
    focus: i
  }, {
    distance: s = 1
  } = r, l = 0, u;
  for (var c of D.positions(e, Qd(Qd({}, r), {}, {
    at: a,
    reverse: !0
  }))) {
    if (l > s)
      break;
    l !== 0 && (u = c), l++;
  }
  return u;
}, PE = (t, e) => {
  var {
    selection: n
  } = t;
  n && re.isCollapsed(n) && se.delete(t, {
    unit: e,
    reverse: !0
  });
}, kE = (t, e) => {
  var {
    selection: n
  } = t;
  n && re.isCollapsed(n) && se.delete(t, {
    unit: e
  });
}, ME = function(e) {
  var {
    direction: n = "forward"
  } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = e;
  r && re.isExpanded(r) && se.delete(e, {
    reverse: n === "backward"
  });
}, BE = (t, e) => [D.start(t, e), D.end(t, e)];
function ef(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function tf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? ef(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : ef(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var TE = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return D.above(e, tf(tf({}, n), {}, {
    match: (r) => me.isElement(r) && D.isElementReadOnly(e, r)
  }));
}, AE = (t, e) => D.point(t, e, {
  edge: "end"
}), jE = (t, e) => {
  var n = D.path(t, e, {
    edge: "start"
  });
  return D.node(t, n);
}, FE = (t, e) => {
  var n = D.range(t, e);
  return fe.fragment(t, n);
};
function nf(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function rf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? nf(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : nf(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var _E = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return D.above(e, rf(rf({}, n), {}, {
    match: (r) => me.isElement(r) && D.isVoid(e, r)
  }));
}, IE = (t, e) => e.children.some((n) => me.isElement(n) && D.isBlock(t, n)), RE = (t, e) => e.children.some((n) => ye.isText(n) || D.isInline(t, n)), NE = (t, e) => fe.has(t, e), $E = (t, e) => e.children.every((n) => ye.isText(n)), zE = (t) => {
  se.splitNodes(t, {
    always: !0
  });
}, UE = (t, e, n) => {
  se.insertNodes(t, e, n);
}, WE = (t) => {
  se.splitNodes(t, {
    always: !0
  });
};
function of(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function HE(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? of(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : of(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var VE = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o,
    marks: i
  } = e;
  if (o) {
    if (i) {
      var a = HE({
        text: n
      }, i);
      se.insertNodes(e, a, {
        at: r.at,
        voids: r.voids
      });
    } else
      se.insertText(e, n, r);
    e.marks = null;
  }
}, qE = (t, e) => !t.isInline(e), GE = (t, e, n) => D.isStart(t, e, n) || D.isEnd(t, e, n), ZE = (t, e) => {
  var {
    children: n
  } = e, [r] = n;
  return n.length === 0 || n.length === 1 && ye.isText(r) && r.text === "" && !t.isVoid(e);
}, KE = (t, e, n) => {
  var r = D.end(t, n);
  return _e.equals(e, r);
}, YE = (t) => {
  var e = py.get(t);
  return e === void 0 ? !0 : e;
}, XE = (t, e, n) => {
  if (e.offset !== 0)
    return !1;
  var r = D.start(t, n);
  return _e.equals(e, r);
}, JE = (t, e) => {
  var n = D.path(t, e, {
    edge: "end"
  });
  return D.node(t, n);
}, QE = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = D.path(e, n, r), i = fe.leaf(e, o);
  return [i, o];
};
function eD(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = t.selection,
      reverse: r = !1,
      voids: o = !1
    } = e, {
      match: i
    } = e;
    if (i == null && (i = () => !0), !!n) {
      var a = [], s = D.path(t, n);
      for (var [l, u] of fe.levels(t, s))
        if (i(l, u) && (a.push([l, u]), !o && me.isElement(l) && D.isVoid(t, l)))
          break;
      r && a.reverse(), yield* a;
    }
  }();
}
var tD = ["text"], nD = ["text"], rD = function(e) {
  var {
    marks: n,
    selection: r
  } = e;
  if (!r)
    return null;
  var {
    anchor: o,
    focus: i
  } = r;
  if (n)
    return n;
  if (re.isExpanded(r)) {
    var a = D.isEnd(e, o, o.path);
    if (a) {
      var s = D.after(e, o);
      s && (o = s);
    }
    var [l] = D.nodes(e, {
      match: ye.isText,
      at: {
        anchor: o,
        focus: i
      }
    });
    if (l) {
      var [u] = l, c = Jn(u, tD);
      return c;
    } else
      return {};
  }
  var {
    path: d
  } = o, [f] = D.leaf(e, d);
  if (o.offset === 0) {
    var v = D.previous(e, {
      at: d,
      match: ye.isText
    }), h = D.above(e, {
      match: (E) => me.isElement(E) && D.isVoid(e, E) && e.markableVoid(E)
    });
    if (!h) {
      var g = D.above(e, {
        match: (E) => me.isElement(E) && D.isBlock(e, E)
      });
      if (v && g) {
        var [p, w] = v, [, b] = g;
        q.isAncestor(b, w) && (f = p);
      }
    }
  }
  var k = Jn(f, nD);
  return k;
}, oD = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = e.selection
  } = n;
  if (a) {
    var s = D.after(e, a, {
      voids: o
    });
    if (s) {
      var [, l] = D.last(e, []), u = [s.path, l];
      if (q.isPath(a) && a.length === 0)
        throw new Error("Cannot get the next node from the root node!");
      if (i == null)
        if (q.isPath(a)) {
          var [c] = D.parent(e, a);
          i = (f) => c.children.includes(f);
        } else
          i = () => !0;
      var [d] = D.nodes(e, {
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return d;
    }
  }
}, iD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = D.path(e, n, r), i = fe.get(e, o);
  return [i, o];
};
function aD(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = t.selection,
      mode: r = "all",
      universal: o = !1,
      reverse: i = !1,
      voids: a = !1,
      ignoreNonSelectable: s = !1
    } = e, {
      match: l
    } = e;
    if (l || (l = () => !0), !!n) {
      var u, c;
      if (Hw.isSpan(n))
        u = n[0], c = n[1];
      else {
        var d = D.path(t, n, {
          edge: "start"
        }), f = D.path(t, n, {
          edge: "end"
        });
        u = i ? f : d, c = i ? d : f;
      }
      var v = fe.nodes(t, {
        reverse: i,
        from: u,
        to: c,
        pass: (E) => {
          var [m] = E;
          return me.isElement(m) ? !!(!a && (D.isVoid(t, m) || D.isElementReadOnly(t, m)) || s && !D.isSelectable(t, m)) : !1;
        }
      }), h = [], g;
      for (var [p, w] of v)
        if (!(s && me.isElement(p) && !D.isSelectable(t, p))) {
          var b = g && q.compare(w, g[1]) === 0;
          if (!(r === "highest" && b)) {
            if (!l(p, w)) {
              if (o && !b && ye.isText(p))
                return;
              continue;
            }
            if (r === "lowest" && b) {
              g = [p, w];
              continue;
            }
            var k = r === "lowest" ? g : [p, w];
            k && (o ? h.push(k) : yield k), g = [p, w];
          }
        }
      r === "lowest" && g && (o ? h.push(g) : yield g), o && (yield* h);
    }
  }();
}
var sD = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    force: r = !1,
    operation: o
  } = n, i = (c) => Ea.get(c) || [], a = (c) => Da.get(c) || /* @__PURE__ */ new Set(), s = (c) => {
    var d = i(c).pop(), f = d.join(",");
    return a(c).delete(f), d;
  };
  if (D.isNormalizing(e)) {
    if (r) {
      var l = Array.from(fe.nodes(e), (c) => {
        var [, d] = c;
        return d;
      }), u = new Set(l.map((c) => c.join(",")));
      Ea.set(e, l), Da.set(e, u);
    }
    i(e).length !== 0 && D.withoutNormalizing(e, () => {
      for (var c of i(e))
        if (fe.has(e, c)) {
          var d = D.node(e, c), [f, v] = d;
          me.isElement(f) && f.children.length === 0 && e.normalizeNode(d, {
            operation: o
          });
        }
      for (var h = i(e), g = h.length, p = 0; h.length !== 0; ) {
        if (!e.shouldNormalize({
          dirtyPaths: h,
          iteration: p,
          initialDirtyPathsLength: g,
          operation: o
        }))
          return;
        var w = s(e);
        if (fe.has(e, w)) {
          var b = D.node(e, w);
          e.normalizeNode(b, {
            operation: o
          });
        }
        p++, h = i(e);
      }
    });
  }
}, lD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, o = D.path(e, n, r), i = q.parent(o), a = D.node(e, i);
  return a;
}, uD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = D.pathRefs(e);
      return l.delete(i), i.current = null, s;
    }
  }, a = D.pathRefs(e);
  return a.add(i), i;
}, cD = (t) => {
  var e = Ad.get(t);
  return e || (e = /* @__PURE__ */ new Set(), Ad.set(t, e)), e;
}, dD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    depth: o,
    edge: i
  } = r;
  if (q.isPath(n)) {
    if (i === "start") {
      var [, a] = fe.first(e, n);
      n = a;
    } else if (i === "end") {
      var [, s] = fe.last(e, n);
      n = s;
    }
  }
  return re.isRange(n) && (i === "start" ? n = re.start(n) : i === "end" ? n = re.end(n) : n = q.common(n.anchor.path, n.focus.path)), _e.isPoint(n) && (n = n.path), o != null && (n = n.slice(0, o)), n;
}, fD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = D.pointRefs(e);
      return l.delete(i), i.current = null, s;
    }
  }, a = D.pointRefs(e);
  return a.add(i), i;
}, pD = (t) => {
  var e = jd.get(t);
  return e || (e = /* @__PURE__ */ new Set(), jd.set(t, e)), e;
}, hD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    edge: o = "start"
  } = r;
  if (q.isPath(n)) {
    var i;
    if (o === "end") {
      var [, a] = fe.last(e, n);
      i = a;
    } else {
      var [, s] = fe.first(e, n);
      i = s;
    }
    var l = fe.get(e, i);
    if (!ye.isText(l))
      throw new Error("Cannot get the ".concat(o, " point in the node at path [").concat(n, "] because it has no ").concat(o, " text node."));
    return {
      path: i,
      offset: o === "end" ? l.text.length : 0
    };
  }
  if (re.isRange(n)) {
    var [u, c] = re.edges(n);
    return o === "start" ? u : c;
  }
  return n;
};
function gD(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  return function* () {
    var {
      at: n = t.selection,
      unit: r = "offset",
      reverse: o = !1,
      voids: i = !1,
      ignoreNonSelectable: a = !1
    } = e;
    if (!n)
      return;
    var s = D.range(t, n), [l, u] = re.edges(s), c = o ? u : l, d = !1, f = "", v = 0, h = 0, g = 0;
    for (var [p, w] of D.nodes(t, {
      at: n,
      reverse: o,
      voids: i,
      ignoreNonSelectable: a
    })) {
      if (me.isElement(p)) {
        if (!i && (t.isVoid(p) || t.isElementReadOnly(p))) {
          yield D.start(t, w);
          continue;
        }
        if (t.isInline(p)) continue;
        if (D.hasInlines(t, p)) {
          var b = q.isAncestor(w, u.path) ? u : D.end(t, w), k = q.isAncestor(w, l.path) ? l : D.start(t, w);
          f = D.string(t, {
            anchor: k,
            focus: b
          }, {
            voids: i
          }), d = !0;
        }
      }
      if (ye.isText(p)) {
        var E = q.equals(w, c.path);
        for (E ? (h = o ? c.offset : p.text.length - c.offset, g = c.offset) : (h = p.text.length, g = o ? h : 0), (E || d || r === "offset") && (yield {
          path: w,
          offset: g
        }, d = !1); ; ) {
          if (v === 0) {
            if (f === "") break;
            v = m(f, r, o), f = lc(f, v, o)[1];
          }
          if (g = o ? g - v : g + v, h = h - v, h < 0) {
            v = -h;
            break;
          }
          v = 0, yield {
            path: w,
            offset: g
          };
        }
      }
    }
    function m(O, S, W) {
      return S === "character" ? sc(O, W) : S === "word" ? Yw(O, W) : S === "line" || S === "block" ? O.length : 1;
    }
  }();
}
var vD = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    mode: r = "lowest",
    voids: o = !1
  } = n, {
    match: i,
    at: a = e.selection
  } = n;
  if (a) {
    var s = D.before(e, a, {
      voids: o
    });
    if (s) {
      var [, l] = D.first(e, []), u = [s.path, l];
      if (q.isPath(a) && a.length === 0)
        throw new Error("Cannot get the previous node from the root node!");
      if (i == null)
        if (q.isPath(a)) {
          var [c] = D.parent(e, a);
          i = (f) => c.children.includes(f);
        } else
          i = () => !0;
      var [d] = D.nodes(e, {
        reverse: !0,
        at: u,
        match: i,
        mode: r,
        voids: o
      });
      return d;
    }
  }
}, mD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    affinity: o = "forward"
  } = r, i = {
    current: n,
    affinity: o,
    unref() {
      var {
        current: s
      } = i, l = D.rangeRefs(e);
      return l.delete(i), i.current = null, s;
    }
  }, a = D.rangeRefs(e);
  return a.add(i), i;
}, yD = (t) => {
  var e = Fd.get(t);
  return e || (e = /* @__PURE__ */ new Set(), Fd.set(t, e)), e;
}, bD = (t, e, n) => {
  if (re.isRange(e) && !n)
    return e;
  var r = D.start(t, e), o = D.end(t, n || e);
  return {
    anchor: r,
    focus: o
  };
};
function af(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function CD(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? af(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : af(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var wD = (t, e) => {
  var {
    selection: n
  } = t;
  if (n) {
    var r = (c, d) => {
      if (!ye.isText(c))
        return !1;
      var [f, v] = D.parent(t, d);
      return !t.isVoid(f) || t.markableVoid(f);
    }, o = re.isExpanded(n), i = !1;
    if (!o) {
      var [a, s] = D.node(t, n);
      if (a && r(a, s)) {
        var [l] = D.parent(t, s);
        i = l && t.markableVoid(l);
      }
    }
    if (o || i)
      se.unsetNodes(t, e, {
        match: r,
        split: !0,
        voids: !0
      });
    else {
      var u = CD({}, D.marks(t) || {});
      delete u[e], t.marks = u, _o.get(t) || t.onChange();
    }
  }
}, ED = (t, e) => {
  py.set(t, e);
}, DD = (t, e) => D.point(t, e, {
  edge: "start"
}), OD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, i = D.range(e, n), [a, s] = re.edges(i), l = "";
  for (var [u, c] of D.nodes(e, {
    at: i,
    match: ye.isText,
    voids: o
  })) {
    var d = u.text;
    q.equals(c, s.path) && (d = d.slice(0, s.offset)), q.equals(c, a.path) && (d = d.slice(a.offset)), l += d;
  }
  return l;
}, xD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    voids: o = !1
  } = r, [i, a] = re.edges(n);
  if (i.offset !== 0 || a.offset !== 0 || re.isCollapsed(n) || q.hasPrevious(a.path))
    return n;
  var s = D.above(e, {
    at: a,
    match: (h) => me.isElement(h) && D.isBlock(e, h),
    voids: o
  }), l = s ? s[1] : [], u = D.start(e, i), c = {
    anchor: u,
    focus: a
  }, d = !0;
  for (var [f, v] of D.nodes(e, {
    at: c,
    match: ye.isText,
    reverse: !0,
    voids: o
  })) {
    if (d) {
      d = !1;
      continue;
    }
    if (f.text !== "" || q.isBefore(v, l)) {
      a = {
        path: v,
        offset: f.text.length
      };
      break;
    }
  }
  return {
    anchor: i,
    focus: a
  };
}, LD = (t, e) => {
  var n = D.isNormalizing(t);
  D.setNormalizing(t, !1);
  try {
    e();
  } finally {
    D.setNormalizing(t, n);
  }
  D.normalize(t);
}, SD = (t, e, n) => {
  var [r, o] = e;
  return me.isElement(r) && D.isEmpty(t, r) || ye.isText(r) && r.text === "" && o[o.length - 1] !== 0;
}, PD = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  D.withoutNormalizing(e, () => {
    var r, o, {
      reverse: i = !1,
      unit: a = "character",
      distance: s = 1,
      voids: l = !1
    } = n, {
      at: u = e.selection,
      hanging: c = !1
    } = n;
    if (u) {
      var d = !1;
      if (re.isRange(u) && re.isCollapsed(u) && (d = !0, u = u.anchor), _e.isPoint(u)) {
        var f = D.void(e, {
          at: u,
          mode: "highest"
        });
        if (!l && f) {
          var [, v] = f;
          u = v;
        } else {
          var h = {
            unit: a,
            distance: s
          }, g = i ? D.before(e, u, h) || D.start(e, []) : D.after(e, u, h) || D.end(e, []);
          u = {
            anchor: u,
            focus: g
          }, c = !0;
        }
      }
      if (q.isPath(u)) {
        se.removeNodes(e, {
          at: u,
          voids: l
        });
        return;
      }
      if (!re.isCollapsed(u)) {
        if (!c) {
          var [, p] = re.edges(u), w = D.end(e, []);
          _e.equals(p, w) || (u = D.unhangRange(e, u, {
            voids: l
          }));
        }
        var [b, k] = re.edges(u), E = D.above(e, {
          match: (he) => me.isElement(he) && D.isBlock(e, he),
          at: b,
          voids: l
        }), m = D.above(e, {
          match: (he) => me.isElement(he) && D.isBlock(e, he),
          at: k,
          voids: l
        }), O = E && m && !q.equals(E[1], m[1]), S = q.equals(b.path, k.path), W = l ? null : (r = D.void(e, {
          at: b,
          mode: "highest"
        })) !== null && r !== void 0 ? r : D.elementReadOnly(e, {
          at: b,
          mode: "highest"
        }), P = l ? null : (o = D.void(e, {
          at: k,
          mode: "highest"
        })) !== null && o !== void 0 ? o : D.elementReadOnly(e, {
          at: k,
          mode: "highest"
        });
        if (W) {
          var $ = D.before(e, b);
          $ && E && q.isAncestor(E[1], $.path) && (b = $);
        }
        if (P) {
          var j = D.after(e, k);
          j && m && q.isAncestor(m[1], j.path) && (k = j);
        }
        var _ = [], I;
        for (var R of D.nodes(e, {
          at: u,
          voids: l
        })) {
          var [V, J] = R;
          I && q.compare(J, I) === 0 || (!l && me.isElement(V) && (D.isVoid(e, V) || D.isElementReadOnly(e, V)) || !q.isCommon(J, b.path) && !q.isCommon(J, k.path)) && (_.push(R), I = J);
        }
        var G = Array.from(_, (he) => {
          var [, le] = he;
          return D.pathRef(e, le);
        }), te = D.pointRef(e, b), Q = D.pointRef(e, k), T = "";
        if (!S && !W) {
          var N = te.current, [Y] = D.leaf(e, N), {
            path: F
          } = N, {
            offset: X
          } = b, L = Y.text.slice(X);
          L.length > 0 && (e.apply({
            type: "remove_text",
            path: F,
            offset: X,
            text: L
          }), T = L);
        }
        if (G.reverse().map((he) => he.unref()).filter((he) => he !== null).forEach((he) => se.removeNodes(e, {
          at: he,
          voids: l
        })), !P) {
          var M = Q.current, [z] = D.leaf(e, M), {
            path: A
          } = M, U = S ? b.offset : 0, H = z.text.slice(U, k.offset);
          H.length > 0 && (e.apply({
            type: "remove_text",
            path: A,
            offset: U,
            text: H
          }), T = H);
        }
        !S && O && Q.current && te.current && se.mergeNodes(e, {
          at: Q.current,
          hanging: !0,
          voids: l
        }), d && i && a === "character" && T.length > 1 && T.match(/[\u0E00-\u0E7F]+/) && se.insertText(e, T.slice(0, T.length - s));
        var ee = te.unref(), Z = Q.unref(), pe = i ? ee || Z : Z || ee;
        n.at == null && pe && se.select(e, pe);
      }
    }
  });
}, kD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  D.withoutNormalizing(e, () => {
    var {
      hanging: o = !1,
      voids: i = !1
    } = r, {
      at: a = ac(e),
      batchDirty: s = !0
    } = r;
    if (n.length) {
      if (re.isRange(a))
        if (o || (a = D.unhangRange(e, a, {
          voids: i
        })), re.isCollapsed(a))
          a = a.anchor;
        else {
          var [, l] = re.edges(a);
          if (!i && D.void(e, {
            at: l
          }))
            return;
          var u = D.pointRef(e, l);
          se.delete(e, {
            at: a
          }), a = u.unref();
        }
      else q.isPath(a) && (a = D.start(e, a));
      if (!(!i && D.void(e, {
        at: a
      }))) {
        var c = D.above(e, {
          at: a,
          match: (L) => me.isElement(L) && D.isInline(e, L),
          mode: "highest",
          voids: i
        });
        if (c) {
          var [, d] = c;
          if (D.isEnd(e, a, d)) {
            var f = D.after(e, d);
            a = f;
          } else if (D.isStart(e, a, d)) {
            var v = D.before(e, d);
            a = v;
          }
        }
        var h = D.above(e, {
          match: (L) => me.isElement(L) && D.isBlock(e, L),
          at: a,
          voids: i
        }), [, g] = h, p = D.isStart(e, a, g), w = D.isEnd(e, a, g), b = p && w, k = !p || p && w, E = !w, [, m] = fe.first({
          children: n
        }, []), [, O] = fe.last({
          children: n
        }, []), S = [], W = (L) => {
          var [M, z] = L, A = z.length === 0;
          return A ? !1 : b ? !0 : !(k && q.isAncestor(z, m) && me.isElement(M) && !e.isVoid(M) && !e.isInline(M) || E && q.isAncestor(z, O) && me.isElement(M) && !e.isVoid(M) && !e.isInline(M));
        };
        for (var P of fe.nodes({
          children: n
        }, {
          pass: W
        }))
          W(P) && S.push(P);
        var $ = [], j = [], _ = [], I = !0, R = !1;
        for (var [V] of S)
          me.isElement(V) && !e.isInline(V) ? (I = !1, R = !0, j.push(V)) : I ? $.push(V) : _.push(V);
        var [J] = D.nodes(e, {
          at: a,
          match: (L) => ye.isText(L) || D.isInline(e, L),
          mode: "highest",
          voids: i
        }), [, G] = J, te = D.isStart(e, a, G), Q = D.isEnd(e, a, G), T = D.pathRef(e, w && !_.length ? q.next(g) : g), N = D.pathRef(e, Q ? q.next(G) : G);
        se.splitNodes(e, {
          at: a,
          match: (L) => R ? me.isElement(L) && D.isBlock(e, L) : ye.isText(L) || D.isInline(e, L),
          mode: R ? "lowest" : "highest",
          always: R && (!p || $.length > 0) && (!w || _.length > 0),
          voids: i
        });
        var Y = D.pathRef(e, !te || te && Q ? q.next(G) : G);
        if (se.insertNodes(e, $, {
          at: Y.current,
          match: (L) => ye.isText(L) || D.isInline(e, L),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), b && !$.length && j.length && !_.length && se.delete(e, {
          at: g,
          voids: i
        }), se.insertNodes(e, j, {
          at: T.current,
          match: (L) => me.isElement(L) && D.isBlock(e, L),
          mode: "lowest",
          voids: i,
          batchDirty: s
        }), se.insertNodes(e, _, {
          at: N.current,
          match: (L) => ye.isText(L) || D.isInline(e, L),
          mode: "highest",
          voids: i,
          batchDirty: s
        }), !r.at) {
          var F;
          if (_.length > 0 && N.current ? F = q.previous(N.current) : j.length > 0 && T.current ? F = q.previous(T.current) : Y.current && (F = q.previous(Y.current)), F) {
            var X = D.end(e, F);
            se.select(e, X);
          }
        }
        Y.unref(), T.unref(), N.unref();
      }
    }
  });
}, MD = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    edge: r = "anchor"
  } = n, {
    selection: o
  } = e;
  if (o) {
    if (r === "anchor")
      se.select(e, o.anchor);
    else if (r === "focus")
      se.select(e, o.focus);
    else if (r === "start") {
      var [i] = re.edges(o);
      se.select(e, i);
    } else if (r === "end") {
      var [, a] = re.edges(o);
      se.select(e, a);
    }
  } else return;
}, BD = (t) => {
  var {
    selection: e
  } = t;
  e && t.apply({
    type: "set_selection",
    properties: e,
    newProperties: null
  });
}, TD = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
    selection: r
  } = e, {
    distance: o = 1,
    unit: i = "character",
    reverse: a = !1
  } = n, {
    edge: s = null
  } = n;
  if (r) {
    s === "start" && (s = re.isBackward(r) ? "focus" : "anchor"), s === "end" && (s = re.isBackward(r) ? "anchor" : "focus");
    var {
      anchor: l,
      focus: u
    } = r, c = {
      distance: o,
      unit: i,
      ignoreNonSelectable: !0
    }, d = {};
    if (s == null || s === "anchor") {
      var f = a ? D.before(e, l, c) : D.after(e, l, c);
      f && (d.anchor = f);
    }
    if (s == null || s === "focus") {
      var v = a ? D.before(e, u, c) : D.after(e, u, c);
      v && (d.focus = v);
    }
    se.setSelection(e, d);
  }
}, AD = (t, e) => {
  var {
    selection: n
  } = t;
  if (e = D.range(t, e), n) {
    se.setSelection(t, e);
    return;
  }
  if (!re.isRange(e))
    throw new Error("When setting the selection and the current selection is `null` you must provide at least an `anchor` and `focus`, but you passed: ".concat(Ut.stringify(e)));
  t.apply({
    type: "set_selection",
    properties: n,
    newProperties: e
  });
};
function sf(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? sf(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : sf(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var jD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
    selection: o
  } = e, {
    edge: i = "both"
  } = r;
  if (o) {
    i === "start" && (i = re.isBackward(o) ? "focus" : "anchor"), i === "end" && (i = re.isBackward(o) ? "anchor" : "focus");
    var {
      anchor: a,
      focus: s
    } = o, l = i === "anchor" ? a : s;
    se.setSelection(e, {
      [i === "anchor" ? "anchor" : "focus"]: lf(lf({}, l), n)
    });
  }
}, FD = (t, e) => {
  var {
    selection: n
  } = t, r = {}, o = {};
  if (n) {
    for (var i in e)
      (i === "anchor" && e.anchor != null && !_e.equals(e.anchor, n.anchor) || i === "focus" && e.focus != null && !_e.equals(e.focus, n.focus) || i !== "anchor" && i !== "focus" && e[i] !== n[i]) && (r[i] = n[i], o[i] = e[i]);
    Object.keys(r).length > 0 && t.apply({
      type: "set_selection",
      properties: r,
      newProperties: o
    });
  }
}, _D = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  D.withoutNormalizing(e, () => {
    var {
      hanging: o = !1,
      voids: i = !1,
      mode: a = "lowest",
      batchDirty: s = !0
    } = r, {
      at: l,
      match: u,
      select: c
    } = r;
    if (fe.isNode(n) && (n = [n]), n.length !== 0) {
      var [d] = n;
      if (l || (l = ac(e), c !== !1 && (c = !0)), c == null && (c = !1), re.isRange(l))
        if (o || (l = D.unhangRange(e, l, {
          voids: i
        })), re.isCollapsed(l))
          l = l.anchor;
        else {
          var [, f] = re.edges(l), v = D.pointRef(e, f);
          se.delete(e, {
            at: l
          }), l = v.unref();
        }
      if (_e.isPoint(l)) {
        u == null && (ye.isText(d) ? u = ($) => ye.isText($) : e.isInline(d) ? u = ($) => ye.isText($) || D.isInline(e, $) : u = ($) => me.isElement($) && D.isBlock(e, $));
        var [h] = D.nodes(e, {
          at: l.path,
          match: u,
          mode: a,
          voids: i
        });
        if (h) {
          var [, g] = h, p = D.pathRef(e, g), w = D.isEnd(e, l, g);
          se.splitNodes(e, {
            at: l,
            match: u,
            mode: a,
            voids: i
          });
          var b = p.unref();
          l = w ? q.next(b) : b;
        } else
          return;
      }
      var k = q.parent(l), E = l[l.length - 1];
      if (!(!i && D.void(e, {
        at: k
      }))) {
        if (s) {
          var m = [], O = q.levels(k);
          yE(e, () => {
            var $ = function() {
              var I = k.concat(E);
              E++;
              var R = {
                type: "insert_node",
                path: I,
                node: j
              };
              e.apply(R), l = q.next(l), m.push(R), ye.isText ? O.push(...Array.from(fe.nodes(j), (V) => {
                var [, J] = V;
                return I.concat(J);
              })) : O.push(I);
            };
            for (var j of n)
              $();
          }, () => {
            gy(e, O, ($) => {
              var j = $;
              for (var _ of m)
                if (q.operationCanTransformPath(_) && (j = q.transform(j, _), !j))
                  return null;
              return j;
            });
          });
        } else
          for (var S of n) {
            var W = k.concat(E);
            E++, e.apply({
              type: "insert_node",
              path: W,
              node: S
            }), l = q.next(l);
          }
        if (l = q.previous(l), c) {
          var P = D.end(e, l);
          P && se.select(e, P);
        }
      }
    }
  });
}, ID = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  D.withoutNormalizing(e, () => {
    var {
      at: r = e.selection,
      mode: o = "lowest",
      voids: i = !1
    } = n, {
      match: a
    } = n;
    if (a == null && (a = q.isPath(r) ? fo(e, r) : (E) => me.isElement(E) && D.isBlock(e, E)), !!r) {
      var s = D.nodes(e, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), l = Array.from(s, (E) => {
        var [, m] = E;
        return D.pathRef(e, m);
      });
      for (var u of l) {
        var c = u.unref();
        if (c.length < 2)
          throw new Error("Cannot lift node at a path [".concat(c, "] because it has a depth of less than `2`."));
        var d = D.node(e, q.parent(c)), [f, v] = d, h = c[c.length - 1], {
          length: g
        } = f.children;
        if (g === 1) {
          var p = q.next(v);
          se.moveNodes(e, {
            at: c,
            to: p,
            voids: i
          }), se.removeNodes(e, {
            at: v,
            voids: i
          });
        } else if (h === 0)
          se.moveNodes(e, {
            at: c,
            to: v,
            voids: i
          });
        else if (h === g - 1) {
          var w = q.next(v);
          se.moveNodes(e, {
            at: c,
            to: w,
            voids: i
          });
        } else {
          var b = q.next(c), k = q.next(v);
          se.splitNodes(e, {
            at: b,
            voids: i
          }), se.moveNodes(e, {
            at: c,
            to: k,
            voids: i
          });
        }
      }
    }
  });
}, RD = ["text"], ND = ["children"], vy = (t, e) => {
  if (me.isElement(e)) {
    var n = e;
    return D.isVoid(t, e) ? !0 : n.children.length === 1 ? vy(t, n.children[0]) : !1;
  } else return !D.isEditor(e);
}, $D = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  D.withoutNormalizing(e, () => {
    var {
      match: r,
      at: o = e.selection
    } = n, {
      hanging: i = !1,
      voids: a = !1,
      mode: s = "lowest"
    } = n;
    if (o) {
      if (r == null)
        if (q.isPath(o)) {
          var [l] = D.parent(e, o);
          r = ($) => l.children.includes($);
        } else
          r = ($) => me.isElement($) && D.isBlock(e, $);
      if (!i && re.isRange(o) && (o = D.unhangRange(e, o, {
        voids: a
      })), re.isRange(o))
        if (re.isCollapsed(o))
          o = o.anchor;
        else {
          var [, u] = re.edges(o), c = D.pointRef(e, u);
          se.delete(e, {
            at: o
          }), o = c.unref(), n.at == null && se.select(e, o);
        }
      var [d] = D.nodes(e, {
        at: o,
        match: r,
        voids: a,
        mode: s
      }), f = D.previous(e, {
        at: o,
        match: r,
        voids: a,
        mode: s
      });
      if (!(!d || !f)) {
        var [v, h] = d, [g, p] = f;
        if (!(h.length === 0 || p.length === 0)) {
          var w = q.next(p), b = q.common(h, p), k = q.isSibling(h, p), E = Array.from(D.levels(e, {
            at: h
          }), ($) => {
            var [j] = $;
            return j;
          }).slice(b.length).slice(0, -1), m = D.above(e, {
            at: h,
            mode: "highest",
            match: ($) => E.includes($) && vy(e, $)
          }), O = m && D.pathRef(e, m[1]), S, W;
          if (ye.isText(v) && ye.isText(g)) {
            var P = Jn(v, RD);
            W = g.text.length, S = P;
          } else if (me.isElement(v) && me.isElement(g)) {
            var P = Jn(v, ND);
            W = g.children.length, S = P;
          } else
            throw new Error("Cannot merge the node at path [".concat(h, "] with the previous sibling because it is not the same kind: ").concat(Ut.stringify(v), " ").concat(Ut.stringify(g)));
          k || se.moveNodes(e, {
            at: h,
            to: w,
            voids: a
          }), O && se.removeNodes(e, {
            at: O.current,
            voids: a
          }), D.shouldMergeNodesRemovePrevNode(e, f, d) ? se.removeNodes(e, {
            at: p,
            voids: a
          }) : e.apply({
            type: "merge_node",
            path: w,
            position: W,
            properties: S
          }), O && O.unref();
        }
      }
    }
  });
}, zD = (t, e) => {
  D.withoutNormalizing(t, () => {
    var {
      to: n,
      at: r = t.selection,
      mode: o = "lowest",
      voids: i = !1
    } = e, {
      match: a
    } = e;
    if (r) {
      a == null && (a = q.isPath(r) ? fo(t, r) : (v) => me.isElement(v) && D.isBlock(t, v));
      var s = D.pathRef(t, n), l = D.nodes(t, {
        at: r,
        match: a,
        mode: o,
        voids: i
      }), u = Array.from(l, (v) => {
        var [, h] = v;
        return D.pathRef(t, h);
      });
      for (var c of u) {
        var d = c.unref(), f = s.current;
        d.length !== 0 && t.apply({
          type: "move_node",
          path: d,
          newPath: f
        }), s.current && q.isSibling(f, d) && q.isAfter(f, d) && (s.current = q.next(s.current));
      }
      s.unref();
    }
  });
}, UD = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  D.withoutNormalizing(e, () => {
    var {
      hanging: r = !1,
      voids: o = !1,
      mode: i = "lowest"
    } = n, {
      at: a = e.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = q.isPath(a) ? fo(e, a) : (v) => me.isElement(v) && D.isBlock(e, v)), !r && re.isRange(a) && (a = D.unhangRange(e, a, {
        voids: o
      }));
      var l = D.nodes(e, {
        at: a,
        match: s,
        mode: i,
        voids: o
      }), u = Array.from(l, (v) => {
        var [, h] = v;
        return D.pathRef(e, h);
      });
      for (var c of u) {
        var d = c.unref();
        if (d) {
          var [f] = D.node(e, d);
          e.apply({
            type: "remove_node",
            path: d,
            node: f
          });
        }
      }
    }
  });
}, WD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  D.withoutNormalizing(e, () => {
    var {
      match: o,
      at: i = e.selection,
      compare: a,
      merge: s
    } = r, {
      hanging: l = !1,
      mode: u = "lowest",
      split: c = !1,
      voids: d = !1
    } = r;
    if (i) {
      if (o == null && (o = q.isPath(i) ? fo(e, i) : (W) => me.isElement(W) && D.isBlock(e, W)), !l && re.isRange(i) && (i = D.unhangRange(e, i, {
        voids: d
      })), c && re.isRange(i)) {
        if (re.isCollapsed(i) && D.leaf(e, i.anchor)[0].text.length > 0)
          return;
        var f = D.rangeRef(e, i, {
          affinity: "inward"
        }), [v, h] = re.edges(i), g = u === "lowest" ? "lowest" : "highest", p = D.isEnd(e, h, h.path);
        se.splitNodes(e, {
          at: h,
          match: o,
          mode: g,
          voids: d,
          always: !p
        });
        var w = D.isStart(e, v, v.path);
        se.splitNodes(e, {
          at: v,
          match: o,
          mode: g,
          voids: d,
          always: !w
        }), i = f.unref(), r.at == null && se.select(e, i);
      }
      a || (a = (W, P) => W !== P);
      for (var [b, k] of D.nodes(e, {
        at: i,
        match: o,
        mode: u,
        voids: d
      })) {
        var E = {}, m = {};
        if (k.length !== 0) {
          var O = !1;
          for (var S in n)
            S === "children" || S === "text" || a(n[S], b[S]) && (O = !0, b.hasOwnProperty(S) && (E[S] = b[S]), s ? n[S] != null && (m[S] = s(b[S], n[S])) : n[S] != null && (m[S] = n[S]));
          O && e.apply({
            type: "set_node",
            path: k,
            properties: E,
            newProperties: m
          });
        }
      }
    }
  });
}, HD = (t, e) => {
  if (re.isCollapsed(e))
    return e.anchor;
  var [, n] = re.edges(e), r = D.pointRef(t, n);
  return se.delete(t, {
    at: e
  }), r.unref();
}, VD = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  D.withoutNormalizing(e, () => {
    var {
      mode: r = "lowest",
      voids: o = !1
    } = n, {
      match: i,
      at: a = e.selection,
      height: s = 0,
      always: l = !1
    } = n;
    if (i == null && (i = (Q) => me.isElement(Q) && D.isBlock(e, Q)), re.isRange(a) && (a = HD(e, a)), q.isPath(a)) {
      var u = a, c = D.point(e, u), [d] = D.parent(e, u);
      i = (Q) => Q === d, s = c.path.length - u.length + 1, a = c, l = !0;
    }
    if (a) {
      var f = D.pointRef(e, a, {
        affinity: "backward"
      }), v;
      try {
        var [h] = D.nodes(e, {
          at: a,
          match: i,
          mode: r,
          voids: o
        });
        if (!h)
          return;
        var g = D.void(e, {
          at: a,
          mode: "highest"
        }), p = 0;
        if (!o && g) {
          var [w, b] = g;
          if (me.isElement(w) && e.isInline(w)) {
            var k = D.after(e, b);
            if (!k) {
              var E = {
                text: ""
              }, m = q.next(b);
              se.insertNodes(e, E, {
                at: m,
                voids: o
              }), k = D.point(e, m);
            }
            a = k, l = !0;
          }
          var O = a.path.length - b.length;
          s = O + 1, l = !0;
        }
        v = D.pointRef(e, a);
        var S = a.path.length - s, [, W] = h, P = a.path.slice(0, S), $ = s === 0 ? a.offset : a.path[S] + p;
        for (var [j, _] of D.levels(e, {
          at: P,
          reverse: !0,
          voids: o
        })) {
          var I = !1;
          if (_.length < W.length || _.length === 0 || !o && me.isElement(j) && D.isVoid(e, j))
            break;
          var R = f.current, V = D.isEnd(e, R, _);
          if (l || !f || !D.isEdge(e, R, _)) {
            I = !0;
            var J = fe.extractProps(j);
            e.apply({
              type: "split_node",
              path: _,
              position: $,
              properties: J
            });
          }
          $ = _[_.length - 1] + (I || V ? 1 : 0);
        }
        if (n.at == null) {
          var G = v.current || D.end(e, []);
          se.select(e, G);
        }
      } finally {
        var te;
        f.unref(), (te = v) === null || te === void 0 || te.unref();
      }
    }
  });
}, qD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  Array.isArray(n) || (n = [n]);
  var o = {};
  for (var i of n)
    o[i] = null;
  se.setNodes(e, o, r);
}, GD = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  D.withoutNormalizing(e, () => {
    var {
      mode: r = "lowest",
      split: o = !1,
      voids: i = !1
    } = n, {
      at: a = e.selection,
      match: s
    } = n;
    if (a) {
      s == null && (s = q.isPath(a) ? fo(e, a) : (v) => me.isElement(v) && D.isBlock(e, v)), q.isPath(a) && (a = D.range(e, a));
      var l = re.isRange(a) ? D.rangeRef(e, a) : null, u = D.nodes(e, {
        at: a,
        match: s,
        mode: r,
        voids: i
      }), c = Array.from(
        u,
        (v) => {
          var [, h] = v;
          return D.pathRef(e, h);
        }
        // unwrapNode will call liftNode which does not support splitting the node when nested.
        // If we do not reverse the order and call it from top to the bottom, it will remove all blocks
        // that wrap target node. So we reverse the order.
      ).reverse(), d = function() {
        var h = f.unref(), [g] = D.node(e, h), p = D.range(e, h);
        o && l && (p = re.intersection(l.current, p)), se.liftNodes(e, {
          at: p,
          match: (w) => me.isAncestor(g) && g.children.includes(w),
          voids: i
        });
      };
      for (var f of c)
        d();
      l && l.unref();
    }
  });
};
function uf(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? uf(Object(n), !0).forEach(function(r) {
      nn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : uf(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var ZD = function(e, n) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
  D.withoutNormalizing(e, () => {
    var {
      mode: o = "lowest",
      split: i = !1,
      voids: a = !1
    } = r, {
      match: s,
      at: l = e.selection
    } = r;
    if (l) {
      if (s == null && (q.isPath(l) ? s = fo(e, l) : e.isInline(n) ? s = (p) => me.isElement(p) && D.isInline(e, p) || ye.isText(p) : s = (p) => me.isElement(p) && D.isBlock(e, p)), i && re.isRange(l)) {
        var [u, c] = re.edges(l), d = D.rangeRef(e, l, {
          affinity: "inward"
        });
        se.splitNodes(e, {
          at: c,
          match: s,
          voids: a
        }), se.splitNodes(e, {
          at: u,
          match: s,
          voids: a
        }), l = d.unref(), r.at == null && se.select(e, l);
      }
      var f = Array.from(D.nodes(e, {
        at: l,
        match: e.isInline(n) ? (p) => me.isElement(p) && D.isBlock(e, p) : (p) => D.isEditor(p),
        mode: "lowest",
        voids: a
      })), v = function() {
        var w = re.isRange(l) ? re.intersection(l, D.range(e, g)) : l;
        if (!w)
          return 0;
        var b = Array.from(D.nodes(e, {
          at: w,
          match: s,
          mode: o,
          voids: a
        }));
        if (b.length > 0) {
          var [k] = b, E = b[b.length - 1], [, m] = k, [, O] = E;
          if (m.length === 0 && O.length === 0)
            return 0;
          var S = q.equals(m, O) ? q.parent(m) : q.common(m, O), W = D.range(e, m, O), P = D.node(e, S), [$] = P, j = S.length + 1, _ = q.next(O.slice(0, j)), I = cf(cf({}, n), {}, {
            children: []
          });
          se.insertNodes(e, I, {
            at: _,
            voids: a
          }), se.moveNodes(e, {
            at: W,
            match: (R) => me.isAncestor($) && $.children.includes(R),
            to: _.concat(0),
            voids: a
          });
        }
      }, h;
      for (var [, g] of f)
        h = v();
    }
  });
}, KD = () => {
  var t = {
    children: [],
    operations: [],
    selection: null,
    marks: null,
    isElementReadOnly: () => !1,
    isInline: () => !1,
    isSelectable: () => !0,
    isVoid: () => !1,
    markableVoid: () => !1,
    onChange: () => {
    },
    // Core
    apply: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bE(t, ...r);
    },
    // Editor
    addMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xE(t, ...r);
    },
    deleteBackward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PE(t, ...r);
    },
    deleteForward: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kE(t, ...r);
    },
    deleteFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ME(t, ...r);
    },
    getFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wE(t, ...r);
    },
    insertBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zE(t, ...r);
    },
    insertSoftBreak: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return WE(t, ...r);
    },
    insertFragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return kD(t, ...r);
    },
    insertNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return UE(t, ...r);
    },
    insertText: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return VE(t, ...r);
    },
    normalizeNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return EE(t, ...r);
    },
    removeMark: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return wD(t, ...r);
    },
    getDirtyPaths: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return CE(t, ...r);
    },
    shouldNormalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DE(t, ...r);
    },
    // Editor interface
    above: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return OE(t, ...r);
    },
    after: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LE(t, ...r);
    },
    before: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SE(t, ...r);
    },
    collapse: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return MD(t, ...r);
    },
    delete: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return PD(t, ...r);
    },
    deselect: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return BD(t, ...r);
    },
    edges: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return BE(t, ...r);
    },
    elementReadOnly: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return TE(t, ...r);
    },
    end: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return AE(t, ...r);
    },
    first: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jE(t, ...r);
    },
    fragment: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return FE(t, ...r);
    },
    getMarks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return rD(t, ...r);
    },
    hasBlocks: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return IE(t, ...r);
    },
    hasInlines: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return RE(t, ...r);
    },
    hasPath: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return NE(t, ...r);
    },
    hasTexts: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $E(t, ...r);
    },
    insertNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _D(t, ...r);
    },
    isBlock: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qE(t, ...r);
    },
    isEdge: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return GE(t, ...r);
    },
    isEmpty: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ZE(t, ...r);
    },
    isEnd: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return KE(t, ...r);
    },
    isNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return YE(t, ...r);
    },
    isStart: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return XE(t, ...r);
    },
    last: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return JE(t, ...r);
    },
    leaf: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return QE(t, ...r);
    },
    levels: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return eD(t, ...r);
    },
    liftNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ID(t, ...r);
    },
    mergeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return $D(t, ...r);
    },
    move: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return TD(t, ...r);
    },
    moveNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return zD(t, ...r);
    },
    next: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return oD(t, ...r);
    },
    node: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return iD(t, ...r);
    },
    nodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return aD(t, ...r);
    },
    normalize: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return sD(t, ...r);
    },
    parent: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return lD(t, ...r);
    },
    path: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return dD(t, ...r);
    },
    pathRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return uD(t, ...r);
    },
    pathRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return cD(t, ...r);
    },
    point: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return hD(t, ...r);
    },
    pointRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return fD(t, ...r);
    },
    pointRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return pD(t, ...r);
    },
    positions: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return gD(t, ...r);
    },
    previous: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return vD(t, ...r);
    },
    range: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return bD(t, ...r);
    },
    rangeRef: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return mD(t, ...r);
    },
    rangeRefs: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return yD(t, ...r);
    },
    removeNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return UD(t, ...r);
    },
    select: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return AD(t, ...r);
    },
    setNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return WD(t, ...r);
    },
    setNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ED(t, ...r);
    },
    setPoint: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return jD(t, ...r);
    },
    setSelection: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return FD(t, ...r);
    },
    splitNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return VD(t, ...r);
    },
    start: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return DD(t, ...r);
    },
    string: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return OD(t, ...r);
    },
    unhangRange: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return xD(t, ...r);
    },
    unsetNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return qD(t, ...r);
    },
    unwrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return GD(t, ...r);
    },
    void: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return _E(t, ...r);
    },
    withoutNormalizing: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return LD(t, ...r);
    },
    wrapNodes: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return ZD(t, ...r);
    },
    shouldMergeNodesRemovePrevNode: function() {
      for (var n = arguments.length, r = new Array(n), o = 0; o < n; o++)
        r[o] = arguments[o];
      return SD(t, ...r);
    }
  };
  return t;
};
const my = (t) => {
  if (ye.isText(t)) {
    let e = t.text;
    return t.bold && (e = `<strong>${e}</strong>`), t.code && (e = `<code>${e}</code>`), t.italic && (e = `<em>${e}</em>`), t.underline && (e = `<u>${e}</u>`), e;
  }
  if (me.isElement(t)) {
    const e = t.children.map((r) => my(r)).join(""), n = t.align || "left";
    switch (t.type) {
      case "image":
        return `<img src="${t.src}" class="align_${n}" />`;
      case "paragraph":
        return `<p class="align_${n}">${e}</p>`;
      case "blockQuote":
        return `<blockquote class="align_${n}">${e}</blockquote>`;
      case "bulletedList":
        return `<ul class="align_${n}">${e}</ul>`;
      case "headingOne":
        return `<h1 class="align_${n}">${e}</h1>`;
      case "headingTwo":
        return `<h2 class="align_${n}">${e}</h2>`;
      case "listItem":
        return `<li class="align_${n}">${e}</li>`;
      case "numberedList":
        return `<ol class="align_${n}">${e}</ol>`;
      default:
        return e;
    }
  }
  return "";
}, o2 = (t) => t.map((e) => my(e)).join("");
var yy = {}, uc = {}, cc = {};
Object.defineProperty(cc, "__esModule", { value: !0 });
cc.default = QD;
var df = "html", ff = "head", Oi = "body", YD = /<([a-zA-Z]+[0-9]?)/, pf = /<head[^]*>/i, hf = /<body[^]*>/i, Oa = function(t, e) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, du = function(t, e) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, gf = typeof window == "object" && window.DOMParser;
if (typeof gf == "function") {
  var XD = new gf(), JD = "text/html";
  du = function(t, e) {
    return e && (t = "<".concat(e, ">").concat(t, "</").concat(e, ">")), XD.parseFromString(t, JD);
  }, Oa = du;
}
if (typeof document == "object" && document.implementation) {
  var xi = document.implementation.createHTMLDocument();
  Oa = function(t, e) {
    if (e) {
      var n = xi.documentElement.querySelector(e);
      return n && (n.innerHTML = t), xi;
    }
    return xi.documentElement.innerHTML = t, xi;
  };
}
var Li = typeof document == "object" && document.createElement("template"), fu;
Li && Li.content && (fu = function(t) {
  return Li.innerHTML = t, Li.content.childNodes;
});
function QD(t) {
  var e, n, r = t.match(YD), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case df: {
      var i = du(t);
      if (!pf.test(t)) {
        var a = i.querySelector(ff);
        (e = a == null ? void 0 : a.parentNode) === null || e === void 0 || e.removeChild(a);
      }
      if (!hf.test(t)) {
        var a = i.querySelector(Oi);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(df);
    }
    case ff:
    case Oi: {
      var s = Oa(t).querySelectorAll(o);
      return hf.test(t) && pf.test(t) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (fu)
        return fu(t);
      var a = Oa(t, Oi).querySelector(Oi);
      return a.childNodes;
    }
  }
}
var us = {}, dc = {}, fc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.Doctype = t.CDATA = t.Tag = t.Style = t.Script = t.Comment = t.Directive = t.Text = t.Root = t.isTag = t.ElementType = void 0;
  var e;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(e = t.ElementType || (t.ElementType = {}));
  function n(r) {
    return r.type === e.Tag || r.type === e.Script || r.type === e.Style;
  }
  t.isTag = n, t.Root = e.Root, t.Text = e.Text, t.Directive = e.Directive, t.Comment = e.Comment, t.Script = e.Script, t.Style = e.Style, t.Tag = e.Tag, t.CDATA = e.CDATA, t.Doctype = e.Doctype;
})(fc);
var ze = {}, Er = ht && ht.__extends || /* @__PURE__ */ function() {
  var t = function(e, n) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, t(e, n);
  };
  return function(e, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    t(e, n);
    function r() {
      this.constructor = e;
    }
    e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), Io = ht && ht.__assign || function() {
  return Io = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) {
      e = arguments[n];
      for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]);
    }
    return t;
  }, Io.apply(this, arguments);
};
Object.defineProperty(ze, "__esModule", { value: !0 });
ze.cloneNode = ze.hasChildren = ze.isDocument = ze.isDirective = ze.isComment = ze.isText = ze.isCDATA = ze.isTag = ze.Element = ze.Document = ze.CDATA = ze.NodeWithChildren = ze.ProcessingInstruction = ze.Comment = ze.Text = ze.DataNode = ze.Node = void 0;
var un = fc, pc = (
  /** @class */
  function() {
    function t() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(t.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(e) {
        this.parent = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(e) {
        this.prev = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(e) {
        this.next = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.cloneNode = function(e) {
      return e === void 0 && (e = !1), hc(this, e);
    }, t;
  }()
);
ze.Node = pc;
var cs = (
  /** @class */
  function(t) {
    Er(e, t);
    function e(n) {
      var r = t.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(e.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(pc)
);
ze.DataNode = cs;
var by = (
  /** @class */
  function(t) {
    Er(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = un.ElementType.Text, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(cs)
);
ze.Text = by;
var Cy = (
  /** @class */
  function(t) {
    Er(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = un.ElementType.Comment, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(cs)
);
ze.Comment = Cy;
var wy = (
  /** @class */
  function(t) {
    Er(e, t);
    function e(n, r) {
      var o = t.call(this, r) || this;
      return o.name = n, o.type = un.ElementType.Directive, o;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(cs)
);
ze.ProcessingInstruction = wy;
var ds = (
  /** @class */
  function(t) {
    Er(e, t);
    function e(n) {
      var r = t.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(e.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(pc)
);
ze.NodeWithChildren = ds;
var Ey = (
  /** @class */
  function(t) {
    Er(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = un.ElementType.CDATA, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(ds)
);
ze.CDATA = Ey;
var Dy = (
  /** @class */
  function(t) {
    Er(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = un.ElementType.Root, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(ds)
);
ze.Document = Dy;
var Oy = (
  /** @class */
  function(t) {
    Er(e, t);
    function e(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? un.ElementType.Script : n === "style" ? un.ElementType.Style : un.ElementType.Tag);
      var a = t.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(ds)
);
ze.Element = Oy;
function xy(t) {
  return (0, un.isTag)(t);
}
ze.isTag = xy;
function Ly(t) {
  return t.type === un.ElementType.CDATA;
}
ze.isCDATA = Ly;
function Sy(t) {
  return t.type === un.ElementType.Text;
}
ze.isText = Sy;
function Py(t) {
  return t.type === un.ElementType.Comment;
}
ze.isComment = Py;
function ky(t) {
  return t.type === un.ElementType.Directive;
}
ze.isDirective = ky;
function My(t) {
  return t.type === un.ElementType.Root;
}
ze.isDocument = My;
function e1(t) {
  return Object.prototype.hasOwnProperty.call(t, "children");
}
ze.hasChildren = e1;
function hc(t, e) {
  e === void 0 && (e = !1);
  var n;
  if (Sy(t))
    n = new by(t.data);
  else if (Py(t))
    n = new Cy(t.data);
  else if (xy(t)) {
    var r = e ? ol(t.children) : [], o = new Oy(t.name, Io({}, t.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), t.namespace != null && (o.namespace = t.namespace), t["x-attribsNamespace"] && (o["x-attribsNamespace"] = Io({}, t["x-attribsNamespace"])), t["x-attribsPrefix"] && (o["x-attribsPrefix"] = Io({}, t["x-attribsPrefix"])), n = o;
  } else if (Ly(t)) {
    var r = e ? ol(t.children) : [], i = new Ey(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (My(t)) {
    var r = e ? ol(t.children) : [], a = new Dy(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), t["x-mode"] && (a["x-mode"] = t["x-mode"]), n = a;
  } else if (ky(t)) {
    var s = new wy(t.name, t.data);
    t["x-name"] != null && (s["x-name"] = t["x-name"], s["x-publicId"] = t["x-publicId"], s["x-systemId"] = t["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(t.type));
  return n.startIndex = t.startIndex, n.endIndex = t.endIndex, t.sourceCodeLocation != null && (n.sourceCodeLocation = t.sourceCodeLocation), n;
}
ze.cloneNode = hc;
function ol(t) {
  for (var e = t.map(function(r) {
    return hc(r, !0);
  }), n = 1; n < e.length; n++)
    e[n].prev = e[n - 1], e[n - 1].next = e[n];
  return e;
}
(function(t) {
  var e = ht && ht.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var d = Object.getOwnPropertyDescriptor(l, u);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, d);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = ht && ht.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && e(l, s, u);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DomHandler = void 0;
  var r = fc, o = ze;
  n(ze, t);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, d = new o.Element(l, u, void 0, c);
        this.addNode(d), this.tagStack.push(d);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  t.DomHandler = a, t.default = a;
})(dc);
var By = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CASE_SENSITIVE_TAG_NAMES_MAP = t.CASE_SENSITIVE_TAG_NAMES = void 0, t.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], t.CASE_SENSITIVE_TAG_NAMES_MAP = t.CASE_SENSITIVE_TAG_NAMES.reduce(function(e, n) {
    return e[n.toLowerCase()] = n, e;
  }, {});
})(By);
Object.defineProperty(us, "__esModule", { value: !0 });
us.formatAttributes = Ty;
us.formatDOM = Ay;
var Si = dc, t1 = By;
function n1(t) {
  return t1.CASE_SENSITIVE_TAG_NAMES_MAP[t];
}
function Ty(t) {
  for (var e = {}, n = 0, r = t.length; n < r; n++) {
    var o = t[n];
    e[o.name] = o.value;
  }
  return e;
}
function r1(t) {
  t = t.toLowerCase();
  var e = n1(t);
  return e || t;
}
function Ay(t, e, n) {
  e === void 0 && (e = null);
  for (var r = [], o, i = 0, a = t.length; i < a; i++) {
    var s = t[i];
    switch (s.nodeType) {
      case 1: {
        var l = r1(s.nodeName);
        o = new Si.Element(l, Ty(s.attributes)), o.children = Ay(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Si.Text(s.nodeValue);
        break;
      case 8:
        o = new Si.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = e, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Si.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = e, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var o1 = ht && ht.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(uc, "__esModule", { value: !0 });
uc.default = l1;
var i1 = o1(cc), a1 = us, s1 = /<(![a-zA-Z\s]+)>/;
function l1(t) {
  if (typeof t != "string")
    throw new TypeError("First argument must be a string");
  if (!t)
    return [];
  var e = t.match(s1), n = e ? e[1] : void 0;
  return (0, a1.formatDOM)((0, i1.default)(t), null, n);
}
var fs = {}, Fn = {}, ps = {}, u1 = 0;
ps.SAME = u1;
var c1 = 1;
ps.CAMELCASE = c1;
ps.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const jy = 0, Dr = 1, hs = 2, gs = 3, gc = 4, Fy = 5, _y = 6;
function d1(t) {
  return qt.hasOwnProperty(t) ? qt[t] : null;
}
function rn(t, e, n, r, o, i, a) {
  this.acceptsBooleans = e === hs || e === gs || e === gc, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = i, this.removeEmptyString = a;
}
const qt = {}, f1 = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
f1.forEach((t) => {
  qt[t] = new rn(
    t,
    jy,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([t, e]) => {
  qt[t] = new rn(
    t,
    Dr,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((t) => {
  qt[t] = new rn(
    t,
    hs,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((t) => {
  qt[t] = new rn(
    t,
    hs,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((t) => {
  qt[t] = new rn(
    t,
    gs,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  qt[t] = new rn(
    t,
    gs,
    !0,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  qt[t] = new rn(
    t,
    gc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  qt[t] = new rn(
    t,
    _y,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((t) => {
  qt[t] = new rn(
    t,
    Fy,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const vc = /[\-\:]([a-z])/g, mc = (t) => t[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  const e = t.replace(vc, mc);
  qt[e] = new rn(
    e,
    Dr,
    !1,
    // mustUseProperty
    t,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  const e = t.replace(vc, mc);
  qt[e] = new rn(
    e,
    Dr,
    !1,
    // mustUseProperty
    t,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  const e = t.replace(vc, mc);
  qt[e] = new rn(
    e,
    Dr,
    !1,
    // mustUseProperty
    t,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((t) => {
  qt[t] = new rn(
    t,
    Dr,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const p1 = "xlinkHref";
qt[p1] = new rn(
  "xlinkHref",
  Dr,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((t) => {
  qt[t] = new rn(
    t,
    Dr,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: h1,
  SAME: g1,
  possibleStandardNames: vf
} = ps, v1 = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", m1 = v1 + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", y1 = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + m1 + "]*$")
), b1 = Object.keys(
  vf
).reduce((t, e) => {
  const n = vf[e];
  return n === g1 ? t[e] = e : n === h1 ? t[e.toLowerCase()] = e : t[e] = n, t;
}, {});
Fn.BOOLEAN = gs;
Fn.BOOLEANISH_STRING = hs;
Fn.NUMERIC = Fy;
Fn.OVERLOADED_BOOLEAN = gc;
Fn.POSITIVE_NUMERIC = _y;
Fn.RESERVED = jy;
Fn.STRING = Dr;
Fn.getPropertyInfo = d1;
Fn.isCustomAttribute = y1;
Fn.possibleStandardNames = b1;
var yc = {}, bc = {}, mf = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, C1 = /\n/g, w1 = /^\s*/, E1 = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, D1 = /^:\s*/, O1 = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, x1 = /^[;\s]*/, L1 = /^\s+|\s+$/g, S1 = `
`, yf = "/", bf = "*", Rr = "", P1 = "comment", k1 = "declaration", M1 = function(t, e) {
  if (typeof t != "string")
    throw new TypeError("First argument must be a string");
  if (!t) return [];
  e = e || {};
  var n = 1, r = 1;
  function o(h) {
    var g = h.match(C1);
    g && (n += g.length);
    var p = h.lastIndexOf(S1);
    r = ~p ? h.length - p : r + h.length;
  }
  function i() {
    var h = { line: n, column: r };
    return function(g) {
      return g.position = new a(h), u(), g;
    };
  }
  function a(h) {
    this.start = h, this.end = { line: n, column: r }, this.source = e.source;
  }
  a.prototype.content = t;
  function s(h) {
    var g = new Error(
      e.source + ":" + n + ":" + r + ": " + h
    );
    if (g.reason = h, g.filename = e.source, g.line = n, g.column = r, g.source = t, !e.silent) throw g;
  }
  function l(h) {
    var g = h.exec(t);
    if (g) {
      var p = g[0];
      return o(p), t = t.slice(p.length), g;
    }
  }
  function u() {
    l(w1);
  }
  function c(h) {
    var g;
    for (h = h || []; g = d(); )
      g !== !1 && h.push(g);
    return h;
  }
  function d() {
    var h = i();
    if (!(yf != t.charAt(0) || bf != t.charAt(1))) {
      for (var g = 2; Rr != t.charAt(g) && (bf != t.charAt(g) || yf != t.charAt(g + 1)); )
        ++g;
      if (g += 2, Rr === t.charAt(g - 1))
        return s("End of comment missing");
      var p = t.slice(2, g - 2);
      return r += 2, o(p), t = t.slice(g), r += 2, h({
        type: P1,
        comment: p
      });
    }
  }
  function f() {
    var h = i(), g = l(E1);
    if (g) {
      if (d(), !l(D1)) return s("property missing ':'");
      var p = l(O1), w = h({
        type: k1,
        property: Cf(g[0].replace(mf, Rr)),
        value: p ? Cf(p[0].replace(mf, Rr)) : Rr
      });
      return l(x1), w;
    }
  }
  function v() {
    var h = [];
    c(h);
    for (var g; g = f(); )
      g !== !1 && (h.push(g), c(h));
    return h;
  }
  return u(), v();
};
function Cf(t) {
  return t ? t.replace(L1, Rr) : Rr;
}
var B1 = ht && ht.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(bc, "__esModule", { value: !0 });
bc.default = A1;
var T1 = B1(M1);
function A1(t, e) {
  var n = null;
  if (!t || typeof t != "string")
    return n;
  var r = (0, T1.default)(t), o = typeof e == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? e(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var vs = {};
Object.defineProperty(vs, "__esModule", { value: !0 });
vs.camelCase = void 0;
var j1 = /^--[a-zA-Z0-9_-]+$/, F1 = /-([a-z])/g, _1 = /^[^-]+$/, I1 = /^-(webkit|moz|ms|o|khtml)-/, R1 = /^-(ms)-/, N1 = function(t) {
  return !t || _1.test(t) || j1.test(t);
}, $1 = function(t, e) {
  return e.toUpperCase();
}, wf = function(t, e) {
  return "".concat(e, "-");
}, z1 = function(t, e) {
  return e === void 0 && (e = {}), N1(t) ? t : (t = t.toLowerCase(), e.reactCompat ? t = t.replace(R1, wf) : t = t.replace(I1, wf), t.replace(F1, $1));
};
vs.camelCase = z1;
var U1 = ht && ht.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
}, W1 = U1(bc), H1 = vs;
function pu(t, e) {
  var n = {};
  return !t || typeof t != "string" || (0, W1.default)(t, function(r, o) {
    r && o && (n[(0, H1.camelCase)(r, e)] = o);
  }), n;
}
pu.default = pu;
var V1 = pu;
(function(t) {
  var e = ht && ht.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.returnFirstArg = t.canTextBeChildOfNode = t.ELEMENTS_WITH_NO_TEXT_CHILDREN = t.PRESERVE_CUSTOM_ATTRIBUTES = void 0, t.isCustomComponent = i, t.setStyleProp = s;
  var n = be, r = e(V1), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, d) {
    return c.includes("-") ? !o.has(c) : !!(d && typeof d.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, d) {
    if (typeof c == "string") {
      if (!c.trim()) {
        d.style = {};
        return;
      }
      try {
        d.style = (0, r.default)(c, a);
      } catch {
        d.style = {};
      }
    }
  }
  t.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, t.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !t.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  t.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  t.returnFirstArg = u;
})(yc);
Object.defineProperty(fs, "__esModule", { value: !0 });
fs.default = K1;
var Ao = Fn, Ef = yc, q1 = ["checked", "value"], G1 = ["input", "select", "textarea"], Z1 = {
  reset: !0,
  submit: !0
};
function K1(t, e) {
  t === void 0 && (t = {});
  var n = {}, r = !!(t.type && Z1[t.type]);
  for (var o in t) {
    var i = t[o];
    if ((0, Ao.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = Df(a);
    if (s) {
      var l = (0, Ao.getPropertyInfo)(s);
      switch (q1.includes(s) && G1.includes(e) && !r && (s = Df("default" + a)), n[s] = i, l && l.type) {
        case Ao.BOOLEAN:
          n[s] = !0;
          break;
        case Ao.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    Ef.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, Ef.setStyleProp)(t.style, n), n;
}
function Df(t) {
  return Ao.possibleStandardNames[t];
}
var Cc = {}, Y1 = ht && ht.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Cc, "__esModule", { value: !0 });
Cc.default = Iy;
var il = be, X1 = Y1(fs), Ro = yc, J1 = {
  cloneElement: il.cloneElement,
  createElement: il.createElement,
  isValidElement: il.isValidElement
};
function Iy(t, e) {
  e === void 0 && (e = {});
  for (var n = [], r = typeof e.replace == "function", o = e.transform || Ro.returnFirstArg, i = e.library || J1, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = t.length, c = 0; c < u; c++) {
    var d = t[c];
    if (r) {
      var f = e.replace(d, c);
      if (l(f)) {
        u > 1 && (f = a(f, {
          key: f.key || c
        })), n.push(o(f, d, c));
        continue;
      }
    }
    if (d.type === "text") {
      var v = !d.data.trim().length;
      if (v && d.parent && !(0, Ro.canTextBeChildOfNode)(d.parent) || e.trim && v)
        continue;
      n.push(o(d.data, d, c));
      continue;
    }
    var h = d, g = {};
    Q1(h) ? ((0, Ro.setStyleProp)(h.attribs.style, h.attribs), g = h.attribs) : h.attribs && (g = (0, X1.default)(h.attribs, h.name));
    var p = void 0;
    switch (d.type) {
      case "script":
      case "style":
        d.children[0] && (g.dangerouslySetInnerHTML = {
          __html: d.children[0].data
        });
        break;
      case "tag":
        d.name === "textarea" && d.children[0] ? g.defaultValue = d.children[0].data : d.children && d.children.length && (p = Iy(d.children, e));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(s(d.name, g, p), d, c));
  }
  return n.length === 1 ? n[0] : n;
}
function Q1(t) {
  return Ro.PRESERVE_CUSTOM_ATTRIBUTES && t.type === "tag" && (0, Ro.isCustomComponent)(t.name, t.attribs);
}
(function(t) {
  var e = ht && ht.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.htmlToDOM = t.domToReact = t.attributesToProps = t.Text = t.ProcessingInstruction = t.Element = t.Comment = void 0, t.default = s;
  var n = e(uc);
  t.htmlToDOM = n.default;
  var r = e(fs);
  t.attributesToProps = r.default;
  var o = e(Cc);
  t.domToReact = o.default;
  var i = dc;
  Object.defineProperty(t, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(t, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(t, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(t, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(yy);
const Of = /* @__PURE__ */ os(yy), eO = Of.default || Of, hu = (t) => {
  var r;
  if (typeof t == "string")
    return { text: t };
  const e = Array.isArray(t.props.children) ? t.props.children.map((o) => hu(o)) : [{ text: t.props.children || "" }], n = (r = t.props.className) == null ? void 0 : r.replace("align_", "");
  switch (t.type) {
    case "img":
      return {
        type: "image",
        align: n,
        src: t.props.src,
        children: [{ text: "" }]
      };
    case "p":
      return { type: "paragraph", align: n, children: e };
    case "blockquote":
      return { type: "blockQuote", align: n, children: e };
    case "ul":
      return { type: "bulletedList", align: n, children: e };
    case "ol":
      return { type: "numberedList", align: n, children: e };
    case "li":
      return { type: "listItem", align: n, children: e };
    case "h1":
      return { type: "headingOne", align: n, children: e };
    case "h2":
      return { type: "headingTwo", align: n, children: e };
    case "strong":
      return { text: t.props.children, bold: !0 };
    case "code":
      return { text: t.props.children, code: !0 };
    case "em":
      return { text: t.props.children, italic: !0 };
    case "u":
      return { text: t.props.children, underline: !0 };
    default:
      return { text: t.props.children || "" };
  }
}, i2 = (t) => {
  const e = eO(t);
  return Array.isArray(e) ? e.map((n) => typeof n == "string" ? { text: n } : hu(n)) : typeof e == "string" ? [{ text: e }] : [hu(e)];
}, a2 = (t) => /<\/?[a-z][\s\S]*>/i.test(t);
function Ry(t, e, n) {
  if (!t) return /* @__PURE__ */ x.jsx(x.Fragment, {});
  if (typeof t == "string") return /* @__PURE__ */ x.jsx("p", { className: n, children: t });
  const r = t;
  return /* @__PURE__ */ x.jsx("p", { className: n, children: /* @__PURE__ */ x.jsx(r, { color: "var(--secondary-600)", size: e, strokeWidth: 2.5 }) });
}
function s2(t) {
  const {
    variant: e = "ghost",
    scheme: n = "primary",
    size: r = "md",
    leftIcon: o,
    rightIcon: i,
    className: a = "",
    children: s,
    ...l
  } = t, c = { md: 12, lg: 14 }[r], d = `arkynBadge ${e} ${n} ${r} ${a}`;
  return /* @__PURE__ */ x.jsxs("div", { className: d.trim(), ...l, children: [
    ya(c, o),
    s,
    ya(c, o)
  ] });
}
function l2(t) {
  const { className: e, ...n } = t, r = `arkynCard ${e}`;
  return /* @__PURE__ */ x.jsx("div", { className: r.trim(), ...n });
}
function u2(t) {
  const {
    className: e,
    orientation: n = "horizontal",
    ...r
  } = t, o = `arkynDivider ${n} ${e}`;
  return /* @__PURE__ */ x.jsx("div", { className: o.trim(), ...r });
}
function c2(t) {
  const { className: e, ...n } = t, r = `arkynSkeleton ${e}`;
  return /* @__PURE__ */ x.jsx("aside", { className: r.trim(), ...n });
}
function d2(t) {
  const {
    emptyMessage: e = "Nenhum dado adicionado.",
    className: n,
    children: r,
    ...o
  } = t, i = `arkynTableBody ${n}`, a = zt.count(r) === 0;
  return /* @__PURE__ */ x.jsx("tbody", { className: i.trim(), ...o, children: a ? /* @__PURE__ */ x.jsx("tr", { className: "arkynTableBodyEmptyLine", children: /* @__PURE__ */ x.jsx("td", { colSpan: 100, children: /* @__PURE__ */ x.jsx("div", { children: e }) }) }) : r });
}
function f2(t) {
  const { className: e, children: n, ...r } = t, o = `arkynTableCaption ${e}`;
  return /* @__PURE__ */ x.jsx("caption", { className: o.trim(), ...r, children: /* @__PURE__ */ x.jsx("div", { className: "arkynTableCaptionContent", children: n }) });
}
function p2(t) {
  const { children: e, className: n, ...r } = t, o = `arkynTableContainer ${n}`;
  return /* @__PURE__ */ x.jsx("div", { className: o.trim(), ...r, children: /* @__PURE__ */ x.jsx("table", { children: e }) });
}
function h2(t) {
  const { className: e, children: n, ...r } = t, o = `arkynTableFooter ${e}`;
  return /* @__PURE__ */ x.jsxs("tfoot", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ x.jsx("tr", { className: "spacingRow" }),
    /* @__PURE__ */ x.jsx("tr", { children: /* @__PURE__ */ x.jsx("th", { colSpan: 100, children: /* @__PURE__ */ x.jsx("div", { className: "arkynTableFooterContent", children: n }) }) })
  ] });
}
function g2(t) {
  const { className: e, children: n, ...r } = t, o = `arkynTableHeader ${e}`;
  return /* @__PURE__ */ x.jsxs("thead", { className: o.trim(), ...r, children: [
    /* @__PURE__ */ x.jsx("tr", { children: n }),
    /* @__PURE__ */ x.jsx("tr", { className: "spacingRow" })
  ] });
}
var gt = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {};
function tO(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var gu = { exports: {} }, Do = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var xf;
function nO() {
  if (xf) return Do;
  xf = 1;
  var t = be, e = Symbol.for("react.element"), n = Symbol.for("react.fragment"), r = Object.prototype.hasOwnProperty, o = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, i = { key: !0, ref: !0, __self: !0, __source: !0 };
  function a(s, l, u) {
    var c, d = {}, f = null, v = null;
    u !== void 0 && (f = "" + u), l.key !== void 0 && (f = "" + l.key), l.ref !== void 0 && (v = l.ref);
    for (c in l) r.call(l, c) && !i.hasOwnProperty(c) && (d[c] = l[c]);
    if (s && s.defaultProps) for (c in l = s.defaultProps, l) d[c] === void 0 && (d[c] = l[c]);
    return { $$typeof: e, type: s, key: f, ref: v, props: d, _owner: o.current };
  }
  return Do.Fragment = n, Do.jsx = a, Do.jsxs = a, Do;
}
var Pi = {};
/**
 * @license React
 * react-jsx-runtime.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Lf;
function rO() {
  return Lf || (Lf = 1, process.env.NODE_ENV !== "production" && function() {
    var t = be, e = Symbol.for("react.element"), n = Symbol.for("react.portal"), r = Symbol.for("react.fragment"), o = Symbol.for("react.strict_mode"), i = Symbol.for("react.profiler"), a = Symbol.for("react.provider"), s = Symbol.for("react.context"), l = Symbol.for("react.forward_ref"), u = Symbol.for("react.suspense"), c = Symbol.for("react.suspense_list"), d = Symbol.for("react.memo"), f = Symbol.for("react.lazy"), v = Symbol.for("react.offscreen"), h = Symbol.iterator, g = "@@iterator";
    function p(C) {
      if (C === null || typeof C != "object")
        return null;
      var K = h && C[h] || C[g];
      return typeof K == "function" ? K : null;
    }
    var w = t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function b(C) {
      {
        for (var K = arguments.length, ne = new Array(K > 1 ? K - 1 : 0), ce = 1; ce < K; ce++)
          ne[ce - 1] = arguments[ce];
        k("error", C, ne);
      }
    }
    function k(C, K, ne) {
      {
        var ce = w.ReactDebugCurrentFrame, Ce = ce.getStackAddendum();
        Ce !== "" && (K += "%s", ne = ne.concat([Ce]));
        var we = ne.map(function(ve) {
          return String(ve);
        });
        we.unshift("Warning: " + K), Function.prototype.apply.call(console[C], console, we);
      }
    }
    var E = !1, m = !1, O = !1, S = !1, W = !1, P;
    P = Symbol.for("react.module.reference");
    function $(C) {
      return !!(typeof C == "string" || typeof C == "function" || C === r || C === i || W || C === o || C === u || C === c || S || C === v || E || m || O || typeof C == "object" && C !== null && (C.$$typeof === f || C.$$typeof === d || C.$$typeof === a || C.$$typeof === s || C.$$typeof === l || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      C.$$typeof === P || C.getModuleId !== void 0));
    }
    function j(C, K, ne) {
      var ce = C.displayName;
      if (ce)
        return ce;
      var Ce = K.displayName || K.name || "";
      return Ce !== "" ? ne + "(" + Ce + ")" : ne;
    }
    function _(C) {
      return C.displayName || "Context";
    }
    function I(C) {
      if (C == null)
        return null;
      if (typeof C.tag == "number" && b("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof C == "function")
        return C.displayName || C.name || null;
      if (typeof C == "string")
        return C;
      switch (C) {
        case r:
          return "Fragment";
        case n:
          return "Portal";
        case i:
          return "Profiler";
        case o:
          return "StrictMode";
        case u:
          return "Suspense";
        case c:
          return "SuspenseList";
      }
      if (typeof C == "object")
        switch (C.$$typeof) {
          case s:
            var K = C;
            return _(K) + ".Consumer";
          case a:
            var ne = C;
            return _(ne._context) + ".Provider";
          case l:
            return j(C, C.render, "ForwardRef");
          case d:
            var ce = C.displayName || null;
            return ce !== null ? ce : I(C.type) || "Memo";
          case f: {
            var Ce = C, we = Ce._payload, ve = Ce._init;
            try {
              return I(ve(we));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var R = Object.assign, V = 0, J, G, te, Q, T, N, Y;
    function F() {
    }
    F.__reactDisabledLog = !0;
    function X() {
      {
        if (V === 0) {
          J = console.log, G = console.info, te = console.warn, Q = console.error, T = console.group, N = console.groupCollapsed, Y = console.groupEnd;
          var C = {
            configurable: !0,
            enumerable: !0,
            value: F,
            writable: !0
          };
          Object.defineProperties(console, {
            info: C,
            log: C,
            warn: C,
            error: C,
            group: C,
            groupCollapsed: C,
            groupEnd: C
          });
        }
        V++;
      }
    }
    function L() {
      {
        if (V--, V === 0) {
          var C = {
            configurable: !0,
            enumerable: !0,
            writable: !0
          };
          Object.defineProperties(console, {
            log: R({}, C, {
              value: J
            }),
            info: R({}, C, {
              value: G
            }),
            warn: R({}, C, {
              value: te
            }),
            error: R({}, C, {
              value: Q
            }),
            group: R({}, C, {
              value: T
            }),
            groupCollapsed: R({}, C, {
              value: N
            }),
            groupEnd: R({}, C, {
              value: Y
            })
          });
        }
        V < 0 && b("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var M = w.ReactCurrentDispatcher, z;
    function A(C, K, ne) {
      {
        if (z === void 0)
          try {
            throw Error();
          } catch (Ce) {
            var ce = Ce.stack.trim().match(/\n( *(at )?)/);
            z = ce && ce[1] || "";
          }
        return `
` + z + C;
      }
    }
    var U = !1, H;
    {
      var ee = typeof WeakMap == "function" ? WeakMap : Map;
      H = new ee();
    }
    function Z(C, K) {
      if (!C || U)
        return "";
      {
        var ne = H.get(C);
        if (ne !== void 0)
          return ne;
      }
      var ce;
      U = !0;
      var Ce = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var we;
      we = M.current, M.current = null, X();
      try {
        if (K) {
          var ve = function() {
            throw Error();
          };
          if (Object.defineProperty(ve.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(ve, []);
            } catch (st) {
              ce = st;
            }
            Reflect.construct(C, [], ve);
          } else {
            try {
              ve.call();
            } catch (st) {
              ce = st;
            }
            C.call(ve.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (st) {
            ce = st;
          }
          C();
        }
      } catch (st) {
        if (st && ce && typeof st.stack == "string") {
          for (var ge = st.stack.split(`
`), et = ce.stack.split(`
`), Me = ge.length - 1, Te = et.length - 1; Me >= 1 && Te >= 0 && ge[Me] !== et[Te]; )
            Te--;
          for (; Me >= 1 && Te >= 0; Me--, Te--)
            if (ge[Me] !== et[Te]) {
              if (Me !== 1 || Te !== 1)
                do
                  if (Me--, Te--, Te < 0 || ge[Me] !== et[Te]) {
                    var vt = `
` + ge[Me].replace(" at new ", " at ");
                    return C.displayName && vt.includes("<anonymous>") && (vt = vt.replace("<anonymous>", C.displayName)), typeof C == "function" && H.set(C, vt), vt;
                  }
                while (Me >= 1 && Te >= 0);
              break;
            }
        }
      } finally {
        U = !1, M.current = we, L(), Error.prepareStackTrace = Ce;
      }
      var mn = C ? C.displayName || C.name : "", Qt = mn ? A(mn) : "";
      return typeof C == "function" && H.set(C, Qt), Qt;
    }
    function pe(C, K, ne) {
      return Z(C, !1);
    }
    function he(C) {
      var K = C.prototype;
      return !!(K && K.isReactComponent);
    }
    function le(C, K, ne) {
      if (C == null)
        return "";
      if (typeof C == "function")
        return Z(C, he(C));
      if (typeof C == "string")
        return A(C);
      switch (C) {
        case u:
          return A("Suspense");
        case c:
          return A("SuspenseList");
      }
      if (typeof C == "object")
        switch (C.$$typeof) {
          case l:
            return pe(C.render);
          case d:
            return le(C.type, K, ne);
          case f: {
            var ce = C, Ce = ce._payload, we = ce._init;
            try {
              return le(we(Ce), K, ne);
            } catch {
            }
          }
        }
      return "";
    }
    var Le = Object.prototype.hasOwnProperty, Fe = {}, Be = w.ReactDebugCurrentFrame;
    function Ne(C) {
      if (C) {
        var K = C._owner, ne = le(C.type, C._source, K ? K.type : null);
        Be.setExtraStackFrame(ne);
      } else
        Be.setExtraStackFrame(null);
    }
    function at(C, K, ne, ce, Ce) {
      {
        var we = Function.call.bind(Le);
        for (var ve in C)
          if (we(C, ve)) {
            var ge = void 0;
            try {
              if (typeof C[ve] != "function") {
                var et = Error((ce || "React class") + ": " + ne + " type `" + ve + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof C[ve] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw et.name = "Invariant Violation", et;
              }
              ge = C[ve](K, ve, ce, ne, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (Me) {
              ge = Me;
            }
            ge && !(ge instanceof Error) && (Ne(Ce), b("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", ce || "React class", ne, ve, typeof ge), Ne(null)), ge instanceof Error && !(ge.message in Fe) && (Fe[ge.message] = !0, Ne(Ce), b("Failed %s type: %s", ne, ge.message), Ne(null));
          }
      }
    }
    var dt = Array.isArray;
    function Oe(C) {
      return dt(C);
    }
    function ft(C) {
      {
        var K = typeof Symbol == "function" && Symbol.toStringTag, ne = K && C[Symbol.toStringTag] || C.constructor.name || "Object";
        return ne;
      }
    }
    function bt(C) {
      try {
        return De(C), !1;
      } catch {
        return !0;
      }
    }
    function De(C) {
      return "" + C;
    }
    function ke(C) {
      if (bt(C))
        return b("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", ft(C)), De(C);
    }
    var Ke = w.ReactCurrentOwner, Je = {
      key: !0,
      ref: !0,
      __self: !0,
      __source: !0
    }, Qe, Bt, He;
    He = {};
    function Yt(C) {
      if (Le.call(C, "ref")) {
        var K = Object.getOwnPropertyDescriptor(C, "ref").get;
        if (K && K.isReactWarning)
          return !1;
      }
      return C.ref !== void 0;
    }
    function Ft(C) {
      if (Le.call(C, "key")) {
        var K = Object.getOwnPropertyDescriptor(C, "key").get;
        if (K && K.isReactWarning)
          return !1;
      }
      return C.key !== void 0;
    }
    function It(C, K) {
      if (typeof C.ref == "string" && Ke.current && K && Ke.current.stateNode !== K) {
        var ne = I(Ke.current.type);
        He[ne] || (b('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', I(Ke.current.type), C.ref), He[ne] = !0);
      }
    }
    function Wt(C, K) {
      {
        var ne = function() {
          Qe || (Qe = !0, b("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", K));
        };
        ne.isReactWarning = !0, Object.defineProperty(C, "key", {
          get: ne,
          configurable: !0
        });
      }
    }
    function fn(C, K) {
      {
        var ne = function() {
          Bt || (Bt = !0, b("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", K));
        };
        ne.isReactWarning = !0, Object.defineProperty(C, "ref", {
          get: ne,
          configurable: !0
        });
      }
    }
    var Ht = function(C, K, ne, ce, Ce, we, ve) {
      var ge = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: e,
        // Built-in properties that belong on the element
        type: C,
        key: K,
        ref: ne,
        props: ve,
        // Record the component responsible for creating this element.
        _owner: we
      };
      return ge._store = {}, Object.defineProperty(ge._store, "validated", {
        configurable: !1,
        enumerable: !1,
        writable: !0,
        value: !1
      }), Object.defineProperty(ge, "_self", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: ce
      }), Object.defineProperty(ge, "_source", {
        configurable: !1,
        enumerable: !1,
        writable: !1,
        value: Ce
      }), Object.freeze && (Object.freeze(ge.props), Object.freeze(ge)), ge;
    };
    function pn(C, K, ne, ce, Ce) {
      {
        var we, ve = {}, ge = null, et = null;
        ne !== void 0 && (ke(ne), ge = "" + ne), Ft(K) && (ke(K.key), ge = "" + K.key), Yt(K) && (et = K.ref, It(K, Ce));
        for (we in K)
          Le.call(K, we) && !Je.hasOwnProperty(we) && (ve[we] = K[we]);
        if (C && C.defaultProps) {
          var Me = C.defaultProps;
          for (we in Me)
            ve[we] === void 0 && (ve[we] = Me[we]);
        }
        if (ge || et) {
          var Te = typeof C == "function" ? C.displayName || C.name || "Unknown" : C;
          ge && Wt(ve, Te), et && fn(ve, Te);
        }
        return Ht(C, ge, et, Ce, ce, Ke.current, ve);
      }
    }
    var _t = w.ReactCurrentOwner, Xt = w.ReactDebugCurrentFrame;
    function Rt(C) {
      if (C) {
        var K = C._owner, ne = le(C.type, C._source, K ? K.type : null);
        Xt.setExtraStackFrame(ne);
      } else
        Xt.setExtraStackFrame(null);
    }
    var hn;
    hn = !1;
    function Vt(C) {
      return typeof C == "object" && C !== null && C.$$typeof === e;
    }
    function Bn() {
      {
        if (_t.current) {
          var C = I(_t.current.type);
          if (C)
            return `

Check the render method of \`` + C + "`.";
        }
        return "";
      }
    }
    function gn(C) {
      return "";
    }
    var Tn = {};
    function vn(C) {
      {
        var K = Bn();
        if (!K) {
          var ne = typeof C == "string" ? C : C.displayName || C.name;
          ne && (K = `

Check the top-level render call using <` + ne + ">.");
        }
        return K;
      }
    }
    function An(C, K) {
      {
        if (!C._store || C._store.validated || C.key != null)
          return;
        C._store.validated = !0;
        var ne = vn(K);
        if (Tn[ne])
          return;
        Tn[ne] = !0;
        var ce = "";
        C && C._owner && C._owner !== _t.current && (ce = " It was passed a child from " + I(C._owner.type) + "."), Rt(C), b('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', ne, ce), Rt(null);
      }
    }
    function Vn(C, K) {
      {
        if (typeof C != "object")
          return;
        if (Oe(C))
          for (var ne = 0; ne < C.length; ne++) {
            var ce = C[ne];
            Vt(ce) && An(ce, K);
          }
        else if (Vt(C))
          C._store && (C._store.validated = !0);
        else if (C) {
          var Ce = p(C);
          if (typeof Ce == "function" && Ce !== C.entries)
            for (var we = Ce.call(C), ve; !(ve = we.next()).done; )
              Vt(ve.value) && An(ve.value, K);
        }
      }
    }
    function Jt(C) {
      {
        var K = C.type;
        if (K == null || typeof K == "string")
          return;
        var ne;
        if (typeof K == "function")
          ne = K.propTypes;
        else if (typeof K == "object" && (K.$$typeof === l || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        K.$$typeof === d))
          ne = K.propTypes;
        else
          return;
        if (ne) {
          var ce = I(K);
          at(ne, C.props, "prop", ce, C);
        } else if (K.PropTypes !== void 0 && !hn) {
          hn = !0;
          var Ce = I(K);
          b("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", Ce || "Unknown");
        }
        typeof K.getDefaultProps == "function" && !K.getDefaultProps.isReactClassApproved && b("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function de(C) {
      {
        for (var K = Object.keys(C.props), ne = 0; ne < K.length; ne++) {
          var ce = K[ne];
          if (ce !== "children" && ce !== "key") {
            Rt(C), b("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", ce), Rt(null);
            break;
          }
        }
        C.ref !== null && (Rt(C), b("Invalid attribute `ref` supplied to `React.Fragment`."), Rt(null));
      }
    }
    var yo = {};
    function bo(C, K, ne, ce, Ce, we) {
      {
        var ve = $(C);
        if (!ve) {
          var ge = "";
          (C === void 0 || typeof C == "object" && C !== null && Object.keys(C).length === 0) && (ge += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var et = gn();
          et ? ge += et : ge += Bn();
          var Me;
          C === null ? Me = "null" : Oe(C) ? Me = "array" : C !== void 0 && C.$$typeof === e ? (Me = "<" + (I(C.type) || "Unknown") + " />", ge = " Did you accidentally export a JSX literal instead of a component?") : Me = typeof C, b("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", Me, ge);
        }
        var Te = pn(C, K, ne, Ce, we);
        if (Te == null)
          return Te;
        if (ve) {
          var vt = K.children;
          if (vt !== void 0)
            if (ce)
              if (Oe(vt)) {
                for (var mn = 0; mn < vt.length; mn++)
                  Vn(vt[mn], C);
                Object.freeze && Object.freeze(vt);
              } else
                b("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Vn(vt, C);
        }
        if (Le.call(K, "key")) {
          var Qt = I(C), st = Object.keys(K).filter(function(tl) {
            return tl !== "key";
          }), kr = st.length > 0 ? "{key: someKey, " + st.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!yo[Qt + kr]) {
            var el = st.length > 0 ? "{" + st.join(": ..., ") + ": ...}" : "{}";
            b(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, kr, Qt, el, Qt), yo[Qt + kr] = !0;
          }
        }
        return C === r ? de(Te) : Jt(Te), Te;
      }
    }
    function Ys(C, K, ne) {
      return bo(C, K, ne, !0);
    }
    function Xs(C, K, ne) {
      return bo(C, K, ne, !1);
    }
    var Js = Xs, Qs = Ys;
    Pi.Fragment = r, Pi.jsx = Js, Pi.jsxs = Qs;
  }()), Pi;
}
process.env.NODE_ENV === "production" ? gu.exports = nO() : gu.exports = rO();
var ut = gu.exports;
ct({});
function Sf(t, e) {
  return e ? /* @__PURE__ */ ut.jsx(e, { size: t, strokeWidth: 2.5 }) : /* @__PURE__ */ ut.jsx(ut.Fragment, {});
}
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function Pf(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function Kt(t) {
  var e, n;
  return Pf(t) === !1 ? !1 : (e = t.constructor, e === void 0 ? !0 : (n = e.prototype, !(Pf(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var Ny = Symbol.for("immer-nothing"), kf = Symbol.for("immer-draftable"), xn = Symbol.for("immer-state"), oO = process.env.NODE_ENV !== "production" ? [
  // All error codes, starting by 0:
  function(t) {
    return `The plugin for '${t}' has not been loaded into Immer. To enable the plugin, import and call \`enable${t}()\` when initializing your application.`;
  },
  function(t) {
    return `produce can only be called on things that are draftable: plain objects, arrays, Map, Set or classes that are marked with '[immerable]: true'. Got '${t}'`;
  },
  "This object has been frozen and should not be mutated",
  function(t) {
    return "Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? " + t;
  },
  "An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.",
  "Immer forbids circular references",
  "The first or second argument to `produce` must be a function",
  "The third argument to `produce` must be a function or undefined",
  "First argument to `createDraft` must be a plain object, an array, or an immerable object",
  "First argument to `finishDraft` must be a draft returned by `createDraft`",
  function(t) {
    return `'current' expects a draft, got: ${t}`;
  },
  "Object.defineProperty() cannot be used on an Immer draft",
  "Object.setPrototypeOf() cannot be used on an Immer draft",
  "Immer only supports deleting array indices",
  "Immer only supports setting array indices and the 'length' property",
  function(t) {
    return `'original' expects a draft, got: ${t}`;
  }
  // Note: if more errors are added, the errorOffset in Patches.ts should be increased
  // See Patches.ts for additional errors
] : [];
function ln(t, ...e) {
  if (process.env.NODE_ENV !== "production") {
    const n = oO[t], r = typeof n == "function" ? n.apply(null, e) : n;
    throw new Error(`[Immer] ${r}`);
  }
  throw new Error(
    `[Immer] minified error nr: ${t}. Full error at: https://bit.ly/3cXEKWf`
  );
}
var lo = Object.getPrototypeOf;
function Yr(t) {
  return !!t && !!t[xn];
}
function Xr(t) {
  var e;
  return t ? $y(t) || Array.isArray(t) || !!t[kf] || !!((e = t.constructor) != null && e[kf]) || ys(t) || bs(t) : !1;
}
var iO = Object.prototype.constructor.toString();
function $y(t) {
  if (!t || typeof t != "object")
    return !1;
  const e = lo(t);
  if (e === null)
    return !0;
  const n = Object.hasOwnProperty.call(e, "constructor") && e.constructor;
  return n === Object ? !0 : typeof n == "function" && Function.toString.call(n) === iO;
}
function xa(t, e) {
  ms(t) === 0 ? Reflect.ownKeys(t).forEach((n) => {
    e(n, t[n], t);
  }) : t.forEach((n, r) => e(r, n, t));
}
function ms(t) {
  const e = t[xn];
  return e ? e.type_ : Array.isArray(t) ? 1 : ys(t) ? 2 : bs(t) ? 3 : 0;
}
function vu(t, e) {
  return ms(t) === 2 ? t.has(e) : Object.prototype.hasOwnProperty.call(t, e);
}
function zy(t, e, n) {
  const r = ms(t);
  r === 2 ? t.set(e, n) : r === 3 ? t.add(n) : t[e] = n;
}
function aO(t, e) {
  return t === e ? t !== 0 || 1 / t === 1 / e : t !== t && e !== e;
}
function ys(t) {
  return t instanceof Map;
}
function bs(t) {
  return t instanceof Set;
}
function _r(t) {
  return t.copy_ || t.base_;
}
function mu(t, e) {
  if (ys(t))
    return new Map(t);
  if (bs(t))
    return new Set(t);
  if (Array.isArray(t))
    return Array.prototype.slice.call(t);
  const n = $y(t);
  if (e === !0 || e === "class_only" && !n) {
    const r = Object.getOwnPropertyDescriptors(t);
    delete r[xn];
    let o = Reflect.ownKeys(r);
    for (let i = 0; i < o.length; i++) {
      const a = o[i], s = r[a];
      s.writable === !1 && (s.writable = !0, s.configurable = !0), (s.get || s.set) && (r[a] = {
        configurable: !0,
        writable: !0,
        // could live with !!desc.set as well here...
        enumerable: s.enumerable,
        value: t[a]
      });
    }
    return Object.create(lo(t), r);
  } else {
    const r = lo(t);
    if (r !== null && n)
      return { ...t };
    const o = Object.create(r);
    return Object.assign(o, t);
  }
}
function wc(t, e = !1) {
  return Cs(t) || Yr(t) || !Xr(t) || (ms(t) > 1 && (t.set = t.add = t.clear = t.delete = sO), Object.freeze(t), e && Object.entries(t).forEach(([n, r]) => wc(r, !0))), t;
}
function sO() {
  ln(2);
}
function Cs(t) {
  return Object.isFrozen(t);
}
var lO = {};
function Jr(t) {
  const e = lO[t];
  return e || ln(0, t), e;
}
var Xo;
function Uy() {
  return Xo;
}
function uO(t, e) {
  return {
    drafts_: [],
    parent_: t,
    immer_: e,
    // Whenever the modified draft contains a draft from another scope, we
    // need to prevent auto-freezing so the unowned draft can be finalized.
    canAutoFreeze_: !0,
    unfinalizedDrafts_: 0
  };
}
function Mf(t, e) {
  e && (Jr("Patches"), t.patches_ = [], t.inversePatches_ = [], t.patchListener_ = e);
}
function yu(t) {
  bu(t), t.drafts_.forEach(cO), t.drafts_ = null;
}
function bu(t) {
  t === Xo && (Xo = t.parent_);
}
function Bf(t) {
  return Xo = uO(Xo, t);
}
function cO(t) {
  const e = t[xn];
  e.type_ === 0 || e.type_ === 1 ? e.revoke_() : e.revoked_ = !0;
}
function Tf(t, e) {
  e.unfinalizedDrafts_ = e.drafts_.length;
  const n = e.drafts_[0];
  return t !== void 0 && t !== n ? (n[xn].modified_ && (yu(e), ln(4)), Xr(t) && (t = La(e, t), e.parent_ || Sa(e, t)), e.patches_ && Jr("Patches").generateReplacementPatches_(
    n[xn].base_,
    t,
    e.patches_,
    e.inversePatches_
  )) : t = La(e, n, []), yu(e), e.patches_ && e.patchListener_(e.patches_, e.inversePatches_), t !== Ny ? t : void 0;
}
function La(t, e, n) {
  if (Cs(e))
    return e;
  const r = e[xn];
  if (!r)
    return xa(
      e,
      (o, i) => Af(t, r, e, o, i, n)
    ), e;
  if (r.scope_ !== t)
    return e;
  if (!r.modified_)
    return Sa(t, r.base_, !0), r.base_;
  if (!r.finalized_) {
    r.finalized_ = !0, r.scope_.unfinalizedDrafts_--;
    const o = r.copy_;
    let i = o, a = !1;
    r.type_ === 3 && (i = new Set(o), o.clear(), a = !0), xa(
      i,
      (s, l) => Af(t, r, o, s, l, n, a)
    ), Sa(t, o, !1), n && t.patches_ && Jr("Patches").generatePatches_(
      r,
      n,
      t.patches_,
      t.inversePatches_
    );
  }
  return r.copy_;
}
function Af(t, e, n, r, o, i, a) {
  if (process.env.NODE_ENV !== "production" && o === n && ln(5), Yr(o)) {
    const s = i && e && e.type_ !== 3 && // Set objects are atomic since they have no keys.
    !vu(e.assigned_, r) ? i.concat(r) : void 0, l = La(t, o, s);
    if (zy(n, r, l), Yr(l))
      t.canAutoFreeze_ = !1;
    else
      return;
  } else a && n.add(o);
  if (Xr(o) && !Cs(o)) {
    if (!t.immer_.autoFreeze_ && t.unfinalizedDrafts_ < 1)
      return;
    La(t, o), (!e || !e.scope_.parent_) && typeof r != "symbol" && Object.prototype.propertyIsEnumerable.call(n, r) && Sa(t, o);
  }
}
function Sa(t, e, n = !1) {
  !t.parent_ && t.immer_.autoFreeze_ && t.canAutoFreeze_ && wc(e, n);
}
function dO(t, e) {
  const n = Array.isArray(t), r = {
    type_: n ? 1 : 0,
    // Track which produce call this is associated with.
    scope_: e ? e.scope_ : Uy(),
    // True for both shallow and deep changes.
    modified_: !1,
    // Used during finalization.
    finalized_: !1,
    // Track which properties have been assigned (true) or deleted (false).
    assigned_: {},
    // The parent draft state.
    parent_: e,
    // The base state.
    base_: t,
    // The base proxy.
    draft_: null,
    // set below
    // The base copy with any updated values.
    copy_: null,
    // Called by the `produce` function.
    revoke_: null,
    isManual_: !1
  };
  let o = r, i = Ec;
  n && (o = [r], i = Jo);
  const { revoke: a, proxy: s } = Proxy.revocable(o, i);
  return r.draft_ = s, r.revoke_ = a, s;
}
var Ec = {
  get(t, e) {
    if (e === xn)
      return t;
    const n = _r(t);
    if (!vu(n, e))
      return fO(t, n, e);
    const r = n[e];
    return t.finalized_ || !Xr(r) ? r : r === al(t.base_, e) ? (sl(t), t.copy_[e] = wu(r, t)) : r;
  },
  has(t, e) {
    return e in _r(t);
  },
  ownKeys(t) {
    return Reflect.ownKeys(_r(t));
  },
  set(t, e, n) {
    const r = Wy(_r(t), e);
    if (r != null && r.set)
      return r.set.call(t.draft_, n), !0;
    if (!t.modified_) {
      const o = al(_r(t), e), i = o == null ? void 0 : o[xn];
      if (i && i.base_ === n)
        return t.copy_[e] = n, t.assigned_[e] = !1, !0;
      if (aO(n, o) && (n !== void 0 || vu(t.base_, e)))
        return !0;
      sl(t), Cu(t);
    }
    return t.copy_[e] === n && // special case: handle new props with value 'undefined'
    (n !== void 0 || e in t.copy_) || // special case: NaN
    Number.isNaN(n) && Number.isNaN(t.copy_[e]) || (t.copy_[e] = n, t.assigned_[e] = !0), !0;
  },
  deleteProperty(t, e) {
    return al(t.base_, e) !== void 0 || e in t.base_ ? (t.assigned_[e] = !1, sl(t), Cu(t)) : delete t.assigned_[e], t.copy_ && delete t.copy_[e], !0;
  },
  // Note: We never coerce `desc.value` into an Immer draft, because we can't make
  // the same guarantee in ES5 mode.
  getOwnPropertyDescriptor(t, e) {
    const n = _r(t), r = Reflect.getOwnPropertyDescriptor(n, e);
    return r && {
      writable: !0,
      configurable: t.type_ !== 1 || e !== "length",
      enumerable: r.enumerable,
      value: n[e]
    };
  },
  defineProperty() {
    ln(11);
  },
  getPrototypeOf(t) {
    return lo(t.base_);
  },
  setPrototypeOf() {
    ln(12);
  }
}, Jo = {};
xa(Ec, (t, e) => {
  Jo[t] = function() {
    return arguments[0] = arguments[0][0], e.apply(this, arguments);
  };
});
Jo.deleteProperty = function(t, e) {
  return process.env.NODE_ENV !== "production" && isNaN(parseInt(e)) && ln(13), Jo.set.call(this, t, e, void 0);
};
Jo.set = function(t, e, n) {
  return process.env.NODE_ENV !== "production" && e !== "length" && isNaN(parseInt(e)) && ln(14), Ec.set.call(this, t[0], e, n, t[0]);
};
function al(t, e) {
  const n = t[xn];
  return (n ? _r(n) : t)[e];
}
function fO(t, e, n) {
  var r;
  const o = Wy(e, n);
  return o ? "value" in o ? o.value : (
    // This is a very special case, if the prop is a getter defined by the
    // prototype, we should invoke it with the draft as context!
    (r = o.get) == null ? void 0 : r.call(t.draft_)
  ) : void 0;
}
function Wy(t, e) {
  if (!(e in t))
    return;
  let n = lo(t);
  for (; n; ) {
    const r = Object.getOwnPropertyDescriptor(n, e);
    if (r)
      return r;
    n = lo(n);
  }
}
function Cu(t) {
  t.modified_ || (t.modified_ = !0, t.parent_ && Cu(t.parent_));
}
function sl(t) {
  t.copy_ || (t.copy_ = mu(
    t.base_,
    t.scope_.immer_.useStrictShallowCopy_
  ));
}
var pO = class {
  constructor(t) {
    this.autoFreeze_ = !0, this.useStrictShallowCopy_ = !1, this.produce = (e, n, r) => {
      if (typeof e == "function" && typeof n != "function") {
        const i = n;
        n = e;
        const a = this;
        return function(s = i, ...l) {
          return a.produce(s, (u) => n.call(this, u, ...l));
        };
      }
      typeof n != "function" && ln(6), r !== void 0 && typeof r != "function" && ln(7);
      let o;
      if (Xr(e)) {
        const i = Bf(this), a = wu(e, void 0);
        let s = !0;
        try {
          o = n(a), s = !1;
        } finally {
          s ? yu(i) : bu(i);
        }
        return Mf(i, r), Tf(o, i);
      } else if (!e || typeof e != "object") {
        if (o = n(e), o === void 0 && (o = e), o === Ny && (o = void 0), this.autoFreeze_ && wc(o, !0), r) {
          const i = [], a = [];
          Jr("Patches").generateReplacementPatches_(e, o, i, a), r(i, a);
        }
        return o;
      } else
        ln(1, e);
    }, this.produceWithPatches = (e, n) => {
      if (typeof e == "function")
        return (i, ...a) => this.produceWithPatches(i, (s) => e(s, ...a));
      let r, o;
      return [this.produce(e, n, (i, a) => {
        r = i, o = a;
      }), r, o];
    }, typeof (t == null ? void 0 : t.autoFreeze) == "boolean" && this.setAutoFreeze(t.autoFreeze), typeof (t == null ? void 0 : t.useStrictShallowCopy) == "boolean" && this.setUseStrictShallowCopy(t.useStrictShallowCopy);
  }
  createDraft(t) {
    Xr(t) || ln(8), Yr(t) && (t = hO(t));
    const e = Bf(this), n = wu(t, void 0);
    return n[xn].isManual_ = !0, bu(e), n;
  }
  finishDraft(t, e) {
    const n = t && t[xn];
    (!n || !n.isManual_) && ln(9);
    const { scope_: r } = n;
    return Mf(r, e), Tf(void 0, r);
  }
  /**
   * Pass true to automatically freeze all copies created by Immer.
   *
   * By default, auto-freezing is enabled.
   */
  setAutoFreeze(t) {
    this.autoFreeze_ = t;
  }
  /**
   * Pass true to enable strict shallow copy.
   *
   * By default, immer does not copy the object descriptors such as getter, setter and non-enumrable properties.
   */
  setUseStrictShallowCopy(t) {
    this.useStrictShallowCopy_ = t;
  }
  applyPatches(t, e) {
    let n;
    for (n = e.length - 1; n >= 0; n--) {
      const o = e[n];
      if (o.path.length === 0 && o.op === "replace") {
        t = o.value;
        break;
      }
    }
    n > -1 && (e = e.slice(n + 1));
    const r = Jr("Patches").applyPatches_;
    return Yr(t) ? r(t, e) : this.produce(
      t,
      (o) => r(o, e)
    );
  }
};
function wu(t, e) {
  const n = ys(t) ? Jr("MapSet").proxyMap_(t, e) : bs(t) ? Jr("MapSet").proxySet_(t, e) : dO(t, e);
  return (e ? e.scope_ : Uy()).drafts_.push(n), n;
}
function hO(t) {
  return Yr(t) || ln(10, t), Hy(t);
}
function Hy(t) {
  if (!Xr(t) || Cs(t))
    return t;
  const e = t[xn];
  let n;
  if (e) {
    if (!e.modified_)
      return e.base_;
    e.finalized_ = !0, n = mu(t, e.scope_.immer_.useStrictShallowCopy_);
  } else
    n = mu(t, !0);
  return xa(n, (r, o) => {
    zy(n, r, Hy(o));
  }), e && (e.finalized_ = !1), n;
}
var Ln = new pO(), Dc = Ln.produce;
Ln.produceWithPatches.bind(
  Ln
);
Ln.setAutoFreeze.bind(Ln);
Ln.setUseStrictShallowCopy.bind(Ln);
Ln.applyPatches.bind(Ln);
var jf = Ln.createDraft.bind(Ln), Ff = Ln.finishDraft.bind(Ln), ue = {
  ancestors(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = e, r = ue.levels(t, e);
    return n ? r = r.slice(1) : r = r.slice(0, -1), r;
  },
  common(t, e) {
    for (var n = [], r = 0; r < t.length && r < e.length; r++) {
      var o = t[r], i = e[r];
      if (o !== i)
        break;
      n.push(o);
    }
    return n;
  },
  compare(t, e) {
    for (var n = Math.min(t.length, e.length), r = 0; r < n; r++) {
      if (t[r] < e[r]) return -1;
      if (t[r] > e[r]) return 1;
    }
    return 0;
  },
  endsAfter(t, e) {
    var n = t.length - 1, r = t.slice(0, n), o = e.slice(0, n), i = t[n], a = e[n];
    return ue.equals(r, o) && i > a;
  },
  endsAt(t, e) {
    var n = t.length, r = t.slice(0, n), o = e.slice(0, n);
    return ue.equals(r, o);
  },
  endsBefore(t, e) {
    var n = t.length - 1, r = t.slice(0, n), o = e.slice(0, n), i = t[n], a = e[n];
    return ue.equals(r, o) && i < a;
  },
  equals(t, e) {
    return t.length === e.length && t.every((n, r) => n === e[r]);
  },
  hasPrevious(t) {
    return t[t.length - 1] > 0;
  },
  isAfter(t, e) {
    return ue.compare(t, e) === 1;
  },
  isAncestor(t, e) {
    return t.length < e.length && ue.compare(t, e) === 0;
  },
  isBefore(t, e) {
    return ue.compare(t, e) === -1;
  },
  isChild(t, e) {
    return t.length === e.length + 1 && ue.compare(t, e) === 0;
  },
  isCommon(t, e) {
    return t.length <= e.length && ue.compare(t, e) === 0;
  },
  isDescendant(t, e) {
    return t.length > e.length && ue.compare(t, e) === 0;
  },
  isParent(t, e) {
    return t.length + 1 === e.length && ue.compare(t, e) === 0;
  },
  isPath(t) {
    return Array.isArray(t) && (t.length === 0 || typeof t[0] == "number");
  },
  isSibling(t, e) {
    if (t.length !== e.length)
      return !1;
    var n = t.slice(0, -1), r = e.slice(0, -1), o = t[t.length - 1], i = e[e.length - 1];
    return o !== i && ue.equals(n, r);
  },
  levels(t) {
    for (var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = e, r = [], o = 0; o <= t.length; o++)
      r.push(t.slice(0, o));
    return n && r.reverse(), r;
  },
  next(t) {
    if (t.length === 0)
      throw new Error("Cannot get the next path of a root path [".concat(t, "], because it has no next index."));
    var e = t[t.length - 1];
    return t.slice(0, -1).concat(e + 1);
  },
  operationCanTransformPath(t) {
    switch (t.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "split_node":
      case "move_node":
        return !0;
      default:
        return !1;
    }
  },
  parent(t) {
    if (t.length === 0)
      throw new Error("Cannot get the parent path of the root path [".concat(t, "]."));
    return t.slice(0, -1);
  },
  previous(t) {
    if (t.length === 0)
      throw new Error("Cannot get the previous path of a root path [".concat(t, "], because it has no previous index."));
    var e = t[t.length - 1];
    if (e <= 0)
      throw new Error("Cannot get the previous path of a first child path [".concat(t, "] because it would result in a negative index."));
    return t.slice(0, -1).concat(e - 1);
  },
  relative(t, e) {
    if (!ue.isAncestor(e, t) && !ue.equals(t, e))
      throw new Error("Cannot get the relative path of [".concat(t, "] inside ancestor [").concat(e, "], because it is not above or equal to the path."));
    return t.slice(e.length);
  },
  transform(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!t) return null;
    var r = [...t], {
      affinity: o = "forward"
    } = n;
    if (t.length === 0)
      return r;
    switch (e.type) {
      case "insert_node": {
        var {
          path: i
        } = e;
        (ue.equals(i, r) || ue.endsBefore(i, r) || ue.isAncestor(i, r)) && (r[i.length - 1] += 1);
        break;
      }
      case "remove_node": {
        var {
          path: a
        } = e;
        if (ue.equals(a, r) || ue.isAncestor(a, r))
          return null;
        ue.endsBefore(a, r) && (r[a.length - 1] -= 1);
        break;
      }
      case "merge_node": {
        var {
          path: s,
          position: l
        } = e;
        ue.equals(s, r) || ue.endsBefore(s, r) ? r[s.length - 1] -= 1 : ue.isAncestor(s, r) && (r[s.length - 1] -= 1, r[s.length] += l);
        break;
      }
      case "split_node": {
        var {
          path: u,
          position: c
        } = e;
        if (ue.equals(u, r)) {
          if (o === "forward")
            r[r.length - 1] += 1;
          else if (o !== "backward") return null;
        } else ue.endsBefore(u, r) ? r[u.length - 1] += 1 : ue.isAncestor(u, r) && t[u.length] >= c && (r[u.length - 1] += 1, r[u.length] -= c);
        break;
      }
      case "move_node": {
        var {
          path: d,
          newPath: f
        } = e;
        if (ue.equals(d, f))
          return r;
        if (ue.isAncestor(d, r) || ue.equals(d, r)) {
          var v = f.slice();
          return ue.endsBefore(d, f) && d.length < f.length && (v[d.length - 1] -= 1), v.concat(r.slice(d.length));
        } else ue.isSibling(d, f) && (ue.isAncestor(f, r) || ue.equals(f, r)) ? ue.endsBefore(d, r) ? r[d.length - 1] -= 1 : r[d.length - 1] += 1 : ue.endsBefore(f, r) || ue.equals(f, r) || ue.isAncestor(f, r) ? (ue.endsBefore(d, r) && (r[d.length - 1] -= 1), r[f.length - 1] += 1) : ue.endsBefore(d, r) && (ue.equals(f, r) && (r[f.length - 1] += 1), r[d.length - 1] -= 1);
        break;
      }
    }
    return r;
  }
};
function Qo(t) {
  "@babel/helpers - typeof";
  return Qo = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, Qo(t);
}
function gO(t, e) {
  if (Qo(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (Qo(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function vO(t) {
  var e = gO(t, "string");
  return Qo(e) === "symbol" ? e : String(e);
}
function po(t, e, n) {
  return e = vO(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function _f(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Oo(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? _f(Object(n), !0).forEach(function(r) {
      po(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : _f(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var mO = (t, e, n) => {
  switch (n.type) {
    case "insert_node": {
      var {
        path: r,
        node: o
      } = n, i = Pe.parent(t, r), a = r[r.length - 1];
      if (a > i.children.length)
        throw new Error('Cannot apply an "insert_node" operation at path ['.concat(r, "] because the destination is past the end of the node."));
      if (i.children.splice(a, 0, o), e)
        for (var [s, l] of Ie.points(e))
          e[l] = yt.transform(s, n);
      break;
    }
    case "insert_text": {
      var {
        path: u,
        offset: c,
        text: d
      } = n;
      if (d.length === 0) break;
      var f = Pe.leaf(t, u), v = f.text.slice(0, c), h = f.text.slice(c);
      if (f.text = v + d + h, e)
        for (var [g, p] of Ie.points(e))
          e[p] = yt.transform(g, n);
      break;
    }
    case "merge_node": {
      var {
        path: w
      } = n, b = Pe.get(t, w), k = ue.previous(w), E = Pe.get(t, k), m = Pe.parent(t, w), O = w[w.length - 1];
      if (Tt.isText(b) && Tt.isText(E))
        E.text += b.text;
      else if (!Tt.isText(b) && !Tt.isText(E))
        E.children.push(...b.children);
      else
        throw new Error('Cannot apply a "merge_node" operation at path ['.concat(w, "] to nodes of different interfaces: ").concat(yn.stringify(b), " ").concat(yn.stringify(E)));
      if (m.children.splice(O, 1), e)
        for (var [S, W] of Ie.points(e))
          e[W] = yt.transform(S, n);
      break;
    }
    case "move_node": {
      var {
        path: P,
        newPath: $
      } = n;
      if (ue.isAncestor(P, $))
        throw new Error("Cannot move a path [".concat(P, "] to new path [").concat($, "] because the destination is inside itself."));
      var j = Pe.get(t, P), _ = Pe.parent(t, P), I = P[P.length - 1];
      _.children.splice(I, 1);
      var R = ue.transform(P, n), V = Pe.get(t, ue.parent(R)), J = R[R.length - 1];
      if (V.children.splice(J, 0, j), e)
        for (var [G, te] of Ie.points(e))
          e[te] = yt.transform(G, n);
      break;
    }
    case "remove_node": {
      var {
        path: Q
      } = n, T = Q[Q.length - 1], N = Pe.parent(t, Q);
      if (N.children.splice(T, 1), e)
        for (var [Y, F] of Ie.points(e)) {
          var X = yt.transform(Y, n);
          if (e != null && X != null)
            e[F] = X;
          else {
            var L = void 0, M = void 0;
            for (var [z, A] of Pe.texts(t))
              if (ue.compare(A, Q) === -1)
                L = [z, A];
              else {
                M = [z, A];
                break;
              }
            var U = !1;
            L && M && (ue.equals(M[1], Q) ? U = !ue.hasPrevious(M[1]) : U = ue.common(L[1], Q).length < ue.common(M[1], Q).length), L && !U ? (Y.path = L[1], Y.offset = L[0].text.length) : M ? (Y.path = M[1], Y.offset = 0) : e = null;
          }
        }
      break;
    }
    case "remove_text": {
      var {
        path: H,
        offset: ee,
        text: Z
      } = n;
      if (Z.length === 0) break;
      var pe = Pe.leaf(t, H), he = pe.text.slice(0, ee), le = pe.text.slice(ee + Z.length);
      if (pe.text = he + le, e)
        for (var [Le, Fe] of Ie.points(e))
          e[Fe] = yt.transform(Le, n);
      break;
    }
    case "set_node": {
      var {
        path: Be,
        properties: Ne,
        newProperties: at
      } = n;
      if (Be.length === 0)
        throw new Error("Cannot set properties on the root node!");
      var dt = Pe.get(t, Be);
      for (var Oe in at) {
        if (Oe === "children" || Oe === "text")
          throw new Error('Cannot set the "'.concat(Oe, '" property of nodes!'));
        var ft = at[Oe];
        ft == null ? delete dt[Oe] : dt[Oe] = ft;
      }
      for (var bt in Ne)
        at.hasOwnProperty(bt) || delete dt[bt];
      break;
    }
    case "set_selection": {
      var {
        newProperties: De
      } = n;
      if (De == null)
        e = De;
      else {
        if (e == null) {
          if (!Ie.isRange(De))
            throw new Error('Cannot apply an incomplete "set_selection" operation properties '.concat(yn.stringify(De), " when there is no current selection."));
          e = Oo({}, De);
        }
        for (var ke in De) {
          var Ke = De[ke];
          if (Ke == null) {
            if (ke === "anchor" || ke === "focus")
              throw new Error('Cannot remove the "'.concat(ke, '" selection property'));
            delete e[ke];
          } else
            e[ke] = Ke;
        }
      }
      break;
    }
    case "split_node": {
      var {
        path: Je,
        position: Qe,
        properties: Bt
      } = n;
      if (Je.length === 0)
        throw new Error('Cannot apply a "split_node" operation at path ['.concat(Je, "] because the root node cannot be split."));
      var He = Pe.get(t, Je), Yt = Pe.parent(t, Je), Ft = Je[Je.length - 1], It;
      if (Tt.isText(He)) {
        var Wt = He.text.slice(0, Qe), fn = He.text.slice(Qe);
        He.text = Wt, It = Oo(Oo({}, Bt), {}, {
          text: fn
        });
      } else {
        var Ht = He.children.slice(0, Qe), pn = He.children.slice(Qe);
        He.children = Ht, It = Oo(Oo({}, Bt), {}, {
          children: pn
        });
      }
      if (Yt.children.splice(Ft + 1, 0, It), e)
        for (var [_t, Xt] of Ie.points(e))
          e[Xt] = yt.transform(_t, n);
      break;
    }
  }
  return e;
}, yO = {
  transform(t, e) {
    t.children = jf(t.children);
    var n = t.selection && jf(t.selection);
    try {
      n = mO(t, n, e);
    } finally {
      t.children = Ff(t.children), n ? t.selection = Yr(n) ? Ff(n) : n : t.selection = null;
    }
  }
}, bO = {
  insertNodes(t, e, n) {
    t.insertNodes(e, n);
  },
  liftNodes(t, e) {
    t.liftNodes(e);
  },
  mergeNodes(t, e) {
    t.mergeNodes(e);
  },
  moveNodes(t, e) {
    t.moveNodes(e);
  },
  removeNodes(t, e) {
    t.removeNodes(e);
  },
  setNodes(t, e, n) {
    t.setNodes(e, n);
  },
  splitNodes(t, e) {
    t.splitNodes(e);
  },
  unsetNodes(t, e, n) {
    t.unsetNodes(e, n);
  },
  unwrapNodes(t, e) {
    t.unwrapNodes(e);
  },
  wrapNodes(t, e, n) {
    t.wrapNodes(e, n);
  }
}, CO = {
  collapse(t, e) {
    t.collapse(e);
  },
  deselect(t) {
    t.deselect();
  },
  move(t, e) {
    t.move(e);
  },
  select(t, e) {
    t.select(e);
  },
  setPoint(t, e, n) {
    t.setPoint(e, n);
  },
  setSelection(t, e) {
    t.setSelection(e);
  }
}, Vy = (t, e) => {
  for (var n in t) {
    var r = t[n], o = e[n];
    if (Kt(r) && Kt(o)) {
      if (!Vy(r, o)) return !1;
    } else if (Array.isArray(r) && Array.isArray(o)) {
      if (r.length !== o.length) return !1;
      for (var i = 0; i < r.length; i++)
        if (r[i] !== o[i]) return !1;
    } else if (r !== o)
      return !1;
  }
  for (var a in e)
    if (t[a] === void 0 && e[a] !== void 0)
      return !1;
  return !0;
};
function wO(t, e) {
  if (t == null) return {};
  var n = {}, r = Object.keys(t), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(e.indexOf(o) >= 0) && (n[o] = t[o]);
  return n;
}
function ei(t, e) {
  if (t == null) return {};
  var n = wO(t, e), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    for (o = 0; o < i.length; o++)
      r = i[o], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]);
  }
  return n;
}
var EO = ["anchor", "focus"];
function If(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function DO(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? If(Object(n), !0).forEach(function(r) {
      po(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : If(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Ie = {
  edges(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      reverse: n = !1
    } = e, {
      anchor: r,
      focus: o
    } = t;
    return Ie.isBackward(t) === n ? [r, o] : [o, r];
  },
  end(t) {
    var [, e] = Ie.edges(t);
    return e;
  },
  equals(t, e) {
    return yt.equals(t.anchor, e.anchor) && yt.equals(t.focus, e.focus);
  },
  includes(t, e) {
    if (Ie.isRange(e)) {
      if (Ie.includes(t, e.anchor) || Ie.includes(t, e.focus))
        return !0;
      var [n, r] = Ie.edges(t), [o, i] = Ie.edges(e);
      return yt.isBefore(n, o) && yt.isAfter(r, i);
    }
    var [a, s] = Ie.edges(t), l = !1, u = !1;
    return yt.isPoint(e) ? (l = yt.compare(e, a) >= 0, u = yt.compare(e, s) <= 0) : (l = ue.compare(e, a.path) >= 0, u = ue.compare(e, s.path) <= 0), l && u;
  },
  intersection(t, e) {
    var n = ei(t, EO), [r, o] = Ie.edges(t), [i, a] = Ie.edges(e), s = yt.isBefore(r, i) ? i : r, l = yt.isBefore(o, a) ? o : a;
    return yt.isBefore(l, s) ? null : DO({
      anchor: s,
      focus: l
    }, n);
  },
  isBackward(t) {
    var {
      anchor: e,
      focus: n
    } = t;
    return yt.isAfter(e, n);
  },
  isCollapsed(t) {
    var {
      anchor: e,
      focus: n
    } = t;
    return yt.equals(e, n);
  },
  isExpanded(t) {
    return !Ie.isCollapsed(t);
  },
  isForward(t) {
    return !Ie.isBackward(t);
  },
  isRange(t) {
    return Kt(t) && yt.isPoint(t.anchor) && yt.isPoint(t.focus);
  },
  *points(t) {
    yield [t.anchor, "anchor"], yield [t.focus, "focus"];
  },
  start(t) {
    var [e] = Ie.edges(t);
    return e;
  },
  transform(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Dc(t, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "inward"
      } = n, i, a;
      if (o === "inward") {
        var s = Ie.isCollapsed(r);
        Ie.isForward(r) ? (i = "forward", a = s ? i : "backward") : (i = "backward", a = s ? i : "forward");
      } else o === "outward" ? Ie.isForward(r) ? (i = "backward", a = "forward") : (i = "forward", a = "backward") : (i = o, a = o);
      var l = yt.transform(r.anchor, e, {
        affinity: i
      }), u = yt.transform(r.focus, e, {
        affinity: a
      });
      if (!l || !u)
        return null;
      r.anchor = l, r.focus = u;
    });
  }
}, Rf = (t) => Kt(t) && Pe.isNodeList(t.children) && !pt.isEditor(t), Yn = {
  isAncestor(t) {
    return Kt(t) && Pe.isNodeList(t.children);
  },
  isElement: Rf,
  isElementList(t) {
    return Array.isArray(t) && t.every((e) => Yn.isElement(e));
  },
  isElementProps(t) {
    return t.children !== void 0;
  },
  isElementType: function(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "type";
    return Rf(t) && t[n] === e;
  },
  matches(t, e) {
    for (var n in e)
      if (n !== "children" && t[n] !== e[n])
        return !1;
    return !0;
  }
}, OO = ["children"], xO = ["text"], Nf = /* @__PURE__ */ new WeakMap(), Pe = {
  ancestor(t, e) {
    var n = Pe.get(t, e);
    if (Tt.isText(n))
      throw new Error("Cannot get the ancestor node at path [".concat(e, "] because it refers to a text node instead: ").concat(yn.stringify(n)));
    return n;
  },
  ancestors(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ue.ancestors(e, n)) {
        var o = Pe.ancestor(t, r), i = [o, r];
        yield i;
      }
    }();
  },
  child(t, e) {
    if (Tt.isText(t))
      throw new Error("Cannot get the child of a text node: ".concat(yn.stringify(t)));
    var n = t.children[e];
    if (n == null)
      throw new Error("Cannot get child at index `".concat(e, "` in node: ").concat(yn.stringify(t)));
    return n;
  },
  children(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var {
        reverse: r = !1
      } = n, o = Pe.ancestor(t, e), {
        children: i
      } = o, a = r ? i.length - 1 : 0; r ? a >= 0 : a < i.length; ) {
        var s = Pe.child(o, a), l = e.concat(a);
        yield [s, l], a = r ? a - 1 : a + 1;
      }
    }();
  },
  common(t, e, n) {
    var r = ue.common(e, n), o = Pe.get(t, r);
    return [o, r];
  },
  descendant(t, e) {
    var n = Pe.get(t, e);
    if (pt.isEditor(n))
      throw new Error("Cannot get the descendant node at path [".concat(e, "] because it refers to the root editor node instead: ").concat(yn.stringify(n)));
    return n;
  },
  descendants(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Pe.nodes(t, e))
        r.length !== 0 && (yield [n, r]);
    }();
  },
  elements(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Pe.nodes(t, e))
        Yn.isElement(n) && (yield [n, r]);
    }();
  },
  extractProps(t) {
    if (Yn.isAncestor(t)) {
      var e = ei(t, OO);
      return e;
    } else {
      var e = ei(t, xO);
      return e;
    }
  },
  first(t, e) {
    for (var n = e.slice(), r = Pe.get(t, n); r && !(Tt.isText(r) || r.children.length === 0); )
      r = r.children[0], n.push(0);
    return [r, n];
  },
  fragment(t, e) {
    if (Tt.isText(t))
      throw new Error("Cannot get a fragment starting from a root text node: ".concat(yn.stringify(t)));
    var n = Dc({
      children: t.children
    }, (r) => {
      var [o, i] = Ie.edges(e), a = Pe.nodes(r, {
        reverse: !0,
        pass: (f) => {
          var [, v] = f;
          return !Ie.includes(e, v);
        }
      });
      for (var [, s] of a) {
        if (!Ie.includes(e, s)) {
          var l = Pe.parent(r, s), u = s[s.length - 1];
          l.children.splice(u, 1);
        }
        if (ue.equals(s, i.path)) {
          var c = Pe.leaf(r, s);
          c.text = c.text.slice(0, i.offset);
        }
        if (ue.equals(s, o.path)) {
          var d = Pe.leaf(r, s);
          d.text = d.text.slice(o.offset);
        }
      }
      pt.isEditor(r) && (r.selection = null);
    });
    return n.children;
  },
  get(t, e) {
    for (var n = t, r = 0; r < e.length; r++) {
      var o = e[r];
      if (Tt.isText(n) || !n.children[o])
        throw new Error("Cannot find a descendant at path [".concat(e, "] in node: ").concat(yn.stringify(t)));
      n = n.children[o];
    }
    return n;
  },
  has(t, e) {
    for (var n = t, r = 0; r < e.length; r++) {
      var o = e[r];
      if (Tt.isText(n) || !n.children[o])
        return !1;
      n = n.children[o];
    }
    return !0;
  },
  isNode(t) {
    return Tt.isText(t) || Yn.isElement(t) || pt.isEditor(t);
  },
  isNodeList(t) {
    if (!Array.isArray(t))
      return !1;
    var e = Nf.get(t);
    if (e !== void 0)
      return e;
    var n = t.every((r) => Pe.isNode(r));
    return Nf.set(t, n), n;
  },
  last(t, e) {
    for (var n = e.slice(), r = Pe.get(t, n); r && !(Tt.isText(r) || r.children.length === 0); ) {
      var o = r.children.length - 1;
      r = r.children[o], n.push(o);
    }
    return [r, n];
  },
  leaf(t, e) {
    var n = Pe.get(t, e);
    if (!Tt.isText(n))
      throw new Error("Cannot get the leaf node at path [".concat(e, "] because it refers to a non-leaf node: ").concat(yn.stringify(n)));
    return n;
  },
  levels(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return function* () {
      for (var r of ue.levels(e, n)) {
        var o = Pe.get(t, r);
        yield [o, r];
      }
    }();
  },
  matches(t, e) {
    return Yn.isElement(t) && Yn.isElementProps(e) && Yn.matches(t, e) || Tt.isText(t) && Tt.isTextProps(e) && Tt.matches(t, e);
  },
  nodes(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var {
        pass: n,
        reverse: r = !1
      } = e, {
        from: o = [],
        to: i
      } = e, a = /* @__PURE__ */ new Set(), s = [], l = t; !(i && (r ? ue.isBefore(s, i) : ue.isAfter(s, i))); ) {
        if (a.has(l) || (yield [l, s]), !a.has(l) && !Tt.isText(l) && l.children.length !== 0 && (n == null || n([l, s]) === !1)) {
          a.add(l);
          var u = r ? l.children.length - 1 : 0;
          ue.isAncestor(s, o) && (u = o[s.length]), s = s.concat(u), l = Pe.get(t, s);
          continue;
        }
        if (s.length === 0)
          break;
        if (!r) {
          var c = ue.next(s);
          if (Pe.has(t, c)) {
            s = c, l = Pe.get(t, s);
            continue;
          }
        }
        if (r && s[s.length - 1] !== 0) {
          var d = ue.previous(s);
          s = d, l = Pe.get(t, s);
          continue;
        }
        s = ue.parent(s), l = Pe.get(t, s), a.add(l);
      }
    }();
  },
  parent(t, e) {
    var n = ue.parent(e), r = Pe.get(t, n);
    if (Tt.isText(r))
      throw new Error("Cannot get the parent of path [".concat(e, "] because it does not exist in the root."));
    return r;
  },
  string(t) {
    return Tt.isText(t) ? t.text : t.children.map(Pe.string).join("");
  },
  texts(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return function* () {
      for (var [n, r] of Pe.nodes(t, e))
        Tt.isText(n) && (yield [n, r]);
    }();
  }
};
function $f(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function wt(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? $f(Object(n), !0).forEach(function(r) {
      po(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : $f(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var jo = {
  isNodeOperation(t) {
    return jo.isOperation(t) && t.type.endsWith("_node");
  },
  isOperation(t) {
    if (!Kt(t))
      return !1;
    switch (t.type) {
      case "insert_node":
        return ue.isPath(t.path) && Pe.isNode(t.node);
      case "insert_text":
        return typeof t.offset == "number" && typeof t.text == "string" && ue.isPath(t.path);
      case "merge_node":
        return typeof t.position == "number" && ue.isPath(t.path) && Kt(t.properties);
      case "move_node":
        return ue.isPath(t.path) && ue.isPath(t.newPath);
      case "remove_node":
        return ue.isPath(t.path) && Pe.isNode(t.node);
      case "remove_text":
        return typeof t.offset == "number" && typeof t.text == "string" && ue.isPath(t.path);
      case "set_node":
        return ue.isPath(t.path) && Kt(t.properties) && Kt(t.newProperties);
      case "set_selection":
        return t.properties === null && Ie.isRange(t.newProperties) || t.newProperties === null && Ie.isRange(t.properties) || Kt(t.properties) && Kt(t.newProperties);
      case "split_node":
        return ue.isPath(t.path) && typeof t.position == "number" && Kt(t.properties);
      default:
        return !1;
    }
  },
  isOperationList(t) {
    return Array.isArray(t) && t.every((e) => jo.isOperation(e));
  },
  isSelectionOperation(t) {
    return jo.isOperation(t) && t.type.endsWith("_selection");
  },
  isTextOperation(t) {
    return jo.isOperation(t) && t.type.endsWith("_text");
  },
  inverse(t) {
    switch (t.type) {
      case "insert_node":
        return wt(wt({}, t), {}, {
          type: "remove_node"
        });
      case "insert_text":
        return wt(wt({}, t), {}, {
          type: "remove_text"
        });
      case "merge_node":
        return wt(wt({}, t), {}, {
          type: "split_node",
          path: ue.previous(t.path)
        });
      case "move_node": {
        var {
          newPath: e,
          path: n
        } = t;
        if (ue.equals(e, n))
          return t;
        if (ue.isSibling(n, e))
          return wt(wt({}, t), {}, {
            path: e,
            newPath: n
          });
        var r = ue.transform(n, t), o = ue.transform(ue.next(n), t);
        return wt(wt({}, t), {}, {
          path: r,
          newPath: o
        });
      }
      case "remove_node":
        return wt(wt({}, t), {}, {
          type: "insert_node"
        });
      case "remove_text":
        return wt(wt({}, t), {}, {
          type: "insert_text"
        });
      case "set_node": {
        var {
          properties: i,
          newProperties: a
        } = t;
        return wt(wt({}, t), {}, {
          properties: a,
          newProperties: i
        });
      }
      case "set_selection": {
        var {
          properties: s,
          newProperties: l
        } = t;
        return s == null ? wt(wt({}, t), {}, {
          properties: l,
          newProperties: null
        }) : l == null ? wt(wt({}, t), {}, {
          properties: null,
          newProperties: s
        }) : wt(wt({}, t), {}, {
          properties: l,
          newProperties: s
        });
      }
      case "split_node":
        return wt(wt({}, t), {}, {
          type: "merge_node",
          path: ue.next(t.path)
        });
    }
  }
}, zf = /* @__PURE__ */ new WeakMap(), LO = (t) => {
  var e = zf.get(t);
  if (e !== void 0)
    return e;
  if (!Kt(t))
    return !1;
  var n = typeof t.addMark == "function" && typeof t.apply == "function" && typeof t.deleteFragment == "function" && typeof t.insertBreak == "function" && typeof t.insertSoftBreak == "function" && typeof t.insertFragment == "function" && typeof t.insertNode == "function" && typeof t.insertText == "function" && typeof t.isElementReadOnly == "function" && typeof t.isInline == "function" && typeof t.isSelectable == "function" && typeof t.isVoid == "function" && typeof t.normalizeNode == "function" && typeof t.onChange == "function" && typeof t.removeMark == "function" && typeof t.getDirtyPaths == "function" && (t.marks === null || Kt(t.marks)) && (t.selection === null || Ie.isRange(t.selection)) && Pe.isNodeList(t.children) && jo.isOperationList(t.operations);
  return zf.set(t, n), n;
}, pt = {
  above(t, e) {
    return t.above(e);
  },
  addMark(t, e, n) {
    t.addMark(e, n);
  },
  after(t, e, n) {
    return t.after(e, n);
  },
  before(t, e, n) {
    return t.before(e, n);
  },
  deleteBackward(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = e;
    t.deleteBackward(n);
  },
  deleteForward(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, {
      unit: n = "character"
    } = e;
    t.deleteForward(n);
  },
  deleteFragment(t, e) {
    t.deleteFragment(e);
  },
  edges(t, e) {
    return t.edges(e);
  },
  elementReadOnly(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    return t.elementReadOnly(e);
  },
  end(t, e) {
    return t.end(e);
  },
  first(t, e) {
    return t.first(e);
  },
  fragment(t, e) {
    return t.fragment(e);
  },
  hasBlocks(t, e) {
    return t.hasBlocks(e);
  },
  hasInlines(t, e) {
    return t.hasInlines(e);
  },
  hasPath(t, e) {
    return t.hasPath(e);
  },
  hasTexts(t, e) {
    return t.hasTexts(e);
  },
  insertBreak(t) {
    t.insertBreak();
  },
  insertFragment(t, e, n) {
    t.insertFragment(e, n);
  },
  insertNode(t, e) {
    t.insertNode(e);
  },
  insertSoftBreak(t) {
    t.insertSoftBreak();
  },
  insertText(t, e) {
    t.insertText(e);
  },
  isBlock(t, e) {
    return t.isBlock(e);
  },
  isEdge(t, e, n) {
    return t.isEdge(e, n);
  },
  isEditor(t) {
    return LO(t);
  },
  isElementReadOnly(t, e) {
    return t.isElementReadOnly(e);
  },
  isEmpty(t, e) {
    return t.isEmpty(e);
  },
  isEnd(t, e, n) {
    return t.isEnd(e, n);
  },
  isInline(t, e) {
    return t.isInline(e);
  },
  isNormalizing(t) {
    return t.isNormalizing();
  },
  isSelectable(t, e) {
    return t.isSelectable(e);
  },
  isStart(t, e, n) {
    return t.isStart(e, n);
  },
  isVoid(t, e) {
    return t.isVoid(e);
  },
  last(t, e) {
    return t.last(e);
  },
  leaf(t, e, n) {
    return t.leaf(e, n);
  },
  levels(t, e) {
    return t.levels(e);
  },
  marks(t) {
    return t.getMarks();
  },
  next(t, e) {
    return t.next(e);
  },
  node(t, e, n) {
    return t.node(e, n);
  },
  nodes(t, e) {
    return t.nodes(e);
  },
  normalize(t, e) {
    t.normalize(e);
  },
  parent(t, e, n) {
    return t.parent(e, n);
  },
  path(t, e, n) {
    return t.path(e, n);
  },
  pathRef(t, e, n) {
    return t.pathRef(e, n);
  },
  pathRefs(t) {
    return t.pathRefs();
  },
  point(t, e, n) {
    return t.point(e, n);
  },
  pointRef(t, e, n) {
    return t.pointRef(e, n);
  },
  pointRefs(t) {
    return t.pointRefs();
  },
  positions(t, e) {
    return t.positions(e);
  },
  previous(t, e) {
    return t.previous(e);
  },
  range(t, e, n) {
    return t.range(e, n);
  },
  rangeRef(t, e, n) {
    return t.rangeRef(e, n);
  },
  rangeRefs(t) {
    return t.rangeRefs();
  },
  removeMark(t, e) {
    t.removeMark(e);
  },
  setNormalizing(t, e) {
    t.setNormalizing(e);
  },
  start(t, e) {
    return t.start(e);
  },
  string(t, e, n) {
    return t.string(e, n);
  },
  unhangRange(t, e, n) {
    return t.unhangRange(e, n);
  },
  void(t, e) {
    return t.void(e);
  },
  withoutNormalizing(t, e) {
    t.withoutNormalizing(e);
  },
  shouldMergeNodesRemovePrevNode: (t, e, n) => t.shouldMergeNodesRemovePrevNode(e, n)
};
function Uf(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Wf(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Uf(Object(n), !0).forEach(function(r) {
      po(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Uf(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var yt = {
  compare(t, e) {
    var n = ue.compare(t.path, e.path);
    return n === 0 ? t.offset < e.offset ? -1 : t.offset > e.offset ? 1 : 0 : n;
  },
  isAfter(t, e) {
    return yt.compare(t, e) === 1;
  },
  isBefore(t, e) {
    return yt.compare(t, e) === -1;
  },
  equals(t, e) {
    return t.offset === e.offset && ue.equals(t.path, e.path);
  },
  isPoint(t) {
    return Kt(t) && typeof t.offset == "number" && ue.isPath(t.path);
  },
  transform(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    return Dc(t, (r) => {
      if (r === null)
        return null;
      var {
        affinity: o = "forward"
      } = n, {
        path: i,
        offset: a
      } = r;
      switch (e.type) {
        case "insert_node":
        case "move_node": {
          r.path = ue.transform(i, e, n);
          break;
        }
        case "insert_text": {
          ue.equals(e.path, i) && (e.offset < a || e.offset === a && o === "forward") && (r.offset += e.text.length);
          break;
        }
        case "merge_node": {
          ue.equals(e.path, i) && (r.offset += e.position), r.path = ue.transform(i, e, n);
          break;
        }
        case "remove_text": {
          ue.equals(e.path, i) && e.offset <= a && (r.offset -= Math.min(a - e.offset, e.text.length));
          break;
        }
        case "remove_node": {
          if (ue.equals(e.path, i) || ue.isAncestor(e.path, i))
            return null;
          r.path = ue.transform(i, e, n);
          break;
        }
        case "split_node": {
          if (ue.equals(e.path, i)) {
            if (e.position === a && o == null)
              return null;
            (e.position < a || e.position === a && o === "forward") && (r.offset -= e.position, r.path = ue.transform(i, e, Wf(Wf({}, n), {}, {
              affinity: "forward"
            })));
          } else
            r.path = ue.transform(i, e, n);
          break;
        }
      }
    });
  }
}, Hf = void 0, yn = {
  setScrubber(t) {
    Hf = t;
  },
  stringify(t) {
    return JSON.stringify(t, Hf);
  }
}, SO = ["text"], PO = ["anchor", "focus"];
function Vf(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Gn(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Vf(Object(n), !0).forEach(function(r) {
      po(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Vf(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Tt = {
  equals(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      loose: r = !1
    } = n;
    function o(i) {
      var a = ei(i, SO);
      return a;
    }
    return Vy(r ? o(t) : t, r ? o(e) : e);
  },
  isText(t) {
    return Kt(t) && typeof t.text == "string";
  },
  isTextList(t) {
    return Array.isArray(t) && t.every((e) => Tt.isText(e));
  },
  isTextProps(t) {
    return t.text !== void 0;
  },
  matches(t, e) {
    for (var n in e)
      if (n !== "text" && (!t.hasOwnProperty(n) || t[n] !== e[n]))
        return !1;
    return !0;
  },
  decorations(t, e) {
    var n = [Gn({}, t)];
    for (var r of e) {
      var o = ei(r, PO), [i, a] = Ie.edges(r), s = [], l = 0, u = i.offset, c = a.offset;
      for (var d of n) {
        var {
          length: f
        } = d.text, v = l;
        if (l += f, u <= v && l <= c) {
          Object.assign(d, o), s.push(d);
          continue;
        }
        if (u !== c && (u === l || c === v) || u > l || c < v || c === v && v !== 0) {
          s.push(d);
          continue;
        }
        var h = d, g = void 0, p = void 0;
        if (c < l) {
          var w = c - v;
          p = Gn(Gn({}, h), {}, {
            text: h.text.slice(w)
          }), h = Gn(Gn({}, h), {}, {
            text: h.text.slice(0, w)
          });
        }
        if (u > v) {
          var b = u - v;
          g = Gn(Gn({}, h), {}, {
            text: h.text.slice(0, b)
          }), h = Gn(Gn({}, h), {}, {
            text: h.text.slice(b)
          });
        }
        Object.assign(h, o), g && s.push(g), s.push(h), p && s.push(p);
      }
      n = s;
    }
    return n;
  }
}, kO = (t) => t.selection ? t.selection : t.children.length > 0 ? pt.end(t, []) : [0], mt;
(function(t) {
  t[t.None = 0] = "None", t[t.Extend = 1] = "Extend", t[t.ZWJ = 2] = "ZWJ", t[t.RI = 4] = "RI", t[t.Prepend = 8] = "Prepend", t[t.SpacingMark = 16] = "SpacingMark", t[t.L = 32] = "L", t[t.V = 64] = "V", t[t.T = 128] = "T", t[t.LV = 256] = "LV", t[t.LVT = 512] = "LVT", t[t.ExtPict = 1024] = "ExtPict", t[t.Any = 2048] = "Any";
})(mt || (mt = {}));
mt.L, mt.L | mt.V | mt.LV | mt.LVT, mt.LV | mt.V, mt.V | mt.T, mt.LVT | mt.T, mt.T, mt.Any, mt.Extend | mt.ZWJ, mt.Any, mt.SpacingMark, mt.Prepend, mt.Any, mt.ZWJ, mt.ExtPict, mt.RI, mt.RI;
var MO = {
  delete(t, e) {
    t.delete(e);
  },
  insertFragment(t, e, n) {
    t.insertFragment(e, n);
  },
  insertText(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    pt.withoutNormalizing(t, () => {
      var {
        voids: r = !1
      } = n, {
        at: o = kO(t)
      } = n;
      if (ue.isPath(o) && (o = pt.range(t, o)), Ie.isRange(o))
        if (Ie.isCollapsed(o))
          o = o.anchor;
        else {
          var i = Ie.end(o);
          if (!r && pt.void(t, {
            at: i
          }))
            return;
          var a = Ie.start(o), s = pt.pointRef(t, a), l = pt.pointRef(t, i);
          Pa.delete(t, {
            at: o,
            voids: r
          });
          var u = s.unref(), c = l.unref();
          o = u || c, Pa.setSelection(t, {
            anchor: o,
            focus: o
          });
        }
      if (!(!r && pt.void(t, {
        at: o
      }) || pt.elementReadOnly(t, {
        at: o
      }))) {
        var {
          path: d,
          offset: f
        } = o;
        e.length > 0 && t.apply({
          type: "insert_text",
          path: d,
          offset: f,
          text: e
        });
      }
    });
  }
};
function qf(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ki(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? qf(Object(n), !0).forEach(function(r) {
      po(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : qf(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Pa = ki(ki(ki(ki({}, yO), bO), CO), MO), qy = {}, Oc = {}, xc = {};
Object.defineProperty(xc, "__esModule", { value: !0 });
xc.default = jO;
var Gf = "html", Zf = "head", Mi = "body", BO = /<([a-zA-Z]+[0-9]?)/, Kf = /<head[^]*>/i, Yf = /<body[^]*>/i, ka = function(t, e) {
  throw new Error("This browser does not support `document.implementation.createHTMLDocument`");
}, Eu = function(t, e) {
  throw new Error("This browser does not support `DOMParser.prototype.parseFromString`");
}, Xf = typeof window == "object" && window.DOMParser;
if (typeof Xf == "function") {
  var TO = new Xf(), AO = "text/html";
  Eu = function(t, e) {
    return e && (t = "<".concat(e, ">").concat(t, "</").concat(e, ">")), TO.parseFromString(t, AO);
  }, ka = Eu;
}
if (typeof document == "object" && document.implementation) {
  var Bi = document.implementation.createHTMLDocument();
  ka = function(t, e) {
    if (e) {
      var n = Bi.documentElement.querySelector(e);
      return n && (n.innerHTML = t), Bi;
    }
    return Bi.documentElement.innerHTML = t, Bi;
  };
}
var Ti = typeof document == "object" && document.createElement("template"), Du;
Ti && Ti.content && (Du = function(t) {
  return Ti.innerHTML = t, Ti.content.childNodes;
});
function jO(t) {
  var e, n, r = t.match(BO), o = r && r[1] ? r[1].toLowerCase() : "";
  switch (o) {
    case Gf: {
      var i = Eu(t);
      if (!Kf.test(t)) {
        var a = i.querySelector(Zf);
        (e = a == null ? void 0 : a.parentNode) === null || e === void 0 || e.removeChild(a);
      }
      if (!Yf.test(t)) {
        var a = i.querySelector(Mi);
        (n = a == null ? void 0 : a.parentNode) === null || n === void 0 || n.removeChild(a);
      }
      return i.querySelectorAll(Gf);
    }
    case Zf:
    case Mi: {
      var s = ka(t).querySelectorAll(o);
      return Yf.test(t) && Kf.test(t) ? s[0].parentNode.childNodes : s;
    }
    default: {
      if (Du)
        return Du(t);
      var a = ka(t, Mi).querySelector(Mi);
      return a.childNodes;
    }
  }
}
var ws = {}, Lc = {}, Sc = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.Doctype = t.CDATA = t.Tag = t.Style = t.Script = t.Comment = t.Directive = t.Text = t.Root = t.isTag = t.ElementType = void 0;
  var e;
  (function(r) {
    r.Root = "root", r.Text = "text", r.Directive = "directive", r.Comment = "comment", r.Script = "script", r.Style = "style", r.Tag = "tag", r.CDATA = "cdata", r.Doctype = "doctype";
  })(e = t.ElementType || (t.ElementType = {}));
  function n(r) {
    return r.type === e.Tag || r.type === e.Script || r.type === e.Style;
  }
  t.isTag = n, t.Root = e.Root, t.Text = e.Text, t.Directive = e.Directive, t.Comment = e.Comment, t.Script = e.Script, t.Style = e.Style, t.Tag = e.Tag, t.CDATA = e.CDATA, t.Doctype = e.Doctype;
})(Sc);
var Ue = {}, Or = gt && gt.__extends || /* @__PURE__ */ function() {
  var t = function(e, n) {
    return t = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(r, o) {
      r.__proto__ = o;
    } || function(r, o) {
      for (var i in o) Object.prototype.hasOwnProperty.call(o, i) && (r[i] = o[i]);
    }, t(e, n);
  };
  return function(e, n) {
    if (typeof n != "function" && n !== null)
      throw new TypeError("Class extends value " + String(n) + " is not a constructor or null");
    t(e, n);
    function r() {
      this.constructor = e;
    }
    e.prototype = n === null ? Object.create(n) : (r.prototype = n.prototype, new r());
  };
}(), No = gt && gt.__assign || function() {
  return No = Object.assign || function(t) {
    for (var e, n = 1, r = arguments.length; n < r; n++) {
      e = arguments[n];
      for (var o in e) Object.prototype.hasOwnProperty.call(e, o) && (t[o] = e[o]);
    }
    return t;
  }, No.apply(this, arguments);
};
Object.defineProperty(Ue, "__esModule", { value: !0 });
Ue.cloneNode = Ue.hasChildren = Ue.isDocument = Ue.isDirective = Ue.isComment = Ue.isText = Ue.isCDATA = Ue.isTag = Ue.Element = Ue.Document = Ue.CDATA = Ue.NodeWithChildren = Ue.ProcessingInstruction = Ue.Comment = Ue.Text = Ue.DataNode = Ue.Node = void 0;
var cn = Sc, Pc = (
  /** @class */
  function() {
    function t() {
      this.parent = null, this.prev = null, this.next = null, this.startIndex = null, this.endIndex = null;
    }
    return Object.defineProperty(t.prototype, "parentNode", {
      // Read-write aliases for properties
      /**
       * Same as {@link parent}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.parent;
      },
      set: function(e) {
        this.parent = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "previousSibling", {
      /**
       * Same as {@link prev}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.prev;
      },
      set: function(e) {
        this.prev = e;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(t.prototype, "nextSibling", {
      /**
       * Same as {@link next}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.next;
      },
      set: function(e) {
        this.next = e;
      },
      enumerable: !1,
      configurable: !0
    }), t.prototype.cloneNode = function(e) {
      return e === void 0 && (e = !1), kc(this, e);
    }, t;
  }()
);
Ue.Node = Pc;
var Es = (
  /** @class */
  function(t) {
    Or(e, t);
    function e(n) {
      var r = t.call(this) || this;
      return r.data = n, r;
    }
    return Object.defineProperty(e.prototype, "nodeValue", {
      /**
       * Same as {@link data}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.data;
      },
      set: function(n) {
        this.data = n;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Pc)
);
Ue.DataNode = Es;
var Gy = (
  /** @class */
  function(t) {
    Or(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = cn.ElementType.Text, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 3;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Es)
);
Ue.Text = Gy;
var Zy = (
  /** @class */
  function(t) {
    Or(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = cn.ElementType.Comment, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 8;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Es)
);
Ue.Comment = Zy;
var Ky = (
  /** @class */
  function(t) {
    Or(e, t);
    function e(n, r) {
      var o = t.call(this, r) || this;
      return o.name = n, o.type = cn.ElementType.Directive, o;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Es)
);
Ue.ProcessingInstruction = Ky;
var Ds = (
  /** @class */
  function(t) {
    Or(e, t);
    function e(n) {
      var r = t.call(this) || this;
      return r.children = n, r;
    }
    return Object.defineProperty(e.prototype, "firstChild", {
      // Aliases
      /** First child of the node. */
      get: function() {
        var n;
        return (n = this.children[0]) !== null && n !== void 0 ? n : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "lastChild", {
      /** Last child of the node. */
      get: function() {
        return this.children.length > 0 ? this.children[this.children.length - 1] : null;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "childNodes", {
      /**
       * Same as {@link children}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.children;
      },
      set: function(n) {
        this.children = n;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Pc)
);
Ue.NodeWithChildren = Ds;
var Yy = (
  /** @class */
  function(t) {
    Or(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = cn.ElementType.CDATA, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 4;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Ds)
);
Ue.CDATA = Yy;
var Xy = (
  /** @class */
  function(t) {
    Or(e, t);
    function e() {
      var n = t !== null && t.apply(this, arguments) || this;
      return n.type = cn.ElementType.Root, n;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 9;
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Ds)
);
Ue.Document = Xy;
var Jy = (
  /** @class */
  function(t) {
    Or(e, t);
    function e(n, r, o, i) {
      o === void 0 && (o = []), i === void 0 && (i = n === "script" ? cn.ElementType.Script : n === "style" ? cn.ElementType.Style : cn.ElementType.Tag);
      var a = t.call(this, o) || this;
      return a.name = n, a.attribs = r, a.type = i, a;
    }
    return Object.defineProperty(e.prototype, "nodeType", {
      get: function() {
        return 1;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "tagName", {
      // DOM Level 1 aliases
      /**
       * Same as {@link name}.
       * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
       */
      get: function() {
        return this.name;
      },
      set: function(n) {
        this.name = n;
      },
      enumerable: !1,
      configurable: !0
    }), Object.defineProperty(e.prototype, "attributes", {
      get: function() {
        var n = this;
        return Object.keys(this.attribs).map(function(r) {
          var o, i;
          return {
            name: r,
            value: n.attribs[r],
            namespace: (o = n["x-attribsNamespace"]) === null || o === void 0 ? void 0 : o[r],
            prefix: (i = n["x-attribsPrefix"]) === null || i === void 0 ? void 0 : i[r]
          };
        });
      },
      enumerable: !1,
      configurable: !0
    }), e;
  }(Ds)
);
Ue.Element = Jy;
function Qy(t) {
  return (0, cn.isTag)(t);
}
Ue.isTag = Qy;
function eb(t) {
  return t.type === cn.ElementType.CDATA;
}
Ue.isCDATA = eb;
function tb(t) {
  return t.type === cn.ElementType.Text;
}
Ue.isText = tb;
function nb(t) {
  return t.type === cn.ElementType.Comment;
}
Ue.isComment = nb;
function rb(t) {
  return t.type === cn.ElementType.Directive;
}
Ue.isDirective = rb;
function ob(t) {
  return t.type === cn.ElementType.Root;
}
Ue.isDocument = ob;
function FO(t) {
  return Object.prototype.hasOwnProperty.call(t, "children");
}
Ue.hasChildren = FO;
function kc(t, e) {
  e === void 0 && (e = !1);
  var n;
  if (tb(t))
    n = new Gy(t.data);
  else if (nb(t))
    n = new Zy(t.data);
  else if (Qy(t)) {
    var r = e ? ll(t.children) : [], o = new Jy(t.name, No({}, t.attribs), r);
    r.forEach(function(l) {
      return l.parent = o;
    }), t.namespace != null && (o.namespace = t.namespace), t["x-attribsNamespace"] && (o["x-attribsNamespace"] = No({}, t["x-attribsNamespace"])), t["x-attribsPrefix"] && (o["x-attribsPrefix"] = No({}, t["x-attribsPrefix"])), n = o;
  } else if (eb(t)) {
    var r = e ? ll(t.children) : [], i = new Yy(r);
    r.forEach(function(u) {
      return u.parent = i;
    }), n = i;
  } else if (ob(t)) {
    var r = e ? ll(t.children) : [], a = new Xy(r);
    r.forEach(function(u) {
      return u.parent = a;
    }), t["x-mode"] && (a["x-mode"] = t["x-mode"]), n = a;
  } else if (rb(t)) {
    var s = new Ky(t.name, t.data);
    t["x-name"] != null && (s["x-name"] = t["x-name"], s["x-publicId"] = t["x-publicId"], s["x-systemId"] = t["x-systemId"]), n = s;
  } else
    throw new Error("Not implemented yet: ".concat(t.type));
  return n.startIndex = t.startIndex, n.endIndex = t.endIndex, t.sourceCodeLocation != null && (n.sourceCodeLocation = t.sourceCodeLocation), n;
}
Ue.cloneNode = kc;
function ll(t) {
  for (var e = t.map(function(r) {
    return kc(r, !0);
  }), n = 1; n < e.length; n++)
    e[n].prev = e[n - 1], e[n - 1].next = e[n];
  return e;
}
(function(t) {
  var e = gt && gt.__createBinding || (Object.create ? function(s, l, u, c) {
    c === void 0 && (c = u);
    var d = Object.getOwnPropertyDescriptor(l, u);
    (!d || ("get" in d ? !l.__esModule : d.writable || d.configurable)) && (d = { enumerable: !0, get: function() {
      return l[u];
    } }), Object.defineProperty(s, c, d);
  } : function(s, l, u, c) {
    c === void 0 && (c = u), s[c] = l[u];
  }), n = gt && gt.__exportStar || function(s, l) {
    for (var u in s) u !== "default" && !Object.prototype.hasOwnProperty.call(l, u) && e(l, s, u);
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.DomHandler = void 0;
  var r = Sc, o = Ue;
  n(Ue, t);
  var i = {
    withStartIndices: !1,
    withEndIndices: !1,
    xmlMode: !1
  }, a = (
    /** @class */
    function() {
      function s(l, u, c) {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null, typeof u == "function" && (c = u, u = i), typeof l == "object" && (u = l, l = void 0), this.callback = l ?? null, this.options = u ?? i, this.elementCB = c ?? null;
      }
      return s.prototype.onparserinit = function(l) {
        this.parser = l;
      }, s.prototype.onreset = function() {
        this.dom = [], this.root = new o.Document(this.dom), this.done = !1, this.tagStack = [this.root], this.lastNode = null, this.parser = null;
      }, s.prototype.onend = function() {
        this.done || (this.done = !0, this.parser = null, this.handleCallback(null));
      }, s.prototype.onerror = function(l) {
        this.handleCallback(l);
      }, s.prototype.onclosetag = function() {
        this.lastNode = null;
        var l = this.tagStack.pop();
        this.options.withEndIndices && (l.endIndex = this.parser.endIndex), this.elementCB && this.elementCB(l);
      }, s.prototype.onopentag = function(l, u) {
        var c = this.options.xmlMode ? r.ElementType.Tag : void 0, d = new o.Element(l, u, void 0, c);
        this.addNode(d), this.tagStack.push(d);
      }, s.prototype.ontext = function(l) {
        var u = this.lastNode;
        if (u && u.type === r.ElementType.Text)
          u.data += l, this.options.withEndIndices && (u.endIndex = this.parser.endIndex);
        else {
          var c = new o.Text(l);
          this.addNode(c), this.lastNode = c;
        }
      }, s.prototype.oncomment = function(l) {
        if (this.lastNode && this.lastNode.type === r.ElementType.Comment) {
          this.lastNode.data += l;
          return;
        }
        var u = new o.Comment(l);
        this.addNode(u), this.lastNode = u;
      }, s.prototype.oncommentend = function() {
        this.lastNode = null;
      }, s.prototype.oncdatastart = function() {
        var l = new o.Text(""), u = new o.CDATA([l]);
        this.addNode(u), l.parent = u, this.lastNode = l;
      }, s.prototype.oncdataend = function() {
        this.lastNode = null;
      }, s.prototype.onprocessinginstruction = function(l, u) {
        var c = new o.ProcessingInstruction(l, u);
        this.addNode(c);
      }, s.prototype.handleCallback = function(l) {
        if (typeof this.callback == "function")
          this.callback(l, this.dom);
        else if (l)
          throw l;
      }, s.prototype.addNode = function(l) {
        var u = this.tagStack[this.tagStack.length - 1], c = u.children[u.children.length - 1];
        this.options.withStartIndices && (l.startIndex = this.parser.startIndex), this.options.withEndIndices && (l.endIndex = this.parser.endIndex), u.children.push(l), c && (l.prev = c, c.next = l), l.parent = u, this.lastNode = null;
      }, s;
    }()
  );
  t.DomHandler = a, t.default = a;
})(Lc);
var ib = {};
(function(t) {
  Object.defineProperty(t, "__esModule", { value: !0 }), t.CASE_SENSITIVE_TAG_NAMES_MAP = t.CASE_SENSITIVE_TAG_NAMES = void 0, t.CASE_SENSITIVE_TAG_NAMES = [
    "animateMotion",
    "animateTransform",
    "clipPath",
    "feBlend",
    "feColorMatrix",
    "feComponentTransfer",
    "feComposite",
    "feConvolveMatrix",
    "feDiffuseLighting",
    "feDisplacementMap",
    "feDropShadow",
    "feFlood",
    "feFuncA",
    "feFuncB",
    "feFuncG",
    "feFuncR",
    "feGaussianBlur",
    "feImage",
    "feMerge",
    "feMergeNode",
    "feMorphology",
    "feOffset",
    "fePointLight",
    "feSpecularLighting",
    "feSpotLight",
    "feTile",
    "feTurbulence",
    "foreignObject",
    "linearGradient",
    "radialGradient",
    "textPath"
  ], t.CASE_SENSITIVE_TAG_NAMES_MAP = t.CASE_SENSITIVE_TAG_NAMES.reduce(function(e, n) {
    return e[n.toLowerCase()] = n, e;
  }, {});
})(ib);
Object.defineProperty(ws, "__esModule", { value: !0 });
ws.formatAttributes = ab;
ws.formatDOM = sb;
var Ai = Lc, _O = ib;
function IO(t) {
  return _O.CASE_SENSITIVE_TAG_NAMES_MAP[t];
}
function ab(t) {
  for (var e = {}, n = 0, r = t.length; n < r; n++) {
    var o = t[n];
    e[o.name] = o.value;
  }
  return e;
}
function RO(t) {
  t = t.toLowerCase();
  var e = IO(t);
  return e || t;
}
function sb(t, e, n) {
  e === void 0 && (e = null);
  for (var r = [], o, i = 0, a = t.length; i < a; i++) {
    var s = t[i];
    switch (s.nodeType) {
      case 1: {
        var l = RO(s.nodeName);
        o = new Ai.Element(l, ab(s.attributes)), o.children = sb(
          // template children are on content
          l === "template" ? s.content.childNodes : s.childNodes,
          o
        );
        break;
      }
      case 3:
        o = new Ai.Text(s.nodeValue);
        break;
      case 8:
        o = new Ai.Comment(s.nodeValue);
        break;
      default:
        continue;
    }
    var u = r[i - 1] || null;
    u && (u.next = o), o.parent = e, o.prev = u, o.next = null, r.push(o);
  }
  return n && (o = new Ai.ProcessingInstruction(n.substring(0, n.indexOf(" ")).toLowerCase(), n), o.next = r[0] || null, o.parent = e, r.unshift(o), r[1] && (r[1].prev = r[0])), r;
}
var NO = gt && gt.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Oc, "__esModule", { value: !0 });
Oc.default = WO;
var $O = NO(xc), zO = ws, UO = /<(![a-zA-Z\s]+)>/;
function WO(t) {
  if (typeof t != "string")
    throw new TypeError("First argument must be a string");
  if (!t)
    return [];
  var e = t.match(UO), n = e ? e[1] : void 0;
  return (0, zO.formatDOM)((0, $O.default)(t), null, n);
}
var Os = {}, _n = {}, xs = {}, HO = 0;
xs.SAME = HO;
var VO = 1;
xs.CAMELCASE = VO;
xs.possibleStandardNames = {
  accept: 0,
  acceptCharset: 1,
  "accept-charset": "acceptCharset",
  accessKey: 1,
  action: 0,
  allowFullScreen: 1,
  alt: 0,
  as: 0,
  async: 0,
  autoCapitalize: 1,
  autoComplete: 1,
  autoCorrect: 1,
  autoFocus: 1,
  autoPlay: 1,
  autoSave: 1,
  capture: 0,
  cellPadding: 1,
  cellSpacing: 1,
  challenge: 0,
  charSet: 1,
  checked: 0,
  children: 0,
  cite: 0,
  class: "className",
  classID: 1,
  className: 1,
  cols: 0,
  colSpan: 1,
  content: 0,
  contentEditable: 1,
  contextMenu: 1,
  controls: 0,
  controlsList: 1,
  coords: 0,
  crossOrigin: 1,
  dangerouslySetInnerHTML: 1,
  data: 0,
  dateTime: 1,
  default: 0,
  defaultChecked: 1,
  defaultValue: 1,
  defer: 0,
  dir: 0,
  disabled: 0,
  disablePictureInPicture: 1,
  disableRemotePlayback: 1,
  download: 0,
  draggable: 0,
  encType: 1,
  enterKeyHint: 1,
  for: "htmlFor",
  form: 0,
  formMethod: 1,
  formAction: 1,
  formEncType: 1,
  formNoValidate: 1,
  formTarget: 1,
  frameBorder: 1,
  headers: 0,
  height: 0,
  hidden: 0,
  high: 0,
  href: 0,
  hrefLang: 1,
  htmlFor: 1,
  httpEquiv: 1,
  "http-equiv": "httpEquiv",
  icon: 0,
  id: 0,
  innerHTML: 1,
  inputMode: 1,
  integrity: 0,
  is: 0,
  itemID: 1,
  itemProp: 1,
  itemRef: 1,
  itemScope: 1,
  itemType: 1,
  keyParams: 1,
  keyType: 1,
  kind: 0,
  label: 0,
  lang: 0,
  list: 0,
  loop: 0,
  low: 0,
  manifest: 0,
  marginWidth: 1,
  marginHeight: 1,
  max: 0,
  maxLength: 1,
  media: 0,
  mediaGroup: 1,
  method: 0,
  min: 0,
  minLength: 1,
  multiple: 0,
  muted: 0,
  name: 0,
  noModule: 1,
  nonce: 0,
  noValidate: 1,
  open: 0,
  optimum: 0,
  pattern: 0,
  placeholder: 0,
  playsInline: 1,
  poster: 0,
  preload: 0,
  profile: 0,
  radioGroup: 1,
  readOnly: 1,
  referrerPolicy: 1,
  rel: 0,
  required: 0,
  reversed: 0,
  role: 0,
  rows: 0,
  rowSpan: 1,
  sandbox: 0,
  scope: 0,
  scoped: 0,
  scrolling: 0,
  seamless: 0,
  selected: 0,
  shape: 0,
  size: 0,
  sizes: 0,
  span: 0,
  spellCheck: 1,
  src: 0,
  srcDoc: 1,
  srcLang: 1,
  srcSet: 1,
  start: 0,
  step: 0,
  style: 0,
  summary: 0,
  tabIndex: 1,
  target: 0,
  title: 0,
  type: 0,
  useMap: 1,
  value: 0,
  width: 0,
  wmode: 0,
  wrap: 0,
  about: 0,
  accentHeight: 1,
  "accent-height": "accentHeight",
  accumulate: 0,
  additive: 0,
  alignmentBaseline: 1,
  "alignment-baseline": "alignmentBaseline",
  allowReorder: 1,
  alphabetic: 0,
  amplitude: 0,
  arabicForm: 1,
  "arabic-form": "arabicForm",
  ascent: 0,
  attributeName: 1,
  attributeType: 1,
  autoReverse: 1,
  azimuth: 0,
  baseFrequency: 1,
  baselineShift: 1,
  "baseline-shift": "baselineShift",
  baseProfile: 1,
  bbox: 0,
  begin: 0,
  bias: 0,
  by: 0,
  calcMode: 1,
  capHeight: 1,
  "cap-height": "capHeight",
  clip: 0,
  clipPath: 1,
  "clip-path": "clipPath",
  clipPathUnits: 1,
  clipRule: 1,
  "clip-rule": "clipRule",
  color: 0,
  colorInterpolation: 1,
  "color-interpolation": "colorInterpolation",
  colorInterpolationFilters: 1,
  "color-interpolation-filters": "colorInterpolationFilters",
  colorProfile: 1,
  "color-profile": "colorProfile",
  colorRendering: 1,
  "color-rendering": "colorRendering",
  contentScriptType: 1,
  contentStyleType: 1,
  cursor: 0,
  cx: 0,
  cy: 0,
  d: 0,
  datatype: 0,
  decelerate: 0,
  descent: 0,
  diffuseConstant: 1,
  direction: 0,
  display: 0,
  divisor: 0,
  dominantBaseline: 1,
  "dominant-baseline": "dominantBaseline",
  dur: 0,
  dx: 0,
  dy: 0,
  edgeMode: 1,
  elevation: 0,
  enableBackground: 1,
  "enable-background": "enableBackground",
  end: 0,
  exponent: 0,
  externalResourcesRequired: 1,
  fill: 0,
  fillOpacity: 1,
  "fill-opacity": "fillOpacity",
  fillRule: 1,
  "fill-rule": "fillRule",
  filter: 0,
  filterRes: 1,
  filterUnits: 1,
  floodOpacity: 1,
  "flood-opacity": "floodOpacity",
  floodColor: 1,
  "flood-color": "floodColor",
  focusable: 0,
  fontFamily: 1,
  "font-family": "fontFamily",
  fontSize: 1,
  "font-size": "fontSize",
  fontSizeAdjust: 1,
  "font-size-adjust": "fontSizeAdjust",
  fontStretch: 1,
  "font-stretch": "fontStretch",
  fontStyle: 1,
  "font-style": "fontStyle",
  fontVariant: 1,
  "font-variant": "fontVariant",
  fontWeight: 1,
  "font-weight": "fontWeight",
  format: 0,
  from: 0,
  fx: 0,
  fy: 0,
  g1: 0,
  g2: 0,
  glyphName: 1,
  "glyph-name": "glyphName",
  glyphOrientationHorizontal: 1,
  "glyph-orientation-horizontal": "glyphOrientationHorizontal",
  glyphOrientationVertical: 1,
  "glyph-orientation-vertical": "glyphOrientationVertical",
  glyphRef: 1,
  gradientTransform: 1,
  gradientUnits: 1,
  hanging: 0,
  horizAdvX: 1,
  "horiz-adv-x": "horizAdvX",
  horizOriginX: 1,
  "horiz-origin-x": "horizOriginX",
  ideographic: 0,
  imageRendering: 1,
  "image-rendering": "imageRendering",
  in2: 0,
  in: 0,
  inlist: 0,
  intercept: 0,
  k1: 0,
  k2: 0,
  k3: 0,
  k4: 0,
  k: 0,
  kernelMatrix: 1,
  kernelUnitLength: 1,
  kerning: 0,
  keyPoints: 1,
  keySplines: 1,
  keyTimes: 1,
  lengthAdjust: 1,
  letterSpacing: 1,
  "letter-spacing": "letterSpacing",
  lightingColor: 1,
  "lighting-color": "lightingColor",
  limitingConeAngle: 1,
  local: 0,
  markerEnd: 1,
  "marker-end": "markerEnd",
  markerHeight: 1,
  markerMid: 1,
  "marker-mid": "markerMid",
  markerStart: 1,
  "marker-start": "markerStart",
  markerUnits: 1,
  markerWidth: 1,
  mask: 0,
  maskContentUnits: 1,
  maskUnits: 1,
  mathematical: 0,
  mode: 0,
  numOctaves: 1,
  offset: 0,
  opacity: 0,
  operator: 0,
  order: 0,
  orient: 0,
  orientation: 0,
  origin: 0,
  overflow: 0,
  overlinePosition: 1,
  "overline-position": "overlinePosition",
  overlineThickness: 1,
  "overline-thickness": "overlineThickness",
  paintOrder: 1,
  "paint-order": "paintOrder",
  panose1: 0,
  "panose-1": "panose1",
  pathLength: 1,
  patternContentUnits: 1,
  patternTransform: 1,
  patternUnits: 1,
  pointerEvents: 1,
  "pointer-events": "pointerEvents",
  points: 0,
  pointsAtX: 1,
  pointsAtY: 1,
  pointsAtZ: 1,
  prefix: 0,
  preserveAlpha: 1,
  preserveAspectRatio: 1,
  primitiveUnits: 1,
  property: 0,
  r: 0,
  radius: 0,
  refX: 1,
  refY: 1,
  renderingIntent: 1,
  "rendering-intent": "renderingIntent",
  repeatCount: 1,
  repeatDur: 1,
  requiredExtensions: 1,
  requiredFeatures: 1,
  resource: 0,
  restart: 0,
  result: 0,
  results: 0,
  rotate: 0,
  rx: 0,
  ry: 0,
  scale: 0,
  security: 0,
  seed: 0,
  shapeRendering: 1,
  "shape-rendering": "shapeRendering",
  slope: 0,
  spacing: 0,
  specularConstant: 1,
  specularExponent: 1,
  speed: 0,
  spreadMethod: 1,
  startOffset: 1,
  stdDeviation: 1,
  stemh: 0,
  stemv: 0,
  stitchTiles: 1,
  stopColor: 1,
  "stop-color": "stopColor",
  stopOpacity: 1,
  "stop-opacity": "stopOpacity",
  strikethroughPosition: 1,
  "strikethrough-position": "strikethroughPosition",
  strikethroughThickness: 1,
  "strikethrough-thickness": "strikethroughThickness",
  string: 0,
  stroke: 0,
  strokeDasharray: 1,
  "stroke-dasharray": "strokeDasharray",
  strokeDashoffset: 1,
  "stroke-dashoffset": "strokeDashoffset",
  strokeLinecap: 1,
  "stroke-linecap": "strokeLinecap",
  strokeLinejoin: 1,
  "stroke-linejoin": "strokeLinejoin",
  strokeMiterlimit: 1,
  "stroke-miterlimit": "strokeMiterlimit",
  strokeWidth: 1,
  "stroke-width": "strokeWidth",
  strokeOpacity: 1,
  "stroke-opacity": "strokeOpacity",
  suppressContentEditableWarning: 1,
  suppressHydrationWarning: 1,
  surfaceScale: 1,
  systemLanguage: 1,
  tableValues: 1,
  targetX: 1,
  targetY: 1,
  textAnchor: 1,
  "text-anchor": "textAnchor",
  textDecoration: 1,
  "text-decoration": "textDecoration",
  textLength: 1,
  textRendering: 1,
  "text-rendering": "textRendering",
  to: 0,
  transform: 0,
  typeof: 0,
  u1: 0,
  u2: 0,
  underlinePosition: 1,
  "underline-position": "underlinePosition",
  underlineThickness: 1,
  "underline-thickness": "underlineThickness",
  unicode: 0,
  unicodeBidi: 1,
  "unicode-bidi": "unicodeBidi",
  unicodeRange: 1,
  "unicode-range": "unicodeRange",
  unitsPerEm: 1,
  "units-per-em": "unitsPerEm",
  unselectable: 0,
  vAlphabetic: 1,
  "v-alphabetic": "vAlphabetic",
  values: 0,
  vectorEffect: 1,
  "vector-effect": "vectorEffect",
  version: 0,
  vertAdvY: 1,
  "vert-adv-y": "vertAdvY",
  vertOriginX: 1,
  "vert-origin-x": "vertOriginX",
  vertOriginY: 1,
  "vert-origin-y": "vertOriginY",
  vHanging: 1,
  "v-hanging": "vHanging",
  vIdeographic: 1,
  "v-ideographic": "vIdeographic",
  viewBox: 1,
  viewTarget: 1,
  visibility: 0,
  vMathematical: 1,
  "v-mathematical": "vMathematical",
  vocab: 0,
  widths: 0,
  wordSpacing: 1,
  "word-spacing": "wordSpacing",
  writingMode: 1,
  "writing-mode": "writingMode",
  x1: 0,
  x2: 0,
  x: 0,
  xChannelSelector: 1,
  xHeight: 1,
  "x-height": "xHeight",
  xlinkActuate: 1,
  "xlink:actuate": "xlinkActuate",
  xlinkArcrole: 1,
  "xlink:arcrole": "xlinkArcrole",
  xlinkHref: 1,
  "xlink:href": "xlinkHref",
  xlinkRole: 1,
  "xlink:role": "xlinkRole",
  xlinkShow: 1,
  "xlink:show": "xlinkShow",
  xlinkTitle: 1,
  "xlink:title": "xlinkTitle",
  xlinkType: 1,
  "xlink:type": "xlinkType",
  xmlBase: 1,
  "xml:base": "xmlBase",
  xmlLang: 1,
  "xml:lang": "xmlLang",
  xmlns: 0,
  "xml:space": "xmlSpace",
  xmlnsXlink: 1,
  "xmlns:xlink": "xmlnsXlink",
  xmlSpace: 1,
  y1: 0,
  y2: 0,
  y: 0,
  yChannelSelector: 1,
  z: 0,
  zoomAndPan: 1
};
const lb = 0, xr = 1, Ls = 2, Ss = 3, Mc = 4, ub = 5, cb = 6;
function qO(t) {
  return Gt.hasOwnProperty(t) ? Gt[t] : null;
}
function on(t, e, n, r, o, i, a) {
  this.acceptsBooleans = e === Ls || e === Ss || e === Mc, this.attributeName = r, this.attributeNamespace = o, this.mustUseProperty = n, this.propertyName = t, this.type = e, this.sanitizeURL = i, this.removeEmptyString = a;
}
const Gt = {}, GO = [
  "children",
  "dangerouslySetInnerHTML",
  // TODO: This prevents the assignment of defaultValue to regular
  // elements (not just inputs). Now that ReactDOMInput assigns to the
  // defaultValue property -- do we need this?
  "defaultValue",
  "defaultChecked",
  "innerHTML",
  "suppressContentEditableWarning",
  "suppressHydrationWarning",
  "style"
];
GO.forEach((t) => {
  Gt[t] = new on(
    t,
    lb,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  ["acceptCharset", "accept-charset"],
  ["className", "class"],
  ["htmlFor", "for"],
  ["httpEquiv", "http-equiv"]
].forEach(([t, e]) => {
  Gt[t] = new on(
    t,
    xr,
    !1,
    // mustUseProperty
    e,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["contentEditable", "draggable", "spellCheck", "value"].forEach((t) => {
  Gt[t] = new on(
    t,
    Ls,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "autoReverse",
  "externalResourcesRequired",
  "focusable",
  "preserveAlpha"
].forEach((t) => {
  Gt[t] = new on(
    t,
    Ls,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "allowFullScreen",
  "async",
  // Note: there is a special case that prevents it from being written to the DOM
  // on the client side because the browsers are inconsistent. Instead we call focus().
  "autoFocus",
  "autoPlay",
  "controls",
  "default",
  "defer",
  "disabled",
  "disablePictureInPicture",
  "disableRemotePlayback",
  "formNoValidate",
  "hidden",
  "loop",
  "noModule",
  "noValidate",
  "open",
  "playsInline",
  "readOnly",
  "required",
  "reversed",
  "scoped",
  "seamless",
  // Microdata
  "itemScope"
].forEach((t) => {
  Gt[t] = new on(
    t,
    Ss,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "checked",
  // Note: `option.selected` is not updated if `select.multiple` is
  // disabled with `removeAttribute`. We have special logic for handling this.
  "multiple",
  "muted",
  "selected"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  Gt[t] = new on(
    t,
    Ss,
    !0,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "capture",
  "download"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  Gt[t] = new on(
    t,
    Mc,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "cols",
  "rows",
  "size",
  "span"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  Gt[t] = new on(
    t,
    cb,
    !1,
    // mustUseProperty
    t,
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["rowSpan", "start"].forEach((t) => {
  Gt[t] = new on(
    t,
    ub,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const Bc = /[\-\:]([a-z])/g, Tc = (t) => t[1].toUpperCase();
[
  "accent-height",
  "alignment-baseline",
  "arabic-form",
  "baseline-shift",
  "cap-height",
  "clip-path",
  "clip-rule",
  "color-interpolation",
  "color-interpolation-filters",
  "color-profile",
  "color-rendering",
  "dominant-baseline",
  "enable-background",
  "fill-opacity",
  "fill-rule",
  "flood-color",
  "flood-opacity",
  "font-family",
  "font-size",
  "font-size-adjust",
  "font-stretch",
  "font-style",
  "font-variant",
  "font-weight",
  "glyph-name",
  "glyph-orientation-horizontal",
  "glyph-orientation-vertical",
  "horiz-adv-x",
  "horiz-origin-x",
  "image-rendering",
  "letter-spacing",
  "lighting-color",
  "marker-end",
  "marker-mid",
  "marker-start",
  "overline-position",
  "overline-thickness",
  "paint-order",
  "panose-1",
  "pointer-events",
  "rendering-intent",
  "shape-rendering",
  "stop-color",
  "stop-opacity",
  "strikethrough-position",
  "strikethrough-thickness",
  "stroke-dasharray",
  "stroke-dashoffset",
  "stroke-linecap",
  "stroke-linejoin",
  "stroke-miterlimit",
  "stroke-opacity",
  "stroke-width",
  "text-anchor",
  "text-decoration",
  "text-rendering",
  "underline-position",
  "underline-thickness",
  "unicode-bidi",
  "unicode-range",
  "units-per-em",
  "v-alphabetic",
  "v-hanging",
  "v-ideographic",
  "v-mathematical",
  "vector-effect",
  "vert-adv-y",
  "vert-origin-x",
  "vert-origin-y",
  "word-spacing",
  "writing-mode",
  "xmlns:xlink",
  "x-height"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  const e = t.replace(Bc, Tc);
  Gt[e] = new on(
    e,
    xr,
    !1,
    // mustUseProperty
    t,
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xlink:actuate",
  "xlink:arcrole",
  "xlink:role",
  "xlink:show",
  "xlink:title",
  "xlink:type"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  const e = t.replace(Bc, Tc);
  Gt[e] = new on(
    e,
    xr,
    !1,
    // mustUseProperty
    t,
    "http://www.w3.org/1999/xlink",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
[
  "xml:base",
  "xml:lang",
  "xml:space"
  // NOTE: if you add a camelCased prop to this list,
  // you'll need to set attributeName to name.toLowerCase()
  // instead in the assignment below.
].forEach((t) => {
  const e = t.replace(Bc, Tc);
  Gt[e] = new on(
    e,
    xr,
    !1,
    // mustUseProperty
    t,
    "http://www.w3.org/XML/1998/namespace",
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
["tabIndex", "crossOrigin"].forEach((t) => {
  Gt[t] = new on(
    t,
    xr,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !1,
    // sanitizeURL
    !1
    // removeEmptyString
  );
});
const ZO = "xlinkHref";
Gt[ZO] = new on(
  "xlinkHref",
  xr,
  !1,
  // mustUseProperty
  "xlink:href",
  "http://www.w3.org/1999/xlink",
  !0,
  // sanitizeURL
  !1
  // removeEmptyString
);
["src", "href", "action", "formAction"].forEach((t) => {
  Gt[t] = new on(
    t,
    xr,
    !1,
    // mustUseProperty
    t.toLowerCase(),
    // attributeName
    null,
    // attributeNamespace
    !0,
    // sanitizeURL
    !0
    // removeEmptyString
  );
});
const {
  CAMELCASE: KO,
  SAME: YO,
  possibleStandardNames: Jf
} = xs, XO = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD", JO = XO + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040", QO = RegExp.prototype.test.bind(
  // eslint-disable-next-line no-misleading-character-class
  new RegExp("^(data|aria)-[" + JO + "]*$")
), ex = Object.keys(
  Jf
).reduce((t, e) => {
  const n = Jf[e];
  return n === YO ? t[e] = e : n === KO ? t[e.toLowerCase()] = e : t[e] = n, t;
}, {});
_n.BOOLEAN = Ss;
_n.BOOLEANISH_STRING = Ls;
_n.NUMERIC = ub;
_n.OVERLOADED_BOOLEAN = Mc;
_n.POSITIVE_NUMERIC = cb;
_n.RESERVED = lb;
_n.STRING = xr;
_n.getPropertyInfo = qO;
_n.isCustomAttribute = QO;
_n.possibleStandardNames = ex;
var Ac = {}, jc = {}, Qf = /\/\*[^*]*\*+([^/*][^*]*\*+)*\//g, tx = /\n/g, nx = /^\s*/, rx = /^(\*?[-#/*\\\w]+(\[[0-9a-z_-]+\])?)\s*/, ox = /^:\s*/, ix = /^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^)]*?\)|[^};])+)/, ax = /^[;\s]*/, sx = /^\s+|\s+$/g, lx = `
`, ep = "/", tp = "*", Nr = "", ux = "comment", cx = "declaration", dx = function(t, e) {
  if (typeof t != "string")
    throw new TypeError("First argument must be a string");
  if (!t) return [];
  e = e || {};
  var n = 1, r = 1;
  function o(h) {
    var g = h.match(tx);
    g && (n += g.length);
    var p = h.lastIndexOf(lx);
    r = ~p ? h.length - p : r + h.length;
  }
  function i() {
    var h = { line: n, column: r };
    return function(g) {
      return g.position = new a(h), u(), g;
    };
  }
  function a(h) {
    this.start = h, this.end = { line: n, column: r }, this.source = e.source;
  }
  a.prototype.content = t;
  function s(h) {
    var g = new Error(
      e.source + ":" + n + ":" + r + ": " + h
    );
    if (g.reason = h, g.filename = e.source, g.line = n, g.column = r, g.source = t, !e.silent) throw g;
  }
  function l(h) {
    var g = h.exec(t);
    if (g) {
      var p = g[0];
      return o(p), t = t.slice(p.length), g;
    }
  }
  function u() {
    l(nx);
  }
  function c(h) {
    var g;
    for (h = h || []; g = d(); )
      g !== !1 && h.push(g);
    return h;
  }
  function d() {
    var h = i();
    if (!(ep != t.charAt(0) || tp != t.charAt(1))) {
      for (var g = 2; Nr != t.charAt(g) && (tp != t.charAt(g) || ep != t.charAt(g + 1)); )
        ++g;
      if (g += 2, Nr === t.charAt(g - 1))
        return s("End of comment missing");
      var p = t.slice(2, g - 2);
      return r += 2, o(p), t = t.slice(g), r += 2, h({
        type: ux,
        comment: p
      });
    }
  }
  function f() {
    var h = i(), g = l(rx);
    if (g) {
      if (d(), !l(ox)) return s("property missing ':'");
      var p = l(ix), w = h({
        type: cx,
        property: np(g[0].replace(Qf, Nr)),
        value: p ? np(p[0].replace(Qf, Nr)) : Nr
      });
      return l(ax), w;
    }
  }
  function v() {
    var h = [];
    c(h);
    for (var g; g = f(); )
      g !== !1 && (h.push(g), c(h));
    return h;
  }
  return u(), v();
};
function np(t) {
  return t ? t.replace(sx, Nr) : Nr;
}
var fx = gt && gt.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(jc, "__esModule", { value: !0 });
jc.default = hx;
var px = fx(dx);
function hx(t, e) {
  var n = null;
  if (!t || typeof t != "string")
    return n;
  var r = (0, px.default)(t), o = typeof e == "function";
  return r.forEach(function(i) {
    if (i.type === "declaration") {
      var a = i.property, s = i.value;
      o ? e(a, s, i) : s && (n = n || {}, n[a] = s);
    }
  }), n;
}
var Ps = {};
Object.defineProperty(Ps, "__esModule", { value: !0 });
Ps.camelCase = void 0;
var gx = /^--[a-zA-Z0-9_-]+$/, vx = /-([a-z])/g, mx = /^[^-]+$/, yx = /^-(webkit|moz|ms|o|khtml)-/, bx = /^-(ms)-/, Cx = function(t) {
  return !t || mx.test(t) || gx.test(t);
}, wx = function(t, e) {
  return e.toUpperCase();
}, rp = function(t, e) {
  return "".concat(e, "-");
}, Ex = function(t, e) {
  return e === void 0 && (e = {}), Cx(t) ? t : (t = t.toLowerCase(), e.reactCompat ? t = t.replace(bx, rp) : t = t.replace(yx, rp), t.replace(vx, wx));
};
Ps.camelCase = Ex;
var Dx = gt && gt.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
}, Ox = Dx(jc), xx = Ps;
function Ou(t, e) {
  var n = {};
  return !t || typeof t != "string" || (0, Ox.default)(t, function(r, o) {
    r && o && (n[(0, xx.camelCase)(r, e)] = o);
  }), n;
}
Ou.default = Ou;
var Lx = Ou;
(function(t) {
  var e = gt && gt.__importDefault || function(c) {
    return c && c.__esModule ? c : { default: c };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.returnFirstArg = t.canTextBeChildOfNode = t.ELEMENTS_WITH_NO_TEXT_CHILDREN = t.PRESERVE_CUSTOM_ATTRIBUTES = void 0, t.isCustomComponent = i, t.setStyleProp = s;
  var n = be, r = e(Lx), o = /* @__PURE__ */ new Set([
    "annotation-xml",
    "color-profile",
    "font-face",
    "font-face-src",
    "font-face-uri",
    "font-face-format",
    "font-face-name",
    "missing-glyph"
  ]);
  function i(c, d) {
    return c.includes("-") ? !o.has(c) : !!(d && typeof d.is == "string");
  }
  var a = {
    reactCompat: !0
  };
  function s(c, d) {
    if (typeof c == "string") {
      if (!c.trim()) {
        d.style = {};
        return;
      }
      try {
        d.style = (0, r.default)(c, a);
      } catch {
        d.style = {};
      }
    }
  }
  t.PRESERVE_CUSTOM_ATTRIBUTES = Number(n.version.split(".")[0]) >= 16, t.ELEMENTS_WITH_NO_TEXT_CHILDREN = /* @__PURE__ */ new Set([
    "tr",
    "tbody",
    "thead",
    "tfoot",
    "colgroup",
    "table",
    "head",
    "html",
    "frameset"
  ]);
  var l = function(c) {
    return !t.ELEMENTS_WITH_NO_TEXT_CHILDREN.has(c.name);
  };
  t.canTextBeChildOfNode = l;
  var u = function(c) {
    return c;
  };
  t.returnFirstArg = u;
})(Ac);
Object.defineProperty(Os, "__esModule", { value: !0 });
Os.default = Mx;
var Fo = _n, op = Ac, Sx = ["checked", "value"], Px = ["input", "select", "textarea"], kx = {
  reset: !0,
  submit: !0
};
function Mx(t, e) {
  t === void 0 && (t = {});
  var n = {}, r = !!(t.type && kx[t.type]);
  for (var o in t) {
    var i = t[o];
    if ((0, Fo.isCustomAttribute)(o)) {
      n[o] = i;
      continue;
    }
    var a = o.toLowerCase(), s = ip(a);
    if (s) {
      var l = (0, Fo.getPropertyInfo)(s);
      switch (Sx.includes(s) && Px.includes(e) && !r && (s = ip("default" + a)), n[s] = i, l && l.type) {
        case Fo.BOOLEAN:
          n[s] = !0;
          break;
        case Fo.OVERLOADED_BOOLEAN:
          i === "" && (n[s] = !0);
          break;
      }
      continue;
    }
    op.PRESERVE_CUSTOM_ATTRIBUTES && (n[o] = i);
  }
  return (0, op.setStyleProp)(t.style, n), n;
}
function ip(t) {
  return Fo.possibleStandardNames[t];
}
var Fc = {}, Bx = gt && gt.__importDefault || function(t) {
  return t && t.__esModule ? t : { default: t };
};
Object.defineProperty(Fc, "__esModule", { value: !0 });
Fc.default = db;
var ul = be, Tx = Bx(Os), $o = Ac, Ax = {
  cloneElement: ul.cloneElement,
  createElement: ul.createElement,
  isValidElement: ul.isValidElement
};
function db(t, e) {
  e === void 0 && (e = {});
  for (var n = [], r = typeof e.replace == "function", o = e.transform || $o.returnFirstArg, i = e.library || Ax, a = i.cloneElement, s = i.createElement, l = i.isValidElement, u = t.length, c = 0; c < u; c++) {
    var d = t[c];
    if (r) {
      var f = e.replace(d, c);
      if (l(f)) {
        u > 1 && (f = a(f, {
          key: f.key || c
        })), n.push(o(f, d, c));
        continue;
      }
    }
    if (d.type === "text") {
      var v = !d.data.trim().length;
      if (v && d.parent && !(0, $o.canTextBeChildOfNode)(d.parent) || e.trim && v)
        continue;
      n.push(o(d.data, d, c));
      continue;
    }
    var h = d, g = {};
    jx(h) ? ((0, $o.setStyleProp)(h.attribs.style, h.attribs), g = h.attribs) : h.attribs && (g = (0, Tx.default)(h.attribs, h.name));
    var p = void 0;
    switch (d.type) {
      case "script":
      case "style":
        d.children[0] && (g.dangerouslySetInnerHTML = {
          __html: d.children[0].data
        });
        break;
      case "tag":
        d.name === "textarea" && d.children[0] ? g.defaultValue = d.children[0].data : d.children && d.children.length && (p = db(d.children, e));
        break;
      default:
        continue;
    }
    u > 1 && (g.key = c), n.push(o(s(d.name, g, p), d, c));
  }
  return n.length === 1 ? n[0] : n;
}
function jx(t) {
  return $o.PRESERVE_CUSTOM_ATTRIBUTES && t.type === "tag" && (0, $o.isCustomComponent)(t.name, t.attribs);
}
(function(t) {
  var e = gt && gt.__importDefault || function(l) {
    return l && l.__esModule ? l : { default: l };
  };
  Object.defineProperty(t, "__esModule", { value: !0 }), t.htmlToDOM = t.domToReact = t.attributesToProps = t.Text = t.ProcessingInstruction = t.Element = t.Comment = void 0, t.default = s;
  var n = e(Oc);
  t.htmlToDOM = n.default;
  var r = e(Os);
  t.attributesToProps = r.default;
  var o = e(Fc);
  t.domToReact = o.default;
  var i = Lc;
  Object.defineProperty(t, "Comment", { enumerable: !0, get: function() {
    return i.Comment;
  } }), Object.defineProperty(t, "Element", { enumerable: !0, get: function() {
    return i.Element;
  } }), Object.defineProperty(t, "ProcessingInstruction", { enumerable: !0, get: function() {
    return i.ProcessingInstruction;
  } }), Object.defineProperty(t, "Text", { enumerable: !0, get: function() {
    return i.Text;
  } });
  var a = { lowerCaseAttributeNames: !1 };
  function s(l, u) {
    if (typeof l != "string")
      throw new TypeError("First argument must be a string");
    return l ? (0, o.default)((0, n.default)(l, (u == null ? void 0 : u.htmlparser2) || a), u) : [];
  }
})(qy);
const ap = /* @__PURE__ */ tO(qy);
ap.default;
function Fx(t) {
  const {
    className: e,
    orientation: n = "horizontal",
    ...r
  } = t, o = `arkynDivider ${n} ${e}`;
  return /* @__PURE__ */ ut.jsx("div", { className: o.trim(), ...r });
}
function fb(t) {
  const {
    isLoading: e = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...d
  } = t, f = { xs: 12, sm: 16, md: 20, lg: 24 }[i], v = `arkynButton ${e ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ ut.jsxs("button", { className: v, disabled: l || e, ...d, children: [
    /* @__PURE__ */ ut.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ ut.jsx(Un, { size: f, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ ut.jsxs("div", { className: "arkynButtonContent", children: [
      Sf(f, a),
      c,
      Sf(f, s)
    ] })
  ] });
}
function _x() {
  const t = ec(), e = ny(), n = ry(), [r, o] = B(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  y(() => {
    var u, c;
    let d = ((c = (u = n[0]) == null ? void 0 : u.data) == null ? void 0 : c.fieldErrors) || {};
    i(r, d) || Object.entries(d).length !== 0 && o(d);
  }, [n, t]), y(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, e]);
  const s = (t == null ? void 0 : t.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
ct({});
function Ix(t) {
  const {
    isLoading: e = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = t, u = { xs: 12, sm: 16, md: 20, lg: 24 }, c = `arkynIconButton ${r} ${n} ${o} ${e ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ ut.jsxs(
    "button",
    {
      disabled: a || e,
      className: c.trim(),
      ...l,
      children: [
        /* @__PURE__ */ ut.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ ut.jsx(Un, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ ut.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ ut.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function Rx(t) {
  const {
    text: e,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = t, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ ut.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ ut.jsx("div", { className: "arkynTooltipText", children: e })
  ] });
}
function Nx(t) {
  return t && t.replace(/[^0-9]/g, "");
}
const $x = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
};
Nx($x.CNPJ).length;
es((t, e) => /* @__PURE__ */ ut.jsx("input", { ref: e, ...t }));
ct({});
var tr = {};
Object.defineProperty(tr, "__esModule", {
  value: !0
});
var zx = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), cl = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, pb = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: zx ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, _c = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var ji = 1; ji < 20; ji++)
  _c["f" + ji] = 111 + ji;
function ks(t, e, n) {
  e && !("byKey" in e) && (n = e, e = null), Array.isArray(t) || (t = [t]);
  var r = t.map(function(a) {
    return hb(a, e);
  }), o = function(a) {
    return r.some(function(s) {
      return gb(s, a);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function Ux(t, e) {
  return ks(t, e);
}
function Wx(t, e) {
  return ks(t, { byKey: !0 }, e);
}
function hb(t, e) {
  var n = e && e.byKey, r = {};
  t = t.replace("++", "+add");
  var o = t.split("+"), i = o.length;
  for (var a in cl)
    r[cl[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), d; !(s = (d = c.next()).done); s = !0) {
      var f = d.value, v = f.endsWith("?") && f.length > 1;
      v && (f = f.slice(0, -1));
      var h = Ic(f), g = cl[h];
      if (f.length > 1 && !g && !pb[f] && !_c[h])
        throw new TypeError('Unknown modifier: "' + f + '"');
      (i === 1 || !g) && (n ? r.key = h : r.which = vb(f)), g && (r[g] = v ? null : !0);
    }
  } catch (p) {
    l = !0, u = p;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function gb(t, e) {
  for (var n in t) {
    var r = t[n], o = void 0;
    if (r != null && (n === "key" && e.key != null ? o = e.key.toLowerCase() : n === "which" ? o = r === 91 && e.which === 93 ? 91 : e.which : o = e[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function vb(t) {
  t = Ic(t);
  var e = _c[t] || t.toUpperCase().charCodeAt(0);
  return e;
}
function Ic(t) {
  return t = t.toLowerCase(), t = pb[t] || t, t;
}
tr.default = ks;
var dl = tr.isHotkey = ks;
tr.isCodeHotkey = Ux;
tr.isKeyHotkey = Wx;
tr.parseHotkey = hb;
tr.compareHotkey = gb;
tr.toKeyCode = vb;
tr.toKeyName = Ic;
var Hx = typeof gt == "object" && gt && gt.Object === Object && gt, Vx = Hx, qx = Vx, Gx = typeof self == "object" && self && self.Object === Object && self, Zx = qx || Gx || Function("return this")(), Kx = Zx, Yx = Kx, Xx = Yx.Symbol, mb = Xx, sp = mb;
sp && sp.toStringTag;
var lp = mb;
lp && lp.toStringTag;
var up;
(function(t) {
  t.BORDER_BOX = "border-box", t.CONTENT_BOX = "content-box", t.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(up || (up = {}));
var Rc = function(t) {
  return Object.freeze(t);
}, Jx = /* @__PURE__ */ function() {
  function t(e, n) {
    this.inlineSize = e, this.blockSize = n, Rc(this);
  }
  return t;
}(), Qx = function() {
  function t(e, n, r, o) {
    return this.x = e, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Rc(this);
  }
  return t.prototype.toJSON = function() {
    var e = this, n = e.x, r = e.y, o = e.top, i = e.right, a = e.bottom, s = e.left, l = e.width, u = e.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, t.fromRect = function(e) {
    return new t(e.x, e.y, e.width, e.height);
  }, t;
}(), cp = typeof window < "u" ? window : {};
/msie|trident/i.test(cp.navigator && cp.navigator.userAgent);
var fl = function(t, e, n) {
  return t === void 0 && (t = 0), e === void 0 && (e = 0), n === void 0 && (n = !1), new Jx((n ? e : t) || 0, (n ? t : e) || 0);
};
Rc({
  devicePixelContentBoxSize: fl(),
  borderBoxSize: fl(),
  contentBoxSize: fl(),
  contentRect: new Qx(0, 0, 0, 0)
});
function ti(t) {
  "@babel/helpers - typeof";
  return ti = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, ti(t);
}
function eL(t, e) {
  if (ti(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (ti(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function tL(t) {
  var e = eL(t, "string");
  return ti(e) === "symbol" ? e : String(e);
}
function zo(t, e, n) {
  return e = tL(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
var nL = /* @__PURE__ */ ct(null), pl, hl;
parseInt(be.version.split(".")[0], 10);
var dp = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), gl = typeof navigator < "u" && /Android/.test(navigator.userAgent), Fi = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), rL = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent);
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && (pl = navigator.userAgent.match(/Version\/(\d+)/)) !== null && pl !== void 0 && pl[1] && parseInt((hl = navigator.userAgent.match(/Version\/(\d+)/)) === null || hl === void 0 ? void 0 : hl[1], 10) < 17;
var oL = /* @__PURE__ */ new WeakMap(), iL = /* @__PURE__ */ new WeakMap(), aL = /* @__PURE__ */ new WeakMap(), sL = /* @__PURE__ */ new WeakMap(), lL = /* @__PURE__ */ new WeakMap(), fp = /* @__PURE__ */ new WeakMap(), uL = /* @__PURE__ */ new WeakMap(), pp = /* @__PURE__ */ new WeakMap(), _i = /* @__PURE__ */ new WeakMap(), cL = /* @__PURE__ */ new WeakMap(), dL = /* @__PURE__ */ new WeakMap(), fL = /* @__PURE__ */ new WeakMap(), yb = globalThis.Node, pL = globalThis.Text, bb = (t) => t && t.ownerDocument && t.ownerDocument.defaultView || null, hL = (t) => Ma(t) && t.nodeType === 8, zn = (t) => Ma(t) && t.nodeType === 1, Ma = (t) => {
  var e = bb(t);
  return !!e && t instanceof e.Node;
}, hp = (t) => {
  var e = t && t.anchorNode && bb(t.anchorNode);
  return !!e && t instanceof e.Selection;
}, gL = (t) => {
  var [e, n] = t;
  if (zn(e) && e.childNodes.length) {
    var r = n === e.childNodes.length, o = r ? n - 1 : n;
    for ([e, o] = Cb(e, o, r ? "backward" : "forward"), r = o < n; zn(e) && e.childNodes.length; ) {
      var i = r ? e.childNodes.length - 1 : 0;
      e = mL(e, i, r ? "backward" : "forward");
    }
    n = r && e.textContent != null ? e.textContent.length : 0;
  }
  return [e, n];
}, vL = (t) => {
  for (var e = t && t.parentNode; e; ) {
    if (e.toString() === "[object ShadowRoot]")
      return !0;
    e = e.parentNode;
  }
  return !1;
}, Cb = (t, e, n) => {
  for (var {
    childNodes: r
  } = t, o = r[e], i = e, a = !1, s = !1; (hL(o) || zn(o) && o.childNodes.length === 0 || zn(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = e - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = e + 1, n = "forward";
      continue;
    }
    o = r[i], e = i, i += n === "forward" ? 1 : -1;
  }
  return [o, e];
}, mL = (t, e, n) => {
  var [r] = Cb(t, e, n);
  return r;
}, gp = (t) => t.getSelection != null ? t.getSelection() : document.getSelection(), wb = (t, e, n) => {
  var {
    target: r
  } = e;
  if (zn(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = Ve.getWindow(t);
  if (o.contains(r))
    return Ve.hasDOMNode(t, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === e ? !1 : wb(t, i, n);
}, vp = (t, e) => !!(t.compareDocumentPosition(e) & yb.DOCUMENT_POSITION_PRECEDING), yL = (t, e) => !!(t.compareDocumentPosition(e) & yb.DOCUMENT_POSITION_FOLLOWING), bL = 0;
class CL {
  constructor() {
    zo(this, "id", void 0), this.id = "".concat(bL++);
  }
}
var Ve = {
  androidPendingDiffs: (t) => fL.get(t),
  androidScheduleFlush: (t) => {
    var e;
    (e = dL.get(t)) === null || e === void 0 || e();
  },
  blur: (t) => {
    var e = Ve.toDOMNode(t, t), n = Ve.findDocumentOrShadowRoot(t);
    _i.set(t, !1), n.activeElement === e && e.blur();
  },
  deselect: (t) => {
    var {
      selection: e
    } = t, n = Ve.findDocumentOrShadowRoot(t), r = gp(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), e && Pa.deselect(t);
  },
  findDocumentOrShadowRoot: (t) => {
    var e = Ve.toDOMNode(t, t), n = e.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : e.ownerDocument;
  },
  findEventRange: (t, e) => {
    "nativeEvent" in e && (e = e.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = e;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(e));
    var i = Ve.toSlateNode(t, e.target), a = Ve.findPath(t, i);
    if (Yn.isElement(i) && pt.isVoid(t, i)) {
      var s = o.getBoundingClientRect(), l = t.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = pt.point(t, a, {
        edge: l ? "start" : "end"
      }), c = l ? pt.before(t, u) : pt.after(t, u);
      if (c) {
        var d = pt.range(t, c);
        return d;
      }
    }
    var f, {
      document: v
    } = Ve.getWindow(t);
    if (v.caretRangeFromPoint)
      f = v.caretRangeFromPoint(n, r);
    else {
      var h = v.caretPositionFromPoint(n, r);
      h && (f = v.createRange(), f.setStart(h.offsetNode, h.offset), f.setEnd(h.offsetNode, h.offset));
    }
    if (!f)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(e));
    var g = Ve.toSlateRange(t, f, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (t, e) => {
    var n = fp.get(e);
    return n || (n = new CL(), fp.set(e, n)), n;
  },
  findPath: (t, e) => {
    for (var n = [], r = e; ; ) {
      var o = iL.get(r);
      if (o == null) {
        if (pt.isEditor(r))
          return n;
        break;
      }
      var i = oL.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(yn.stringify(e)));
  },
  focus: function(t) {
    var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!_i.get(t)) {
      if (e.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (t.operations.length > 0) {
        setTimeout(() => {
          Ve.focus(t, {
            retries: e.retries - 1
          });
        }, 10);
        return;
      }
      var n = Ve.toDOMNode(t, t), r = Ve.findDocumentOrShadowRoot(t);
      if (r.activeElement !== n) {
        if (t.selection && r instanceof Document) {
          var o = gp(r), i = Ve.toDOMRange(t, t.selection);
          o == null || o.removeAllRanges(), o == null || o.addRange(i);
        }
        t.selection || Pa.select(t, pt.start(t, [])), _i.set(t, !0), n.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (t) => {
    var e = aL.get(t);
    if (!e)
      throw new Error("Unable to find a host window element for this editor");
    return e;
  },
  hasDOMNode: function(t, e) {
    var n = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: r = !1
    } = n, o = Ve.toDOMNode(t, t), i;
    try {
      i = zn(e) ? e : e.parentElement;
    } catch (a) {
      if (a instanceof Error && !a.message.includes('Permission denied to access property "nodeType"'))
        throw a;
    }
    return i ? i.closest("[data-slate-editor]") === o && (!r || i.isContentEditable ? !0 : typeof i.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    i.closest('[contenteditable="false"]') === o || !!i.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (t, e) => Ma(e) && Ve.hasDOMNode(t, e, {
    editable: !0
  }),
  hasRange: (t, e) => {
    var {
      anchor: n,
      focus: r
    } = e;
    return pt.hasPath(t, n.path) && pt.hasPath(t, r.path);
  },
  hasSelectableTarget: (t, e) => Ve.hasEditableTarget(t, e) || Ve.isTargetInsideNonReadonlyVoid(t, e),
  hasTarget: (t, e) => Ma(e) && Ve.hasDOMNode(t, e),
  insertData: (t, e) => {
    t.insertData(e);
  },
  insertFragmentData: (t, e) => t.insertFragmentData(e),
  insertTextData: (t, e) => t.insertTextData(e),
  isComposing: (t) => !!cL.get(t),
  isFocused: (t) => !!_i.get(t),
  isReadOnly: (t) => !!pp.get(t),
  isTargetInsideNonReadonlyVoid: (t, e) => {
    if (pp.get(t)) return !1;
    var n = Ve.hasTarget(t, e) && Ve.toSlateNode(t, e);
    return Yn.isElement(n) && pt.isVoid(t, n);
  },
  setFragmentData: (t, e, n) => t.setFragmentData(e, n),
  toDOMNode: (t, e) => {
    var n = uL.get(t), r = pt.isEditor(e) ? sL.get(t) : n == null ? void 0 : n.get(Ve.findKey(t, e));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(yn.stringify(e)));
    return r;
  },
  toDOMPoint: (t, e) => {
    var [n] = pt.node(t, e.path), r = Ve.toDOMNode(t, n), o;
    pt.void(t, {
      at: e
    }) && (e = {
      path: e.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: d
        } = c.textContent, f = u.getAttribute("data-slate-length"), v = f == null ? d : parseInt(f, 10), h = s + v, g = a[l + 1];
        if (e.offset === h && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var p, w = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            w instanceof pL ? w : g,
            (p = g.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (e.offset <= h) {
          var b = Math.min(d, Math.max(0, e.offset - s));
          o = [c, b];
          break;
        }
        s = h;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(yn.stringify(e)));
    return o;
  },
  toDOMRange: (t, e) => {
    var {
      anchor: n,
      focus: r
    } = e, o = Ie.isBackward(e), i = Ve.toDOMPoint(t, n), a = Ie.isCollapsed(e) ? i : Ve.toDOMPoint(t, r), s = Ve.getWindow(t), l = s.document.createRange(), [u, c] = o ? a : i, [d, f] = o ? i : a, v = zn(u) ? u : u.parentElement, h = !!v.getAttribute("data-slate-zero-width"), g = zn(d) ? d : d.parentElement, p = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, h ? 1 : c), l.setEnd(d, p ? 1 : f), l;
  },
  toSlateNode: (t, e) => {
    var n = zn(e) ? e : e.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? lL.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (t, e, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? e : gL(e), l = a.parentNode, u = null, c = 0;
    if (l) {
      var d, f, v = Ve.toDOMNode(t, t), h = l.closest('[data-slate-void="true"]'), g = h && v.contains(h) ? h : null, p = l.closest('[contenteditable="false"]'), w = p && v.contains(p) ? p : null, b = l.closest("[data-slate-leaf]"), k = null;
      if (b) {
        if (u = b.closest('[data-slate-node="text"]'), u) {
          var E = Ve.getWindow(t), m = E.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var O = m.cloneContents(), S = [...Array.prototype.slice.call(O.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(O.querySelectorAll("[contenteditable=false]"))];
          S.forEach((F) => {
            if (gl && !r && F.hasAttribute("data-slate-zero-width") && F.textContent.length > 0 && F.textContext !== "\uFEFF") {
              F.textContent.startsWith("\uFEFF") && (F.textContent = F.textContent.slice(1));
              return;
            }
            F.parentNode.removeChild(F);
          }), c = O.textContent.length, k = u;
        }
      } else if (g) {
        for (var W = g.querySelectorAll("[data-slate-leaf]"), P = 0; P < W.length; P++) {
          var $ = W[P];
          if (Ve.hasDOMNode(t, $)) {
            b = $;
            break;
          }
        }
        b ? (u = b.closest('[data-slate-node="text"]'), k = b, c = k.textContent.length, k.querySelectorAll("[data-slate-zero-width]").forEach((F) => {
          c -= F.textContent.length;
        })) : c = 1;
      } else if (w) {
        var j = (F) => F ? F.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], _ = w.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var I, R = [...j(_), ...j(_ == null ? void 0 : _.nextElementSibling)];
          b = (I = R.find((F) => yL(w, F))) !== null && I !== void 0 ? I : null;
        } else {
          var V, J = [...j(_ == null ? void 0 : _.previousElementSibling), ...j(_)];
          b = (V = J.findLast((F) => vp(w, F))) !== null && V !== void 0 ? V : null;
        }
        b && (u = b.closest('[data-slate-node="text"]'), k = b, i === "forward" ? c = 0 : (c = k.textContent.length, k.querySelectorAll("[data-slate-zero-width]").forEach((F) => {
          c -= F.textContent.length;
        })));
      }
      k && c === k.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      gl && k.getAttribute("data-slate-zero-width") === "z" && (d = k.textContent) !== null && d !== void 0 && d.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      Fi && (f = k.textContent) !== null && f !== void 0 && f.endsWith(`

`)) && c--;
    }
    if (gl && !u && !r) {
      var G = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (G && Ve.hasDOMNode(t, G, {
        editable: !0
      })) {
        var te = Ve.toSlateNode(t, G), {
          path: Q,
          offset: T
        } = pt.start(t, Ve.findPath(t, te));
        return G.querySelector("[data-slate-leaf]") || (T = s), {
          path: Q,
          offset: T
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(e));
    }
    var N = Ve.toSlateNode(t, u), Y = Ve.findPath(t, N);
    return {
      path: Y,
      offset: c
    };
  },
  toSlateRange: (t, e, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = hp(e) ? e.anchorNode : e.startContainer, s, l, u, c, d;
    if (a)
      if (hp(e)) {
        if (Fi && e.rangeCount > 1) {
          u = e.focusNode;
          var f = e.getRangeAt(0), v = e.getRangeAt(e.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && f.startContainer instanceof HTMLTableRowElement && v.startContainer instanceof HTMLTableRowElement) {
            let O = function(S) {
              return S.childElementCount > 0 ? O(S.children[0]) : S;
            };
            var h = f.startContainer, g = v.startContainer, p = O(h.children[f.startOffset]), w = O(g.children[v.startOffset]);
            c = 0, w.childNodes.length > 0 ? s = w.childNodes[0] : s = w, p.childNodes.length > 0 ? u = p.childNodes[0] : u = p, w instanceof HTMLElement ? l = w.innerHTML.length : l = 0;
          } else
            f.startContainer === u ? (s = v.endContainer, l = v.endOffset, c = f.startOffset) : (s = f.startContainer, l = f.endOffset, c = v.startOffset);
        } else
          s = e.anchorNode, l = e.anchorOffset, u = e.focusNode, c = e.focusOffset;
        rL && vL(s) || Fi ? d = e.anchorNode === e.focusNode && e.anchorOffset === e.focusOffset : d = e.isCollapsed;
      } else
        s = e.startContainer, l = e.startOffset, u = e.endContainer, c = e.endOffset, d = e.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(e));
    Fi && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var b = Ve.toSlatePoint(t, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!b)
      return null;
    var k = vp(s, u) || s === u && c < l, E = d ? b : Ve.toSlatePoint(t, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: k ? "forward" : "backward"
    });
    if (!E)
      return null;
    var m = {
      anchor: b,
      focus: E
    };
    return Ie.isExpanded(m) && Ie.isForward(m) && zn(u) && pt.void(t, {
      at: m.focus,
      mode: "highest"
    }) && (m = pt.unhangRange(t, m, {
      voids: !0
    })), m;
  }
}, wL = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, EL = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, DL = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Et = (t) => {
  var e = wL[t], n = EL[t], r = DL[t], o = e && dl(e), i = n && dl(n), a = r && dl(r);
  return (s) => !!(o && o(s) || dp && i && i(s) || !dp && a && a(s));
};
Et("bold"), Et("compose"), Et("moveBackward"), Et("moveForward"), Et("deleteBackward"), Et("deleteForward"), Et("deleteLineBackward"), Et("deleteLineForward"), Et("deleteWordBackward"), Et("deleteWordForward"), Et("extendBackward"), Et("extendForward"), Et("extendLineBackward"), Et("extendLineForward"), Et("italic"), Et("moveLineBackward"), Et("moveLineForward"), Et("moveWordBackward"), Et("moveWordForward"), Et("redo"), Et("insertSoftBreak"), Et("splitBlock"), Et("transposeCharacter"), Et("undo");
var OL = (t, e) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (e.current) {
      var s = a.filter((l) => wb(t, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, xL = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class LL extends Km {
  constructor() {
    super(...arguments), zo(this, "context", null), zo(this, "manager", null), zo(this, "mutationObserver", null);
  }
  observe() {
    var e, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (e = this.mutationObserver) === null || e === void 0 || e.observe(n.current, xL);
  }
  componentDidMount() {
    var {
      receivedUserInput: e
    } = this.props, n = this.context;
    this.manager = OL(n, e), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var e, n, r, o = (e = this.mutationObserver) === null || e === void 0 ? void 0 : e.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var e;
    (e = this.manager) === null || e === void 0 || e.clear(), this.observe();
  }
  componentWillUnmount() {
    var e;
    (e = this.mutationObserver) === null || e === void 0 || e.disconnect();
  }
  render() {
    return this.props.children;
  }
}
zo(LL, "contextType", nL);
ct({});
ct({});
ct({});
var At = {}, Nc = {}, li = {}, ui = {}, Eb = "Expected a function", mp = NaN, SL = "[object Symbol]", PL = /^\s+|\s+$/g, kL = /^[-+]0x[0-9a-f]+$/i, ML = /^0b[01]+$/i, BL = /^0o[0-7]+$/i, TL = parseInt, AL = typeof gt == "object" && gt && gt.Object === Object && gt, jL = typeof self == "object" && self && self.Object === Object && self, FL = AL || jL || Function("return this")(), _L = Object.prototype, IL = _L.toString, RL = Math.max, NL = Math.min, vl = function() {
  return FL.Date.now();
};
function $L(t, e, n) {
  var r, o, i, a, s, l, u = 0, c = !1, d = !1, f = !0;
  if (typeof t != "function")
    throw new TypeError(Eb);
  e = yp(e) || 0, Ba(n) && (c = !!n.leading, d = "maxWait" in n, i = d ? RL(yp(n.maxWait) || 0, e) : i, f = "trailing" in n ? !!n.trailing : f);
  function v(O) {
    var S = r, W = o;
    return r = o = void 0, u = O, a = t.apply(W, S), a;
  }
  function h(O) {
    return u = O, s = setTimeout(w, e), c ? v(O) : a;
  }
  function g(O) {
    var S = O - l, W = O - u, P = e - S;
    return d ? NL(P, i - W) : P;
  }
  function p(O) {
    var S = O - l, W = O - u;
    return l === void 0 || S >= e || S < 0 || d && W >= i;
  }
  function w() {
    var O = vl();
    if (p(O))
      return b(O);
    s = setTimeout(w, g(O));
  }
  function b(O) {
    return s = void 0, f && r ? v(O) : (r = o = void 0, a);
  }
  function k() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function E() {
    return s === void 0 ? a : b(vl());
  }
  function m() {
    var O = vl(), S = p(O);
    if (r = arguments, o = this, l = O, S) {
      if (s === void 0)
        return h(l);
      if (d)
        return s = setTimeout(w, e), v(l);
    }
    return s === void 0 && (s = setTimeout(w, e)), a;
  }
  return m.cancel = k, m.flush = E, m;
}
function zL(t, e, n) {
  var r = !0, o = !0;
  if (typeof t != "function")
    throw new TypeError(Eb);
  return Ba(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), $L(t, e, {
    leading: r,
    maxWait: e,
    trailing: o
  });
}
function Ba(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function UL(t) {
  return !!t && typeof t == "object";
}
function WL(t) {
  return typeof t == "symbol" || UL(t) && IL.call(t) == SL;
}
function yp(t) {
  if (typeof t == "number")
    return t;
  if (WL(t))
    return mp;
  if (Ba(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Ba(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = t.replace(PL, "");
  var n = ML.test(t);
  return n || BL.test(t) ? TL(t.slice(2), n ? 2 : 8) : kL.test(t) ? mp : +t;
}
var HL = zL, ci = {};
Object.defineProperty(ci, "__esModule", {
  value: !0
});
ci.addPassiveEventListener = function(t, e, n) {
  var r = n.name;
  r || (r = e, console.warn("Listener must be a named function.")), ua.has(e) || ua.set(e, /* @__PURE__ */ new Set());
  var o = ua.get(e);
  if (!o.has(r)) {
    var i = function() {
      var a = !1;
      try {
        var s = Object.defineProperty({}, "passive", {
          get: function() {
            a = !0;
          }
        });
        window.addEventListener("test", null, s);
      } catch {
      }
      return a;
    }();
    t.addEventListener(e, n, i ? { passive: !0 } : !1), o.add(r);
  }
};
ci.removePassiveEventListener = function(t, e, n) {
  t.removeEventListener(e, n), ua.get(e).delete(n.name || e);
};
var ua = /* @__PURE__ */ new Map();
Object.defineProperty(ui, "__esModule", {
  value: !0
});
var VL = HL, qL = ZL(VL), GL = ci;
function ZL(t) {
  return t && t.__esModule ? t : { default: t };
}
var KL = function(t) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, qL.default)(t, e);
}, St = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(t, e) {
    if (t) {
      var n = KL(function(r) {
        St.scrollHandler(t);
      }, e);
      St.scrollSpyContainers.push(t), (0, GL.addPassiveEventListener)(t, "scroll", n);
    }
  },
  isMounted: function(t) {
    return St.scrollSpyContainers.indexOf(t) !== -1;
  },
  currentPositionX: function(t) {
    if (t === document) {
      var e = window.pageYOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return e ? window.pageXOffset : n ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return t.scrollLeft;
  },
  currentPositionY: function(t) {
    if (t === document) {
      var e = window.pageXOffset !== void 0, n = (document.compatMode || "") === "CSS1Compat";
      return e ? window.pageYOffset : n ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return t.scrollTop;
  },
  scrollHandler: function(t) {
    var e = St.scrollSpyContainers[St.scrollSpyContainers.indexOf(t)].spyCallbacks || [];
    e.forEach(function(n) {
      return n(St.currentPositionX(t), St.currentPositionY(t));
    });
  },
  addStateHandler: function(t) {
    St.spySetState.push(t);
  },
  addSpyHandler: function(t, e) {
    var n = St.scrollSpyContainers[St.scrollSpyContainers.indexOf(e)];
    n.spyCallbacks || (n.spyCallbacks = []), n.spyCallbacks.push(t), t(St.currentPositionX(e), St.currentPositionY(e));
  },
  updateStates: function() {
    St.spySetState.forEach(function(t) {
      return t();
    });
  },
  unmount: function(t, e) {
    St.scrollSpyContainers.forEach(function(n) {
      return n.spyCallbacks && n.spyCallbacks.length && n.spyCallbacks.indexOf(e) > -1 && n.spyCallbacks.splice(n.spyCallbacks.indexOf(e), 1);
    }), St.spySetState && St.spySetState.length && St.spySetState.indexOf(t) > -1 && St.spySetState.splice(St.spySetState.indexOf(t), 1), document.removeEventListener("scroll", St.scrollHandler);
  },
  update: function() {
    return St.scrollSpyContainers.forEach(function(t) {
      return St.scrollHandler(t);
    });
  }
};
ui.default = St;
var ho = {}, di = {};
Object.defineProperty(di, "__esModule", {
  value: !0
});
var YL = function(t, e) {
  var n = t.indexOf("#") === 0 ? t.substring(1) : t, r = n ? "#" + n : "", o = window && window.location, i = r ? o.pathname + o.search + r : o.pathname + o.search;
  e ? history.pushState(history.state, "", i) : history.replaceState(history.state, "", i);
}, XL = function() {
  return window.location.hash.replace(/^#/, "");
}, JL = function(t) {
  return function(e) {
    return t.contains ? t != e && t.contains(e) : !!(t.compareDocumentPosition(e) & 16);
  };
}, QL = function(t) {
  return getComputedStyle(t).position !== "static";
}, ml = function(t, e) {
  for (var n = t.offsetTop, r = t.offsetParent; r && !e(r); )
    n += r.offsetTop, r = r.offsetParent;
  return { offsetTop: n, offsetParent: r };
}, eS = function(t, e, n) {
  if (n)
    return t === document ? e.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(t).position !== "static" ? e.offsetLeft : e.offsetLeft - t.offsetLeft;
  if (t === document)
    return e.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (QL(t)) {
    if (e.offsetParent !== t) {
      var r = function(l) {
        return l === t || l === document;
      }, o = ml(e, r), i = o.offsetTop, a = o.offsetParent;
      if (a !== t)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return i;
    }
    return e.offsetTop;
  }
  if (e.offsetParent === t.offsetParent)
    return e.offsetTop - t.offsetTop;
  var s = function(l) {
    return l === document;
  };
  return ml(e, s).offsetTop - ml(t, s).offsetTop;
};
di.default = {
  updateHash: YL,
  getHash: XL,
  filterElementInContainer: JL,
  scrollOffset: eS
};
var Ms = {}, $c = {};
Object.defineProperty($c, "__esModule", {
  value: !0
});
$c.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(t) {
    return t < 0.5 ? Math.pow(t * 2, 2) / 2 : 1 - Math.pow((1 - t) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(t) {
    return t;
  },
  // accelerating from zero velocity
  easeInQuad: function(t) {
    return t * t;
  },
  // decelerating to zero velocity
  easeOutQuad: function(t) {
    return t * (2 - t);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(t) {
    return t < 0.5 ? 2 * t * t : -1 + (4 - 2 * t) * t;
  },
  // accelerating from zero velocity 
  easeInCubic: function(t) {
    return t * t * t;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(t) {
    return --t * t * t + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(t) {
    return t * t * t * t;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(t) {
    return 1 - --t * t * t * t;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(t) {
    return t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t;
  },
  // accelerating from zero velocity
  easeInQuint: function(t) {
    return t * t * t * t * t;
  },
  // decelerating to zero velocity
  easeOutQuint: function(t) {
    return 1 + --t * t * t * t * t;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(t) {
    return t < 0.5 ? 16 * t * t * t * t * t : 1 + 16 * --t * t * t * t * t;
  }
};
var zc = {};
Object.defineProperty(zc, "__esModule", {
  value: !0
});
var tS = ci, nS = ["mousedown", "mousewheel", "touchmove", "keydown"];
zc.default = {
  subscribe: function(t) {
    return typeof document < "u" && nS.forEach(function(e) {
      return (0, tS.addPassiveEventListener)(document, e, t);
    });
  }
};
var fi = {};
Object.defineProperty(fi, "__esModule", {
  value: !0
});
var xu = {
  registered: {},
  scrollEvent: {
    register: function(t, e) {
      xu.registered[t] = e;
    },
    remove: function(t) {
      xu.registered[t] = null;
    }
  }
};
fi.default = xu;
Object.defineProperty(Ms, "__esModule", {
  value: !0
});
var rS = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
}, oS = di;
Bs(oS);
var iS = $c, bp = Bs(iS), aS = zc, sS = Bs(aS), lS = fi, Nn = Bs(lS);
function Bs(t) {
  return t && t.__esModule ? t : { default: t };
}
var Db = function(t) {
  return bp.default[t.smooth] || bp.default.defaultEasing;
}, uS = function(t) {
  return typeof t == "function" ? t : function() {
    return t;
  };
}, cS = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Lu = function() {
  return cS() || function(t, e, n) {
    window.setTimeout(t, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), Ob = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, xb = function(t) {
  var e = t.data.containerElement;
  if (e && e !== document && e !== document.body)
    return e.scrollLeft;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, Lb = function(t) {
  var e = t.data.containerElement;
  if (e && e !== document && e !== document.body)
    return e.scrollTop;
  var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
  return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
}, dS = function(t) {
  var e = t.data.containerElement;
  if (e && e !== document && e !== document.body)
    return e.scrollWidth - e.offsetWidth;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollWidth, n.offsetWidth, r.clientWidth, r.scrollWidth, r.offsetWidth);
}, fS = function(t) {
  var e = t.data.containerElement;
  if (e && e !== document && e !== document.body)
    return e.scrollHeight - e.offsetHeight;
  var n = document.body, r = document.documentElement;
  return Math.max(n.scrollHeight, n.offsetHeight, r.clientHeight, r.scrollHeight, r.offsetHeight);
}, pS = function t(e, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    Nn.default.registered.end && Nn.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : e(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = t.bind(null, e, n);
    Lu.call(window, i);
    return;
  }
  Nn.default.registered.end && Nn.default.registered.end(o.to, o.target, o.currentPosition);
}, Uc = function(t) {
  t.data.containerElement = t ? t.containerId ? document.getElementById(t.containerId) : t.container && t.container.nodeType ? t.container : document : null;
}, pi = function(t, e, n, r) {
  e.data = e.data || Ob(), window.clearTimeout(e.data.delayTimeout);
  var o = function() {
    e.data.cancel = !0;
  };
  if (sS.default.subscribe(o), Uc(e), e.data.start = null, e.data.cancel = !1, e.data.startPosition = e.horizontal ? xb(e) : Lb(e), e.data.targetPosition = e.absolute ? t : t + e.data.startPosition, e.data.startPosition === e.data.targetPosition) {
    Nn.default.registered.end && Nn.default.registered.end(e.data.to, e.data.target, e.data.currentPosition);
    return;
  }
  e.data.delta = Math.round(e.data.targetPosition - e.data.startPosition), e.data.duration = uS(e.duration)(e.data.delta), e.data.duration = isNaN(parseFloat(e.data.duration)) ? 1e3 : parseFloat(e.data.duration), e.data.to = n, e.data.target = r;
  var i = Db(e), a = pS.bind(null, i, e);
  if (e && e.delay > 0) {
    e.data.delayTimeout = window.setTimeout(function() {
      Nn.default.registered.begin && Nn.default.registered.begin(e.data.to, e.data.target), Lu.call(window, a);
    }, e.delay);
    return;
  }
  Nn.default.registered.begin && Nn.default.registered.begin(e.data.to, e.data.target), Lu.call(window, a);
}, Ts = function(t) {
  return t = rS({}, t), t.data = t.data || Ob(), t.absolute = !0, t;
}, hS = function(t) {
  pi(0, Ts(t));
}, gS = function(t, e) {
  pi(t, Ts(e));
}, vS = function(t) {
  t = Ts(t), Uc(t), pi(t.horizontal ? dS(t) : fS(t), t);
}, mS = function(t, e) {
  e = Ts(e), Uc(e);
  var n = e.horizontal ? xb(e) : Lb(e);
  pi(t + n, e);
};
Ms.default = {
  animateTopScroll: pi,
  getAnimationType: Db,
  scrollToTop: hS,
  scrollToBottom: vS,
  scrollTo: gS,
  scrollMore: mS
};
Object.defineProperty(ho, "__esModule", {
  value: !0
});
var yS = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
}, bS = di, CS = Wc(bS), wS = Ms, ES = Wc(wS), DS = fi, Ii = Wc(DS);
function Wc(t) {
  return t && t.__esModule ? t : { default: t };
}
var Ri = {}, Cp = void 0;
ho.default = {
  unmount: function() {
    Ri = {};
  },
  register: function(t, e) {
    Ri[t] = e;
  },
  unregister: function(t) {
    delete Ri[t];
  },
  get: function(t) {
    return Ri[t] || document.getElementById(t) || document.getElementsByName(t)[0] || document.getElementsByClassName(t)[0];
  },
  setActiveLink: function(t) {
    return Cp = t;
  },
  getActiveLink: function() {
    return Cp;
  },
  scrollTo: function(t, e) {
    var n = this.get(t);
    if (!n) {
      console.warn("target Element not found");
      return;
    }
    e = yS({}, e, { absolute: !1 });
    var r = e.containerId, o = e.container, i = void 0;
    r ? i = document.getElementById(r) : o && o.nodeType ? i = o : i = document, e.absolute = !0;
    var a = e.horizontal, s = CS.default.scrollOffset(i, n, a) + (e.offset || 0);
    if (!e.smooth) {
      Ii.default.registered.begin && Ii.default.registered.begin(t, n), i === document ? e.horizontal ? window.scrollTo(s, 0) : window.scrollTo(0, s) : i.scrollTop = s, Ii.default.registered.end && Ii.default.registered.end(t, n);
      return;
    }
    ES.default.animateTopScroll(s, e, t, n);
  }
};
var Su = { exports: {} }, yl = { exports: {} }, nt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var wp;
function OS() {
  if (wp) return nt;
  wp = 1;
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, o = t ? Symbol.for("react.strict_mode") : 60108, i = t ? Symbol.for("react.profiler") : 60114, a = t ? Symbol.for("react.provider") : 60109, s = t ? Symbol.for("react.context") : 60110, l = t ? Symbol.for("react.async_mode") : 60111, u = t ? Symbol.for("react.concurrent_mode") : 60111, c = t ? Symbol.for("react.forward_ref") : 60112, d = t ? Symbol.for("react.suspense") : 60113, f = t ? Symbol.for("react.suspense_list") : 60120, v = t ? Symbol.for("react.memo") : 60115, h = t ? Symbol.for("react.lazy") : 60116, g = t ? Symbol.for("react.block") : 60121, p = t ? Symbol.for("react.fundamental") : 60117, w = t ? Symbol.for("react.responder") : 60118, b = t ? Symbol.for("react.scope") : 60119;
  function k(m) {
    if (typeof m == "object" && m !== null) {
      var O = m.$$typeof;
      switch (O) {
        case e:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case d:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case h:
                case v:
                case a:
                  return m;
                default:
                  return O;
              }
          }
        case n:
          return O;
      }
    }
  }
  function E(m) {
    return k(m) === u;
  }
  return nt.AsyncMode = l, nt.ConcurrentMode = u, nt.ContextConsumer = s, nt.ContextProvider = a, nt.Element = e, nt.ForwardRef = c, nt.Fragment = r, nt.Lazy = h, nt.Memo = v, nt.Portal = n, nt.Profiler = i, nt.StrictMode = o, nt.Suspense = d, nt.isAsyncMode = function(m) {
    return E(m) || k(m) === l;
  }, nt.isConcurrentMode = E, nt.isContextConsumer = function(m) {
    return k(m) === s;
  }, nt.isContextProvider = function(m) {
    return k(m) === a;
  }, nt.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === e;
  }, nt.isForwardRef = function(m) {
    return k(m) === c;
  }, nt.isFragment = function(m) {
    return k(m) === r;
  }, nt.isLazy = function(m) {
    return k(m) === h;
  }, nt.isMemo = function(m) {
    return k(m) === v;
  }, nt.isPortal = function(m) {
    return k(m) === n;
  }, nt.isProfiler = function(m) {
    return k(m) === i;
  }, nt.isStrictMode = function(m) {
    return k(m) === o;
  }, nt.isSuspense = function(m) {
    return k(m) === d;
  }, nt.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === d || m === f || typeof m == "object" && m !== null && (m.$$typeof === h || m.$$typeof === v || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === p || m.$$typeof === w || m.$$typeof === b || m.$$typeof === g);
  }, nt.typeOf = k, nt;
}
var lt = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Ep;
function xS() {
  return Ep || (Ep = 1, process.env.NODE_ENV !== "production" && function() {
    var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, o = t ? Symbol.for("react.strict_mode") : 60108, i = t ? Symbol.for("react.profiler") : 60114, a = t ? Symbol.for("react.provider") : 60109, s = t ? Symbol.for("react.context") : 60110, l = t ? Symbol.for("react.async_mode") : 60111, u = t ? Symbol.for("react.concurrent_mode") : 60111, c = t ? Symbol.for("react.forward_ref") : 60112, d = t ? Symbol.for("react.suspense") : 60113, f = t ? Symbol.for("react.suspense_list") : 60120, v = t ? Symbol.for("react.memo") : 60115, h = t ? Symbol.for("react.lazy") : 60116, g = t ? Symbol.for("react.block") : 60121, p = t ? Symbol.for("react.fundamental") : 60117, w = t ? Symbol.for("react.responder") : 60118, b = t ? Symbol.for("react.scope") : 60119;
    function k(Z) {
      return typeof Z == "string" || typeof Z == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Z === r || Z === u || Z === i || Z === o || Z === d || Z === f || typeof Z == "object" && Z !== null && (Z.$$typeof === h || Z.$$typeof === v || Z.$$typeof === a || Z.$$typeof === s || Z.$$typeof === c || Z.$$typeof === p || Z.$$typeof === w || Z.$$typeof === b || Z.$$typeof === g);
    }
    function E(Z) {
      if (typeof Z == "object" && Z !== null) {
        var pe = Z.$$typeof;
        switch (pe) {
          case e:
            var he = Z.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case d:
                return he;
              default:
                var le = he && he.$$typeof;
                switch (le) {
                  case s:
                  case c:
                  case h:
                  case v:
                  case a:
                    return le;
                  default:
                    return pe;
                }
            }
          case n:
            return pe;
        }
      }
    }
    var m = l, O = u, S = s, W = a, P = e, $ = c, j = r, _ = h, I = v, R = n, V = i, J = o, G = d, te = !1;
    function Q(Z) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), T(Z) || E(Z) === l;
    }
    function T(Z) {
      return E(Z) === u;
    }
    function N(Z) {
      return E(Z) === s;
    }
    function Y(Z) {
      return E(Z) === a;
    }
    function F(Z) {
      return typeof Z == "object" && Z !== null && Z.$$typeof === e;
    }
    function X(Z) {
      return E(Z) === c;
    }
    function L(Z) {
      return E(Z) === r;
    }
    function M(Z) {
      return E(Z) === h;
    }
    function z(Z) {
      return E(Z) === v;
    }
    function A(Z) {
      return E(Z) === n;
    }
    function U(Z) {
      return E(Z) === i;
    }
    function H(Z) {
      return E(Z) === o;
    }
    function ee(Z) {
      return E(Z) === d;
    }
    lt.AsyncMode = m, lt.ConcurrentMode = O, lt.ContextConsumer = S, lt.ContextProvider = W, lt.Element = P, lt.ForwardRef = $, lt.Fragment = j, lt.Lazy = _, lt.Memo = I, lt.Portal = R, lt.Profiler = V, lt.StrictMode = J, lt.Suspense = G, lt.isAsyncMode = Q, lt.isConcurrentMode = T, lt.isContextConsumer = N, lt.isContextProvider = Y, lt.isElement = F, lt.isForwardRef = X, lt.isFragment = L, lt.isLazy = M, lt.isMemo = z, lt.isPortal = A, lt.isProfiler = U, lt.isStrictMode = H, lt.isSuspense = ee, lt.isValidElementType = k, lt.typeOf = E;
  }()), lt;
}
var Dp;
function Sb() {
  return Dp || (Dp = 1, process.env.NODE_ENV === "production" ? yl.exports = OS() : yl.exports = xS()), yl.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var bl, Op;
function LS() {
  if (Op) return bl;
  Op = 1;
  var t = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return bl = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var d in s)
        e.call(s, d) && (l[d] = s[d]);
      if (t) {
        u = t(s);
        for (var f = 0; f < u.length; f++)
          n.call(s, u[f]) && (l[u[f]] = s[u[f]]);
      }
    }
    return l;
  }, bl;
}
var Cl, xp;
function Hc() {
  if (xp) return Cl;
  xp = 1;
  var t = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Cl = t, Cl;
}
var Lp, Sp;
function Pb() {
  return Sp || (Sp = 1, Lp = Function.call.bind(Object.prototype.hasOwnProperty)), Lp;
}
var wl, Pp;
function SS() {
  if (Pp) return wl;
  Pp = 1;
  var t = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = Hc(), n = {}, r = Pb();
    t = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var d;
          try {
            if (typeof i[c] != "function") {
              var f = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw f.name = "Invariant Violation", f;
            }
            d = i[c](a, c, l, s, null, e);
          } catch (h) {
            d = h;
          }
          if (d && !(d instanceof Error) && t(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var v = u ? u() : "";
            t(
              "Failed " + s + " type: " + d.message + (v ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, wl = o, wl;
}
var El, kp;
function PS() {
  if (kp) return El;
  kp = 1;
  var t = Sb(), e = LS(), n = Hc(), r = Pb(), o = SS(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return El = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(T) {
      var N = T && (u && T[u] || T[c]);
      if (typeof N == "function")
        return N;
    }
    var f = "<<anonymous>>", v = {
      array: w("array"),
      bigint: w("bigint"),
      bool: w("boolean"),
      func: w("function"),
      number: w("number"),
      object: w("object"),
      string: w("string"),
      symbol: w("symbol"),
      any: b(),
      arrayOf: k,
      element: E(),
      elementType: m(),
      instanceOf: O,
      node: $(),
      objectOf: W,
      oneOf: S,
      oneOfType: P,
      shape: _,
      exact: I
    };
    function h(T, N) {
      return T === N ? T !== 0 || 1 / T === 1 / N : T !== T && N !== N;
    }
    function g(T, N) {
      this.message = T, this.data = N && typeof N == "object" ? N : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function p(T) {
      if (process.env.NODE_ENV !== "production")
        var N = {}, Y = 0;
      function F(L, M, z, A, U, H, ee) {
        if (A = A || f, H = H || z, ee !== n) {
          if (l) {
            var Z = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw Z.name = "Invariant Violation", Z;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var pe = A + ":" + z;
            !N[pe] && // Avoid spamming the console because they are often not actionable except for lib authors
            Y < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + H + "` prop on `" + A + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), N[pe] = !0, Y++);
          }
        }
        return M[z] == null ? L ? M[z] === null ? new g("The " + U + " `" + H + "` is marked as required " + ("in `" + A + "`, but its value is `null`.")) : new g("The " + U + " `" + H + "` is marked as required in " + ("`" + A + "`, but its value is `undefined`.")) : null : T(M, z, A, U, H);
      }
      var X = F.bind(null, !1);
      return X.isRequired = F.bind(null, !0), X;
    }
    function w(T) {
      function N(Y, F, X, L, M, z) {
        var A = Y[F], U = J(A);
        if (U !== T) {
          var H = G(A);
          return new g(
            "Invalid " + L + " `" + M + "` of type " + ("`" + H + "` supplied to `" + X + "`, expected ") + ("`" + T + "`."),
            { expectedType: T }
          );
        }
        return null;
      }
      return p(N);
    }
    function b() {
      return p(a);
    }
    function k(T) {
      function N(Y, F, X, L, M) {
        if (typeof T != "function")
          return new g("Property `" + M + "` of component `" + X + "` has invalid PropType notation inside arrayOf.");
        var z = Y[F];
        if (!Array.isArray(z)) {
          var A = J(z);
          return new g("Invalid " + L + " `" + M + "` of type " + ("`" + A + "` supplied to `" + X + "`, expected an array."));
        }
        for (var U = 0; U < z.length; U++) {
          var H = T(z, U, X, L, M + "[" + U + "]", n);
          if (H instanceof Error)
            return H;
        }
        return null;
      }
      return p(N);
    }
    function E() {
      function T(N, Y, F, X, L) {
        var M = N[Y];
        if (!s(M)) {
          var z = J(M);
          return new g("Invalid " + X + " `" + L + "` of type " + ("`" + z + "` supplied to `" + F + "`, expected a single ReactElement."));
        }
        return null;
      }
      return p(T);
    }
    function m() {
      function T(N, Y, F, X, L) {
        var M = N[Y];
        if (!t.isValidElementType(M)) {
          var z = J(M);
          return new g("Invalid " + X + " `" + L + "` of type " + ("`" + z + "` supplied to `" + F + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return p(T);
    }
    function O(T) {
      function N(Y, F, X, L, M) {
        if (!(Y[F] instanceof T)) {
          var z = T.name || f, A = Q(Y[F]);
          return new g("Invalid " + L + " `" + M + "` of type " + ("`" + A + "` supplied to `" + X + "`, expected ") + ("instance of `" + z + "`."));
        }
        return null;
      }
      return p(N);
    }
    function S(T) {
      if (!Array.isArray(T))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function N(Y, F, X, L, M) {
        for (var z = Y[F], A = 0; A < T.length; A++)
          if (h(z, T[A]))
            return null;
        var U = JSON.stringify(T, function(H, ee) {
          var Z = G(ee);
          return Z === "symbol" ? String(ee) : ee;
        });
        return new g("Invalid " + L + " `" + M + "` of value `" + String(z) + "` " + ("supplied to `" + X + "`, expected one of " + U + "."));
      }
      return p(N);
    }
    function W(T) {
      function N(Y, F, X, L, M) {
        if (typeof T != "function")
          return new g("Property `" + M + "` of component `" + X + "` has invalid PropType notation inside objectOf.");
        var z = Y[F], A = J(z);
        if (A !== "object")
          return new g("Invalid " + L + " `" + M + "` of type " + ("`" + A + "` supplied to `" + X + "`, expected an object."));
        for (var U in z)
          if (r(z, U)) {
            var H = T(z, U, X, L, M + "." + U, n);
            if (H instanceof Error)
              return H;
          }
        return null;
      }
      return p(N);
    }
    function P(T) {
      if (!Array.isArray(T))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var N = 0; N < T.length; N++) {
        var Y = T[N];
        if (typeof Y != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(Y) + " at index " + N + "."
          ), a;
      }
      function F(X, L, M, z, A) {
        for (var U = [], H = 0; H < T.length; H++) {
          var ee = T[H], Z = ee(X, L, M, z, A, n);
          if (Z == null)
            return null;
          Z.data && r(Z.data, "expectedType") && U.push(Z.data.expectedType);
        }
        var pe = U.length > 0 ? ", expected one of type [" + U.join(", ") + "]" : "";
        return new g("Invalid " + z + " `" + A + "` supplied to " + ("`" + M + "`" + pe + "."));
      }
      return p(F);
    }
    function $() {
      function T(N, Y, F, X, L) {
        return R(N[Y]) ? null : new g("Invalid " + X + " `" + L + "` supplied to " + ("`" + F + "`, expected a ReactNode."));
      }
      return p(T);
    }
    function j(T, N, Y, F, X) {
      return new g(
        (T || "React class") + ": " + N + " type `" + Y + "." + F + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + X + "`."
      );
    }
    function _(T) {
      function N(Y, F, X, L, M) {
        var z = Y[F], A = J(z);
        if (A !== "object")
          return new g("Invalid " + L + " `" + M + "` of type `" + A + "` " + ("supplied to `" + X + "`, expected `object`."));
        for (var U in T) {
          var H = T[U];
          if (typeof H != "function")
            return j(X, L, M, U, G(H));
          var ee = H(z, U, X, L, M + "." + U, n);
          if (ee)
            return ee;
        }
        return null;
      }
      return p(N);
    }
    function I(T) {
      function N(Y, F, X, L, M) {
        var z = Y[F], A = J(z);
        if (A !== "object")
          return new g("Invalid " + L + " `" + M + "` of type `" + A + "` " + ("supplied to `" + X + "`, expected `object`."));
        var U = e({}, Y[F], T);
        for (var H in U) {
          var ee = T[H];
          if (r(T, H) && typeof ee != "function")
            return j(X, L, M, H, G(ee));
          if (!ee)
            return new g(
              "Invalid " + L + " `" + M + "` key `" + H + "` supplied to `" + X + "`.\nBad object: " + JSON.stringify(Y[F], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(T), null, "  ")
            );
          var Z = ee(z, H, X, L, M + "." + H, n);
          if (Z)
            return Z;
        }
        return null;
      }
      return p(N);
    }
    function R(T) {
      switch (typeof T) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !T;
        case "object":
          if (Array.isArray(T))
            return T.every(R);
          if (T === null || s(T))
            return !0;
          var N = d(T);
          if (N) {
            var Y = N.call(T), F;
            if (N !== T.entries) {
              for (; !(F = Y.next()).done; )
                if (!R(F.value))
                  return !1;
            } else
              for (; !(F = Y.next()).done; ) {
                var X = F.value;
                if (X && !R(X[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function V(T, N) {
      return T === "symbol" ? !0 : N ? N["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && N instanceof Symbol : !1;
    }
    function J(T) {
      var N = typeof T;
      return Array.isArray(T) ? "array" : T instanceof RegExp ? "object" : V(N, T) ? "symbol" : N;
    }
    function G(T) {
      if (typeof T > "u" || T === null)
        return "" + T;
      var N = J(T);
      if (N === "object") {
        if (T instanceof Date)
          return "date";
        if (T instanceof RegExp)
          return "regexp";
      }
      return N;
    }
    function te(T) {
      var N = G(T);
      switch (N) {
        case "array":
        case "object":
          return "an " + N;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + N;
        default:
          return N;
      }
    }
    function Q(T) {
      return !T.constructor || !T.constructor.name ? f : T.constructor.name;
    }
    return v.checkPropTypes = o, v.resetWarningCache = o.resetWarningCache, v.PropTypes = v, v;
  }, El;
}
var Dl, Mp;
function kS() {
  if (Mp) return Dl;
  Mp = 1;
  var t = Hc();
  function e() {
  }
  function n() {
  }
  return n.resetWarningCache = e, Dl = function() {
    function r(a, s, l, u, c, d) {
      if (d !== t) {
        var f = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw f.name = "Invariant Violation", f;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: e
    };
    return i.PropTypes = i, i;
  }, Dl;
}
if (process.env.NODE_ENV !== "production") {
  var MS = Sb(), BS = !0;
  Su.exports = PS()(MS.isElement, BS);
} else
  Su.exports = kS()();
var As = Su.exports, js = {};
Object.defineProperty(js, "__esModule", {
  value: !0
});
var TS = di, Ol = AS(TS);
function AS(t) {
  return t && t.__esModule ? t : { default: t };
}
var jS = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(t) {
    this.scroller = t, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(t, e) {
    this.containers[t] = e;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var t = this, e = this.getHash();
    e ? window.setTimeout(function() {
      t.scrollTo(e, !0), t.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(t, e) {
    var n = this.scroller, r = n.get(t);
    if (r && (e || t !== n.getActiveLink())) {
      var o = this.containers[t] || document;
      n.scrollTo(t, { container: o });
    }
  },
  getHash: function() {
    return Ol.default.getHash();
  },
  changeHash: function(t, e) {
    this.isInitialized() && Ol.default.getHash() !== t && Ol.default.updateHash(t, e);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
js.default = jS;
Object.defineProperty(li, "__esModule", {
  value: !0
});
var Ni = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
}, FS = /* @__PURE__ */ function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}(), _S = be, Bp = hi(_S), IS = ui, $i = hi(IS), RS = ho, NS = hi(RS), $S = As, Dt = hi($S), zS = js, rr = hi(zS);
function hi(t) {
  return t && t.__esModule ? t : { default: t };
}
function US(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function WS(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function HS(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
var Tp = {
  to: Dt.default.string.isRequired,
  containerId: Dt.default.string,
  container: Dt.default.object,
  activeClass: Dt.default.string,
  activeStyle: Dt.default.object,
  spy: Dt.default.bool,
  horizontal: Dt.default.bool,
  smooth: Dt.default.oneOfType([Dt.default.bool, Dt.default.string]),
  offset: Dt.default.number,
  delay: Dt.default.number,
  isDynamic: Dt.default.bool,
  onClick: Dt.default.func,
  duration: Dt.default.oneOfType([Dt.default.number, Dt.default.func]),
  absolute: Dt.default.bool,
  onSetActive: Dt.default.func,
  onSetInactive: Dt.default.func,
  ignoreCancelEvents: Dt.default.bool,
  hashSpy: Dt.default.bool,
  saveHashHistory: Dt.default.bool,
  spyThrottle: Dt.default.number
};
li.default = function(t, e) {
  var n = e || NS.default, r = function(i) {
    HS(a, i);
    function a(s) {
      US(this, a);
      var l = WS(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return FS(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var s = this.props.containerId, l = this.props.container;
        return s && !l ? document.getElementById(s) : l && l.nodeType ? l : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var s = this.getScrollSpyContainer();
          $i.default.isMounted(s) || $i.default.mount(s, this.props.spyThrottle), this.props.hashSpy && (rr.default.isMounted() || rr.default.mount(n), rr.default.mapContainer(this.props.to, s)), $i.default.addSpyHandler(this.spyHandler, s), this.setState({
            container: s
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        $i.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var s = "";
        this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
        var l = {};
        this.state && this.state.active ? l = Ni({}, this.props.style, this.props.activeStyle) : l = Ni({}, this.props.style);
        var u = Ni({}, this.props);
        for (var c in Tp)
          u.hasOwnProperty(c) && delete u[c];
        return u.className = s, u.style = l, u.onClick = this.handleClick, Bp.default.createElement(t, u);
      }
    }]), a;
  }(Bp.default.PureComponent), o = function() {
    var i = this;
    this.scrollTo = function(a, s) {
      n.scrollTo(a, Ni({}, i.state, s));
    }, this.handleClick = function(a) {
      i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
    }, this.spyHandler = function(a, s) {
      var l = i.getScrollSpyContainer();
      if (!(rr.default.isMounted() && !rr.default.isInitialized())) {
        var u = i.props.horizontal, c = i.props.to, d = null, f = void 0, v = void 0;
        if (u) {
          var h = 0, g = 0, p = 0;
          if (l.getBoundingClientRect) {
            var w = l.getBoundingClientRect();
            p = w.left;
          }
          if (!d || i.props.isDynamic) {
            if (d = n.get(c), !d)
              return;
            var b = d.getBoundingClientRect();
            h = b.left - p + a, g = h + b.width;
          }
          var k = a - i.props.offset;
          f = k >= Math.floor(h) && k < Math.floor(g), v = k < Math.floor(h) || k >= Math.floor(g);
        } else {
          var E = 0, m = 0, O = 0;
          if (l.getBoundingClientRect) {
            var S = l.getBoundingClientRect();
            O = S.top;
          }
          if (!d || i.props.isDynamic) {
            if (d = n.get(c), !d)
              return;
            var W = d.getBoundingClientRect();
            E = W.top - O + s, m = E + W.height;
          }
          var P = s - i.props.offset;
          f = P >= Math.floor(E) && P < Math.floor(m), v = P < Math.floor(E) || P >= Math.floor(m);
        }
        var $ = n.getActiveLink();
        if (v) {
          if (c === $ && n.setActiveLink(void 0), i.props.hashSpy && rr.default.getHash() === c) {
            var j = i.props.saveHashHistory, _ = j === void 0 ? !1 : j;
            rr.default.changeHash("", _);
          }
          i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive(c, d));
        }
        if (f && ($ !== c || i.state.active === !1)) {
          n.setActiveLink(c);
          var I = i.props.saveHashHistory, R = I === void 0 ? !1 : I;
          i.props.hashSpy && rr.default.changeHash(c, R), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(c, d));
        }
      }
    };
  };
  return r.propTypes = Tp, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(Nc, "__esModule", {
  value: !0
});
var VS = be, Ap = kb(VS), qS = li, GS = kb(qS);
function kb(t) {
  return t && t.__esModule ? t : { default: t };
}
function ZS(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function jp(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function KS(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
var YS = function(t) {
  KS(e, t);
  function e() {
    var n, r, o, i;
    ZS(this, e);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = jp(this, (n = e.__proto__ || Object.getPrototypeOf(e)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return Ap.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), jp(o, i);
  }
  return e;
}(Ap.default.Component);
Nc.default = (0, GS.default)(YS);
var Vc = {};
Object.defineProperty(Vc, "__esModule", {
  value: !0
});
var XS = /* @__PURE__ */ function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}(), JS = be, Fp = Mb(JS), QS = li, eP = Mb(QS);
function Mb(t) {
  return t && t.__esModule ? t : { default: t };
}
function tP(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function nP(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function rP(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
var oP = function(t) {
  rP(e, t);
  function e() {
    return tP(this, e), nP(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
  }
  return XS(e, [{
    key: "render",
    value: function() {
      return Fp.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), e;
}(Fp.default.Component);
Vc.default = (0, eP.default)(oP);
var qc = {}, Fs = {};
Object.defineProperty(Fs, "__esModule", {
  value: !0
});
var iP = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
}, aP = /* @__PURE__ */ function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}(), sP = be, _p = _s(sP), lP = nc;
_s(lP);
var uP = ho, Ip = _s(uP), cP = As, Rp = _s(cP);
function _s(t) {
  return t && t.__esModule ? t : { default: t };
}
function dP(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function fP(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function pP(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
Fs.default = function(t) {
  var e = function(n) {
    pP(r, n);
    function r(o) {
      dP(this, r);
      var i = fP(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return aP(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(o) {
        this.props.name !== o.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        Ip.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(o) {
        Ip.default.register(o, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return _p.default.createElement(t, iP({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(_p.default.Component);
  return e.propTypes = {
    name: Rp.default.string,
    id: Rp.default.string
  }, e;
};
Object.defineProperty(qc, "__esModule", {
  value: !0
});
var Np = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
}, hP = /* @__PURE__ */ function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}(), gP = be, $p = Gc(gP), vP = Fs, mP = Gc(vP), yP = As, zp = Gc(yP);
function Gc(t) {
  return t && t.__esModule ? t : { default: t };
}
function bP(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function CP(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function wP(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
var Bb = function(t) {
  wP(e, t);
  function e() {
    return bP(this, e), CP(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
  }
  return hP(e, [{
    key: "render",
    value: function() {
      var n = this, r = Np({}, this.props);
      return delete r.name, r.parentBindings && delete r.parentBindings, $p.default.createElement(
        "div",
        Np({}, r, { ref: function(o) {
          n.props.parentBindings.domNode = o;
        } }),
        this.props.children
      );
    }
  }]), e;
}($p.default.Component);
Bb.propTypes = {
  name: zp.default.string,
  id: zp.default.string
};
qc.default = (0, mP.default)(Bb);
var xl = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
}, Up = /* @__PURE__ */ function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}();
function Wp(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Hp(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function Vp(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
var zi = be, Mr = ui, Ll = ho, kt = As, or = js, qp = {
  to: kt.string.isRequired,
  containerId: kt.string,
  container: kt.object,
  activeClass: kt.string,
  spy: kt.bool,
  smooth: kt.oneOfType([kt.bool, kt.string]),
  offset: kt.number,
  delay: kt.number,
  isDynamic: kt.bool,
  onClick: kt.func,
  duration: kt.oneOfType([kt.number, kt.func]),
  absolute: kt.bool,
  onSetActive: kt.func,
  onSetInactive: kt.func,
  ignoreCancelEvents: kt.bool,
  hashSpy: kt.bool,
  spyThrottle: kt.number
}, EP = {
  Scroll: function(t, e) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var n = e || Ll, r = function(i) {
      Vp(a, i);
      function a(s) {
        Wp(this, a);
        var l = Hp(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
        return o.call(l), l.state = {
          active: !1
        }, l;
      }
      return Up(a, [{
        key: "getScrollSpyContainer",
        value: function() {
          var s = this.props.containerId, l = this.props.container;
          return s ? document.getElementById(s) : l && l.nodeType ? l : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var s = this.getScrollSpyContainer();
            Mr.isMounted(s) || Mr.mount(s, this.props.spyThrottle), this.props.hashSpy && (or.isMounted() || or.mount(n), or.mapContainer(this.props.to, s)), this.props.spy && Mr.addStateHandler(this.stateHandler), Mr.addSpyHandler(this.spyHandler, s), this.setState({
              container: s
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Mr.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var s = "";
          this.state && this.state.active ? s = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : s = this.props.className;
          var l = xl({}, this.props);
          for (var u in qp)
            l.hasOwnProperty(u) && delete l[u];
          return l.className = s, l.onClick = this.handleClick, zi.createElement(t, l);
        }
      }]), a;
    }(zi.Component), o = function() {
      var i = this;
      this.scrollTo = function(a, s) {
        n.scrollTo(a, xl({}, i.state, s));
      }, this.handleClick = function(a) {
        i.props.onClick && i.props.onClick(a), a.stopPropagation && a.stopPropagation(), a.preventDefault && a.preventDefault(), i.scrollTo(i.props.to, i.props);
      }, this.stateHandler = function() {
        n.getActiveLink() !== i.props.to && (i.state !== null && i.state.active && i.props.onSetInactive && i.props.onSetInactive(), i.setState({ active: !1 }));
      }, this.spyHandler = function(a) {
        var s = i.getScrollSpyContainer();
        if (!(or.isMounted() && !or.isInitialized())) {
          var l = i.props.to, u = null, c = 0, d = 0, f = 0;
          if (s.getBoundingClientRect) {
            var v = s.getBoundingClientRect();
            f = v.top;
          }
          if (!u || i.props.isDynamic) {
            if (u = n.get(l), !u)
              return;
            var h = u.getBoundingClientRect();
            c = h.top - f + a, d = c + h.height;
          }
          var g = a - i.props.offset, p = g >= Math.floor(c) && g < Math.floor(d), w = g < Math.floor(c) || g >= Math.floor(d), b = n.getActiveLink();
          if (w)
            return l === b && n.setActiveLink(void 0), i.props.hashSpy && or.getHash() === l && or.changeHash(), i.props.spy && i.state.active && (i.setState({ active: !1 }), i.props.onSetInactive && i.props.onSetInactive()), Mr.updateStates();
          if (p && b !== l)
            return n.setActiveLink(l), i.props.hashSpy && or.changeHash(l), i.props.spy && (i.setState({ active: !0 }), i.props.onSetActive && i.props.onSetActive(l)), Mr.updateStates();
        }
      };
    };
    return r.propTypes = qp, r.defaultProps = { offset: 0 }, r;
  },
  Element: function(t) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var e = function(n) {
      Vp(r, n);
      function r(o) {
        Wp(this, r);
        var i = Hp(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
        return i.childBindings = {
          domNode: null
        }, i;
      }
      return Up(r, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(o) {
          this.props.name !== o.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Ll.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(o) {
          Ll.register(o, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return zi.createElement(t, xl({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), r;
    }(zi.Component);
    return e.propTypes = {
      name: kt.string,
      id: kt.string
    }, e;
  }
}, DP = EP;
Object.defineProperty(At, "__esModule", {
  value: !0
});
At.Helpers = At.ScrollElement = At.ScrollLink = At.animateScroll = At.scrollSpy = At.Events = At.scroller = At.Element = At.Button = At.Link = void 0;
var OP = Nc, Tb = Wn(OP), xP = Vc, Ab = Wn(xP), LP = qc, jb = Wn(LP), SP = ho, Fb = Wn(SP), PP = fi, _b = Wn(PP), kP = ui, Ib = Wn(kP), MP = Ms, Rb = Wn(MP), BP = li, Nb = Wn(BP), TP = Fs, $b = Wn(TP), AP = DP, zb = Wn(AP);
function Wn(t) {
  return t && t.__esModule ? t : { default: t };
}
At.Link = Tb.default;
At.Button = Ab.default;
At.Element = jb.default;
At.scroller = Fb.default;
At.Events = _b.default;
At.scrollSpy = Ib.default;
At.animateScroll = Rb.default;
At.ScrollLink = Nb.default;
At.ScrollElement = $b.default;
At.Helpers = zb.default;
At.default = { Link: Tb.default, Button: Ab.default, Element: jb.default, scroller: Fb.default, Events: _b.default, scrollSpy: Ib.default, animateScroll: Rb.default, ScrollLink: Nb.default, ScrollElement: $b.default, Helpers: zb.default };
ct({});
ct({});
ct({});
function ni(t) {
  "@babel/helpers - typeof";
  return ni = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, ni(t);
}
function jP(t, e) {
  if (ni(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (ni(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function FP(t) {
  var e = jP(t, "string");
  return ni(e) == "symbol" ? e : e + "";
}
function ae(t, e, n) {
  return (e = FP(e)) in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function Ub(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Sl, Gp;
function _P() {
  if (Gp) return Sl;
  Gp = 1;
  var t = process.env.NODE_ENV, e = function(n, r, o, i, a, s, l, u) {
    if (t !== "production" && r === void 0)
      throw new Error("invariant requires an error message argument");
    if (!n) {
      var c;
      if (r === void 0)
        c = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var d = [o, i, a, s, l, u], f = 0;
        c = new Error(r.replace(/%s/g, function() {
          return d[f++];
        })), c.name = "Invariant Violation";
      }
      throw c.framesToPop = 1, c;
    }
  };
  return Sl = e, Sl;
}
var IP = _P(), Nt = /* @__PURE__ */ Ub(IP), je = ct(null);
function RP() {
  Nt(!!Ee, "useGoogleMap is React hook and requires React version 16.8+");
  var t = Ee(je);
  return Nt(!!t, "useGoogleMap needs a GoogleMap available up in the tree"), t;
}
function NP(t, e, n) {
  return Object.keys(t).reduce(function(r, o) {
    return e(r, t[o], o);
  }, n);
}
function $P(t, e) {
  Object.keys(t).forEach((n) => e(t[n], n));
}
function zP(t, e, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== e[s] && (o[s] = l, a(r, l));
  };
  return $P(t, i), o;
}
function UP(t, e, n) {
  var r = NP(n, function(o, i, a) {
    return typeof t[a] == "function" && o.push(google.maps.event.addListener(e, i, t[a])), o;
  }, []);
  return r;
}
function WP(t) {
  google.maps.event.removeListener(t);
}
function Ze() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  t.forEach(WP);
}
function Ge(t) {
  var {
    updaterMap: e,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = t, a = UP(o, i, n);
  return zP(e, r, o, i), a;
}
function HP(t) {
  var {
    children: e,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: d,
    onMouseMove: f,
    onMouseOut: v,
    onMouseOver: h,
    onMouseDown: g,
    onMouseUp: p,
    onRightClick: w,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: b,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: k,
    onUnmount: E
  } = t, [m, O] = B(null), S = qe(null), [W, P] = B(null), [$, j] = B(null), [_, I] = B(null), [R, V] = B(null), [J, G] = B(null), [te, Q] = B(null), [T, N] = B(null), [Y, F] = B(null), [X, L] = B(null), [M, z] = B(null), [A, U] = B(null), [H, ee] = B(null);
  return y(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), y(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), y(() => {
    m && l && ($ !== null && google.maps.event.removeListener($), j(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), y(() => {
    m && c && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), y(() => {
    m && d && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(m, "dragstart", d)));
  }, [d]), y(() => {
    m && g && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(m, "mousedown", g)));
  }, [g]), y(() => {
    m && f && (te !== null && google.maps.event.removeListener(te), Q(google.maps.event.addListener(m, "mousemove", f)));
  }, [f]), y(() => {
    m && v && (T !== null && google.maps.event.removeListener(T), N(google.maps.event.addListener(m, "mouseout", v)));
  }, [v]), y(() => {
    m && h && (Y !== null && google.maps.event.removeListener(Y), F(google.maps.event.addListener(m, "mouseover", h)));
  }, [h]), y(() => {
    m && p && (X !== null && google.maps.event.removeListener(X), L(google.maps.event.addListener(m, "mouseup", p)));
  }, [p]), y(() => {
    m && w && (M !== null && google.maps.event.removeListener(M), z(google.maps.event.addListener(m, "rightclick", w)));
  }, [w]), y(() => {
    m && s && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(m, "click", s)));
  }, [s]), y(() => {
    m && u && (H !== null && google.maps.event.removeListener(H), ee(google.maps.event.addListener(m, "drag", u)));
  }, [u]), y(() => {
    m && b && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(m, "center_changed", b)));
  }, [s]), y(() => {
    var Z = S.current === null ? null : new google.maps.Map(S.current, n);
    return O(Z), Z !== null && k && k(Z), () => {
      Z !== null && E && E(Z);
    };
  }, []), ut.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: ut.jsx(je.Provider, {
      value: m,
      children: m !== null ? e : null
    })
  });
}
Re(HP);
function Zp(t, e, n, r, o, i, a) {
  try {
    var s = t[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? e(l) : Promise.resolve(l).then(r, o);
}
function Wb(t) {
  return function() {
    var e = this, n = arguments;
    return new Promise(function(r, o) {
      var i = t.apply(e, n);
      function a(l) {
        Zp(i, r, o, a, s, "next", l);
      }
      function s(l) {
        Zp(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function Hb(t) {
  var {
    googleMapsApiKey: e,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = t, c = [];
  return Nt(e && n || !(e && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), e ? c.push("key=".concat(e)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var $r = typeof document < "u";
function Vb(t) {
  var {
    url: e,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = t;
  return $r ? new Promise(function(o, i) {
    var a = document.getElementById(n), s = window;
    if (a) {
      var l = a.getAttribute("data-state");
      if (a.src === e && l !== "error") {
        if (l === "ready")
          return o(n);
        var u = s.initMap, c = a.onerror;
        s.initMap = function() {
          u && u(), o(n);
        }, a.onerror = function(f) {
          c && c(f), i(f);
        };
        return;
      } else
        a.remove();
    }
    var d = document.createElement("script");
    d.type = "text/javascript", d.src = e, d.id = n, d.async = !0, d.nonce = r || "", d.onerror = function(f) {
      d.setAttribute("data-state", "error"), i(f);
    }, s.initMap = function() {
      d.setAttribute("data-state", "ready"), o(n);
    }, document.head.appendChild(d);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function Kp(t) {
  var e = t.href;
  return e && (e.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || e.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    t.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    t.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    t.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    t.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (t.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      t.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      t.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      t.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (t.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        t.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !t.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !t.innerHTML
      )
    )
  );
}
function qb() {
  var t = document.getElementsByTagName("head")[0];
  if (t) {
    var e = t.insertBefore.bind(t);
    t.insertBefore = function(r, o) {
      return Kp(r) || Reflect.apply(e, t, [r, o]), r;
    };
    var n = t.appendChild.bind(t);
    t.appendChild = function(r) {
      return Kp(r) || Reflect.apply(n, t, [r]), r;
    };
  }
}
var xo = !1;
function Gb() {
  return ut.jsx("div", {
    children: "Loading..."
  });
}
var Pu = {
  id: "script-loader",
  version: "weekly"
};
class VP extends xe {
  constructor() {
    super(...arguments), ae(this, "check", Cr()), ae(this, "state", {
      loaded: !1
    }), ae(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), ae(this, "isCleaningUp", /* @__PURE__ */ Wb(function* () {
      function e(n) {
        if (!xo)
          n();
        else if ($r)
          var r = window.setInterval(function() {
            xo || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(e);
    })), ae(this, "cleanup", () => {
      xo = !0;
      var e = document.getElementById(this.props.id);
      e && e.parentNode && e.parentNode.removeChild(e), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(n) {
        return typeof n.src == "string" && n.src.includes("maps.googleapis");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(n) {
        return n.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(n) {
        return n.innerText !== void 0 && n.innerText.length > 0 && n.innerText.includes(".gm-");
      }).forEach(function(n) {
        n.parentNode && n.parentNode.removeChild(n);
      });
    }), ae(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && qb(), Nt(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var e = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: Hb(this.props)
      };
      Vb(e).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if ($r) {
      if (window.google && window.google.maps && !xo) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(e) {
        console.error("Error at injecting script after cleaning up: ", e);
      });
    }
  }
  componentDidUpdate(e) {
    this.props.libraries !== e.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), $r && e.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if ($r) {
      this.cleanup();
      var e = () => {
        this.check.current || (delete window.google, xo = !1);
      };
      window.setTimeout(e, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return ut.jsxs(ut.Fragment, {
      children: [ut.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || ut.jsx(Gb, {})]
    });
  }
}
ae(VP, "defaultProps", Pu);
function qP(t, e) {
  if (t == null) return {};
  var n = {};
  for (var r in t) if ({}.hasOwnProperty.call(t, r)) {
    if (e.includes(r)) continue;
    n[r] = t[r];
  }
  return n;
}
function Zc(t, e) {
  if (t == null) return {};
  var n, r, o = qP(t, e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    for (r = 0; r < i.length; r++) n = i[r], e.includes(n) || {}.propertyIsEnumerable.call(t, n) && (o[n] = t[n]);
  }
  return o;
}
var Yp;
function GP(t) {
  var {
    id: e = Pu.id,
    version: n = Pu.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: d,
    authReferrerPolicy: f
  } = t, v = qe(!1), [h, g] = B(!1), [p, w] = B(void 0);
  y(function() {
    return v.current = !0, () => {
      v.current = !1;
    };
  }, []), y(function() {
    $r && u && qb();
  }, [u]), y(function() {
    h && Nt(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [h]);
  var b = Hb({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: d,
    authReferrerPolicy: f
  });
  y(function() {
    if (!$r)
      return;
    function E() {
      v.current && (g(!0), Yp = b);
    }
    if (window.google && window.google.maps && Yp === b) {
      E();
      return;
    }
    Vb({
      id: e,
      url: b,
      nonce: r
    }).then(E).catch(function(m) {
      v.current && w(m), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(m);
    });
  }, [e, b, r]);
  var k = qe();
  return y(function() {
    k.current && l !== k.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), k.current = l;
  }, [l]), {
    isLoaded: h,
    loadError: p,
    url: b
  };
}
var ZP = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], KP = ut.jsx(Gb, {});
function YP(t) {
  var {
    loadingElement: e,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = t, a = Zc(t, ZP), {
    isLoaded: s,
    loadError: l
  } = GP(a);
  return y(function() {
    s && typeof n == "function" && n();
  }, [s, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : e || KP;
}
Re(YP);
var Xp;
(function(t) {
  t[t.INITIALIZED = 0] = "INITIALIZED", t[t.LOADING = 1] = "LOADING", t[t.SUCCESS = 2] = "SUCCESS", t[t.FAILURE = 3] = "FAILURE";
})(Xp || (Xp = {}));
function Jp(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ta(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Jp(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Jp(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Qp = {}, eh = {
  options(t, e) {
    t.setOptions(e);
  }
};
function XP(t) {
  var {
    options: e,
    onLoad: n,
    onUnmount: r
  } = t, o = Ee(je), [i, a] = B(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    e && i !== null && i.setOptions(e);
  }, [i, e]), y(() => {
    var s = new google.maps.TrafficLayer(Ta(Ta({}, e), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Re(XP);
class JP extends xe {
  constructor() {
    super(...arguments), ae(this, "state", {
      trafficLayer: null
    }), ae(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), ae(this, "registeredEvents", []);
  }
  componentDidMount() {
    var e = new google.maps.TrafficLayer(Ta(Ta({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ge({
      updaterMap: eh,
      eventMap: Qp,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        trafficLayer: e
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(e) {
    this.state.trafficLayer !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: eh,
      eventMap: Qp,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), Ze(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ae(JP, "contextType", je);
function QP(t) {
  var {
    onLoad: e,
    onUnmount: n
  } = t, r = Ee(je), [o, i] = B(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), e && e(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Re(QP);
class ek extends xe {
  constructor() {
    super(...arguments), ae(this, "state", {
      bicyclingLayer: null
    }), ae(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var e = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: e
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ae(ek, "contextType", je);
function tk(t) {
  var {
    onLoad: e,
    onUnmount: n
  } = t, r = Ee(je), [o, i] = B(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), e && e(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Re(tk);
class nk extends xe {
  constructor() {
    super(...arguments), ae(this, "state", {
      transitLayer: null
    }), ae(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var e = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: e
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ae(nk, "contextType", je);
function th(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Aa(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? th(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : th(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var nh = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, rh = {
  drawingMode(t, e) {
    t.setDrawingMode(e);
  },
  options(t, e) {
    t.setOptions(e);
  }
};
function rk(t) {
  var {
    options: e,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = t, d = Ee(je), [f, v] = B(null), [h, g] = B(null), [p, w] = B(null), [b, k] = B(null), [E, m] = B(null), [O, S] = B(null), [W, P] = B(null);
  return y(() => {
    f !== null && f.setMap(d);
  }, [d]), y(() => {
    e && f !== null && f.setOptions(e);
  }, [f, e]), y(() => {
    f !== null && f.setDrawingMode(n ?? null);
  }, [f, n]), y(() => {
    f && r && (h !== null && google.maps.event.removeListener(h), g(google.maps.event.addListener(f, "circlecomplete", r)));
  }, [f, r]), y(() => {
    f && o && (p !== null && google.maps.event.removeListener(p), w(google.maps.event.addListener(f, "markercomplete", o)));
  }, [f, o]), y(() => {
    f && i && (b !== null && google.maps.event.removeListener(b), k(google.maps.event.addListener(f, "overlaycomplete", i)));
  }, [f, i]), y(() => {
    f && a && (E !== null && google.maps.event.removeListener(E), m(google.maps.event.addListener(f, "polygoncomplete", a)));
  }, [f, a]), y(() => {
    f && s && (O !== null && google.maps.event.removeListener(O), S(google.maps.event.addListener(f, "polylinecomplete", s)));
  }, [f, s]), y(() => {
    f && l && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(f, "rectanglecomplete", l)));
  }, [f, l]), y(() => {
    Nt(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var $ = new google.maps.drawing.DrawingManager(Aa(Aa({}, e), {}, {
      map: d
    }));
    return n && $.setDrawingMode(n), r && g(google.maps.event.addListener($, "circlecomplete", r)), o && w(google.maps.event.addListener($, "markercomplete", o)), i && k(google.maps.event.addListener($, "overlaycomplete", i)), a && m(google.maps.event.addListener($, "polygoncomplete", a)), s && S(google.maps.event.addListener($, "polylinecomplete", s)), l && P(google.maps.event.addListener($, "rectanglecomplete", l)), v($), u && u($), () => {
      f !== null && (h && google.maps.event.removeListener(h), p && google.maps.event.removeListener(p), b && google.maps.event.removeListener(b), E && google.maps.event.removeListener(E), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), c && c(f), f.setMap(null));
    };
  }, []), null;
}
Re(rk);
class ok extends xe {
  constructor(e) {
    super(e), ae(this, "registeredEvents", []), ae(this, "state", {
      drawingManager: null
    }), ae(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), Nt(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var e = new google.maps.drawing.DrawingManager(Aa(Aa({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ge({
      updaterMap: rh,
      eventMap: nh,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        drawingManager: e
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(e) {
    this.state.drawingManager !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: rh,
      eventMap: nh,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), Ze(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
ae(ok, "contextType", je);
function oh(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ro(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? oh(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : oh(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var ih = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, ah = {
  animation(t, e) {
    t.setAnimation(e);
  },
  clickable(t, e) {
    t.setClickable(e);
  },
  cursor(t, e) {
    t.setCursor(e);
  },
  draggable(t, e) {
    t.setDraggable(e);
  },
  icon(t, e) {
    t.setIcon(e);
  },
  label(t, e) {
    t.setLabel(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  opacity(t, e) {
    t.setOpacity(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  position(t, e) {
    t.setPosition(e);
  },
  shape(t, e) {
    t.setShape(e);
  },
  title(t, e) {
    t.setTitle(e);
  },
  visible(t, e) {
    t.setVisible(e);
  },
  zIndex(t, e) {
    t.setZIndex(e);
  }
}, ja = {};
function ik(t) {
  var {
    position: e,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: d,
    label: f,
    opacity: v,
    shape: h,
    title: g,
    zIndex: p,
    onClick: w,
    onDblClick: b,
    onDrag: k,
    onDragEnd: E,
    onDragStart: m,
    onMouseOut: O,
    onMouseOver: S,
    onMouseUp: W,
    onMouseDown: P,
    onRightClick: $,
    onClickableChanged: j,
    onCursorChanged: _,
    onAnimationChanged: I,
    onDraggableChanged: R,
    onFlatChanged: V,
    onIconChanged: J,
    onPositionChanged: G,
    onShapeChanged: te,
    onTitleChanged: Q,
    onVisibleChanged: T,
    onZindexChanged: N,
    onLoad: Y,
    onUnmount: F
  } = t, X = Ee(je), [L, M] = B(null), [z, A] = B(null), [U, H] = B(null), [ee, Z] = B(null), [pe, he] = B(null), [le, Le] = B(null), [Fe, Be] = B(null), [Ne, at] = B(null), [dt, Oe] = B(null), [ft, bt] = B(null), [De, ke] = B(null), [Ke, Je] = B(null), [Qe, Bt] = B(null), [He, Yt] = B(null), [Ft, It] = B(null), [Wt, fn] = B(null), [Ht, pn] = B(null), [_t, Xt] = B(null), [Rt, hn] = B(null), [Vt, Bn] = B(null), [gn, Tn] = B(null), [vn, An] = B(null);
  y(() => {
    L !== null && L.setMap(X);
  }, [X]), y(() => {
    typeof n < "u" && L !== null && L.setOptions(n);
  }, [L, n]), y(() => {
    typeof a < "u" && L !== null && L.setDraggable(a);
  }, [L, a]), y(() => {
    e && L !== null && L.setPosition(e);
  }, [L, e]), y(() => {
    typeof s < "u" && L !== null && L.setVisible(s);
  }, [L, s]), y(() => {
    L == null || L.setAnimation(l);
  }, [L, l]), y(() => {
    L && u !== void 0 && L.setClickable(u);
  }, [L, u]), y(() => {
    L && c !== void 0 && L.setCursor(c);
  }, [L, c]), y(() => {
    L && d !== void 0 && L.setIcon(d);
  }, [L, d]), y(() => {
    L && f !== void 0 && L.setLabel(f);
  }, [L, f]), y(() => {
    L && v !== void 0 && L.setOpacity(v);
  }, [L, v]), y(() => {
    L && h !== void 0 && L.setShape(h);
  }, [L, h]), y(() => {
    L && g !== void 0 && L.setTitle(g);
  }, [L, g]), y(() => {
    L && p !== void 0 && L.setZIndex(p);
  }, [L, p]), y(() => {
    L && b && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(L, "dblclick", b)));
  }, [b]), y(() => {
    L && E && (U !== null && google.maps.event.removeListener(U), H(google.maps.event.addListener(L, "dragend", E)));
  }, [E]), y(() => {
    L && m && (ee !== null && google.maps.event.removeListener(ee), Z(google.maps.event.addListener(L, "dragstart", m)));
  }, [m]), y(() => {
    L && P && (pe !== null && google.maps.event.removeListener(pe), he(google.maps.event.addListener(L, "mousedown", P)));
  }, [P]), y(() => {
    L && O && (le !== null && google.maps.event.removeListener(le), Le(google.maps.event.addListener(L, "mouseout", O)));
  }, [O]), y(() => {
    L && S && (Fe !== null && google.maps.event.removeListener(Fe), Be(google.maps.event.addListener(L, "mouseover", S)));
  }, [S]), y(() => {
    L && W && (Ne !== null && google.maps.event.removeListener(Ne), at(google.maps.event.addListener(L, "mouseup", W)));
  }, [W]), y(() => {
    L && $ && (dt !== null && google.maps.event.removeListener(dt), Oe(google.maps.event.addListener(L, "rightclick", $)));
  }, [$]), y(() => {
    L && w && (ft !== null && google.maps.event.removeListener(ft), bt(google.maps.event.addListener(L, "click", w)));
  }, [w]), y(() => {
    L && k && (De !== null && google.maps.event.removeListener(De), ke(google.maps.event.addListener(L, "drag", k)));
  }, [k]), y(() => {
    L && j && (Ke !== null && google.maps.event.removeListener(Ke), Je(google.maps.event.addListener(L, "clickable_changed", j)));
  }, [j]), y(() => {
    L && _ && (Qe !== null && google.maps.event.removeListener(Qe), Bt(google.maps.event.addListener(L, "cursor_changed", _)));
  }, [_]), y(() => {
    L && I && (He !== null && google.maps.event.removeListener(He), Yt(google.maps.event.addListener(L, "animation_changed", I)));
  }, [I]), y(() => {
    L && R && (Ft !== null && google.maps.event.removeListener(Ft), It(google.maps.event.addListener(L, "draggable_changed", R)));
  }, [R]), y(() => {
    L && V && (Wt !== null && google.maps.event.removeListener(Wt), fn(google.maps.event.addListener(L, "flat_changed", V)));
  }, [V]), y(() => {
    L && J && (Ht !== null && google.maps.event.removeListener(Ht), pn(google.maps.event.addListener(L, "icon_changed", J)));
  }, [J]), y(() => {
    L && G && (_t !== null && google.maps.event.removeListener(_t), Xt(google.maps.event.addListener(L, "position_changed", G)));
  }, [G]), y(() => {
    L && te && (Rt !== null && google.maps.event.removeListener(Rt), hn(google.maps.event.addListener(L, "shape_changed", te)));
  }, [te]), y(() => {
    L && Q && (Vt !== null && google.maps.event.removeListener(Vt), Bn(google.maps.event.addListener(L, "title_changed", Q)));
  }, [Q]), y(() => {
    L && T && (gn !== null && google.maps.event.removeListener(gn), Tn(google.maps.event.addListener(L, "visible_changed", T)));
  }, [T]), y(() => {
    L && N && (vn !== null && google.maps.event.removeListener(vn), An(google.maps.event.addListener(L, "zindex_changed", N)));
  }, [N]), y(() => {
    var Jt = ro(ro(ro({}, n || ja), r ? ja : {
      map: X
    }), {}, {
      position: e
    }), de = new google.maps.Marker(Jt);
    return r ? r.addMarker(de, !!o) : de.setMap(X), e && de.setPosition(e), typeof s < "u" && de.setVisible(s), typeof a < "u" && de.setDraggable(a), typeof u < "u" && de.setClickable(u), typeof c == "string" && de.setCursor(c), d && de.setIcon(d), typeof f < "u" && de.setLabel(f), typeof v < "u" && de.setOpacity(v), h && de.setShape(h), typeof g == "string" && de.setTitle(g), typeof p == "number" && de.setZIndex(p), b && A(google.maps.event.addListener(de, "dblclick", b)), E && H(google.maps.event.addListener(de, "dragend", E)), m && Z(google.maps.event.addListener(de, "dragstart", m)), P && he(google.maps.event.addListener(de, "mousedown", P)), O && Le(google.maps.event.addListener(de, "mouseout", O)), S && Be(google.maps.event.addListener(de, "mouseover", S)), W && at(google.maps.event.addListener(de, "mouseup", W)), $ && Oe(google.maps.event.addListener(de, "rightclick", $)), w && bt(google.maps.event.addListener(de, "click", w)), k && ke(google.maps.event.addListener(de, "drag", k)), j && Je(google.maps.event.addListener(de, "clickable_changed", j)), _ && Bt(google.maps.event.addListener(de, "cursor_changed", _)), I && Yt(google.maps.event.addListener(de, "animation_changed", I)), R && It(google.maps.event.addListener(de, "draggable_changed", R)), V && fn(google.maps.event.addListener(de, "flat_changed", V)), J && pn(google.maps.event.addListener(de, "icon_changed", J)), G && Xt(google.maps.event.addListener(de, "position_changed", G)), te && hn(google.maps.event.addListener(de, "shape_changed", te)), Q && Bn(google.maps.event.addListener(de, "title_changed", Q)), T && Tn(google.maps.event.addListener(de, "visible_changed", T)), N && An(google.maps.event.addListener(de, "zindex_changed", N)), M(de), Y && Y(de), () => {
      z !== null && google.maps.event.removeListener(z), U !== null && google.maps.event.removeListener(U), ee !== null && google.maps.event.removeListener(ee), pe !== null && google.maps.event.removeListener(pe), le !== null && google.maps.event.removeListener(le), Fe !== null && google.maps.event.removeListener(Fe), Ne !== null && google.maps.event.removeListener(Ne), dt !== null && google.maps.event.removeListener(dt), ft !== null && google.maps.event.removeListener(ft), Ke !== null && google.maps.event.removeListener(Ke), Qe !== null && google.maps.event.removeListener(Qe), He !== null && google.maps.event.removeListener(He), Ft !== null && google.maps.event.removeListener(Ft), Wt !== null && google.maps.event.removeListener(Wt), Ht !== null && google.maps.event.removeListener(Ht), _t !== null && google.maps.event.removeListener(_t), Vt !== null && google.maps.event.removeListener(Vt), gn !== null && google.maps.event.removeListener(gn), vn !== null && google.maps.event.removeListener(vn), F && F(de), r ? r.removeMarker(de, !!o) : de && de.setMap(null);
    };
  }, []);
  var Vn = En(() => i ? zt.map(i, (Jt) => {
    if (!ts(Jt))
      return Jt;
    var de = Jt;
    return ns(de, {
      anchor: L
    });
  }) : null, [i, L]);
  return ut.jsx(ut.Fragment, {
    children: Vn
  }) || null;
}
Re(ik);
class ak extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []);
  }
  componentDidMount() {
    var e = this;
    return Wb(function* () {
      var n = ro(ro(ro({}, e.props.options || ja), e.props.clusterer ? ja : {
        map: e.context
      }), {}, {
        position: e.props.position
      });
      e.marker = new google.maps.Marker(n), e.props.clusterer ? e.props.clusterer.addMarker(e.marker, !!e.props.noClustererRedraw) : e.marker.setMap(e.context), e.registeredEvents = Ge({
        updaterMap: ah,
        eventMap: ih,
        prevProps: {},
        nextProps: e.props,
        instance: e.marker
      }), e.props.onLoad && e.props.onLoad(e.marker);
    })();
  }
  componentDidUpdate(e) {
    this.marker && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: ah,
      eventMap: ih,
      prevProps: e,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), Ze(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var e = this.props.children ? zt.map(this.props.children, (n) => {
      if (!ts(n))
        return n;
      var r = n;
      return ns(r, {
        anchor: this.marker
      });
    }) : null;
    return e || null;
  }
}
ae(ak, "contextType", je);
var sk = (
  /** @class */
  function() {
    function t(e, n) {
      e.getClusterer().extend(t, google.maps.OverlayView), this.cluster = e, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(e.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return t.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, t.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, t.prototype.onClick = function(e) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
      }
    }, t.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, t.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, t.prototype.onAdd = function() {
      var e;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (e = this.getPanes()) === null || e === void 0 || e.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, t.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, t.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var e = this.getPosFromLatLng(this.center);
        this.div.style.top = e !== null ? "".concat(e.y, "px") : "0", this.div.style.left = e !== null ? "".concat(e.x, "px") : "0";
      }
    }, t.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, t.prototype.show = function() {
      var e, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((e = l[0]) === null || e === void 0 ? void 0 : e.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), d = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(d !== null ? "".concat(d.y, "px") : "0", "; left: ").concat(d !== null ? "".concat(d.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var f = document.createElement("img");
        f.alt = s, f.src = this.url, f.width = this.width, f.height = this.height, f.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (f.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var v = document.createElement("div");
        v.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (v.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (v.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(f), this.div.appendChild(v), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, t.prototype.useStyle = function(e) {
      this.sums = e;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, e.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, t.prototype.setCenter = function(e) {
      this.center = e;
    }, t.prototype.getPosFromLatLng = function(e) {
      var n = this.getProjection().fromLatLngToDivPixel(e);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, t;
  }()
), lk = (
  /** @class */
  function() {
    function t(e) {
      this.markerClusterer = e, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new sk(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return t.prototype.getSize = function() {
      return this.markers.length;
    }, t.prototype.getMarkers = function() {
      return this.markers;
    }, t.prototype.getCenter = function() {
      return this.center;
    }, t.prototype.getMap = function() {
      return this.map;
    }, t.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, t.prototype.getBounds = function() {
      for (var e = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && e.extend(a);
      }
      return e;
    }, t.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, t.prototype.addMarker = function(e) {
      var n;
      if (this.isMarkerAlreadyAdded(e))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = e.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = e.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      e.isAdded = !0, this.markers.push(e);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        e.getMap() !== this.map && e.setMap(this.map);
      else if (i < this.minClusterSize)
        e.getMap() !== this.map && e.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        e.setMap(null);
      return !0;
    }, t.prototype.isMarkerInClusterBounds = function(e) {
      if (this.bounds !== null) {
        var n = e.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, t.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, t.prototype.updateIcon = function() {
      var e, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (e = this.map) === null || e === void 0 ? void 0 : e.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, t.prototype.isMarkerAlreadyAdded = function(e) {
      if (this.markers.includes)
        return this.markers.includes(e);
      for (var n = 0; n < this.markers.length; n++)
        if (e === this.markers[n])
          return !0;
      return !1;
    }, t;
  }()
);
function uk(t, e) {
  var n = t.length, r = n.toString().length, o = Math.min(r, e);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var ck = 2e3, dk = 500, fk = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", pk = "png", hk = [53, 56, 66, 78, 90], gk = "cluster", Zb = (
  /** @class */
  function() {
    function t(e, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(t, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || fk, this.imageExtension = r.imageExtension || pk, this.imageSizes = r.imageSizes || hk, this.calculator = r.calculator || uk, this.batchSize = r.batchSize || ck, this.batchSizeIE = r.batchSizeIE || dk, this.clusterClass = r.clusterClass || gk, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(e);
    }
    return t.prototype.onZoomChanged = function() {
      var e, n;
      this.resetViewport(!1), (((e = this.getMap()) === null || e === void 0 ? void 0 : e.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, t.prototype.onIdle = function() {
      this.redraw();
    }, t.prototype.onAdd = function() {
      var e = this.getMap();
      this.activeMap = e, this.ready = !0, this.repaint(), e !== null && (this.listeners = [google.maps.event.addListener(e, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(e, "idle", this.onIdle)]);
    }, t.prototype.onRemove = function() {
      for (var e = 0, n = this.markers; e < n.length; e++) {
        var r = n[e];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, t.prototype.draw = function() {
    }, t.prototype.getMap = function() {
      return null;
    }, t.prototype.getPanes = function() {
      return null;
    }, t.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, t.prototype.setMap = function() {
    }, t.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, t.prototype.bindTo = function() {
    }, t.prototype.get = function() {
    }, t.prototype.notify = function() {
    }, t.prototype.set = function() {
    }, t.prototype.setValues = function() {
    }, t.prototype.unbind = function() {
    }, t.prototype.unbindAll = function() {
    }, t.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var e = 0; e < this.imageSizes.length; e++)
          this.styles.push({
            url: "".concat(this.imagePath + (e + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[e] || 0,
            width: this.imageSizes[e] || 0
          });
    }, t.prototype.fitMapToMarkers = function() {
      for (var e = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = e; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, t.prototype.getGridSize = function() {
      return this.gridSize;
    }, t.prototype.setGridSize = function(e) {
      this.gridSize = e;
    }, t.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, t.prototype.setMinimumClusterSize = function(e) {
      this.minClusterSize = e;
    }, t.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, t.prototype.setMaxZoom = function(e) {
      this.maxZoom = e;
    }, t.prototype.getStyles = function() {
      return this.styles;
    }, t.prototype.setStyles = function(e) {
      this.styles = e;
    }, t.prototype.getTitle = function() {
      return this.title;
    }, t.prototype.setTitle = function(e) {
      this.title = e;
    }, t.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, t.prototype.setZoomOnClick = function(e) {
      this.zoomOnClick = e;
    }, t.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, t.prototype.setAverageCenter = function(e) {
      this.averageCenter = e;
    }, t.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, t.prototype.setIgnoreHidden = function(e) {
      this.ignoreHidden = e;
    }, t.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, t.prototype.setEnableRetinaIcons = function(e) {
      this.enableRetinaIcons = e;
    }, t.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, t.prototype.setImageExtension = function(e) {
      this.imageExtension = e;
    }, t.prototype.getImagePath = function() {
      return this.imagePath;
    }, t.prototype.setImagePath = function(e) {
      this.imagePath = e;
    }, t.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, t.prototype.setImageSizes = function(e) {
      this.imageSizes = e;
    }, t.prototype.getCalculator = function() {
      return this.calculator;
    }, t.prototype.setCalculator = function(e) {
      this.calculator = e;
    }, t.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, t.prototype.setBatchSizeIE = function(e) {
      this.batchSizeIE = e;
    }, t.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, t.prototype.setClusterClass = function(e) {
      this.clusterClass = e;
    }, t.prototype.getMarkers = function() {
      return this.markers;
    }, t.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, t.prototype.getClusters = function() {
      return this.clusters;
    }, t.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, t.prototype.addMarker = function(e, n) {
      this.pushMarkerTo(e), n || this.redraw();
    }, t.prototype.addMarkers = function(e, n) {
      for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
          var o = e[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, t.prototype.pushMarkerTo = function(e) {
      var n = this;
      e.getDraggable() && google.maps.event.addListener(e, "dragend", function() {
        n.ready && (e.isAdded = !1, n.repaint());
      }), e.isAdded = !1, this.markers.push(e);
    }, t.prototype.removeMarker_ = function(e) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(e);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (e === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (e.setMap(null), this.markers.splice(n, 1), !0);
    }, t.prototype.removeMarker = function(e, n) {
      var r = this.removeMarker_(e);
      return !n && r && this.repaint(), r;
    }, t.prototype.removeMarkers = function(e, n) {
      for (var r = !1, o = 0, i = e; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, t.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, t.prototype.repaint = function() {
      var e = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var n = 0, r = e; n < r.length; n++) {
          var o = r[n];
          o.remove();
        }
      }, 0);
    }, t.prototype.getExtendedBounds = function(e) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(e.getNorthEast().lat(), e.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(e.getSouthWest().lat(), e.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && e.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && e.extend(a);
      }
      return e;
    }, t.prototype.redraw = function() {
      this.createClusters(0);
    }, t.prototype.resetViewport = function(e) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, e && s.setMap(null);
      }
    }, t.prototype.distanceBetweenPoints = function(e, n) {
      var r = 6371, o = (n.lat() - e.lat()) * Math.PI / 180, i = (n.lng() - e.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(e.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, t.prototype.isMarkerInBounds = function(e, n) {
      var r = e.getPosition();
      return r ? n.contains(r) : !1;
    }, t.prototype.addToClosestCluster = function(e) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = e.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(e) ? o.addMarker(e) : (n = new lk(this), n.addMarker(e), this.clusters.push(n));
    }, t.prototype.createClusters = function(e) {
      var n = this;
      if (this.ready) {
        e === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(e + this.batchSize, this.markers.length), u = e; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var d = 0, f = this.clusters; d < f.length; d++) {
            var v = f[d];
            v.updateIcon();
          }
        }
      }
    }, t.prototype.extend = function(e, n) {
      return (function(r) {
        for (var o in r.prototype) {
          var i = o;
          this.prototype[i] = r.prototype[i];
        }
        return this;
      }).apply(e, [n]);
    }, t;
  }()
);
function sh(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function vk(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? sh(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : sh(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Sn = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Ye = {
  averageCenter(t, e) {
    t.setAverageCenter(e);
  },
  batchSizeIE(t, e) {
    t.setBatchSizeIE(e);
  },
  calculator(t, e) {
    t.setCalculator(e);
  },
  clusterClass(t, e) {
    t.setClusterClass(e);
  },
  enableRetinaIcons(t, e) {
    t.setEnableRetinaIcons(e);
  },
  gridSize(t, e) {
    t.setGridSize(e);
  },
  ignoreHidden(t, e) {
    t.setIgnoreHidden(e);
  },
  imageExtension(t, e) {
    t.setImageExtension(e);
  },
  imagePath(t, e) {
    t.setImagePath(e);
  },
  imageSizes(t, e) {
    t.setImageSizes(e);
  },
  maxZoom(t, e) {
    t.setMaxZoom(e);
  },
  minimumClusterSize(t, e) {
    t.setMinimumClusterSize(e);
  },
  styles(t, e) {
    t.setStyles(e);
  },
  title(t, e) {
    t.setTitle(e);
  },
  zoomOnClick(t, e) {
    t.setZoomOnClick(e);
  }
}, mk = {};
function yk(t) {
  var {
    children: e,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: d,
    imageSizes: f,
    maxZoom: v,
    minimumClusterSize: h,
    styles: g,
    title: p,
    zoomOnClick: w,
    onClick: b,
    onClusteringBegin: k,
    onClusteringEnd: E,
    onMouseOver: m,
    onMouseOut: O,
    onLoad: S,
    onUnmount: W
  } = t, [P, $] = B(null), j = Ee(je), [_, I] = B(null), [R, V] = B(null), [J, G] = B(null), [te, Q] = B(null), [T, N] = B(null);
  return y(() => {
    P && O && (te !== null && google.maps.event.removeListener(te), Q(google.maps.event.addListener(P, Sn.onMouseOut, O)));
  }, [O]), y(() => {
    P && m && (T !== null && google.maps.event.removeListener(T), N(google.maps.event.addListener(P, Sn.onMouseOver, m)));
  }, [m]), y(() => {
    P && b && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(P, Sn.onClick, b)));
  }, [b]), y(() => {
    P && k && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(P, Sn.onClusteringBegin, k)));
  }, [k]), y(() => {
    P && E && (J !== null && google.maps.event.removeListener(J), V(google.maps.event.addListener(P, Sn.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && P !== null && Ye.averageCenter(P, r);
  }, [P, r]), y(() => {
    typeof o < "u" && P !== null && Ye.batchSizeIE(P, o);
  }, [P, o]), y(() => {
    typeof i < "u" && P !== null && Ye.calculator(P, i);
  }, [P, i]), y(() => {
    typeof a < "u" && P !== null && Ye.clusterClass(P, a);
  }, [P, a]), y(() => {
    typeof s < "u" && P !== null && Ye.enableRetinaIcons(P, s);
  }, [P, s]), y(() => {
    typeof l < "u" && P !== null && Ye.gridSize(P, l);
  }, [P, l]), y(() => {
    typeof u < "u" && P !== null && Ye.ignoreHidden(P, u);
  }, [P, u]), y(() => {
    typeof c < "u" && P !== null && Ye.imageExtension(P, c);
  }, [P, c]), y(() => {
    typeof d < "u" && P !== null && Ye.imagePath(P, d);
  }, [P, d]), y(() => {
    typeof f < "u" && P !== null && Ye.imageSizes(P, f);
  }, [P, f]), y(() => {
    typeof v < "u" && P !== null && Ye.maxZoom(P, v);
  }, [P, v]), y(() => {
    typeof h < "u" && P !== null && Ye.minimumClusterSize(P, h);
  }, [P, h]), y(() => {
    typeof g < "u" && P !== null && Ye.styles(P, g);
  }, [P, g]), y(() => {
    typeof p < "u" && P !== null && Ye.title(P, p);
  }, [P, p]), y(() => {
    typeof w < "u" && P !== null && Ye.zoomOnClick(P, w);
  }, [P, w]), y(() => {
    if (j) {
      var Y = vk({}, n || mk), F = new Zb(j, [], Y);
      return r && Ye.averageCenter(F, r), o && Ye.batchSizeIE(F, o), i && Ye.calculator(F, i), a && Ye.clusterClass(F, a), s && Ye.enableRetinaIcons(F, s), l && Ye.gridSize(F, l), u && Ye.ignoreHidden(F, u), c && Ye.imageExtension(F, c), d && Ye.imagePath(F, d), f && Ye.imageSizes(F, f), v && Ye.maxZoom(F, v), h && Ye.minimumClusterSize(F, h), g && Ye.styles(F, g), p && Ye.title(F, p), w && Ye.zoomOnClick(F, w), O && Q(google.maps.event.addListener(F, Sn.onMouseOut, O)), m && N(google.maps.event.addListener(F, Sn.onMouseOver, m)), b && I(google.maps.event.addListener(F, Sn.onClick, b)), k && V(google.maps.event.addListener(F, Sn.onClusteringBegin, k)), E && G(google.maps.event.addListener(F, Sn.onClusteringEnd, E)), $(F), S && S(F), () => {
        te !== null && google.maps.event.removeListener(te), T !== null && google.maps.event.removeListener(T), _ !== null && google.maps.event.removeListener(_), R !== null && google.maps.event.removeListener(R), J !== null && google.maps.event.removeListener(J), W && W(F);
      };
    }
  }, []), P !== null && e(P) || null;
}
Re(yk);
class bk extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      markerClusterer: null
    }), ae(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var e = new Zb(this.context, [], this.props.options);
      this.registeredEvents = Ge({
        updaterMap: Ye,
        eventMap: Sn,
        prevProps: {},
        nextProps: this.props,
        instance: e
      }), this.setState(() => ({
        markerClusterer: e
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(e) {
    this.state.markerClusterer && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Ye,
      eventMap: Sn,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), Ze(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
ae(bk, "contextType", je);
function lh(t) {
  t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
}
var Kb = (
  /** @class */
  function() {
    function t(e) {
      e === void 0 && (e = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(t, google.maps.OverlayView), this.content = e.content || "", this.disableAutoPan = e.disableAutoPan || !1, this.maxWidth = e.maxWidth || 0, this.pixelOffset = e.pixelOffset || new google.maps.Size(0, 0), this.position = e.position || new google.maps.LatLng(0, 0), this.zIndex = e.zIndex || null, this.boxClass = e.boxClass || "infoBox", this.boxStyle = e.boxStyle || {}, this.closeBoxMargin = e.closeBoxMargin || "2px", this.closeBoxURL = e.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", e.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = e.infoBoxClearance || new google.maps.Size(1, 1), typeof e.visible > "u" && (typeof e.isHidden > "u" ? e.visible = !0 : e.visible = !e.isHidden), this.isHidden = !e.visible, this.alignBottom = e.alignBottom || !1, this.pane = e.pane || "floatPane", this.enableEventPropagation = e.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return t.prototype.createInfoBoxDiv = function() {
      var e = this, n = function(u) {
        u.returnValue = !1, u.preventDefault && u.preventDefault(), e.enableEventPropagation || lh(u);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, lh));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            e.div && (e.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, t.prototype.getCloseBoxImg = function() {
      var e = "";
      return this.closeBoxURL !== "" && (e = '<img alt=""', e += ' aria-hidden="true"', e += " src='" + this.closeBoxURL + "'", e += " align=right", e += " style='", e += " position: relative;", e += " cursor: pointer;", e += " margin: " + this.closeBoxMargin + ";", e += "'>"), e;
    }, t.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, t.prototype.closeClickHandler = function(e) {
      e.cancelBubble = !0, e.stopPropagation && e.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, t.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, t.prototype.panBox = function(e) {
      if (this.div && !e) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, d = this.div.offsetWidth, f = this.div.offsetHeight, v = this.infoBoxClearance.width, h = this.infoBoxClearance.height, g = this.getProjection(), p = g.fromLatLngToContainerPixel(this.position);
          p !== null && (p.x < -u + v ? r = p.x + u - v : p.x + d + u + v > s && (r = p.x + d + u + v - s), this.alignBottom ? p.y < -c + h + f ? o = p.y + c - h - f : p.y + c + h > l && (o = p.y + c + h - l) : p.y < -c + h ? o = p.y + c - h : p.y + f + c + h > l && (o = p.y + f + c + h - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, t.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var e = this.boxStyle;
        for (var n in e)
          Object.prototype.hasOwnProperty.call(e, n) && (this.div.style[n] = e[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, t.prototype.getBoxWidths = function() {
      var e = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return e;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (e.top = parseInt(r.borderTopWidth || "", 10) || 0, e.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, e.left = parseInt(r.borderLeftWidth || "", 10) || 0, e.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (e.top = parseInt(o.borderTopWidth || "", 10) || 0, e.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, e.left = parseInt(o.borderLeftWidth || "", 10) || 0, e.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return e;
    }, t.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, t.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var e = this.getProjection(), n = e.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, t.prototype.setOptions = function(e) {
      e === void 0 && (e = {}), typeof e.boxClass < "u" && (this.boxClass = e.boxClass, this.setBoxStyle()), typeof e.boxStyle < "u" && (this.boxStyle = e.boxStyle, this.setBoxStyle()), typeof e.content < "u" && this.setContent(e.content), typeof e.disableAutoPan < "u" && (this.disableAutoPan = e.disableAutoPan), typeof e.maxWidth < "u" && (this.maxWidth = e.maxWidth), typeof e.pixelOffset < "u" && (this.pixelOffset = e.pixelOffset), typeof e.alignBottom < "u" && (this.alignBottom = e.alignBottom), typeof e.position < "u" && this.setPosition(e.position), typeof e.zIndex < "u" && this.setZIndex(e.zIndex), typeof e.closeBoxMargin < "u" && (this.closeBoxMargin = e.closeBoxMargin), typeof e.closeBoxURL < "u" && (this.closeBoxURL = e.closeBoxURL), typeof e.infoBoxClearance < "u" && (this.infoBoxClearance = e.infoBoxClearance), typeof e.isHidden < "u" && (this.isHidden = e.isHidden), typeof e.visible < "u" && (this.isHidden = !e.visible), typeof e.enableEventPropagation < "u" && (this.enableEventPropagation = e.enableEventPropagation), this.div && this.draw();
    }, t.prototype.setContent = function(e) {
      this.content = e, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof e == "string" ? this.div.innerHTML = this.getCloseBoxImg() + e : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(e)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof e == "string" ? this.div.innerHTML = this.getCloseBoxImg() + e : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(e))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, t.prototype.setPosition = function(e) {
      this.position = e, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, t.prototype.setVisible = function(e) {
      this.isHidden = !e, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, t.prototype.setZIndex = function(e) {
      this.zIndex = e, this.div && (this.div.style.zIndex = e + ""), google.maps.event.trigger(this, "zindex_changed");
    }, t.prototype.getContent = function() {
      return this.content;
    }, t.prototype.getPosition = function() {
      return this.position;
    }, t.prototype.getZIndex = function() {
      return this.zIndex;
    }, t.prototype.getVisible = function() {
      var e = this.getMap();
      return typeof e > "u" || e === null ? !1 : !this.isHidden;
    }, t.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, t.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, t.prototype.open = function(e, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(e), this.div && this.panBox();
    }, t.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var e = 0, n = this.eventListeners; e < n.length; e++) {
          var r = n[e];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, t.prototype.extend = function(e, n) {
      return (function(r) {
        for (var o in r.prototype)
          Object.prototype.hasOwnProperty.call(this, o) || (this.prototype[o] = r.prototype[o]);
        return this;
      }).apply(e, [n]);
    }, t;
  }()
), Ck = ["position"], wk = ["position"];
function uh(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Fa(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? uh(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : uh(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var ch = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, dh = {
  options(t, e) {
    t.setOptions(e);
  },
  position(t, e) {
    e instanceof google.maps.LatLng ? t.setPosition(e) : t.setPosition(new google.maps.LatLng(e.lat, e.lng));
  },
  visible(t, e) {
    t.setVisible(e);
  },
  zIndex(t, e) {
    t.setZIndex(e);
  }
}, Ek = {};
function Dk(t) {
  var {
    children: e,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: f
  } = t, v = Ee(je), [h, g] = B(null), [p, w] = B(null), [b, k] = B(null), [E, m] = B(null), [O, S] = B(null), [W, P] = B(null), $ = qe(null);
  return y(() => {
    v && h !== null && (h.close(), n ? h.open(v, n) : h.getPosition() && h.open(v));
  }, [v, h, n]), y(() => {
    r && h !== null && h.setOptions(r);
  }, [h, r]), y(() => {
    if (o && h !== null) {
      var j = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      h.setPosition(j);
    }
  }, [o]), y(() => {
    typeof i == "number" && h !== null && h.setZIndex(i);
  }, [i]), y(() => {
    h && a && (p !== null && google.maps.event.removeListener(p), w(google.maps.event.addListener(h, "closeclick", a)));
  }, [a]), y(() => {
    h && s && (b !== null && google.maps.event.removeListener(b), k(google.maps.event.addListener(h, "domready", s)));
  }, [s]), y(() => {
    h && l && (E !== null && google.maps.event.removeListener(E), m(google.maps.event.addListener(h, "content_changed", l)));
  }, [l]), y(() => {
    h && u && (O !== null && google.maps.event.removeListener(O), S(google.maps.event.addListener(h, "position_changed", u)));
  }, [u]), y(() => {
    h && c && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(h, "zindex_changed", c)));
  }, [c]), y(() => {
    if (v) {
      var j = r || Ek, {
        position: _
      } = j, I = Zc(j, Ck), R;
      _ && !(_ instanceof google.maps.LatLng) && (R = new google.maps.LatLng(_.lat, _.lng));
      var V = new Kb(Fa(Fa({}, I), R ? {
        position: R
      } : {}));
      $.current = document.createElement("div"), g(V), a && w(google.maps.event.addListener(V, "closeclick", a)), s && k(google.maps.event.addListener(V, "domready", s)), l && m(google.maps.event.addListener(V, "content_changed", l)), u && S(google.maps.event.addListener(V, "position_changed", u)), c && P(google.maps.event.addListener(V, "zindex_changed", c)), V.setContent($.current), n ? V.open(v, n) : V.getPosition() ? V.open(v) : Nt(!1, "You must provide either an anchor or a position prop for <InfoBox>."), d && d(V);
    }
    return () => {
      h !== null && (p && google.maps.event.removeListener(p), E && google.maps.event.removeListener(E), b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), f && f(h), h.close());
    };
  }, []), $.current ? wr(zt.only(e), $.current) : null;
}
Re(Dk);
class Ok extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "containerElement", null), ae(this, "state", {
      infoBox: null
    }), ae(this, "open", (e, n) => {
      n ? this.context !== null && e.open(this.context, n) : e.getPosition() ? this.context !== null && e.open(this.context) : Nt(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), ae(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var e = this.props.options || {}, {
      position: n
    } = e, r = Zc(e, wk), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new Kb(Fa(Fa({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = Ge({
      updaterMap: dh,
      eventMap: ch,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(e) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: dh,
      eventMap: ch,
      prevProps: e,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: e
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (e && e(n), Ze(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? wr(zt.only(this.props.children), this.containerElement) : null;
  }
}
ae(Ok, "contextType", je);
var fh, ph;
function xk() {
  return ph || (ph = 1, fh = function t(e, n) {
    if (e === n) return !0;
    if (e && n && typeof e == "object" && typeof n == "object") {
      if (e.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(e)) {
        if (r = e.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!t(e[o], n[o])) return !1;
        return !0;
      }
      if (e.constructor === RegExp) return e.source === n.source && e.flags === n.flags;
      if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === n.valueOf();
      if (e.toString !== Object.prototype.toString) return e.toString() === n.toString();
      if (i = Object.keys(e), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!t(e[a], n[a])) return !1;
      }
      return !0;
    }
    return e !== e && n !== n;
  }), fh;
}
var Lk = xk(), hh = /* @__PURE__ */ Ub(Lk), gh = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], Pl = 1, Lo = 8;
class Kc {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(e) {
    if (!(e instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(e, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== Pl)
      throw new Error("Got v".concat(o, " data when expected v").concat(Pl, "."));
    var i = gh[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(e, 2, 1), [s] = new Uint32Array(e, 4, 1);
    return new Kc(s, a, i, e);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(e) || e < 0) throw new Error("Unpexpected numItems value: ".concat(e, "."));
    this.numItems = +e, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
    var i = gh.indexOf(this.ArrayType), a = e * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = e * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Lo, e), this.coords = new this.ArrayType(this.data, Lo + s + l, e * 2), this._pos = e * 2, this._finished = !0) : (this.data = new ArrayBuffer(Lo + a + s + l), this.ids = new this.IndexArrayType(this.data, Lo, e), this.coords = new this.ArrayType(this.data, Lo + s + l, e * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (Pl << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = e);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(e, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = e, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var e = this._pos >> 1;
    if (e !== this.numItems)
      throw new Error("Added ".concat(e, " items when expected ").concat(this.numItems, "."));
    return ku(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(e, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, d = l.pop() || 0, f = l.pop() || 0;
      if (d - f <= s) {
        for (var v = f; v <= d; v++) {
          var h = a[2 * v], g = a[2 * v + 1];
          h >= e && h <= r && g >= n && g <= o && u.push(i[v]);
        }
        continue;
      }
      var p = f + d >> 1, w = a[2 * p], b = a[2 * p + 1];
      w >= e && w <= r && b >= n && b <= o && u.push(i[p]), (c === 0 ? e <= w : n <= b) && (l.push(f), l.push(p - 1), l.push(1 - c)), (c === 0 ? r >= w : o >= b) && (l.push(p + 1), l.push(d), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(e, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, d = s.pop() || 0, f = s.pop() || 0;
      if (d - f <= a) {
        for (var v = f; v <= d; v++)
          vh(i[2 * v], i[2 * v + 1], e, n) <= u && l.push(o[v]);
        continue;
      }
      var h = f + d >> 1, g = i[2 * h], p = i[2 * h + 1];
      vh(g, p, e, n) <= u && l.push(o[h]), (c === 0 ? e - r <= g : n - r <= p) && (s.push(f), s.push(h - 1), s.push(1 - c)), (c === 0 ? e + r >= g : n + r >= p) && (s.push(h + 1), s.push(d), s.push(1 - c));
    }
    return l;
  }
}
function ku(t, e, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    Yb(t, e, a, r, o, i), ku(t, e, n, r, a - 1, 1 - i), ku(t, e, n, a + 1, o, 1 - i);
  }
}
function Yb(t, e, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), d = Math.max(r, Math.floor(n - s * u / a + c)), f = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      Yb(t, e, n, d, f, i);
    }
    var v = e[2 * n + i], h = r, g = o;
    for (So(t, e, r, n), e[2 * o + i] > v && So(t, e, r, o); h < g; ) {
      for (So(t, e, h, g), h++, g--; e[2 * h + i] < v; ) h++;
      for (; e[2 * g + i] > v; ) g--;
    }
    e[2 * r + i] === v ? So(t, e, r, g) : (g++, So(t, e, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function So(t, e, n, r) {
  kl(t, n, r), kl(e, 2 * n, 2 * r), kl(e, 2 * n + 1, 2 * r + 1);
}
function kl(t, e, n) {
  var r = t[e];
  t[e] = t[n], t[n] = r;
}
function vh(t, e, n, r) {
  var o = t - n, i = e - r;
  return o * o + i * i;
}
var Sk = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (t) => t
  // props => ({sum: props.my_value})
}, mh = Math.fround || /* @__PURE__ */ ((t) => (e) => (t[0] = +e, t[0]))(new Float32Array(1)), Br = 2, cr = 3, Ml = 4, lr = 5, Xb = 6;
class Pk {
  constructor(e) {
    this.options = Object.assign(Object.create(Sk), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(e) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(e.length, " points");
    n && console.time(i), this.points = e;
    for (var a = [], s = 0; s < e.length; s++) {
      var l = e[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, d = mh(Ui(u)), f = mh(Wi(c));
        a.push(
          d,
          f,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var v = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var h = o; h >= r; h--) {
      var g = +Date.now();
      v = this.trees[h] = this._createTree(this._cluster(v, h)), n && console.log("z%d: %d clusters in %dms", h, v.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(e, n) {
    var r = ((e[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, e[1])), i = e[2] === 180 ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, e[3]));
    if (e[2] - e[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(Ui(r), Wi(a), Ui(i), Wi(o)), d = u.data, f = [];
    for (var v of c) {
      var h = this.stride * v;
      f.push(d[h + lr] > 1 ? yh(d, h, this.clusterProps) : this.points[d[h + cr]]);
    }
    return f;
  }
  getChildren(e) {
    var n = this._getOriginId(e), r = this._getOriginZoom(e), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), d = [];
    for (var f of c) {
      var v = f * this.stride;
      a[v + Ml] === e && d.push(a[v + lr] > 1 ? yh(a, v, this.clusterProps) : this.points[a[v + cr]]);
    }
    if (d.length === 0) throw new Error(o);
    return d;
  }
  getLeaves(e, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, e, n, r, 0), o;
  }
  getTile(e, n, r) {
    var o = this.trees[this._limitZoom(e)], i = Math.pow(2, e), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, d = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, d), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, d), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, d), d.features.length ? d : null;
  }
  getClusterExpansionZoom(e) {
    for (var n = this._getOriginZoom(e) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(e);
      if (n++, r.length !== 1) break;
      e = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(e, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(e, l.cluster_id, r, o, i) : i < o ? i++ : e.push(s), e.length === r) break;
    }
    return i;
  }
  _createTree(e) {
    for (var n = new Kc(e.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < e.length; r += this.stride) n.add(e[r], e[r + 1]);
    return n.finish(), n.data = e, n;
  }
  _addTileFeatures(e, n, r, o, i, a) {
    for (var s of e) {
      var l = s * this.stride, u = n[l + lr] > 1, c = void 0, d = void 0, f = void 0;
      if (u)
        c = Jb(n, l, this.clusterProps), d = n[l], f = n[l + 1];
      else {
        var v = this.points[n[l + cr]];
        c = v.properties;
        var [h, g] = v.geometry.coordinates;
        d = Ui(h), f = Wi(g);
      }
      var p = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (d * i - r)), Math.round(this.options.extent * (f * i - o))]],
        tags: c
      }, w = void 0;
      u || this.options.generateId ? w = n[l + cr] : w = this.points[n[l + cr]].id, w !== void 0 && (p.id = w), a.features.push(p);
    }
  }
  _limitZoom(e) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
  }
  _cluster(e, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = e.data, u = [], c = this.stride, d = 0; d < l.length; d += c)
      if (!(l[d + Br] <= n)) {
        l[d + Br] = n;
        var f = l[d], v = l[d + 1], h = e.within(l[d], l[d + 1], s), g = l[d + lr], p = g;
        for (var w of h) {
          var b = w * c;
          l[b + Br] > n && (p += l[b + lr]);
        }
        if (p > g && p >= a) {
          var k = f * g, E = v * g, m = void 0, O = -1, S = ((d / c | 0) << 5) + (n + 1) + this.points.length;
          for (var W of h) {
            var P = W * c;
            if (!(l[P + Br] <= n)) {
              l[P + Br] = n;
              var $ = l[P + lr];
              k += l[P] * $, E += l[P + 1] * $, l[P + Ml] = S, i && (m || (m = this._map(l, d, !0), O = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, P)));
            }
          }
          l[d + Ml] = S, u.push(k / p, E / p, 1 / 0, S, -1, p), i && u.push(O);
        } else {
          for (var j = 0; j < c; j++) u.push(l[d + j]);
          if (p > 1)
            for (var _ of h) {
              var I = _ * c;
              if (!(l[I + Br] <= n)) {
                l[I + Br] = n;
                for (var R = 0; R < c; R++) u.push(l[I + R]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(e) {
    return e - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(e) {
    return (e - this.points.length) % 32;
  }
  _map(e, n, r) {
    if (e[n + lr] > 1) {
      var o = this.clusterProps[e[n + Xb]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[e[n + cr]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function yh(t, e, n) {
  return {
    type: "Feature",
    id: t[e + cr],
    properties: Jb(t, e, n),
    geometry: {
      type: "Point",
      coordinates: [kk(t[e]), Mk(t[e + 1])]
    }
  };
}
function Jb(t, e, n) {
  var r = t[e + lr], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = t[e + Xb], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: t[e + cr],
    point_count: r,
    point_count_abbreviated: o
  });
}
function Ui(t) {
  return t / 360 + 0.5;
}
function Wi(t) {
  var e = Math.sin(t * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + e) / (1 - e)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function kk(t) {
  return (t - 0.5) * 360;
}
function Mk(t) {
  var e = (180 - t * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(e)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function Bk(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(t); o < r.length; o++)
    e.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[o]) && (n[r[o]] = t[r[o]]);
  return n;
}
class bn {
  static isAdvancedMarkerAvailable(e) {
    return google.maps.marker && e.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(e) {
    return google.maps.marker && e instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(e, n) {
    this.isAdvancedMarker(e) ? e.map = n : e.setMap(n);
  }
  static getPosition(e) {
    if (this.isAdvancedMarker(e)) {
      if (e.position) {
        if (e.position instanceof google.maps.LatLng)
          return e.position;
        if (e.position.lat && e.position.lng)
          return new google.maps.LatLng(e.position.lat, e.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return e.getPosition();
  }
  static getVisible(e) {
    return this.isAdvancedMarker(e) ? !0 : e.getVisible();
  }
}
class Mu {
  constructor(e) {
    var {
      markers: n,
      position: r
    } = e;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var e = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        e.extend(bn.getPosition(n));
      return e;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((e) => bn.getVisible(e)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(e) {
    this.markers.push(e);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (bn.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class Tk {
  constructor(e) {
    var {
      maxZoom: n = 16
    } = e;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(e) {
    var {
      markers: n
    } = e;
    return Ak(n);
  }
}
var Ak = (t) => {
  var e = t.map((n) => new Mu({
    position: bn.getPosition(n),
    markers: [n]
  }));
  return e;
};
class jk extends Tk {
  constructor(e) {
    var {
      maxZoom: n,
      radius: r = 60
    } = e, o = Bk(e, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new Pk(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(e) {
    var n = !1, r = {
      zoom: e.map.getZoom()
    };
    if (!hh(e.markers, this.markers)) {
      n = !0, this.markers = [...e.markers];
      var o = this.markers.map((i) => {
        var a = bn.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !hh(this.state, r)), this.state = r, n && (this.clusters = this.cluster(e)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(e) {
    var {
      map: n
    } = e;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(e) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = e;
    if (o.cluster)
      return new Mu({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Mu({
      markers: [i],
      position: bn.getPosition(i)
    });
  }
}
class Fk {
  constructor(e, n) {
    this.markers = {
      sum: e.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class _k {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(e, n, r) {
    var {
      count: o,
      position: i
    } = e, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (bn.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), d = c.parseFromString(s, "image/svg+xml").documentElement;
      d.setAttribute("transform", "translate(0 25)");
      var f = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: d
      };
      return new google.maps.marker.AdvancedMarkerElement(f);
    }
    var v = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(v);
  }
}
function Ik(t, e) {
  for (var n in e.prototype)
    t.prototype[n] = e.prototype[n];
}
class Yc {
  constructor() {
    Ik(Yc, google.maps.OverlayView);
  }
}
var Uo;
(function(t) {
  t.CLUSTERING_BEGIN = "clusteringbegin", t.CLUSTERING_END = "clusteringend", t.CLUSTER_CLICK = "click";
})(Uo || (Uo = {}));
var Rk = (t, e, n) => {
  n.fitBounds(e.bounds);
};
class Nk extends Yc {
  constructor(e) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new jk(o),
      renderer: a = new _k(),
      onClusterClick: s = Rk
    } = e;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(e, n) {
    this.markers.includes(e) || (this.markers.push(e), n || this.render());
  }
  addMarkers(e, n) {
    e.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(e, n) {
    var r = this.markers.indexOf(e);
    return r === -1 ? !1 : (bn.setMap(e, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(e, n) {
    var r = !1;
    return e.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(e) {
    this.markers.length = 0, e || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var e = this.getMap();
    if (e instanceof google.maps.Map && e.getProjection()) {
      google.maps.event.trigger(this, Uo.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: e,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || bn.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => bn.setMap(l, null)));
      }
      google.maps.event.trigger(this, Uo.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((e) => bn.setMap(e, null)), this.clusters.forEach((e) => e.delete()), this.clusters = [];
  }
  renderClusters() {
    var e = new Fk(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, e, n), r.markers.forEach((o) => bn.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, Uo.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), bn.setMap(r.marker, n);
    });
  }
}
function bh(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ch(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? bh(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : bh(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function $k(t) {
  var e = RP(), [n, r] = B(null);
  return y(() => {
    if (e && n === null) {
      var o = new Nk(Ch(Ch({}, t), {}, {
        map: e
      }));
      r(o);
    }
  }, [e]), n;
}
function zk(t) {
  var {
    children: e,
    options: n
  } = t, r = $k(n);
  return r !== null ? e(r) : null;
}
Re(zk);
var wh = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Eh = {
  options(t, e) {
    t.setOptions(e);
  },
  position(t, e) {
    t.setPosition(e);
  },
  zIndex(t, e) {
    t.setZIndex(e);
  }
};
function Uk(t) {
  var {
    children: e,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: f
  } = t, v = Ee(je), [h, g] = B(null), [p, w] = B(null), [b, k] = B(null), [E, m] = B(null), [O, S] = B(null), [W, P] = B(null), $ = qe(null);
  return y(() => {
    h !== null && (h.close(), n ? h.open(v, n) : h.getPosition() && h.open(v));
  }, [v, h, n]), y(() => {
    r && h !== null && h.setOptions(r);
  }, [h, r]), y(() => {
    o && h !== null && h.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && h !== null && h.setZIndex(i);
  }, [i]), y(() => {
    h && a && (p !== null && google.maps.event.removeListener(p), w(google.maps.event.addListener(h, "closeclick", a)));
  }, [a]), y(() => {
    h && s && (b !== null && google.maps.event.removeListener(b), k(google.maps.event.addListener(h, "domready", s)));
  }, [s]), y(() => {
    h && l && (E !== null && google.maps.event.removeListener(E), m(google.maps.event.addListener(h, "content_changed", l)));
  }, [l]), y(() => {
    h && u && (O !== null && google.maps.event.removeListener(O), S(google.maps.event.addListener(h, "position_changed", u)));
  }, [u]), y(() => {
    h && c && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(h, "zindex_changed", c)));
  }, [c]), y(() => {
    var j = new google.maps.InfoWindow(r);
    return g(j), $.current = document.createElement("div"), a && w(google.maps.event.addListener(j, "closeclick", a)), s && k(google.maps.event.addListener(j, "domready", s)), l && m(google.maps.event.addListener(j, "content_changed", l)), u && S(google.maps.event.addListener(j, "position_changed", u)), c && P(google.maps.event.addListener(j, "zindex_changed", c)), j.setContent($.current), o && j.setPosition(o), i && j.setZIndex(i), n ? j.open(v, n) : j.getPosition() ? j.open(v) : Nt(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), d && d(j), () => {
      p && google.maps.event.removeListener(p), E && google.maps.event.removeListener(E), b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), f && f(j), j.close();
    };
  }, []), $.current ? wr(zt.only(e), $.current) : null;
}
Re(Uk);
class Wk extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "containerElement", null), ae(this, "state", {
      infoWindow: null
    }), ae(this, "open", (e, n) => {
      n ? e.open(this.context, n) : e.getPosition() ? e.open(this.context) : Nt(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), ae(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var e = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = Ge({
      updaterMap: Eh,
      eventMap: wh,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(() => ({
      infoWindow: e
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(e) {
    this.state.infoWindow !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Eh,
      eventMap: wh,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (Ze(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? wr(zt.only(this.props.children), this.containerElement) : null;
  }
}
ae(Wk, "contextType", je);
function Dh(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function _a(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Dh(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Dh(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Oh = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, xh = {
  draggable(t, e) {
    t.setDraggable(e);
  },
  editable(t, e) {
    t.setEditable(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  path(t, e) {
    t.setPath(e);
  },
  visible(t, e) {
    t.setVisible(e);
  }
}, Hk = {};
function Vk(t) {
  var {
    options: e,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: f,
    onMouseUp: v,
    onRightClick: h,
    onClick: g,
    onDrag: p,
    onLoad: w,
    onUnmount: b
  } = t, k = Ee(je), [E, m] = B(null), [O, S] = B(null), [W, P] = B(null), [$, j] = B(null), [_, I] = B(null), [R, V] = B(null), [J, G] = B(null), [te, Q] = B(null), [T, N] = B(null), [Y, F] = B(null), [X, L] = B(null), [M, z] = B(null);
  return y(() => {
    E !== null && E.setMap(k);
  }, [k]), y(() => {
    typeof e < "u" && E !== null && E.setOptions(e);
  }, [E, e]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && a && (O !== null && google.maps.event.removeListener(O), S(google.maps.event.addListener(E, "dblclick", a)));
  }, [a]), y(() => {
    E && s && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(E, "dragend", s)));
  }, [s]), y(() => {
    E && l && ($ !== null && google.maps.event.removeListener($), j(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && d && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(E, "mouseout", d)));
  }, [d]), y(() => {
    E && f && (te !== null && google.maps.event.removeListener(te), Q(google.maps.event.addListener(E, "mouseover", f)));
  }, [f]), y(() => {
    E && v && (T !== null && google.maps.event.removeListener(T), N(google.maps.event.addListener(E, "mouseup", v)));
  }, [v]), y(() => {
    E && h && (Y !== null && google.maps.event.removeListener(Y), F(google.maps.event.addListener(E, "rightclick", h)));
  }, [h]), y(() => {
    E && g && (X !== null && google.maps.event.removeListener(X), L(google.maps.event.addListener(E, "click", g)));
  }, [g]), y(() => {
    E && p && (M !== null && google.maps.event.removeListener(M), z(google.maps.event.addListener(E, "drag", p)));
  }, [p]), y(() => {
    var A = new google.maps.Polyline(_a(_a({}, e || Hk), {}, {
      map: k
    }));
    return i && A.setPath(i), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), a && S(google.maps.event.addListener(A, "dblclick", a)), s && P(google.maps.event.addListener(A, "dragend", s)), l && j(google.maps.event.addListener(A, "dragstart", l)), u && I(google.maps.event.addListener(A, "mousedown", u)), c && V(google.maps.event.addListener(A, "mousemove", c)), d && G(google.maps.event.addListener(A, "mouseout", d)), f && Q(google.maps.event.addListener(A, "mouseover", f)), v && N(google.maps.event.addListener(A, "mouseup", v)), h && F(google.maps.event.addListener(A, "rightclick", h)), g && L(google.maps.event.addListener(A, "click", g)), p && z(google.maps.event.addListener(A, "drag", p)), m(A), w && w(A), () => {
      O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), $ !== null && google.maps.event.removeListener($), _ !== null && google.maps.event.removeListener(_), R !== null && google.maps.event.removeListener(R), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), T !== null && google.maps.event.removeListener(T), Y !== null && google.maps.event.removeListener(Y), X !== null && google.maps.event.removeListener(X), b && b(A), A.setMap(null);
    };
  }, []), null;
}
Re(Vk);
class qk extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      polyline: null
    }), ae(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var e = new google.maps.Polyline(_a(_a({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ge({
      updaterMap: xh,
      eventMap: Oh,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        polyline: e
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(e) {
    this.state.polyline !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: xh,
      eventMap: Oh,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), Ze(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
ae(qk, "contextType", je);
function Lh(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Sh(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Lh(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Lh(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Ph = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, kh = {
  draggable(t, e) {
    t.setDraggable(e);
  },
  editable(t, e) {
    t.setEditable(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  path(t, e) {
    t.setPath(e);
  },
  paths(t, e) {
    t.setPaths(e);
  },
  visible(t, e) {
    t.setVisible(e);
  }
};
function Gk(t) {
  var {
    options: e,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: f,
    onMouseOver: v,
    onMouseUp: h,
    onRightClick: g,
    onClick: p,
    onDrag: w,
    onLoad: b,
    onUnmount: k,
    onEdit: E
  } = t, m = Ee(je), [O, S] = B(null), [W, P] = B(null), [$, j] = B(null), [_, I] = B(null), [R, V] = B(null), [J, G] = B(null), [te, Q] = B(null), [T, N] = B(null), [Y, F] = B(null), [X, L] = B(null), [M, z] = B(null), [A, U] = B(null);
  return y(() => {
    O !== null && O.setMap(m);
  }, [m]), y(() => {
    typeof e < "u" && O !== null && O.setOptions(e);
  }, [O, e]), y(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), y(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), y(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), y(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), y(() => {
    typeof a < "u" && O !== null && O.setPaths(a);
  }, [O, a]), y(() => {
    O && typeof s == "function" && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(O, "dblclick", s)));
  }, [s]), y(() => {
    O && (google.maps.event.addListener(O.getPath(), "insert_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "set_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "remove_at", () => {
      E == null || E(O);
    }));
  }, [O, E]), y(() => {
    O && typeof l == "function" && ($ !== null && google.maps.event.removeListener($), j(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), y(() => {
    O && typeof u == "function" && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), y(() => {
    O && typeof c == "function" && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), y(() => {
    O && typeof d == "function" && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(O, "mousemove", d)));
  }, [d]), y(() => {
    O && typeof f == "function" && (te !== null && google.maps.event.removeListener(te), Q(google.maps.event.addListener(O, "mouseout", f)));
  }, [f]), y(() => {
    O && typeof v == "function" && (T !== null && google.maps.event.removeListener(T), N(google.maps.event.addListener(O, "mouseover", v)));
  }, [v]), y(() => {
    O && typeof h == "function" && (Y !== null && google.maps.event.removeListener(Y), F(google.maps.event.addListener(O, "mouseup", h)));
  }, [h]), y(() => {
    O && typeof g == "function" && (X !== null && google.maps.event.removeListener(X), L(google.maps.event.addListener(O, "rightclick", g)));
  }, [g]), y(() => {
    O && typeof p == "function" && (M !== null && google.maps.event.removeListener(M), z(google.maps.event.addListener(O, "click", p)));
  }, [p]), y(() => {
    O && typeof w == "function" && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(O, "drag", w)));
  }, [w]), y(() => {
    var H = new google.maps.Polygon(Sh(Sh({}, e), {}, {
      map: m
    }));
    return i && H.setPath(i), a && H.setPaths(a), typeof o < "u" && H.setVisible(o), typeof r < "u" && H.setEditable(r), typeof n < "u" && H.setDraggable(n), s && P(google.maps.event.addListener(H, "dblclick", s)), l && j(google.maps.event.addListener(H, "dragend", l)), u && I(google.maps.event.addListener(H, "dragstart", u)), c && V(google.maps.event.addListener(H, "mousedown", c)), d && G(google.maps.event.addListener(H, "mousemove", d)), f && Q(google.maps.event.addListener(H, "mouseout", f)), v && N(google.maps.event.addListener(H, "mouseover", v)), h && F(google.maps.event.addListener(H, "mouseup", h)), g && L(google.maps.event.addListener(H, "rightclick", g)), p && z(google.maps.event.addListener(H, "click", p)), w && U(google.maps.event.addListener(H, "drag", w)), S(H), b && b(H), () => {
      W !== null && google.maps.event.removeListener(W), $ !== null && google.maps.event.removeListener($), _ !== null && google.maps.event.removeListener(_), R !== null && google.maps.event.removeListener(R), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), T !== null && google.maps.event.removeListener(T), Y !== null && google.maps.event.removeListener(Y), X !== null && google.maps.event.removeListener(X), M !== null && google.maps.event.removeListener(M), k && k(H), H.setMap(null);
    };
  }, []), null;
}
Re(Gk);
class Zk extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []);
  }
  componentDidMount() {
    var e = this.props.options || {};
    this.polygon = new google.maps.Polygon(e), this.polygon.setMap(this.context), this.registeredEvents = Ge({
      updaterMap: kh,
      eventMap: Ph,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(e) {
    this.polygon && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: kh,
      eventMap: Ph,
      prevProps: e,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), Ze(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
ae(Zk, "contextType", je);
function Mh(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ia(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Mh(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Mh(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Bh = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Th = {
  bounds(t, e) {
    t.setBounds(e);
  },
  draggable(t, e) {
    t.setDraggable(e);
  },
  editable(t, e) {
    t.setEditable(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  visible(t, e) {
    t.setVisible(e);
  }
};
function Kk(t) {
  var {
    options: e,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: f,
    onMouseUp: v,
    onRightClick: h,
    onClick: g,
    onDrag: p,
    onBoundsChanged: w,
    onLoad: b,
    onUnmount: k
  } = t, E = Ee(je), [m, O] = B(null), [S, W] = B(null), [P, $] = B(null), [j, _] = B(null), [I, R] = B(null), [V, J] = B(null), [G, te] = B(null), [Q, T] = B(null), [N, Y] = B(null), [F, X] = B(null), [L, M] = B(null), [z, A] = B(null), [U, H] = B(null);
  return y(() => {
    m !== null && m.setMap(E);
  }, [E]), y(() => {
    typeof e < "u" && m !== null && m.setOptions(e);
  }, [m, e]), y(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), y(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), y(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), y(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), y(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), y(() => {
    m && s && (P !== null && google.maps.event.removeListener(P), $(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), y(() => {
    m && l && (j !== null && google.maps.event.removeListener(j), _(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), y(() => {
    m && u && (I !== null && google.maps.event.removeListener(I), R(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), y(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), y(() => {
    m && d && (G !== null && google.maps.event.removeListener(G), te(google.maps.event.addListener(m, "mouseout", d)));
  }, [d]), y(() => {
    m && f && (Q !== null && google.maps.event.removeListener(Q), T(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), y(() => {
    m && v && (N !== null && google.maps.event.removeListener(N), Y(google.maps.event.addListener(m, "mouseup", v)));
  }, [v]), y(() => {
    m && h && (F !== null && google.maps.event.removeListener(F), X(google.maps.event.addListener(m, "rightclick", h)));
  }, [h]), y(() => {
    m && g && (L !== null && google.maps.event.removeListener(L), M(google.maps.event.addListener(m, "click", g)));
  }, [g]), y(() => {
    m && p && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(m, "drag", p)));
  }, [p]), y(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), H(google.maps.event.addListener(m, "bounds_changed", w)));
  }, [w]), y(() => {
    var ee = new google.maps.Rectangle(Ia(Ia({}, e), {}, {
      map: E
    }));
    return typeof i < "u" && ee.setVisible(i), typeof o < "u" && ee.setEditable(o), typeof r < "u" && ee.setDraggable(r), typeof n < "u" && ee.setBounds(n), a && W(google.maps.event.addListener(ee, "dblclick", a)), s && $(google.maps.event.addListener(ee, "dragend", s)), l && _(google.maps.event.addListener(ee, "dragstart", l)), u && R(google.maps.event.addListener(ee, "mousedown", u)), c && J(google.maps.event.addListener(ee, "mousemove", c)), d && te(google.maps.event.addListener(ee, "mouseout", d)), f && T(google.maps.event.addListener(ee, "mouseover", f)), v && Y(google.maps.event.addListener(ee, "mouseup", v)), h && X(google.maps.event.addListener(ee, "rightclick", h)), g && M(google.maps.event.addListener(ee, "click", g)), p && A(google.maps.event.addListener(ee, "drag", p)), w && H(google.maps.event.addListener(ee, "bounds_changed", w)), O(ee), b && b(ee), () => {
      S !== null && google.maps.event.removeListener(S), P !== null && google.maps.event.removeListener(P), j !== null && google.maps.event.removeListener(j), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), N !== null && google.maps.event.removeListener(N), F !== null && google.maps.event.removeListener(F), L !== null && google.maps.event.removeListener(L), z !== null && google.maps.event.removeListener(z), U !== null && google.maps.event.removeListener(U), k && k(ee), ee.setMap(null);
    };
  }, []), null;
}
Re(Kk);
class Yk extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      rectangle: null
    }), ae(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var e = new google.maps.Rectangle(Ia(Ia({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ge({
      updaterMap: Th,
      eventMap: Bh,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        rectangle: e
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(e) {
    this.state.rectangle !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Th,
      eventMap: Bh,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), Ze(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
ae(Yk, "contextType", je);
function Ah(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ra(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Ah(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Ah(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var jh = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, Fh = {
  center(t, e) {
    t.setCenter(e);
  },
  draggable(t, e) {
    t.setDraggable(e);
  },
  editable(t, e) {
    t.setEditable(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  radius(t, e) {
    t.setRadius(e);
  },
  visible(t, e) {
    t.setVisible(e);
  }
}, Xk = {};
function Jk(t) {
  var {
    options: e,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: f,
    onMouseOver: v,
    onMouseUp: h,
    onRightClick: g,
    onClick: p,
    onDrag: w,
    onCenterChanged: b,
    onRadiusChanged: k,
    onLoad: E,
    onUnmount: m
  } = t, O = Ee(je), [S, W] = B(null), [P, $] = B(null), [j, _] = B(null), [I, R] = B(null), [V, J] = B(null), [G, te] = B(null), [Q, T] = B(null), [N, Y] = B(null), [F, X] = B(null), [L, M] = B(null), [z, A] = B(null), [U, H] = B(null), [ee, Z] = B(null), [pe, he] = B(null);
  return y(() => {
    S !== null && S.setMap(O);
  }, [O]), y(() => {
    typeof e < "u" && S !== null && S.setOptions(e);
  }, [S, e]), y(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), y(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), y(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), y(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), y(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), y(() => {
    S && s && (P !== null && google.maps.event.removeListener(P), $(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), y(() => {
    S && l && (j !== null && google.maps.event.removeListener(j), _(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), y(() => {
    S && u && (I !== null && google.maps.event.removeListener(I), R(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), y(() => {
    S && c && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), y(() => {
    S && d && (G !== null && google.maps.event.removeListener(G), te(google.maps.event.addListener(S, "mousemove", d)));
  }, [d]), y(() => {
    S && f && (Q !== null && google.maps.event.removeListener(Q), T(google.maps.event.addListener(S, "mouseout", f)));
  }, [f]), y(() => {
    S && v && (N !== null && google.maps.event.removeListener(N), Y(google.maps.event.addListener(S, "mouseover", v)));
  }, [v]), y(() => {
    S && h && (F !== null && google.maps.event.removeListener(F), X(google.maps.event.addListener(S, "mouseup", h)));
  }, [h]), y(() => {
    S && g && (L !== null && google.maps.event.removeListener(L), M(google.maps.event.addListener(S, "rightclick", g)));
  }, [g]), y(() => {
    S && p && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(S, "click", p)));
  }, [p]), y(() => {
    S && w && (U !== null && google.maps.event.removeListener(U), H(google.maps.event.addListener(S, "drag", w)));
  }, [w]), y(() => {
    S && b && (ee !== null && google.maps.event.removeListener(ee), Z(google.maps.event.addListener(S, "center_changed", b)));
  }, [p]), y(() => {
    S && k && (pe !== null && google.maps.event.removeListener(pe), he(google.maps.event.addListener(S, "radius_changed", k)));
  }, [k]), y(() => {
    var le = new google.maps.Circle(Ra(Ra({}, e || Xk), {}, {
      map: O
    }));
    return typeof r == "number" && le.setRadius(r), typeof n < "u" && le.setCenter(n), typeof r == "number" && le.setRadius(r), typeof a < "u" && le.setVisible(a), typeof i < "u" && le.setEditable(i), typeof o < "u" && le.setDraggable(o), s && $(google.maps.event.addListener(le, "dblclick", s)), l && _(google.maps.event.addListener(le, "dragend", l)), u && R(google.maps.event.addListener(le, "dragstart", u)), c && J(google.maps.event.addListener(le, "mousedown", c)), d && te(google.maps.event.addListener(le, "mousemove", d)), f && T(google.maps.event.addListener(le, "mouseout", f)), v && Y(google.maps.event.addListener(le, "mouseover", v)), h && X(google.maps.event.addListener(le, "mouseup", h)), g && M(google.maps.event.addListener(le, "rightclick", g)), p && A(google.maps.event.addListener(le, "click", p)), w && H(google.maps.event.addListener(le, "drag", w)), b && Z(google.maps.event.addListener(le, "center_changed", b)), k && he(google.maps.event.addListener(le, "radius_changed", k)), W(le), E && E(le), () => {
      P !== null && google.maps.event.removeListener(P), j !== null && google.maps.event.removeListener(j), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), N !== null && google.maps.event.removeListener(N), F !== null && google.maps.event.removeListener(F), L !== null && google.maps.event.removeListener(L), z !== null && google.maps.event.removeListener(z), ee !== null && google.maps.event.removeListener(ee), pe !== null && google.maps.event.removeListener(pe), m && m(le), le.setMap(null);
    };
  }, []), null;
}
Re(Jk);
class Qk extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      circle: null
    }), ae(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var e = new google.maps.Circle(Ra(Ra({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ge({
      updaterMap: Fh,
      eventMap: jh,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        circle: e
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(e) {
    this.state.circle !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Fh,
      eventMap: jh,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var e;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), Ze(this.registeredEvents), (e = this.state.circle) === null || e === void 0 || e.setMap(null);
    }
  }
  render() {
    return null;
  }
}
ae(Qk, "contextType", je);
function _h(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Na(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? _h(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : _h(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Ih = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, Rh = {
  add(t, e) {
    t.add(e);
  },
  addgeojson(t, e, n) {
    t.addGeoJson(e, n);
  },
  contains(t, e) {
    t.contains(e);
  },
  foreach(t, e) {
    t.forEach(e);
  },
  loadgeojson(t, e, n, r) {
    t.loadGeoJson(e, n, r);
  },
  overridestyle(t, e, n) {
    t.overrideStyle(e, n);
  },
  remove(t, e) {
    t.remove(e);
  },
  revertstyle(t, e) {
    t.revertStyle(e);
  },
  controlposition(t, e) {
    t.setControlPosition(e);
  },
  controls(t, e) {
    t.setControls(e);
  },
  drawingmode(t, e) {
    t.setDrawingMode(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  style(t, e) {
    t.setStyle(e);
  },
  togeojson(t, e) {
    t.toGeoJson(e);
  }
};
function eM(t) {
  var {
    options: e,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: d,
    onRemoveProperty: f,
    onSetGeometry: v,
    onSetProperty: h,
    onLoad: g,
    onUnmount: p
  } = t, w = Ee(je), [b, k] = B(null), [E, m] = B(null), [O, S] = B(null), [W, P] = B(null), [$, j] = B(null), [_, I] = B(null), [R, V] = B(null), [J, G] = B(null), [te, Q] = B(null), [T, N] = B(null), [Y, F] = B(null), [X, L] = B(null), [M, z] = B(null), [A, U] = B(null);
  return y(() => {
    b !== null && b.setMap(w);
  }, [w]), y(() => {
    b && r && (E !== null && google.maps.event.removeListener(E), m(google.maps.event.addListener(b, "dblclick", r)));
  }, [r]), y(() => {
    b && o && (O !== null && google.maps.event.removeListener(O), S(google.maps.event.addListener(b, "mousedown", o)));
  }, [o]), y(() => {
    b && i && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(b, "mousemove", i)));
  }, [i]), y(() => {
    b && a && ($ !== null && google.maps.event.removeListener($), j(google.maps.event.addListener(b, "mouseout", a)));
  }, [a]), y(() => {
    b && s && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(b, "mouseover", s)));
  }, [s]), y(() => {
    b && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(b, "mouseup", l)));
  }, [l]), y(() => {
    b && u && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(b, "rightclick", u)));
  }, [u]), y(() => {
    b && n && (te !== null && google.maps.event.removeListener(te), Q(google.maps.event.addListener(b, "click", n)));
  }, [n]), y(() => {
    b && c && (T !== null && google.maps.event.removeListener(T), N(google.maps.event.addListener(b, "addfeature", c)));
  }, [c]), y(() => {
    b && d && (Y !== null && google.maps.event.removeListener(Y), F(google.maps.event.addListener(b, "removefeature", d)));
  }, [d]), y(() => {
    b && f && (X !== null && google.maps.event.removeListener(X), L(google.maps.event.addListener(b, "removeproperty", f)));
  }, [f]), y(() => {
    b && v && (M !== null && google.maps.event.removeListener(M), z(google.maps.event.addListener(b, "setgeometry", v)));
  }, [v]), y(() => {
    b && h && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(b, "setproperty", h)));
  }, [h]), y(() => {
    if (w !== null) {
      var H = new google.maps.Data(Na(Na({}, e), {}, {
        map: w
      }));
      r && m(google.maps.event.addListener(H, "dblclick", r)), o && S(google.maps.event.addListener(H, "mousedown", o)), i && P(google.maps.event.addListener(H, "mousemove", i)), a && j(google.maps.event.addListener(H, "mouseout", a)), s && I(google.maps.event.addListener(H, "mouseover", s)), l && V(google.maps.event.addListener(H, "mouseup", l)), u && G(google.maps.event.addListener(H, "rightclick", u)), n && Q(google.maps.event.addListener(H, "click", n)), c && N(google.maps.event.addListener(H, "addfeature", c)), d && F(google.maps.event.addListener(H, "removefeature", d)), f && L(google.maps.event.addListener(H, "removeproperty", f)), v && z(google.maps.event.addListener(H, "setgeometry", v)), h && U(google.maps.event.addListener(H, "setproperty", h)), k(H), g && g(H);
    }
    return () => {
      b && (E !== null && google.maps.event.removeListener(E), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), $ !== null && google.maps.event.removeListener($), _ !== null && google.maps.event.removeListener(_), R !== null && google.maps.event.removeListener(R), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), T !== null && google.maps.event.removeListener(T), Y !== null && google.maps.event.removeListener(Y), X !== null && google.maps.event.removeListener(X), M !== null && google.maps.event.removeListener(M), A !== null && google.maps.event.removeListener(A), p && p(b), b.setMap(null));
    };
  }, []), null;
}
Re(eM);
class tM extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      data: null
    }), ae(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var e = new google.maps.Data(Na(Na({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = Ge({
        updaterMap: Rh,
        eventMap: Ih,
        prevProps: {},
        nextProps: this.props,
        instance: e
      }), this.setState(() => ({
        data: e
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(e) {
    this.state.data !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Rh,
      eventMap: Ih,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), Ze(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
ae(tM, "contextType", je);
function Nh(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $h(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Nh(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Nh(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var zh = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Uh = {
  options(t, e) {
    t.setOptions(e);
  },
  url(t, e) {
    t.setUrl(e);
  },
  zIndex(t, e) {
    t.setZIndex(e);
  }
};
class nM extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      kmlLayer: null
    }), ae(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var e = new google.maps.KmlLayer($h($h({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ge({
      updaterMap: Uh,
      eventMap: zh,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        kmlLayer: e
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(e) {
    this.state.kmlLayer !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Uh,
      eventMap: zh,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), Ze(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ae(nM, "contextType", je);
function Qb(t, e) {
  return typeof e == "function" ? e(t.offsetWidth, t.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function rM(t, e) {
  return new e(t.lat, t.lng);
}
function oM(t, e) {
  return new e(new google.maps.LatLng(t.ne.lat, t.ne.lng), new google.maps.LatLng(t.sw.lat, t.sw.lng));
}
function iM(t, e, n) {
  return t instanceof e ? t : n(t, e);
}
function aM(t, e, n) {
  return t instanceof e ? t : n(t, e);
}
function sM(t, e, n) {
  var r = t && t.fromLatLngToDivPixel(n.getNorthEast()), o = t && t.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + e.x, "px"),
    top: "".concat(r.y + e.y, "px"),
    width: "".concat(r.x - o.x - e.x, "px"),
    height: "".concat(o.y - r.y - e.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function lM(t, e, n) {
  var r = t && t.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + e.x, "px"),
      top: "".concat(i + e.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function e0(t, e, n, r) {
  return n !== void 0 ? sM(t, e, aM(n, google.maps.LatLngBounds, oM)) : lM(t, e, iM(r, google.maps.LatLng, rM));
}
function uM(t, e) {
  return t.left === e.left && t.top === e.top && t.width === e.height && t.height === e.height;
}
function Wh(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function cM(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Wh(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Wh(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function dM(t, e, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = cM({}, this.container ? Qb(this.container, o) : {
        x: 0,
        y: 0
      }), u = e0(s, l, this.bounds, this.position);
      for (var [c, d] of Object.entries(u))
        this.container.style[c] = d;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(t, e, n, r);
}
function Hh(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function fM(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Hh(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Hh(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function Vh(t) {
  if (!t)
    return "";
  var e = t instanceof google.maps.LatLng ? t : new google.maps.LatLng(t.lat, t.lng);
  return e + "";
}
function qh(t) {
  if (!t)
    return "";
  var e = t instanceof google.maps.LatLngBounds ? t : new google.maps.LatLngBounds(new google.maps.LatLng(t.south, t.east), new google.maps.LatLng(t.north, t.west));
  return e + "";
}
function pM(t) {
  var {
    position: e,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = t, u = Ee(je), c = En(() => {
    var f = document.createElement("div");
    return f.style.position = "absolute", f;
  }, []), d = En(() => dM(c, r, e, n, s), [c, r, e, n]);
  return y(() => (i == null || i(d), d == null || d.setMap(u), () => {
    a == null || a(d), d == null || d.setMap(null);
  }), [u, d]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), rs.createPortal(l, c);
}
Re(pM);
class go extends xe {
  constructor(e) {
    super(e), ae(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), ae(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      Nt(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), ae(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), ae(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = fM({
        x: 0,
        y: 0
      }, this.containerRef.current ? Qb(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = e0(r, o, this.props.bounds, this.props.position);
      if (!uM(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), ae(this, "draw", () => {
      this.onPositionElement();
    }), ae(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Cr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(e) {
    var n = Vh(e.position), r = Vh(this.props.position), o = qh(e.bounds), i = qh(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), e.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var e = this.state.paneEl;
    return e ? rs.createPortal(ut.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: zt.only(this.props.children)
    }), e) : null;
  }
}
ae(go, "FLOAT_PANE", "floatPane");
ae(go, "MAP_PANE", "mapPane");
ae(go, "MARKER_LAYER", "markerLayer");
ae(go, "OVERLAY_LAYER", "overlayLayer");
ae(go, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
ae(go, "contextType", je);
function hM() {
}
function Gh(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zh(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Gh(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Gh(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Kh = {
  onDblClick: "dblclick",
  onClick: "click"
}, Yh = {
  opacity(t, e) {
    t.setOpacity(e);
  }
};
function gM(t) {
  var {
    url: e,
    bounds: n,
    options: r,
    visible: o
  } = t, i = Ee(je), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = En(() => new google.maps.GroundOverlay(e, a, r), []);
  return y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    typeof e < "u" && s !== null && (s.set("url", e), s.setMap(i));
  }, [s, e]), y(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
Re(gM);
class t0 extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      groundOverlay: null
    }), ae(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    Nt(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var e = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Zh(Zh({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = Ge({
      updaterMap: Yh,
      eventMap: Kh,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        groundOverlay: e
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(e) {
    this.state.groundOverlay !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Yh,
      eventMap: Kh,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
ae(t0, "defaultProps", {
  onLoad: hM
});
ae(t0, "contextType", je);
function Xh(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function $a(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Xh(Object(n), !0).forEach(function(r) {
      ae(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Xh(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Jh = {}, Qh = {
  data(t, e) {
    t.setData(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  options(t, e) {
    t.setOptions(e);
  }
};
function vM(t) {
  var {
    data: e,
    onLoad: n,
    onUnmount: r,
    options: o
  } = t, i = Ee(je), [a, s] = B(null);
  return y(() => {
    google.maps.visualization || Nt(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    Nt(!!e, "data property is required in HeatmapLayer %s", e);
  }, [e]), y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer($a($a({}, o), {}, {
      data: e,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Re(vM);
class mM extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      heatmapLayer: null
    }), ae(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    Nt(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), Nt(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var e = new google.maps.visualization.HeatmapLayer($a($a({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = Ge({
      updaterMap: Qh,
      eventMap: Jh,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        heatmapLayer: e
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(e) {
    Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: Qh,
      eventMap: Jh,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), Ze(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
ae(mM, "contextType", je);
var eg = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, tg = {
  register(t, e, n) {
    t.registerPanoProvider(e, n);
  },
  links(t, e) {
    t.setLinks(e);
  },
  motionTracking(t, e) {
    t.setMotionTracking(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  pano(t, e) {
    t.setPano(e);
  },
  position(t, e) {
    t.setPosition(e);
  },
  pov(t, e) {
    t.setPov(e);
  },
  visible(t, e) {
    t.setVisible(e);
  },
  zoom(t, e) {
    t.setZoom(e);
  }
};
class yM extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      streetViewPanorama: null
    }), ae(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var e, n, r = (e = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && e !== void 0 ? e : null;
    this.registeredEvents = Ge({
      updaterMap: tg,
      eventMap: eg,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(e) {
    this.state.streetViewPanorama !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: tg,
      eventMap: eg,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), Ze(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
ae(yM, "contextType", je);
class bM extends xe {
  constructor() {
    super(...arguments), ae(this, "state", {
      streetViewService: null
    }), ae(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var e = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: e
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
ae(bM, "contextType", je);
var ng = {
  onDirectionsChanged: "directions_changed"
}, rg = {
  directions(t, e) {
    t.setDirections(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  panel(t, e) {
    t.setPanel(e);
  },
  routeIndex(t, e) {
    t.setRouteIndex(e);
  }
};
class CM extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "state", {
      directionsRenderer: null
    }), ae(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var e = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = Ge({
      updaterMap: rg,
      eventMap: ng,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        directionsRenderer: e
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(e) {
    this.state.directionsRenderer !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: rg,
      eventMap: ng,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), Ze(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
ae(CM, "contextType", je);
var og = {
  onPlacesChanged: "places_changed"
}, ig = {
  bounds(t, e) {
    t.setBounds(e);
  }
};
class wM extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "containerElement", Cr()), ae(this, "state", {
      searchBox: null
    }), ae(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if (Nt(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var e = this.containerElement.current.querySelector("input");
      if (e !== null) {
        var n = new google.maps.places.SearchBox(e, this.props.options);
        this.registeredEvents = Ge({
          updaterMap: ig,
          eventMap: og,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(e) {
    this.state.searchBox !== null && (Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: ig,
      eventMap: og,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), Ze(this.registeredEvents));
  }
  render() {
    return ut.jsx("div", {
      ref: this.containerElement,
      children: zt.only(this.props.children)
    });
  }
}
ae(wM, "contextType", je);
var ag = {
  onPlaceChanged: "place_changed"
}, sg = {
  bounds(t, e) {
    t.setBounds(e);
  },
  restrictions(t, e) {
    t.setComponentRestrictions(e);
  },
  fields(t, e) {
    t.setFields(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  types(t, e) {
    t.setTypes(e);
  }
};
class n0 extends xe {
  constructor() {
    super(...arguments), ae(this, "registeredEvents", []), ae(this, "containerElement", Cr()), ae(this, "state", {
      autocomplete: null
    }), ae(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var e;
    Nt(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (e = this.containerElement.current) === null || e === void 0 ? void 0 : e.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = Ge({
        updaterMap: sg,
        eventMap: ag,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(e) {
    Ze(this.registeredEvents), this.registeredEvents = Ge({
      updaterMap: sg,
      eventMap: ag,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && Ze(this.registeredEvents);
  }
  render() {
    return ut.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: zt.only(this.props.children)
    });
  }
}
ae(n0, "defaultProps", {
  className: ""
});
ae(n0, "contextType", je);
let EM = { data: "" }, DM = (t) => typeof window == "object" ? ((t ? t.querySelector("#_goober") : window._goober) || Object.assign((t || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t || EM, OM = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, xM = /\/\*[^]*?\*\/|  +/g, lg = /\n+/g, hr = (t, e) => {
  let n = "", r = "", o = "";
  for (let i in t) {
    let a = t[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? hr(a, i) : i + "{" + hr(a, i[1] == "k" ? "" : e) + "}" : typeof a == "object" ? r += hr(a, e ? e.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += hr.p ? hr.p(i, a) : i + ":" + a + ";");
  }
  return n + (e && o ? e + "{" + o + "}" : o) + r;
}, Zn = {}, r0 = (t) => {
  if (typeof t == "object") {
    let e = "";
    for (let n in t) e += n + r0(t[n]);
    return e;
  }
  return t;
}, LM = (t, e, n, r, o) => {
  let i = r0(t), a = Zn[i] || (Zn[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Zn[a]) {
    let l = i !== t ? t : ((u) => {
      let c, d, f = [{}];
      for (; c = OM.exec(u.replace(xM, "")); ) c[4] ? f.shift() : c[3] ? (d = c[3].replace(lg, " ").trim(), f.unshift(f[0][d] = f[0][d] || {})) : f[0][c[1]] = c[2].replace(lg, " ").trim();
      return f[0];
    })(t);
    Zn[a] = hr(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Zn.g ? Zn.g : null;
  return n && (Zn.g = Zn[a]), ((l, u, c, d) => {
    d ? u.data = u.data.replace(d, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Zn[a], e, r, s), a;
}, SM = (t, e, n) => t.reduce((r, o, i) => {
  let a = e[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : hr(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Is(t) {
  let e = this || {}, n = t.call ? t(e.p) : t;
  return LM(n.unshift ? n.raw ? SM(n, [].slice.call(arguments, 1), e.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(e.p) : o), {}) : n, DM(e.target), e.g, e.o, e.k);
}
let o0, Bu, Tu;
Is.bind({ g: 1 });
let Qn = Is.bind({ k: 1 });
function PM(t, e, n, r) {
  hr.p = e, o0 = t, Bu = n, Tu = r;
}
function Lr(t, e) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: Bu && Bu() }, s), n.o = / *go\d+/.test(l), s.className = Is.apply(n, r) + (l ? " " + l : "");
      let u = t;
      return t[0] && (u = s.as || t, delete s.as), Tu && u[0] && Tu(s), o0(u, s);
    }
    return o;
  };
}
var kM = (t) => typeof t == "function", MM = (t, e) => kM(t) ? t(e) : t, BM = /* @__PURE__ */ (() => {
  let t;
  return () => {
    if (t === void 0 && typeof window < "u") {
      let e = matchMedia("(prefers-reduced-motion: reduce)");
      t = !e || e.matches;
    }
    return t;
  };
})(), TM = Qn`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, AM = Qn`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, jM = Qn`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, FM = Lr("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(t) => t.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${TM} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${AM} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(t) => t.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${jM} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, _M = Qn`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, IM = Lr("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(t) => t.secondary || "#e0e0e0"};
  border-right-color: ${(t) => t.primary || "#616161"};
  animation: ${_M} 1s linear infinite;
`, RM = Qn`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, NM = Qn`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, $M = Lr("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(t) => t.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${RM} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${NM} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(t) => t.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, zM = Lr("div")`
  position: absolute;
`, UM = Lr("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, WM = Qn`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, HM = Lr("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${WM} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, VM = ({ toast: t }) => {
  let { icon: e, type: n, iconTheme: r } = t;
  return e !== void 0 ? typeof e == "string" ? tt.createElement(HM, null, e) : e : n === "blank" ? null : tt.createElement(UM, null, tt.createElement(IM, { ...r }), n !== "loading" && tt.createElement(zM, null, n === "error" ? tt.createElement(FM, { ...r }) : tt.createElement($M, { ...r })));
}, qM = (t) => `
0% {transform: translate3d(0,${t * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, GM = (t) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${t * -150}%,-1px) scale(.6); opacity:0;}
`, ZM = "0%{opacity:0;} 100%{opacity:1;}", KM = "0%{opacity:1;} 100%{opacity:0;}", YM = Lr("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, XM = Lr("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, JM = (t, e) => {
  let n = t.includes("top") ? 1 : -1, [r, o] = BM() ? [ZM, KM] : [qM(n), GM(n)];
  return { animation: e ? `${Qn(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${Qn(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
};
tt.memo(({ toast: t, position: e, style: n, children: r }) => {
  let o = t.height ? JM(t.position || e || "top-center", t.visible) : { opacity: 0 }, i = tt.createElement(VM, { toast: t }), a = tt.createElement(XM, { ...t.ariaProps }, MM(t.message, t));
  return tt.createElement(YM, { className: t.className, style: { ...o, ...n, ...t.style } }, typeof r == "function" ? r({ icon: i, message: a }) : tt.createElement(tt.Fragment, null, i, a));
});
PM(tt.createElement);
Is`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`;
function QM(t) {
  const { error: e } = t, n = "arkynAudioUploadError";
  return e ? /* @__PURE__ */ x.jsx("strong", { className: n, children: e }) : /* @__PURE__ */ x.jsx(x.Fragment, {});
}
function eB(t) {
  const { label: e, showAsterisk: n } = t, o = `arkynAudioUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ x.jsx("strong", { className: o.trim(), children: e });
}
function tB(t) {
  const { onChange: e, value: n, disableDrag: r = !1, onDragging: o } = t, [i, a] = B(!1), s = qe(null), l = () => {
    a(!0);
  }, u = () => {
    a(!1);
  }, c = (h) => {
    if (r || !i || !s.current) return;
    const g = s.current.getBoundingClientRect(), p = h.clientX - g.left, w = Math.min(Math.max(p / g.width * 100, 0), 100);
    e(w);
  }, d = (h) => {
    if (!s.current) return;
    const g = s.current.getBoundingClientRect(), p = h.clientX - g.left, w = Math.min(Math.max(p / g.width * 100, 0), 100);
    e(w);
  };
  y(() => (i ? (o && o(!0), document.addEventListener("mousemove", c), document.addEventListener("mouseup", u)) : (o && o(!1), document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u)), () => {
    document.removeEventListener("mousemove", c), document.removeEventListener("mouseup", u);
  }), [i]);
  const v = `arkynSliderTrack ${i ? "isDragging" : "isNotDragging"}`;
  return /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: v,
      ref: s,
      onMouseDown: l,
      onClick: d,
      children: [
        /* @__PURE__ */ x.jsx("div", { className: "arkynSliderFill", style: { width: `${n}%` } }),
        /* @__PURE__ */ x.jsx("div", { className: "arkynSliderThumb", style: { left: `${n}%` } })
      ]
    }
  );
}
function nB(t) {
  var S, W, P, $;
  const {
    filePath: e,
    disabled: n,
    acceptAudio: r,
    handleSelectFile: o,
    isLoading: i,
    reSendAudio: a,
    changeAudioButtonText: s
  } = t, [l, u] = B(0), c = qe(null), [d, f] = B(!1), [v, h] = B(!1);
  y(() => {
    const j = c.current;
    if (!j) return;
    const _ = () => {
      const I = j.duration, V = j.currentTime / I * 100;
      u(V);
    };
    return j.addEventListener("timeupdate", _), () => {
      j.removeEventListener("timeupdate", _);
    };
  }, []);
  function g(j) {
    const _ = c.current;
    if (!_) return;
    const I = _.duration, R = j / 100 * I;
    _.currentTime = R;
  }
  function p() {
    var j;
    (j = c.current) == null || j.play(), h(!0);
  }
  function w() {
    var j;
    (j = c.current) == null || j.pause(), h(!1);
  }
  function b() {
    v ? w() : p();
  }
  const k = (S = c.current) == null ? void 0 : S.currentTime, E = (W = c.current) == null ? void 0 : W.duration;
  function m(j) {
    if (!j) return "00:00";
    const _ = Math.floor(j / 60), I = Math.floor(j % 60), R = String(_).padStart(2, "0"), V = String(I).padStart(2, "0");
    return `${R}:${V}`;
  }
  d || !v ? (P = c.current) == null || P.pause() : v && (($ = c.current) == null || $.play());
  function O() {
    if (n) return;
    const j = document.createElement("input");
    j.type = "file", j.accept = r, j.onchange = (_) => {
      var R;
      const I = (R = _.target.files) == null ? void 0 : R[0];
      I && o(I);
    }, j.click();
  }
  return /* @__PURE__ */ x.jsxs("div", { className: "arkynAudioUploadHasFileContentContainer", children: [
    /* @__PURE__ */ x.jsx("audio", { ref: c, src: e, onEnded: w }),
    /* @__PURE__ */ x.jsxs("div", { className: "arkynAudioUploadAudioPlayer", children: [
      /* @__PURE__ */ x.jsxs("button", { type: "button", onClick: b, children: [
        v && /* @__PURE__ */ x.jsx(YC, {}),
        !v && /* @__PURE__ */ x.jsx(XC, {})
      ] }),
      /* @__PURE__ */ x.jsx("p", { children: m(k) }),
      /* @__PURE__ */ x.jsx(
        tB,
        {
          value: l,
          onChange: g,
          onDragging: f
        }
      ),
      /* @__PURE__ */ x.jsx("p", { children: m(E) })
    ] }),
    /* @__PURE__ */ x.jsx(Fx, {}),
    /* @__PURE__ */ x.jsxs("div", { className: "arkynAudioUploadButtonsContainer", children: [
      !!a && /* @__PURE__ */ x.jsx(Rx, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ x.jsx(
        Ix,
        {
          type: "button",
          "aria-label": "resend image",
          variant: "outline",
          scheme: "danger",
          size: "sm",
          isLoading: i,
          onClick: a,
          icon: Qm,
          disabled: n
        }
      ) }),
      /* @__PURE__ */ x.jsx(
        fb,
        {
          isLoading: i,
          onClick: O,
          variant: "outline",
          size: "sm",
          type: "button",
          disabled: n,
          children: s
        }
      )
    ] })
  ] });
}
function rB(t) {
  const {
    dropAudioText: e,
    isLoading: n,
    acceptAudio: r,
    handleSelectFile: o,
    selectAudioButtonText: i,
    disabled: a
  } = t;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var f;
      const d = (f = c.target.files) == null ? void 0 : f[0];
      d && o(d);
    }, u.click();
  }
  return /* @__PURE__ */ x.jsxs("div", { onDrop: s, className: "arkynAudioUploadNoFileContent", children: [
    /* @__PURE__ */ x.jsx(
      fb,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ x.jsx("p", { children: e })
  ] });
}
function v2(t) {
  const {
    name: e,
    label: n,
    fileName: r = "file",
    method: o = "POST",
    onUpload: i,
    fileResponseName: a = "url",
    selectAudioButtonText: s = "Selecionar arquivo de áudio",
    dropAudioText: l = "Ou arraste e solte um arquivo de áudio aqui",
    changeAudioButtonText: u = "Trocar arquivo de áudio",
    acceptAudio: c = "audio/*",
    action: d,
    defaultValue: f = "",
    showAsterisk: v = !1,
    disabled: h = !1
  } = t, p = _x()[e], [w, b] = B(f), [k, E] = B(""), [m, O] = B(null), [S, W] = B(f), [P, $] = B(!1);
  async function j(G) {
    if (h) return;
    $(!0), O(G), E("");
    const te = new FormData();
    te.append(r, G), await fetch(d, { method: o, body: te }).then(async (Q) => await Q.json()).then((Q) => {
      Q != null && Q.error ? E(Q.error) : b(Q == null ? void 0 : Q[a]), i && i(Q == null ? void 0 : Q[a]);
    }).catch((Q) => {
      console.error(Q), E("Erro ao enviar audio");
    }).finally(() => $(!1));
  }
  function _(G) {
    if (!h) {
      if (console.log(G.type), G.type.indexOf("audio") === -1) {
        E("O arquivo selecionado não é um arquivo de áudio");
        return;
      }
      W(URL.createObjectURL(G)), j(G);
    }
  }
  const I = p || k, J = `arkynAudioUpload ${I ? "hasError" : "noHasError"} ${S ? "hasAudio" : "noHasAudio"}`;
  return /* @__PURE__ */ x.jsxs("div", { className: "arkynAudioUploadContainer", children: [
    n && /* @__PURE__ */ x.jsx(eB, { label: n, showAsterisk: v }),
    /* @__PURE__ */ x.jsxs("div", { className: J, children: [
      /* @__PURE__ */ x.jsx("input", { type: "hidden", name: e, value: w || "" }),
      !S && /* @__PURE__ */ x.jsx(
        rB,
        {
          disabled: h,
          isLoading: P,
          acceptAudio: c,
          dropAudioText: l,
          handleSelectFile: _,
          selectAudioButtonText: s
        }
      ),
      S && /* @__PURE__ */ x.jsx(
        nB,
        {
          filePath: S,
          acceptAudio: c,
          changeAudioButtonText: u,
          disabled: h,
          handleSelectFile: _,
          isLoading: P,
          reSendAudio: I && m ? () => j(m) : void 0
        }
      )
    ] }),
    I && /* @__PURE__ */ x.jsx(QM, { error: I })
  ] });
}
function za(t) {
  const {
    isLoading: e = !1,
    scheme: n = "primary",
    variant: r = "solid",
    loadingText: o,
    size: i = "md",
    leftIcon: a,
    rightIcon: s,
    disabled: l,
    className: u = "",
    children: c,
    ...d
  } = t, v = { xs: 12, sm: 16, md: 20, lg: 24 }[i], p = `arkynButton ${e ? "loadingTrue" : "loadingFalse"} ${r} ${n} ${i} ${o ? "loadingTextTrue" : "loadingTextFalse"} ${u}`;
  return /* @__PURE__ */ x.jsxs("button", { className: p, disabled: l || e, ...d, children: [
    /* @__PURE__ */ x.jsxs("div", { className: "arkynButtonSpinner", children: [
      /* @__PURE__ */ x.jsx(Un, { size: v, strokeWidth: 2.5 }),
      o && o
    ] }),
    /* @__PURE__ */ x.jsxs("div", { className: "arkynButtonContent", children: [
      ya(v, a),
      c,
      ya(v, s)
    ] })
  ] });
}
function i0() {
  const t = ec(), e = ny(), n = ry(), [r, o] = B(null);
  function i(u, c) {
    return JSON.stringify(u) === JSON.stringify(c);
  }
  function a() {
    r && o(null);
  }
  y(() => {
    var c, d;
    let u = ((d = (c = n[0]) == null ? void 0 : c.data) == null ? void 0 : d.fieldErrors) || {};
    i(r, u) || Object.entries(u).length !== 0 && o(u);
  }, [n, t]), y(() => {
    var u;
    ((u = n[0]) == null ? void 0 : u.state) === "submitting" && a();
  }, [n, e]);
  const s = (t == null ? void 0 : t.fieldErrors) || r;
  let l = {};
  return Object.entries(s || {}).forEach(([u, c]) => {
    typeof c == "string" && typeof u == "string" && (l[u] = c);
  }), l;
}
const a0 = ct({});
function ug(t) {
  var d;
  const {
    children: e,
    className: n,
    id: r,
    ...o
  } = t, i = i0(), a = qe(null), s = ((d = a.current) == null ? void 0 : d.name) || "", l = (i == null ? void 0 : i[s]) || null, u = VC(), c = `arkynFormController ${n}`;
  return /* @__PURE__ */ x.jsx(a0.Provider, { value: { error: l, id: u, inputRef: a }, children: /* @__PURE__ */ x.jsx(
    "section",
    {
      id: r || s || void 0,
      className: c.trim(),
      ...o,
      children: e
    }
  ) });
}
function dn() {
  return Ee(a0);
}
function m2(t) {
  const {
    name: e,
    className: n = "",
    size: r = "md",
    isError: o,
    defaultChecked: i = !1,
    checked: a = null,
    onCheck: s,
    value: l,
    ...u
  } = t, { id: c, inputRef: d, error: f } = dn(), v = o || !!f, [h, g] = B(i || !1), p = typeof a == "boolean" ? a : h, k = `arkynCheckbox ${r} ${v ? "errorTrue" : "errorFalse"} ${p ? "checkedTrue" : "checkedFalse"} ${n}`;
  function E() {
    const m = h;
    g(!m), s && s(m ? "" : l || "checked");
  }
  return /* @__PURE__ */ x.jsxs(
    "button",
    {
      id: c,
      type: "button",
      className: k,
      onClick: E,
      ...u,
      children: [
        /* @__PURE__ */ x.jsx(
          "input",
          {
            type: "hidden",
            name: e,
            ref: d,
            value: p ? l || "checked" : ""
          }
        ),
        /* @__PURE__ */ x.jsx(Ju, {})
      ]
    }
  );
}
function y2(t) {
  const { children: e, className: n, ...r } = t, o = `arkynFormError ${n}`, { error: i } = dn();
  return e ? /* @__PURE__ */ x.jsx("strong", { className: o.trim(), ...r, children: e }) : i ? /* @__PURE__ */ x.jsx("strong", { className: o.trim(), ...r, children: i }) : /* @__PURE__ */ x.jsx(x.Fragment, {});
}
function cg(t) {
  const {
    showAsterisk: e = !1,
    className: n = "",
    ...r
  } = t, { id: o } = dn(), a = `arkynFormLabel ${e ? "asteriskTrue" : "asteriskFalse"} ${n}`;
  return /* @__PURE__ */ x.jsx("label", { className: a.trim(), htmlFor: o, ...r });
}
function oB(t) {
  const {
    isLoading: e = !1,
    scheme: n = "primary",
    variant: r = "solid",
    size: o = "md",
    icon: i,
    disabled: a,
    className: s = "",
    ...l
  } = t, u = { xs: 12, sm: 16, md: 20, lg: 24 }, d = `arkynIconButton ${r} ${n} ${o} ${e ? "loadingTrue" : "loadingFalse"} ${s}`;
  return /* @__PURE__ */ x.jsxs(
    "button",
    {
      disabled: a || e,
      className: d.trim(),
      ...l,
      children: [
        /* @__PURE__ */ x.jsx("div", { className: "arkynIconButtonSpinner", children: /* @__PURE__ */ x.jsx(Un, { size: u[o], strokeWidth: 2.5 }) }),
        /* @__PURE__ */ x.jsx("div", { className: "arkynIconButtonContent", children: /* @__PURE__ */ x.jsx(i, { size: u[o], strokeWidth: 2.5 }) })
      ]
    }
  );
}
function iB(t) {
  const {
    text: e,
    size: n = "lg",
    children: r,
    orientation: o = "top",
    className: i = "",
    ...a
  } = t, s = `arkynTooltip ${n} ${o} ${i}`;
  return /* @__PURE__ */ x.jsxs("div", { className: s.trim(), ...a, children: [
    r,
    /* @__PURE__ */ x.jsx("div", { className: "arkynTooltipText", children: e })
  ] });
}
function aB(t) {
  const {
    disabled: e,
    filePath: n,
    isLoading: r,
    acceptImage: o,
    changeImageButtonText: i,
    handleSelectFile: a,
    reSendImage: s
  } = t;
  function l() {
    if (e) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = o, u.onchange = (c) => {
      var f;
      const d = (f = c.target.files) == null ? void 0 : f[0];
      d && a(d);
    }, u.click();
  }
  return /* @__PURE__ */ x.jsxs(
    "div",
    {
      className: "arkynImageUploadHasFileContent",
      style: { backgroundImage: `url("${n}")` },
      children: [
        s && /* @__PURE__ */ x.jsx(iB, { orientation: "bottom", text: "Reenviar imagem", children: /* @__PURE__ */ x.jsx(
          oB,
          {
            type: "button",
            "aria-label": "resend image",
            variant: "outline",
            scheme: "danger",
            size: "sm",
            isLoading: r,
            onClick: s,
            icon: Qm,
            disabled: e
          }
        ) }),
        /* @__PURE__ */ x.jsx(
          za,
          {
            isLoading: r,
            onClick: l,
            variant: "outline",
            size: "sm",
            type: "button",
            disabled: e,
            children: i
          }
        )
      ]
    }
  );
}
function sB(t) {
  const { error: e } = t, n = "arkynImageUploadError";
  return e ? /* @__PURE__ */ x.jsx("strong", { className: n, children: e }) : /* @__PURE__ */ x.jsx(x.Fragment, {});
}
function lB(t) {
  const { label: e, showAsterisk: n } = t, o = `arkynImageUploadLabel ${n ? "asteriskTrue" : "asteriskFalse"}`;
  return /* @__PURE__ */ x.jsx("strong", { className: o.trim(), children: e });
}
function uB(t) {
  const {
    dropImageText: e,
    isLoading: n,
    acceptImage: r,
    handleSelectFile: o,
    selectImageButtonText: i,
    disabled: a
  } = t;
  function s(u) {
    if (a) return;
    u.preventDefault();
    const c = u.dataTransfer.files[0];
    c && o(c);
  }
  function l() {
    if (a) return;
    const u = document.createElement("input");
    u.type = "file", u.accept = r, u.onchange = (c) => {
      var f;
      const d = (f = c.target.files) == null ? void 0 : f[0];
      d && o(d);
    }, u.click();
  }
  return /* @__PURE__ */ x.jsxs("div", { onDrop: s, className: "arkynImageUploadNoFileContent", children: [
    /* @__PURE__ */ x.jsx(
      za,
      {
        isLoading: n,
        onClick: l,
        variant: "ghost",
        size: "sm",
        type: "button",
        disabled: a,
        children: i
      }
    ),
    /* @__PURE__ */ x.jsx("p", { children: e })
  ] });
}
function cB(t) {
  const {
    name: e,
    defaultValue: n = "",
    label: r,
    showAsterisk: o = !1,
    action: i,
    fileName: a = "file",
    method: s = "POST",
    acceptImage: l = "image/*",
    fileResponseName: u = "url",
    changeImageButtonText: c = "Alterar imagem",
    selectImageButtonText: d = "Selecionar imagem",
    dropImageText: f = "Ou arraste e solte a imagem aqui",
    onUpload: v,
    disabled: h = !1
  } = t, p = i0()[e], [w, b] = B(n), [k, E] = B(""), [m, O] = B(null), [S, W] = B(n), [P, $] = B(!1);
  async function j(G) {
    if (h) return;
    $(!0), O(G), E("");
    const te = new FormData();
    te.append(a, G), await fetch(i, { method: s, body: te }).then(async (Q) => await Q.json()).then((Q) => {
      Q != null && Q.error ? E(Q.error) : b(Q == null ? void 0 : Q[u]), v && v(Q == null ? void 0 : Q[u]);
    }).catch((Q) => {
      console.error(Q), E("Erro ao enviar imagem");
    }).finally(() => $(!1));
  }
  function _(G) {
    h || (W(URL.createObjectURL(G)), j(G));
  }
  const I = p || k, J = `arkynImageUpload ${I ? "hasError" : "noHasError"} ${S ? "hasImage" : "noHasImage"}`;
  return /* @__PURE__ */ x.jsxs("div", { className: "arkynImageUploadContainer", children: [
    r && /* @__PURE__ */ x.jsx(lB, { label: r, showAsterisk: o }),
    /* @__PURE__ */ x.jsxs("div", { className: J, children: [
      /* @__PURE__ */ x.jsx("input", { type: "hidden", name: e, value: w || "" }),
      !S && /* @__PURE__ */ x.jsx(
        uB,
        {
          disabled: h,
          isLoading: P,
          acceptImage: l,
          dropImageText: f,
          handleSelectFile: _,
          selectImageButtonText: d
        }
      ),
      S && /* @__PURE__ */ x.jsx(
        aB,
        {
          disabled: h,
          isLoading: P,
          acceptImage: l,
          filePath: S,
          handleSelectFile: _,
          changeImageButtonText: c,
          reSendImage: I && m ? () => j(m) : void 0
        }
      )
    ] }),
    I && /* @__PURE__ */ x.jsx(sB, { error: I })
  ] });
}
function yr(t, e, n) {
  if (!t) return /* @__PURE__ */ x.jsx(x.Fragment, {});
  if (typeof t == "string") return /* @__PURE__ */ x.jsx("p", { className: n, children: t });
  const r = t;
  return /* @__PURE__ */ x.jsx("p", { className: n, children: /* @__PURE__ */ x.jsx(r, { color: "var(--secondary-600)", size: e, strokeWidth: 2.5 }) });
}
function Xc(t) {
  return t && t.replace(/[^0-9]/g, "");
}
function s0(t, e) {
  let n = "", r = 0;
  return Array.from(t).forEach((o, i) => {
    e[i + r].match(/[0-9]/) || (n += e[i + r], r++), n += o;
  }), n;
}
function l0(t) {
  return t.length > 11 ? "CNPJ" : "CPF";
}
const Jc = {
  CPF: "999.999.999-999",
  CNPJ: "99.999.999/9999-99"
}, u0 = Xc(Jc.CNPJ).length;
function dB(t, e) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: d,
    defaultValue: f,
    readOnly: v,
    onFocus: h,
    onBlur: g,
    title: p,
    style: w,
    onChange: b,
    ...k
  } = t;
  function E(R) {
    let V = Xc(R);
    const J = l0(V);
    if (!(V.length > u0))
      return V = s0(V, Jc[J]), V;
  }
  const m = c ? "right" : "left", j = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${d || v || n ? "opacity" : ""} ${r ? "errored" : ""} ${e ? "focused" : ""} ${i}`, I = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: j,
    prefix: yr(s, I, "prefix"),
    sufix: yr(l, I, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    defaultValue: E(f || ""),
    disabled: d,
    readOnly: v,
    onFocus: h,
    onBlur: g,
    title: p,
    style: w,
    onChange: b,
    loadingPosition: m,
    iconSize: I,
    Spinner: /* @__PURE__ */ x.jsx(Un, { className: "spinner", size: I, strokeWidth: 2.5 }),
    ...k
  };
}
function fB(t) {
  const [e, n] = B(!1), r = qe(null), { inputRef: o, id: i, error: a } = dn(), s = o || r, l = t.isError || !!a, {
    disabled: u,
    title: c,
    style: d,
    className: f,
    prefix: v,
    sufix: h,
    iconSize: g,
    loadingPosition: p,
    isLoading: w,
    LeftIcon: b,
    readOnly: k,
    onFocus: E,
    onBlur: m,
    RightIcon: O,
    Spinner: S,
    onChange: W,
    value: P,
    defaultValue: $,
    ...j
  } = dB({ ...t, id: i, isError: l }, e), [_, I] = B($), R = b && !w, V = O && !w, J = p === "left" && w, G = p === "right" && w;
  function te() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function Q(Y) {
    let F = Xc(Y.target.value);
    const X = l0(F);
    F.length > u0 || (F = s0(F, Jc[X]), Y.target.value = F, I(F), W && W(Y));
  }
  function T(Y) {
    n(!0), E && E(Y);
  }
  function N(Y) {
    n(!1), m && m(Y);
  }
  return /* @__PURE__ */ x.jsxs(
    "section",
    {
      title: c,
      style: d,
      onClick: te,
      className: f,
      children: [
        v,
        J && S,
        R && /* @__PURE__ */ x.jsx(b, { size: g, strokeWidth: 2.5 }),
        /* @__PURE__ */ x.jsx(
          "input",
          {
            disabled: u || w,
            readOnly: k,
            ref: s,
            value: P || _,
            onFocus: T,
            onChange: Q,
            onBlur: N,
            ...j
          }
        ),
        V && /* @__PURE__ */ x.jsx(O, { size: g, strokeWidth: 2.5 }),
        G && S,
        h
      ]
    }
  );
}
const pB = 3, hB = (t = "pt-BR", e, n = "BRL", r = !0) => new Intl.NumberFormat(t, {
  style: "currency",
  currency: n,
  currencyDisplay: "symbol",
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(e).slice(r ? pB : 0), Hi = 2, dg = (t) => typeof t == "number" ? t : Number(t.toString().replace(/[^0-9-]/g, "")), Au = (t) => {
  let e = t;
  return typeof t == "string" ? (e = dg(t), e % 1 !== 0 && (e = e.toFixed(Hi))) : e = Number.isInteger(t) ? Number(t) * 10 ** Hi : t.toFixed(Hi), dg(e) / 10 ** Hi;
}, fg = (t, e, n) => {
  if (!e) return [0, ""];
  const r = Au(e), o = hB(t, r, n);
  return [r, o];
};
function gB(t, e) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: d,
    readOnly: f,
    onFocus: v,
    onBlur: h,
    title: g,
    style: p,
    // showCents = false,
    max: w = 1e9,
    locale: b = "pt-BR",
    currency: k = "BRL",
    ...E
  } = t, m = c ? "right" : "left", j = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${d || f || n ? "opacity" : ""} ${r ? "errored" : ""} ${e ? "focused" : ""} ${i}`, I = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: j,
    prefix: yr(s, I, "prefix"),
    sufix: yr(l, I, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: d,
    locale: b,
    currency: k,
    readOnly: f,
    onFocus: v,
    onBlur: h,
    title: g,
    style: p,
    max: w,
    // showCents,
    loadingPosition: m,
    iconSize: I,
    Spinner: /* @__PURE__ */ x.jsx(Un, { className: "spinner", size: I, strokeWidth: 2.5 }),
    ...E
  };
}
function vB(t) {
  const [e, n] = B(!1), [r, o] = B("0"), i = qe(null), { inputRef: a, id: s, error: l } = dn(), u = a || i, c = t.isError || !!l, {
    disabled: d,
    title: f,
    style: v,
    className: h,
    prefix: g,
    sufix: p,
    iconSize: w,
    loadingPosition: b,
    isLoading: k,
    LeftIcon: E,
    readOnly: m,
    onFocus: O,
    onBlur: S,
    RightIcon: W,
    Spinner: P,
    value: $,
    max: j,
    onChangeValue: _,
    onKeyPress: I,
    currency: R,
    locale: V,
    name: J,
    defaultValue: G,
    ...te
  } = gB({ ...t, id: s, isError: c }, e), Q = E && !k, T = W && !k, N = b === "left" && k, Y = b === "right" && k;
  function F() {
    d || !(u != null && u.current) || (n(!0), u.current.focus());
  }
  function X(U) {
    n(!0), O && O(U);
  }
  function L(U) {
    n(!1), S && S(U);
  }
  const M = (U) => {
    const [H, ee] = fg(
      V,
      U,
      R
    );
    return !j || H <= j ? (o(ee), [H, ee]) : [Au(r), r];
  }, z = (U) => {
    U.preventDefault();
    const [H, ee] = M(U.target.value);
    _ && _(U, String(H), String(ee));
  }, A = (U) => I && I(U, U.key, U.key);
  return y(() => {
    const U = $ || +G || void 0, [, H] = fg(V, U, R);
    o(H);
  }, [R, G, $]), /* @__PURE__ */ x.jsxs(
    "section",
    {
      title: f,
      style: v,
      onClick: F,
      className: h,
      children: [
        g,
        N && P,
        Q && /* @__PURE__ */ x.jsx(E, { size: w, strokeWidth: 2.5 }),
        /* @__PURE__ */ x.jsx(
          "input",
          {
            value: r,
            onChange: z,
            onBlur: L,
            onFocus: X,
            onKeyUp: A,
            disabled: d || k,
            readOnly: m,
            ...te
          }
        ),
        /* @__PURE__ */ x.jsx(
          "input",
          {
            type: "hidden",
            ref: u,
            name: J,
            value: Au(r)
          }
        ),
        Y && P,
        T && /* @__PURE__ */ x.jsx(W, { size: w, strokeWidth: 2.5 }),
        p
      ]
    }
  );
}
function mB(t, e) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: d,
    readOnly: f,
    onFocus: v,
    onBlur: h,
    title: g,
    style: p,
    onChange: w,
    showMask: b = !1,
    type: k,
    ...E
  } = t, m = c ? "right" : "left", j = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${d || f || n ? "opacity" : ""} ${r ? "errored" : ""} ${e ? "focused" : ""} ${i}`, I = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: j,
    prefix: yr(s, I, "prefix"),
    sufix: yr(l, I, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: d,
    readOnly: f,
    onFocus: v,
    onBlur: h,
    title: g,
    style: p,
    onChange: w,
    loadingPosition: m,
    iconSize: I,
    showMask: b,
    Spinner: /* @__PURE__ */ x.jsx(Un, { className: "spinner", size: I, strokeWidth: 2.5 }),
    ...E
  };
}
const yB = es((t, e) => /* @__PURE__ */ x.jsx("input", { ref: e, ...t }));
function bB(t) {
  const [e, n] = B(!1), r = qe(null), { inputRef: o, id: i, error: a } = dn(), s = o || r, l = t.isError || !!a, {
    disabled: u,
    title: c,
    style: d,
    className: f,
    prefix: v,
    sufix: h,
    iconSize: g,
    loadingPosition: p,
    isLoading: w,
    LeftIcon: b,
    readOnly: k,
    onFocus: E,
    onBlur: m,
    RightIcon: O,
    Spinner: S,
    ...W
  } = mB({ ...t, id: i, isError: l }, e), P = b && !w, $ = O && !w, j = p === "left" && w, _ = p === "right" && w;
  function I() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function R(J) {
    n(!0), E && E(J);
  }
  function V(J) {
    n(!1), m && m(J);
  }
  return /* @__PURE__ */ x.jsxs(
    "section",
    {
      title: c,
      style: d,
      onClick: I,
      className: f,
      children: [
        v,
        j && S,
        P && /* @__PURE__ */ x.jsx(b, { size: g, strokeWidth: 2.5 }),
        /* @__PURE__ */ x.jsx(
          pw,
          {
            component: yB,
            ref: s,
            onFocus: R,
            onBlur: V,
            disabled: u,
            ...W
          }
        ),
        $ && /* @__PURE__ */ x.jsx(O, { size: g, strokeWidth: 2.5 }),
        _ && S,
        h
      ]
    }
  );
}
function CB(t, e) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    sufix: l,
    leftIcon: u,
    rightIcon: c,
    disabled: d,
    readOnly: f,
    onFocus: v,
    onBlur: h,
    title: g,
    style: p,
    onChange: w,
    ...b
  } = t, k = c ? "right" : "left", P = `arkyn_input ${s ? "hasPrefix" : ""} ${l ? "hasSufix" : ""} ${a} ${o} ${d || f || n ? "opacity" : ""} ${r ? "errored" : ""} ${e ? "focused" : ""} ${i}`, j = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: P,
    prefix: yr(s, j, "prefix"),
    sufix: yr(l, j, "sufix"),
    LeftIcon: u,
    RightIcon: c,
    disabled: d,
    readOnly: f,
    onFocus: v,
    onBlur: h,
    title: g,
    style: p,
    onChange: w,
    loadingPosition: k,
    iconSize: j,
    Spinner: /* @__PURE__ */ x.jsx(Un, { className: "spinner", size: j, strokeWidth: 2.5 }),
    ...b
  };
}
function wB(t) {
  const [e, n] = B(!1), r = qe(null), { inputRef: o, id: i, error: a } = dn(), s = o || r, l = t.isError || !!a, {
    disabled: u,
    title: c,
    style: d,
    className: f,
    prefix: v,
    sufix: h,
    iconSize: g,
    loadingPosition: p,
    isLoading: w,
    LeftIcon: b,
    readOnly: k,
    onFocus: E,
    onBlur: m,
    RightIcon: O,
    type: S,
    Spinner: W,
    ...P
  } = CB({ ...t, id: i, isError: l }, e), $ = b && !w, j = O && !w, _ = p === "left" && w, I = p === "right" && w;
  function R() {
    u || !(s != null && s.current) || (n(!0), s.current.focus());
  }
  function V(G) {
    n(!0), E && E(G);
  }
  function J(G) {
    n(!1), m && m(G);
  }
  return S === "hidden" ? /* @__PURE__ */ x.jsx(
    "input",
    {
      style: { display: "none" },
      readOnly: !0,
      type: "text",
      ref: s,
      ...P
    }
  ) : /* @__PURE__ */ x.jsxs(
    "section",
    {
      title: c,
      style: d,
      onClick: R,
      className: f,
      children: [
        v,
        _ && W,
        $ && /* @__PURE__ */ x.jsx(b, { size: g, strokeWidth: 2.5 }),
        /* @__PURE__ */ x.jsx(
          "input",
          {
            disabled: u || w,
            readOnly: k,
            ref: s,
            onFocus: V,
            onBlur: J,
            type: S,
            ...P
          }
        ),
        j && /* @__PURE__ */ x.jsx(O, { size: g, strokeWidth: 2.5 }),
        I && W,
        h
      ]
    }
  );
}
function Rs(t) {
  return t.type === "currency" ? /* @__PURE__ */ x.jsx(vB, { ...t }) : t.type === "masked" ? /* @__PURE__ */ x.jsx(bB, { ...t }) : t.type === "cpf-cnpj" ? /* @__PURE__ */ x.jsx(fB, { ...t }) : /* @__PURE__ */ x.jsx(wB, { ...t });
}
function EB(t) {
  const { iconSize: e, isLoading: n, disabled: r, readOnly: o, isFocused: i } = t, l = `arkynMultiSelectChevron ${r || o ? "notAnimate" : ""} ${i ? "focused" : ""}`;
  return n ? /* @__PURE__ */ x.jsx(x.Fragment, {}) : /* @__PURE__ */ x.jsx(ey, { className: l, size: e, strokeWidth: 2.5 });
}
function DB(t) {
  const {
    children: e,
    handleContainerFocus: n,
    disabled: r,
    isError: o,
    isLoading: i,
    isFocused: a,
    className: s,
    readOnly: l,
    variant: u,
    size: c,
    id: d,
    prefixExists: f
  } = t, v = f ? "hasPrefix" : "", h = o ? "errored" : "", g = r || l || i ? "opacity" : "", p = a ? "focused" : "";
  return /* @__PURE__ */ x.jsx(
    "section",
    {
      onClick: n,
      id: d,
      className: `arkynMultiSelectContainer ${v} ${u} ${c} ${g} ${h} ${p} ${s}`,
      children: e
    }
  );
}
function OB(t) {
  const { children: e, size: n } = t, r = `arkynMultiSelectContent ${n}`;
  return /* @__PURE__ */ x.jsx("div", { className: r, children: e });
}
function xB(t) {
  const { label: e, value: n, handleChangeValue: r } = t;
  return /* @__PURE__ */ x.jsxs("div", { className: "arkynMultiSelectMark", children: [
    e,
    /* @__PURE__ */ x.jsx(
      "button",
      {
        type: "button",
        onClick: (o) => {
          o.stopPropagation(), r(n);
        },
        children: /* @__PURE__ */ x.jsx(Qu, {})
      }
    )
  ] });
}
function LB(t) {
  const { label: e, optionHasSelected: n, handleChangeValue: r, value: o, size: i } = t, a = n(o) ? "active" : "", s = `arkynMultiSelectOption ${i} ${a}`;
  return /* @__PURE__ */ x.jsxs("div", { onClick: () => r(o), className: s, children: [
    e,
    " ",
    /* @__PURE__ */ x.jsx(Ju, {})
  ] });
}
function SB(t) {
  const { children: e, isFocused: n, isSearchable: r, onSearch: o } = t;
  function i(a) {
    r && o(a.target.value);
  }
  return n ? /* @__PURE__ */ x.jsxs("div", { className: "arkynMultiSelectOptionsContainer", children: [
    r && /* @__PURE__ */ x.jsx(
      Rs,
      {
        type: "search",
        name: "search-select",
        variant: "underline",
        leftIcon: ty,
        onChange: i
      }
    ),
    e
  ] }) : /* @__PURE__ */ x.jsx(x.Fragment, {});
}
function PB(t) {
  const { isFocused: e, handleBlur: n } = t;
  return e ? /* @__PURE__ */ x.jsx("aside", { className: "arkynMultiSelectOverlay", onClick: n }) : /* @__PURE__ */ x.jsx(x.Fragment, {});
}
function kB(t) {
  const { iconSize: e, isLoading: n } = t;
  return n ? /* @__PURE__ */ x.jsx(
    Un,
    {
      className: "arkynMultiSelectSpinner",
      size: e,
      strokeWidth: 2.5
    }
  ) : /* @__PURE__ */ x.jsx(x.Fragment, {});
}
function b2(t) {
  const {
    name: e,
    options: n,
    className: r = "",
    placeholder: o = "Selecione...",
    closeOnSelect: i = !1,
    defaultValue: a = [],
    isError: s,
    isLoading: l = !1,
    readOnly: u = !1,
    isSearchable: c = !1,
    leftIcon: d,
    onSearch: f,
    onSelect: v,
    onBlur: h,
    notFoundText: g = "Sem opções disponíveis",
    onFocus: p,
    disabled: w = !1,
    prefix: b,
    size: k = "md",
    value: E,
    variant: m = "solid"
  } = t, O = dn(), S = qe(null), W = O.inputRef || S, P = O.id, $ = s || !!O.error, _ = { md: 20, lg: 20 }[k], I = Ry(b, _, "prefix"), [R, V] = B(""), [J, G] = B(!1), [te, Q] = B(a), T = E || te;
  function N(A) {
    return T.includes(A);
  }
  function Y(A) {
    const U = n.find((H) => H.value === A);
    return (U == null ? void 0 : U.label) || "";
  }
  function F() {
    w || !(W != null && W.current) || J || (G(!0), W.current.focus(), p && p());
  }
  function X() {
    G(!1), h && W.current && W.current.blur();
  }
  function L(A) {
    V(A), f && f(A);
  }
  function M(A) {
    N(A) ? Q(te.filter((U) => U !== A)) : Q([...te, A]), v && v(te), i && X();
  }
  const z = n.filter((A) => !!(t.onSearch || !t.isSearchable || A.label.toLowerCase().includes(R.toLowerCase())));
  return /* @__PURE__ */ x.jsxs(
    DB,
    {
      handleContainerFocus: F,
      disabled: w,
      isError: $,
      isFocused: J,
      isLoading: l,
      readOnly: u,
      size: k,
      variant: m,
      className: r,
      prefixExists: !!b,
      id: P,
      children: [
        /* @__PURE__ */ x.jsx(
          "input",
          {
            ref: W,
            name: e,
            value: JSON.stringify(T),
            type: "hidden"
          }
        ),
        I,
        d && /* @__PURE__ */ x.jsx(d, { size: _, strokeWidth: 2.5 }),
        /* @__PURE__ */ x.jsxs(OB, { size: k, children: [
          T.map((A) => /* @__PURE__ */ x.jsx(
            xB,
            {
              label: Y(A),
              value: A,
              handleChangeValue: M
            },
            A
          )),
          T.length <= 0 && /* @__PURE__ */ x.jsx("p", { children: o })
        ] }),
        /* @__PURE__ */ x.jsxs(
          SB,
          {
            isFocused: J,
            isSearchable: c,
            onSearch: L,
            children: [
              z.map(({ label: A, value: U }) => /* @__PURE__ */ x.jsx(
                LB,
                {
                  label: A,
                  value: U,
                  size: k,
                  handleChangeValue: M,
                  optionHasSelected: N
                },
                U
              )),
              z.length <= 0 && /* @__PURE__ */ x.jsx("p", { children: g })
            ]
          }
        ),
        /* @__PURE__ */ x.jsx(
          EB,
          {
            disabled: w,
            isFocused: J,
            readOnly: u,
            iconSize: _,
            isLoading: l
          }
        ),
        /* @__PURE__ */ x.jsx(kB, { iconSize: _, isLoading: l }),
        /* @__PURE__ */ x.jsx(PB, { handleBlur: X, isFocused: J })
      ]
    }
  );
}
const c0 = ct({});
function MB() {
  return Ee(c0);
}
function C2(t) {
  const {
    defaultValue: e,
    name: n,
    value: r,
    onChange: o,
    size: i = "md",
    className: a = "",
    ...s
  } = t, [l, u] = B(e || ""), { inputRef: c, id: d } = dn();
  function f(h) {
    u(h), o && o(h);
  }
  const v = `arkynRadioGroup ${i} ${a}`;
  return /* @__PURE__ */ x.jsxs(
    c0.Provider,
    {
      value: { onChange: f, value: r || l, size: i },
      children: [
        /* @__PURE__ */ x.jsx(
          "input",
          {
            style: { display: "none" },
            type: "text",
            id: d,
            readOnly: !0,
            name: n,
            ref: c,
            value: r || l
          }
        ),
        /* @__PURE__ */ x.jsx("div", { className: v.trim(), ...s })
      ]
    }
  );
}
function w2(t) {
  const {
    value: e,
    size: n,
    disabled: r,
    children: o,
    className: i = "",
    ...a
  } = t, { onChange: s, size: l, value: u } = MB(), { error: c } = dn(), g = `arkynRadioBox ${n || l} ${u === e ? "checkedTrue" : "checkedFalse"} ${c ? "errorTrue" : "errorFalse"} ${r ? "disabledTrue" : "disabledFalse"} ${i}`;
  return /* @__PURE__ */ x.jsxs("label", { className: g.trim(), children: [
    /* @__PURE__ */ x.jsx(
      "button",
      {
        type: "button",
        disabled: r,
        onClick: () => s(e),
        onFocus: () => s(e),
        ...a
      }
    ),
    o
  ] });
}
var nr = {};
Object.defineProperty(nr, "__esModule", {
  value: !0
});
var BB = typeof window < "u" && /Mac|iPod|iPhone|iPad/.test(window.navigator.platform), Bl = {
  alt: "altKey",
  control: "ctrlKey",
  meta: "metaKey",
  shift: "shiftKey"
}, d0 = {
  add: "+",
  break: "pause",
  cmd: "meta",
  command: "meta",
  ctl: "control",
  ctrl: "control",
  del: "delete",
  down: "arrowdown",
  esc: "escape",
  ins: "insert",
  left: "arrowleft",
  mod: BB ? "meta" : "control",
  opt: "alt",
  option: "alt",
  return: "enter",
  right: "arrowright",
  space: " ",
  spacebar: " ",
  up: "arrowup",
  win: "meta",
  windows: "meta"
}, Qc = {
  backspace: 8,
  tab: 9,
  enter: 13,
  shift: 16,
  control: 17,
  alt: 18,
  pause: 19,
  capslock: 20,
  escape: 27,
  " ": 32,
  pageup: 33,
  pagedown: 34,
  end: 35,
  home: 36,
  arrowleft: 37,
  arrowup: 38,
  arrowright: 39,
  arrowdown: 40,
  insert: 45,
  delete: 46,
  meta: 91,
  numlock: 144,
  scrolllock: 145,
  ";": 186,
  "=": 187,
  ",": 188,
  "-": 189,
  ".": 190,
  "/": 191,
  "`": 192,
  "[": 219,
  "\\": 220,
  "]": 221,
  "'": 222
};
for (var Vi = 1; Vi < 20; Vi++)
  Qc["f" + Vi] = 111 + Vi;
function Ns(t, e, n) {
  e && !("byKey" in e) && (n = e, e = null), Array.isArray(t) || (t = [t]);
  var r = t.map(function(a) {
    return f0(a, e);
  }), o = function(s) {
    return r.some(function(l) {
      return p0(l, s);
    });
  }, i = n == null ? o : o(n);
  return i;
}
function TB(t, e) {
  return Ns(t, e);
}
function AB(t, e) {
  return Ns(t, { byKey: !0 }, e);
}
function f0(t, e) {
  var n = e && e.byKey, r = {};
  t = t.replace("++", "+add");
  var o = t.split("+"), i = o.length;
  for (var a in Bl)
    r[Bl[a]] = !1;
  var s = !0, l = !1, u = void 0;
  try {
    for (var c = o[Symbol.iterator](), d; !(s = (d = c.next()).done); s = !0) {
      var f = d.value, v = f.endsWith("?") && f.length > 1;
      v && (f = f.slice(0, -1));
      var h = ed(f), g = Bl[h];
      if (f.length > 1 && !g && !d0[f] && !Qc[h])
        throw new TypeError('Unknown modifier: "' + f + '"');
      (i === 1 || !g) && (n ? r.key = h : r.which = h0(f)), g && (r[g] = v ? null : !0);
    }
  } catch (p) {
    l = !0, u = p;
  } finally {
    try {
      !s && c.return && c.return();
    } finally {
      if (l)
        throw u;
    }
  }
  return r;
}
function p0(t, e) {
  for (var n in t) {
    var r = t[n], o = void 0;
    if (r != null && (n === "key" && e.key != null ? o = e.key.toLowerCase() : n === "which" ? o = r === 91 && e.which === 93 ? 91 : e.which : o = e[n], !(o == null && r === !1) && o !== r))
      return !1;
  }
  return !0;
}
function h0(t) {
  t = ed(t);
  var e = Qc[t] || t.toUpperCase().charCodeAt(0);
  return e;
}
function ed(t) {
  return t = t.toLowerCase(), t = d0[t] || t, t;
}
var jB = nr.default = Ns, Tl = nr.isHotkey = Ns;
nr.isCodeHotkey = TB;
nr.isKeyHotkey = AB;
nr.parseHotkey = f0;
nr.compareHotkey = p0;
nr.toKeyCode = h0;
nr.toKeyName = ed;
/*!
 * is-plain-object <https://github.com/jonschlinkert/is-plain-object>
 *
 * Copyright (c) 2014-2017, Jon Schlinkert.
 * Released under the MIT License.
 */
function pg(t) {
  return Object.prototype.toString.call(t) === "[object Object]";
}
function FB(t) {
  var e, n;
  return pg(t) === !1 ? !1 : (e = t.constructor, e === void 0 ? !0 : (n = e.prototype, !(pg(n) === !1 || n.hasOwnProperty("isPrototypeOf") === !1)));
}
var _B = {
  /**
   * Check if a value is a `History` object.
   */
  isHistory(t) {
    return FB(t) && Array.isArray(t.redos) && Array.isArray(t.undos) && (t.redos.length === 0 || vr.isOperationList(t.redos[0].operations)) && (t.undos.length === 0 || vr.isOperationList(t.undos[0].operations));
  }
}, Al = /* @__PURE__ */ new WeakMap(), Po = /* @__PURE__ */ new WeakMap(), zr = {
  /**
   * Check if a value is a `HistoryEditor` object.
   */
  isHistoryEditor(t) {
    return _B.isHistory(t.history) && D.isEditor(t);
  },
  /**
   * Get the merge flag's current value.
   */
  isMerging(t) {
    return Po.get(t);
  },
  /**
   * Get the saving flag's current value.
   */
  isSaving(t) {
    return Al.get(t);
  },
  /**
   * Redo to the previous saved state.
   */
  redo(t) {
    t.redo();
  },
  /**
   * Undo to the previous saved state.
   */
  undo(t) {
    t.undo();
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, These operations will
   * be merged into the previous history.
   */
  withMerging(t, e) {
    var n = zr.isMerging(t);
    Po.set(t, !0), e(), Po.set(t, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without merging any of
   * the new operations into previous save point in the history.
   */
  withoutMerging(t, e) {
    var n = zr.isMerging(t);
    Po.set(t, !1), e(), Po.set(t, n);
  },
  /**
   * Apply a series of changes inside a synchronous `fn`, without saving any of
   * their operations into the history.
   */
  withoutSaving(t, e) {
    var n = zr.isSaving(t);
    Al.set(t, !1), e(), Al.set(t, n);
  }
}, IB = (t) => {
  var e = t, {
    apply: n
  } = e;
  return e.history = {
    undos: [],
    redos: []
  }, e.redo = () => {
    var {
      history: r
    } = e, {
      redos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      i.selectionBefore && se.setSelection(e, i.selectionBefore), zr.withoutSaving(e, () => {
        D.withoutNormalizing(e, () => {
          for (var a of i.operations)
            e.apply(a);
        });
      }), r.redos.pop(), e.writeHistory("undos", i);
    }
  }, e.undo = () => {
    var {
      history: r
    } = e, {
      undos: o
    } = r;
    if (o.length > 0) {
      var i = o[o.length - 1];
      zr.withoutSaving(e, () => {
        D.withoutNormalizing(e, () => {
          var a = i.operations.map(vr.inverse).reverse();
          for (var s of a)
            e.apply(s);
          i.selectionBefore && se.setSelection(e, i.selectionBefore);
        });
      }), e.writeHistory("redos", i), r.undos.pop();
    }
  }, e.apply = (r) => {
    var {
      operations: o,
      history: i
    } = e, {
      undos: a
    } = i, s = a[a.length - 1], l = s && s.operations[s.operations.length - 1], u = zr.isSaving(e), c = zr.isMerging(e);
    if (u == null && (u = NB(r)), u) {
      if (c == null && (s == null ? c = !1 : o.length !== 0 ? c = !0 : c = RB(r, l)), s && c)
        s.operations.push(r);
      else {
        var d = {
          operations: [r],
          selectionBefore: e.selection
        };
        e.writeHistory("undos", d);
      }
      for (; a.length > 100; )
        a.shift();
      i.redos = [];
    }
    n(r);
  }, e.writeHistory = (r, o) => {
    e.history[r].push(o);
  }, e;
}, RB = (t, e) => !!(e && t.type === "insert_text" && e.type === "insert_text" && t.offset === e.offset + e.text.length && q.equals(t.path, e.path) || e && t.type === "remove_text" && e.type === "remove_text" && t.offset + t.text.length === e.offset && q.equals(t.path, e.path)), NB = (t, e) => t.type !== "set_selection", $B = WB, g0 = "֑-߿יִ-﷽ﹰ-ﻼ", v0 = "A-Za-zÀ-ÖØ-öø-ʸ̀-֐ࠀ-῿‎Ⰰ-﬜︀-﹯﻽-￿", zB = new RegExp("^[^" + v0 + "]*[" + g0 + "]"), UB = new RegExp("^[^" + g0 + "]*[" + v0 + "]");
function WB(t) {
  return t = String(t || ""), zB.test(t) ? "rtl" : UB.test(t) ? "ltr" : "neutral";
}
const m0 = /* @__PURE__ */ os($B);
function HB(t) {
  var e = typeof t;
  return t != null && (e == "object" || e == "function");
}
var td = HB, VB = typeof ht == "object" && ht && ht.Object === Object && ht, qB = VB, GB = qB, ZB = typeof self == "object" && self && self.Object === Object && self, KB = GB || ZB || Function("return this")(), y0 = KB, YB = y0, XB = function() {
  return YB.Date.now();
}, JB = XB, QB = /\s/;
function eT(t) {
  for (var e = t.length; e-- && QB.test(t.charAt(e)); )
    ;
  return e;
}
var tT = eT, nT = tT, rT = /^\s+/;
function oT(t) {
  return t && t.slice(0, nT(t) + 1).replace(rT, "");
}
var iT = oT, aT = y0, sT = aT.Symbol, b0 = sT, hg = b0, C0 = Object.prototype, lT = C0.hasOwnProperty, uT = C0.toString, ko = hg ? hg.toStringTag : void 0;
function cT(t) {
  var e = lT.call(t, ko), n = t[ko];
  try {
    t[ko] = void 0;
    var r = !0;
  } catch {
  }
  var o = uT.call(t);
  return r && (e ? t[ko] = n : delete t[ko]), o;
}
var dT = cT, fT = Object.prototype, pT = fT.toString;
function hT(t) {
  return pT.call(t);
}
var gT = hT, gg = b0, vT = dT, mT = gT, yT = "[object Null]", bT = "[object Undefined]", vg = gg ? gg.toStringTag : void 0;
function CT(t) {
  return t == null ? t === void 0 ? bT : yT : vg && vg in Object(t) ? vT(t) : mT(t);
}
var wT = CT;
function ET(t) {
  return t != null && typeof t == "object";
}
var DT = ET, OT = wT, xT = DT, LT = "[object Symbol]";
function ST(t) {
  return typeof t == "symbol" || xT(t) && OT(t) == LT;
}
var PT = ST, kT = iT, mg = td, MT = PT, yg = NaN, BT = /^[-+]0x[0-9a-f]+$/i, TT = /^0b[01]+$/i, AT = /^0o[0-7]+$/i, jT = parseInt;
function FT(t) {
  if (typeof t == "number")
    return t;
  if (MT(t))
    return yg;
  if (mg(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = mg(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = kT(t);
  var n = TT.test(t);
  return n || AT.test(t) ? jT(t.slice(2), n ? 2 : 8) : BT.test(t) ? yg : +t;
}
var _T = FT, IT = td, jl = JB, bg = _T, RT = "Expected a function", NT = Math.max, $T = Math.min;
function zT(t, e, n) {
  var r, o, i, a, s, l, u = 0, c = !1, d = !1, f = !0;
  if (typeof t != "function")
    throw new TypeError(RT);
  e = bg(e) || 0, IT(n) && (c = !!n.leading, d = "maxWait" in n, i = d ? NT(bg(n.maxWait) || 0, e) : i, f = "trailing" in n ? !!n.trailing : f);
  function v(O) {
    var S = r, W = o;
    return r = o = void 0, u = O, a = t.apply(W, S), a;
  }
  function h(O) {
    return u = O, s = setTimeout(w, e), c ? v(O) : a;
  }
  function g(O) {
    var S = O - l, W = O - u, P = e - S;
    return d ? $T(P, i - W) : P;
  }
  function p(O) {
    var S = O - l, W = O - u;
    return l === void 0 || S >= e || S < 0 || d && W >= i;
  }
  function w() {
    var O = jl();
    if (p(O))
      return b(O);
    s = setTimeout(w, g(O));
  }
  function b(O) {
    return s = void 0, f && r ? v(O) : (r = o = void 0, a);
  }
  function k() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function E() {
    return s === void 0 ? a : b(jl());
  }
  function m() {
    var O = jl(), S = p(O);
    if (r = arguments, o = this, l = O, S) {
      if (s === void 0)
        return h(l);
      if (d)
        return clearTimeout(s), s = setTimeout(w, e), v(l);
    }
    return s === void 0 && (s = setTimeout(w, e)), a;
  }
  return m.cancel = k, m.flush = E, m;
}
var w0 = zT;
const UT = /* @__PURE__ */ os(w0);
var WT = w0, HT = td, VT = "Expected a function";
function qT(t, e, n) {
  var r = !0, o = !0;
  if (typeof t != "function")
    throw new TypeError(VT);
  return HT(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), WT(t, e, {
    leading: r,
    maxWait: e,
    trailing: o
  });
}
var GT = qT;
const ZT = /* @__PURE__ */ os(GT), Cg = (t) => typeof t == "object" && t != null && t.nodeType === 1, wg = (t, e) => (!e || t !== "hidden") && t !== "visible" && t !== "clip", Fl = (t, e) => {
  if (t.clientHeight < t.scrollHeight || t.clientWidth < t.scrollWidth) {
    const n = getComputedStyle(t, null);
    return wg(n.overflowY, e) || wg(n.overflowX, e) || ((r) => {
      const o = ((i) => {
        if (!i.ownerDocument || !i.ownerDocument.defaultView) return null;
        try {
          return i.ownerDocument.defaultView.frameElement;
        } catch {
          return null;
        }
      })(r);
      return !!o && (o.clientHeight < r.scrollHeight || o.clientWidth < r.scrollWidth);
    })(t);
  }
  return !1;
}, qi = (t, e, n, r, o, i, a, s) => i < t && a > e || i > t && a < e ? 0 : i <= t && s <= n || a >= e && s >= n ? i - t - r : a > e && s < n || i < t && s > n ? a - e + o : 0, KT = (t) => {
  const e = t.parentElement;
  return e ?? (t.getRootNode().host || null);
}, Eg = (t, e) => {
  var n, r, o, i;
  if (typeof document > "u") return [];
  const { scrollMode: a, block: s, inline: l, boundary: u, skipOverflowHiddenElements: c } = e, d = typeof u == "function" ? u : (J) => J !== u;
  if (!Cg(t)) throw new TypeError("Invalid target");
  const f = document.scrollingElement || document.documentElement, v = [];
  let h = t;
  for (; Cg(h) && d(h); ) {
    if (h = KT(h), h === f) {
      v.push(h);
      break;
    }
    h != null && h === document.body && Fl(h) && !Fl(document.documentElement) || h != null && Fl(h, c) && v.push(h);
  }
  const g = (r = (n = window.visualViewport) == null ? void 0 : n.width) != null ? r : innerWidth, p = (i = (o = window.visualViewport) == null ? void 0 : o.height) != null ? i : innerHeight, { scrollX: w, scrollY: b } = window, { height: k, width: E, top: m, right: O, bottom: S, left: W } = t.getBoundingClientRect(), { top: P, right: $, bottom: j, left: _ } = ((J) => {
    const G = window.getComputedStyle(J);
    return { top: parseFloat(G.scrollMarginTop) || 0, right: parseFloat(G.scrollMarginRight) || 0, bottom: parseFloat(G.scrollMarginBottom) || 0, left: parseFloat(G.scrollMarginLeft) || 0 };
  })(t);
  let I = s === "start" || s === "nearest" ? m - P : s === "end" ? S + j : m + k / 2 - P + j, R = l === "center" ? W + E / 2 - _ + $ : l === "end" ? O + $ : W - _;
  const V = [];
  for (let J = 0; J < v.length; J++) {
    const G = v[J], { height: te, width: Q, top: T, right: N, bottom: Y, left: F } = G.getBoundingClientRect();
    if (a === "if-needed" && m >= 0 && W >= 0 && S <= p && O <= g && m >= T && S <= Y && W >= F && O <= N) return V;
    const X = getComputedStyle(G), L = parseInt(X.borderLeftWidth, 10), M = parseInt(X.borderTopWidth, 10), z = parseInt(X.borderRightWidth, 10), A = parseInt(X.borderBottomWidth, 10);
    let U = 0, H = 0;
    const ee = "offsetWidth" in G ? G.offsetWidth - G.clientWidth - L - z : 0, Z = "offsetHeight" in G ? G.offsetHeight - G.clientHeight - M - A : 0, pe = "offsetWidth" in G ? G.offsetWidth === 0 ? 0 : Q / G.offsetWidth : 0, he = "offsetHeight" in G ? G.offsetHeight === 0 ? 0 : te / G.offsetHeight : 0;
    if (f === G) U = s === "start" ? I : s === "end" ? I - p : s === "nearest" ? qi(b, b + p, p, M, A, b + I, b + I + k, k) : I - p / 2, H = l === "start" ? R : l === "center" ? R - g / 2 : l === "end" ? R - g : qi(w, w + g, g, L, z, w + R, w + R + E, E), U = Math.max(0, U + b), H = Math.max(0, H + w);
    else {
      U = s === "start" ? I - T - M : s === "end" ? I - Y + A + Z : s === "nearest" ? qi(T, Y, te, M, A + Z, I, I + k, k) : I - (T + te / 2) + Z / 2, H = l === "start" ? R - F - L : l === "center" ? R - (F + Q / 2) + ee / 2 : l === "end" ? R - N + z + ee : qi(F, N, Q, L, z + ee, R, R + E, E);
      const { scrollLeft: le, scrollTop: Le } = G;
      U = he === 0 ? 0 : Math.max(0, Math.min(Le + U / he, G.scrollHeight - te / he + Z)), H = pe === 0 ? 0 : Math.max(0, Math.min(le + H / pe, G.scrollWidth - Q / pe + ee)), I += Le - U, R += le - H;
    }
    V.push({ el: G, top: U, left: H });
  }
  return V;
}, YT = (t) => t === !1 ? { block: "end", inline: "nearest" } : ((e) => e === Object(e) && Object.keys(e).length !== 0)(t) ? t : { block: "start", inline: "nearest" };
function XT(t, e) {
  if (!t.isConnected || !((o) => {
    let i = o;
    for (; i && i.parentNode; ) {
      if (i.parentNode === document) return !0;
      i = i.parentNode instanceof ShadowRoot ? i.parentNode.host : i.parentNode;
    }
    return !1;
  })(t)) return;
  const n = ((o) => {
    const i = window.getComputedStyle(o);
    return { top: parseFloat(i.scrollMarginTop) || 0, right: parseFloat(i.scrollMarginRight) || 0, bottom: parseFloat(i.scrollMarginBottom) || 0, left: parseFloat(i.scrollMarginLeft) || 0 };
  })(t);
  if (((o) => typeof o == "object" && typeof o.behavior == "function")(e)) return e.behavior(Eg(t, e));
  const r = typeof e == "boolean" || e == null ? void 0 : e.behavior;
  for (const { el: o, top: i, left: a } of Eg(t, YT(e))) {
    const s = i - n.top + n.bottom, l = a - n.left + n.right;
    o.scroll({ top: s, left: l, behavior: r });
  }
}
var Hr = [], JT = function() {
  return Hr.some(function(t) {
    return t.activeTargets.length > 0;
  });
}, QT = function() {
  return Hr.some(function(t) {
    return t.skippedTargets.length > 0;
  });
}, Dg = "ResizeObserver loop completed with undelivered notifications.", eA = function() {
  var t;
  typeof ErrorEvent == "function" ? t = new ErrorEvent("error", {
    message: Dg
  }) : (t = document.createEvent("Event"), t.initEvent("error", !1, !1), t.message = Dg), window.dispatchEvent(t);
}, ri;
(function(t) {
  t.BORDER_BOX = "border-box", t.CONTENT_BOX = "content-box", t.DEVICE_PIXEL_CONTENT_BOX = "device-pixel-content-box";
})(ri || (ri = {}));
var Vr = function(t) {
  return Object.freeze(t);
}, tA = /* @__PURE__ */ function() {
  function t(e, n) {
    this.inlineSize = e, this.blockSize = n, Vr(this);
  }
  return t;
}(), E0 = function() {
  function t(e, n, r, o) {
    return this.x = e, this.y = n, this.width = r, this.height = o, this.top = this.y, this.left = this.x, this.bottom = this.top + this.height, this.right = this.left + this.width, Vr(this);
  }
  return t.prototype.toJSON = function() {
    var e = this, n = e.x, r = e.y, o = e.top, i = e.right, a = e.bottom, s = e.left, l = e.width, u = e.height;
    return { x: n, y: r, top: o, right: i, bottom: a, left: s, width: l, height: u };
  }, t.fromRect = function(e) {
    return new t(e.x, e.y, e.width, e.height);
  }, t;
}(), nd = function(t) {
  return t instanceof SVGElement && "getBBox" in t;
}, D0 = function(t) {
  if (nd(t)) {
    var e = t.getBBox(), n = e.width, r = e.height;
    return !n && !r;
  }
  var o = t, i = o.offsetWidth, a = o.offsetHeight;
  return !(i || a || t.getClientRects().length);
}, Og = function(t) {
  var e;
  if (t instanceof Element)
    return !0;
  var n = (e = t == null ? void 0 : t.ownerDocument) === null || e === void 0 ? void 0 : e.defaultView;
  return !!(n && t instanceof n.Element);
}, nA = function(t) {
  switch (t.tagName) {
    case "INPUT":
      if (t.type !== "image")
        break;
    case "VIDEO":
    case "AUDIO":
    case "EMBED":
    case "OBJECT":
    case "CANVAS":
    case "IFRAME":
    case "IMG":
      return !0;
  }
  return !1;
}, Wo = typeof window < "u" ? window : {}, Gi = /* @__PURE__ */ new WeakMap(), xg = /auto|scroll/, rA = /^tb|vertical/, oA = /msie|trident/i.test(Wo.navigator && Wo.navigator.userAgent), In = function(t) {
  return parseFloat(t || "0");
}, oo = function(t, e, n) {
  return t === void 0 && (t = 0), e === void 0 && (e = 0), n === void 0 && (n = !1), new tA((n ? e : t) || 0, (n ? t : e) || 0);
}, Lg = Vr({
  devicePixelContentBoxSize: oo(),
  borderBoxSize: oo(),
  contentBoxSize: oo(),
  contentRect: new E0(0, 0, 0, 0)
}), O0 = function(t, e) {
  if (e === void 0 && (e = !1), Gi.has(t) && !e)
    return Gi.get(t);
  if (D0(t))
    return Gi.set(t, Lg), Lg;
  var n = getComputedStyle(t), r = nd(t) && t.ownerSVGElement && t.getBBox(), o = !oA && n.boxSizing === "border-box", i = rA.test(n.writingMode || ""), a = !r && xg.test(n.overflowY || ""), s = !r && xg.test(n.overflowX || ""), l = r ? 0 : In(n.paddingTop), u = r ? 0 : In(n.paddingRight), c = r ? 0 : In(n.paddingBottom), d = r ? 0 : In(n.paddingLeft), f = r ? 0 : In(n.borderTopWidth), v = r ? 0 : In(n.borderRightWidth), h = r ? 0 : In(n.borderBottomWidth), g = r ? 0 : In(n.borderLeftWidth), p = d + u, w = l + c, b = g + v, k = f + h, E = s ? t.offsetHeight - k - t.clientHeight : 0, m = a ? t.offsetWidth - b - t.clientWidth : 0, O = o ? p + b : 0, S = o ? w + k : 0, W = r ? r.width : In(n.width) - O - m, P = r ? r.height : In(n.height) - S - E, $ = W + p + m + b, j = P + w + E + k, _ = Vr({
    devicePixelContentBoxSize: oo(Math.round(W * devicePixelRatio), Math.round(P * devicePixelRatio), i),
    borderBoxSize: oo($, j, i),
    contentBoxSize: oo(W, P, i),
    contentRect: new E0(d, l, W, P)
  });
  return Gi.set(t, _), _;
}, x0 = function(t, e, n) {
  var r = O0(t, n), o = r.borderBoxSize, i = r.contentBoxSize, a = r.devicePixelContentBoxSize;
  switch (e) {
    case ri.DEVICE_PIXEL_CONTENT_BOX:
      return a;
    case ri.BORDER_BOX:
      return o;
    default:
      return i;
  }
}, iA = /* @__PURE__ */ function() {
  function t(e) {
    var n = O0(e);
    this.target = e, this.contentRect = n.contentRect, this.borderBoxSize = Vr([n.borderBoxSize]), this.contentBoxSize = Vr([n.contentBoxSize]), this.devicePixelContentBoxSize = Vr([n.devicePixelContentBoxSize]);
  }
  return t;
}(), L0 = function(t) {
  if (D0(t))
    return 1 / 0;
  for (var e = 0, n = t.parentNode; n; )
    e += 1, n = n.parentNode;
  return e;
}, aA = function() {
  var t = 1 / 0, e = [];
  Hr.forEach(function(a) {
    if (a.activeTargets.length !== 0) {
      var s = [];
      a.activeTargets.forEach(function(u) {
        var c = new iA(u.target), d = L0(u.target);
        s.push(c), u.lastReportedSize = x0(u.target, u.observedBox), d < t && (t = d);
      }), e.push(function() {
        a.callback.call(a.observer, s, a.observer);
      }), a.activeTargets.splice(0, a.activeTargets.length);
    }
  });
  for (var n = 0, r = e; n < r.length; n++) {
    var o = r[n];
    o();
  }
  return t;
}, Sg = function(t) {
  Hr.forEach(function(n) {
    n.activeTargets.splice(0, n.activeTargets.length), n.skippedTargets.splice(0, n.skippedTargets.length), n.observationTargets.forEach(function(o) {
      o.isActive() && (L0(o.target) > t ? n.activeTargets.push(o) : n.skippedTargets.push(o));
    });
  });
}, sA = function() {
  var t = 0;
  for (Sg(t); JT(); )
    t = aA(), Sg(t);
  return QT() && eA(), t > 0;
}, _l, S0 = [], lA = function() {
  return S0.splice(0).forEach(function(t) {
    return t();
  });
}, uA = function(t) {
  if (!_l) {
    var e = 0, n = document.createTextNode(""), r = { characterData: !0 };
    new MutationObserver(function() {
      return lA();
    }).observe(n, r), _l = function() {
      n.textContent = "".concat(e ? e-- : e++);
    };
  }
  S0.push(t), _l();
}, cA = function(t) {
  uA(function() {
    requestAnimationFrame(t);
  });
}, ca = 0, dA = function() {
  return !!ca;
}, fA = 250, pA = { attributes: !0, characterData: !0, childList: !0, subtree: !0 }, Pg = [
  "resize",
  "load",
  "transitionend",
  "animationend",
  "animationstart",
  "animationiteration",
  "keyup",
  "keydown",
  "mouseup",
  "mousedown",
  "mouseover",
  "mouseout",
  "blur",
  "focus"
], kg = function(t) {
  return t === void 0 && (t = 0), Date.now() + t;
}, Il = !1, hA = function() {
  function t() {
    var e = this;
    this.stopped = !0, this.listener = function() {
      return e.schedule();
    };
  }
  return t.prototype.run = function(e) {
    var n = this;
    if (e === void 0 && (e = fA), !Il) {
      Il = !0;
      var r = kg(e);
      cA(function() {
        var o = !1;
        try {
          o = sA();
        } finally {
          if (Il = !1, e = r - kg(), !dA())
            return;
          o ? n.run(1e3) : e > 0 ? n.run(e) : n.start();
        }
      });
    }
  }, t.prototype.schedule = function() {
    this.stop(), this.run();
  }, t.prototype.observe = function() {
    var e = this, n = function() {
      return e.observer && e.observer.observe(document.body, pA);
    };
    document.body ? n() : Wo.addEventListener("DOMContentLoaded", n);
  }, t.prototype.start = function() {
    var e = this;
    this.stopped && (this.stopped = !1, this.observer = new MutationObserver(this.listener), this.observe(), Pg.forEach(function(n) {
      return Wo.addEventListener(n, e.listener, !0);
    }));
  }, t.prototype.stop = function() {
    var e = this;
    this.stopped || (this.observer && this.observer.disconnect(), Pg.forEach(function(n) {
      return Wo.removeEventListener(n, e.listener, !0);
    }), this.stopped = !0);
  }, t;
}(), ju = new hA(), Mg = function(t) {
  !ca && t > 0 && ju.start(), ca += t, !ca && ju.stop();
}, gA = function(t) {
  return !nd(t) && !nA(t) && getComputedStyle(t).display === "inline";
}, vA = function() {
  function t(e, n) {
    this.target = e, this.observedBox = n || ri.CONTENT_BOX, this.lastReportedSize = {
      inlineSize: 0,
      blockSize: 0
    };
  }
  return t.prototype.isActive = function() {
    var e = x0(this.target, this.observedBox, !0);
    return gA(this.target) && (this.lastReportedSize = e), this.lastReportedSize.inlineSize !== e.inlineSize || this.lastReportedSize.blockSize !== e.blockSize;
  }, t;
}(), mA = /* @__PURE__ */ function() {
  function t(e, n) {
    this.activeTargets = [], this.skippedTargets = [], this.observationTargets = [], this.observer = e, this.callback = n;
  }
  return t;
}(), Zi = /* @__PURE__ */ new WeakMap(), Bg = function(t, e) {
  for (var n = 0; n < t.length; n += 1)
    if (t[n].target === e)
      return n;
  return -1;
}, Ki = function() {
  function t() {
  }
  return t.connect = function(e, n) {
    var r = new mA(e, n);
    Zi.set(e, r);
  }, t.observe = function(e, n, r) {
    var o = Zi.get(e), i = o.observationTargets.length === 0;
    Bg(o.observationTargets, n) < 0 && (i && Hr.push(o), o.observationTargets.push(new vA(n, r && r.box)), Mg(1), ju.schedule());
  }, t.unobserve = function(e, n) {
    var r = Zi.get(e), o = Bg(r.observationTargets, n), i = r.observationTargets.length === 1;
    o >= 0 && (i && Hr.splice(Hr.indexOf(r), 1), r.observationTargets.splice(o, 1), Mg(-1));
  }, t.disconnect = function(e) {
    var n = this, r = Zi.get(e);
    r.observationTargets.slice().forEach(function(o) {
      return n.unobserve(e, o.target);
    }), r.activeTargets.splice(0, r.activeTargets.length);
  }, t;
}(), yA = function() {
  function t(e) {
    if (arguments.length === 0)
      throw new TypeError("Failed to construct 'ResizeObserver': 1 argument required, but only 0 present.");
    if (typeof e != "function")
      throw new TypeError("Failed to construct 'ResizeObserver': The callback provided as parameter 1 is not a function.");
    Ki.connect(this, e);
  }
  return t.prototype.observe = function(e, n) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!Og(e))
      throw new TypeError("Failed to execute 'observe' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Ki.observe(this, e, n);
  }, t.prototype.unobserve = function(e) {
    if (arguments.length === 0)
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': 1 argument required, but only 0 present.");
    if (!Og(e))
      throw new TypeError("Failed to execute 'unobserve' on 'ResizeObserver': parameter 1 is not of type 'Element");
    Ki.unobserve(this, e);
  }, t.prototype.disconnect = function() {
    Ki.disconnect(this);
  }, t.toString = function() {
    return "function ResizeObserver () { [polyfill code] }";
  }, t;
}();
function bA(t, e) {
  if (t == null) return {};
  var n = {}, r = Object.keys(t), o, i;
  for (i = 0; i < r.length; i++)
    o = r[i], !(e.indexOf(o) >= 0) && (n[o] = t[o]);
  return n;
}
function uo(t, e) {
  if (t == null) return {};
  var n = bA(t, e), r, o;
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    for (o = 0; o < i.length; o++)
      r = i[o], !(e.indexOf(r) >= 0) && Object.prototype.propertyIsEnumerable.call(t, r) && (n[r] = t[r]);
  }
  return n;
}
function oi(t) {
  "@babel/helpers - typeof";
  return oi = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, oi(t);
}
function CA(t, e) {
  if (oi(t) !== "object" || t === null) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (oi(r) !== "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function wA(t) {
  var e = CA(t, "string");
  return oi(e) === "symbol" ? e : String(e);
}
function Mn(t, e, n) {
  return e = wA(e), e in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
var rd = /* @__PURE__ */ ct(null), Sr = () => {
  var t = Ee(rd);
  if (!t)
    throw new Error("The `useSlateStatic` hook must be used inside the <Slate> component's context.");
  return t;
}, Rl, Nl, P0 = parseInt(be.version.split(".")[0], 10), k0 = typeof navigator < "u" && typeof window < "u" && /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream, Tg = typeof navigator < "u" && /Mac OS X/.test(navigator.userAgent), tn = typeof navigator < "u" && /Android/.test(navigator.userAgent), no = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox).*/i.test(navigator.userAgent), Ir = typeof navigator < "u" && /AppleWebKit(?!.*Chrome)/i.test(navigator.userAgent), EA = typeof navigator < "u" && /Edge?\/(?:[0-6][0-9]|[0-7][0-8])(?:\.)/i.test(navigator.userAgent), M0 = typeof navigator < "u" && /Chrome/i.test(navigator.userAgent), DA = typeof navigator < "u" && /Chrome?\/(?:[0-7][0-5]|[0-6][0-9])(?:\.)/i.test(navigator.userAgent), OA = tn && typeof navigator < "u" && /Chrome?\/(?:[0-5]?\d)(?:\.)/i.test(navigator.userAgent), xA = typeof navigator < "u" && /^(?!.*Seamonkey)(?=.*Firefox\/(?:[0-7][0-9]|[0-8][0-6])(?:\.)).*/i.test(navigator.userAgent), LA = typeof navigator < "u" && /.*UCBrowser/.test(navigator.userAgent), SA = typeof navigator < "u" && /.*Wechat/.test(navigator.userAgent) && !/.*MacWechat/.test(navigator.userAgent), da = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u";
typeof navigator < "u" && /Safari/.test(navigator.userAgent) && /Version\/(\d+)/.test(navigator.userAgent) && ((Rl = navigator.userAgent.match(/Version\/(\d+)/)) !== null && Rl !== void 0 && Rl[1] && parseInt((Nl = navigator.userAgent.match(/Version\/(\d+)/)) === null || Nl === void 0 ? void 0 : Nl[1], 10) < 17);
var ir = (!DA || !OA) && !EA && // globalThis is undefined in older browsers
typeof globalThis < "u" && globalThis.InputEvent && // @ts-ignore The `getTargetRanges` property isn't recognized.
typeof globalThis.InputEvent.prototype.getTargetRanges == "function", io = /* @__PURE__ */ new WeakMap(), od = /* @__PURE__ */ new WeakMap(), id = /* @__PURE__ */ new WeakMap(), B0 = /* @__PURE__ */ new WeakMap(), fa = /* @__PURE__ */ new WeakMap(), Fu = /* @__PURE__ */ new WeakMap(), ii = /* @__PURE__ */ new WeakMap(), qr = /* @__PURE__ */ new WeakMap(), Ua = /* @__PURE__ */ new WeakMap(), $s = /* @__PURE__ */ new WeakMap(), _u = /* @__PURE__ */ new WeakMap(), mr = /* @__PURE__ */ new WeakMap(), Ur = /* @__PURE__ */ new WeakMap(), Ho = /* @__PURE__ */ new WeakMap(), Iu = /* @__PURE__ */ new WeakMap(), ad = /* @__PURE__ */ new WeakMap(), jn = /* @__PURE__ */ new WeakMap(), Xn = /* @__PURE__ */ new WeakMap(), an = /* @__PURE__ */ new WeakMap(), dr = /* @__PURE__ */ new WeakMap(), fr = /* @__PURE__ */ new WeakMap(), T0 = /* @__PURE__ */ new WeakMap(), co = Symbol("placeholder"), A0 = Symbol("mark-placeholder"), j0 = globalThis.Node, PA = globalThis.Text, sd = (t) => t && t.ownerDocument && t.ownerDocument.defaultView || null, kA = (t) => br(t) && t.nodeType === 8, kn = (t) => br(t) && t.nodeType === 1, br = (t) => {
  var e = sd(t);
  return !!e && t instanceof e.Node;
}, Ru = (t) => {
  var e = t && t.anchorNode && sd(t.anchorNode);
  return !!e && t instanceof e.Selection;
}, F0 = (t) => br(t) && t.nodeType === 3, MA = (t) => t.clipboardData && t.clipboardData.getData("text/plain") !== "" && t.clipboardData.types.length === 1, BA = (t) => {
  var [e, n] = t;
  if (kn(e) && e.childNodes.length) {
    var r = n === e.childNodes.length, o = r ? n - 1 : n;
    for ([e, o] = _0(e, o, r ? "backward" : "forward"), r = o < n; kn(e) && e.childNodes.length; ) {
      var i = r ? e.childNodes.length - 1 : 0;
      e = AA(e, i, r ? "backward" : "forward");
    }
    n = r && e.textContent != null ? e.textContent.length : 0;
  }
  return [e, n];
}, TA = (t) => {
  for (var e = t && t.parentNode; e; ) {
    if (e.toString() === "[object ShadowRoot]")
      return !0;
    e = e.parentNode;
  }
  return !1;
}, _0 = (t, e, n) => {
  for (var {
    childNodes: r
  } = t, o = r[e], i = e, a = !1, s = !1; (kA(o) || kn(o) && o.childNodes.length === 0 || kn(o) && o.getAttribute("contenteditable") === "false") && !(a && s); ) {
    if (i >= r.length) {
      a = !0, i = e - 1, n = "backward";
      continue;
    }
    if (i < 0) {
      s = !0, i = e + 1, n = "forward";
      continue;
    }
    o = r[i], e = i, i += n === "forward" ? 1 : -1;
  }
  return [o, e];
}, AA = (t, e, n) => {
  var [r] = _0(t, e, n);
  return r;
}, I0 = (t) => {
  var e = "";
  if (F0(t) && t.nodeValue)
    return t.nodeValue;
  if (kn(t)) {
    for (var n of Array.from(t.childNodes))
      e += I0(n);
    var r = getComputedStyle(t).getPropertyValue("display");
    (r === "block" || r === "list" || t.tagName === "BR") && (e += `
`);
  }
  return e;
}, jA = /data-slate-fragment="(.+?)"/m, FA = (t) => {
  var e = t.getData("text/html"), [, n] = e.match(jA) || [];
  return n;
}, Vo = (t) => t.getSelection != null ? t.getSelection() : document.getSelection(), ld = (t, e, n) => {
  var {
    target: r
  } = e;
  if (kn(r) && r.matches('[contentEditable="false"]'))
    return !1;
  var {
    document: o
  } = ie.getWindow(t);
  if (o.contains(r))
    return ie.hasDOMNode(t, r, {
      editable: !0
    });
  var i = n.find((a) => {
    var {
      addedNodes: s,
      removedNodes: l
    } = a;
    for (var u of s)
      if (u === r || u.contains(r))
        return !0;
    for (var c of l)
      if (c === r || c.contains(r))
        return !0;
  });
  return !i || i === e ? !1 : ld(t, i, n);
}, _A = () => {
  for (var t = document.activeElement; (e = t) !== null && e !== void 0 && e.shadowRoot && (n = t.shadowRoot) !== null && n !== void 0 && n.activeElement; ) {
    var e, n, r;
    t = (r = t) === null || r === void 0 || (r = r.shadowRoot) === null || r === void 0 ? void 0 : r.activeElement;
  }
  return t;
}, Ag = (t, e) => !!(t.compareDocumentPosition(e) & j0.DOCUMENT_POSITION_PRECEDING), IA = (t, e) => !!(t.compareDocumentPosition(e) & j0.DOCUMENT_POSITION_FOLLOWING), RA = 0;
class NA {
  constructor() {
    Mn(this, "id", void 0), this.id = "".concat(RA++);
  }
}
var ie = {
  androidPendingDiffs: (t) => an.get(t),
  androidScheduleFlush: (t) => {
    var e;
    (e = ad.get(t)) === null || e === void 0 || e();
  },
  blur: (t) => {
    var e = ie.toDOMNode(t, t), n = ie.findDocumentOrShadowRoot(t);
    mr.set(t, !1), n.activeElement === e && e.blur();
  },
  deselect: (t) => {
    var {
      selection: e
    } = t, n = ie.findDocumentOrShadowRoot(t), r = Vo(n);
    r && r.rangeCount > 0 && r.removeAllRanges(), e && se.deselect(t);
  },
  findDocumentOrShadowRoot: (t) => {
    var e = ie.toDOMNode(t, t), n = e.getRootNode();
    return n instanceof Document || n instanceof ShadowRoot ? n : e.ownerDocument;
  },
  findEventRange: (t, e) => {
    "nativeEvent" in e && (e = e.nativeEvent);
    var {
      clientX: n,
      clientY: r,
      target: o
    } = e;
    if (n == null || r == null)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(e));
    var i = ie.toSlateNode(t, e.target), a = ie.findPath(t, i);
    if (me.isElement(i) && D.isVoid(t, i)) {
      var s = o.getBoundingClientRect(), l = t.isInline(i) ? n - s.left < s.left + s.width - n : r - s.top < s.top + s.height - r, u = D.point(t, a, {
        edge: l ? "start" : "end"
      }), c = l ? D.before(t, u) : D.after(t, u);
      if (c) {
        var d = D.range(t, c);
        return d;
      }
    }
    var f, {
      document: v
    } = ie.getWindow(t);
    if (v.caretRangeFromPoint)
      f = v.caretRangeFromPoint(n, r);
    else {
      var h = v.caretPositionFromPoint(n, r);
      h && (f = v.createRange(), f.setStart(h.offsetNode, h.offset), f.setEnd(h.offsetNode, h.offset));
    }
    if (!f)
      throw new Error("Cannot resolve a Slate range from a DOM event: ".concat(e));
    var g = ie.toSlateRange(t, f, {
      exactMatch: !1,
      suppressThrow: !1
    });
    return g;
  },
  findKey: (t, e) => {
    var n = Ua.get(e);
    return n || (n = new NA(), Ua.set(e, n)), n;
  },
  findPath: (t, e) => {
    for (var n = [], r = e; ; ) {
      var o = id.get(r);
      if (o == null) {
        if (D.isEditor(r))
          return n;
        break;
      }
      var i = od.get(r);
      if (i == null)
        break;
      n.unshift(i), r = o;
    }
    throw new Error("Unable to find the path for Slate node: ".concat(Ut.stringify(e)));
  },
  focus: function(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {
      retries: 5
    };
    if (!mr.get(e)) {
      if (n.retries <= 0)
        throw new Error("Could not set focus, editor seems stuck with pending operations");
      if (e.operations.length > 0) {
        setTimeout(() => {
          ie.focus(e, {
            retries: n.retries - 1
          });
        }, 10);
        return;
      }
      var r = ie.toDOMNode(e, e), o = ie.findDocumentOrShadowRoot(e);
      if (o.activeElement !== r) {
        if (e.selection && o instanceof Document) {
          var i = Vo(o), a = ie.toDOMRange(e, e.selection);
          i == null || i.removeAllRanges(), i == null || i.addRange(a);
        }
        e.selection || se.select(e, D.start(e, [])), mr.set(e, !0), r.focus({
          preventScroll: !0
        });
      }
    }
  },
  getWindow: (t) => {
    var e = B0.get(t);
    if (!e)
      throw new Error("Unable to find a host window element for this editor");
    return e;
  },
  hasDOMNode: function(e, n) {
    var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {}, {
      editable: o = !1
    } = r, i = ie.toDOMNode(e, e), a;
    try {
      a = kn(n) ? n : n.parentElement;
    } catch (s) {
      if (s instanceof Error && !s.message.includes('Permission denied to access property "nodeType"'))
        throw s;
    }
    return a ? a.closest("[data-slate-editor]") === i && (!o || a.isContentEditable ? !0 : typeof a.isContentEditable == "boolean" && // isContentEditable exists only on HTMLElement, and on other nodes it will be undefined
    // this is the core logic that lets you know you got the right editor.selection instead of null when editor is contenteditable="false"(readOnly)
    a.closest('[contenteditable="false"]') === i || !!a.getAttribute("data-slate-zero-width")) : !1;
  },
  hasEditableTarget: (t, e) => br(e) && ie.hasDOMNode(t, e, {
    editable: !0
  }),
  hasRange: (t, e) => {
    var {
      anchor: n,
      focus: r
    } = e;
    return D.hasPath(t, n.path) && D.hasPath(t, r.path);
  },
  hasSelectableTarget: (t, e) => ie.hasEditableTarget(t, e) || ie.isTargetInsideNonReadonlyVoid(t, e),
  hasTarget: (t, e) => br(e) && ie.hasDOMNode(t, e),
  insertData: (t, e) => {
    t.insertData(e);
  },
  insertFragmentData: (t, e) => t.insertFragmentData(e),
  insertTextData: (t, e) => t.insertTextData(e),
  isComposing: (t) => !!Ur.get(t),
  isFocused: (t) => !!mr.get(t),
  isReadOnly: (t) => !!_u.get(t),
  isTargetInsideNonReadonlyVoid: (t, e) => {
    if (_u.get(t)) return !1;
    var n = ie.hasTarget(t, e) && ie.toSlateNode(t, e);
    return me.isElement(n) && D.isVoid(t, n);
  },
  setFragmentData: (t, e, n) => t.setFragmentData(e, n),
  toDOMNode: (t, e) => {
    var n = $s.get(t), r = D.isEditor(e) ? fa.get(t) : n == null ? void 0 : n.get(ie.findKey(t, e));
    if (!r)
      throw new Error("Cannot resolve a DOM node from Slate node: ".concat(Ut.stringify(e)));
    return r;
  },
  toDOMPoint: (t, e) => {
    var [n] = D.node(t, e.path), r = ie.toDOMNode(t, n), o;
    D.void(t, {
      at: e
    }) && (e = {
      path: e.path,
      offset: 0
    });
    for (var i = "[data-slate-string], [data-slate-zero-width]", a = Array.from(r.querySelectorAll(i)), s = 0, l = 0; l < a.length; l++) {
      var u = a[l], c = u.childNodes[0];
      if (!(c == null || c.textContent == null)) {
        var {
          length: d
        } = c.textContent, f = u.getAttribute("data-slate-length"), v = f == null ? d : parseInt(f, 10), h = s + v, g = a[l + 1];
        if (e.offset === h && g !== null && g !== void 0 && g.hasAttribute("data-slate-mark-placeholder")) {
          var p, w = g.childNodes[0];
          o = [
            // COMPAT: If we don't explicity set the dom point to be on the actual
            // dom text element, chrome will put the selection behind the actual dom
            // text element, causing domRange.getBoundingClientRect() calls on a collapsed
            // selection to return incorrect zero values (https://bugs.chromium.org/p/chromium/issues/detail?id=435438)
            // which will cause issues when scrolling to it.
            w instanceof PA ? w : g,
            (p = g.textContent) !== null && p !== void 0 && p.startsWith("\uFEFF") ? 1 : 0
          ];
          break;
        }
        if (e.offset <= h) {
          var b = Math.min(d, Math.max(0, e.offset - s));
          o = [c, b];
          break;
        }
        s = h;
      }
    }
    if (!o)
      throw new Error("Cannot resolve a DOM point from Slate point: ".concat(Ut.stringify(e)));
    return o;
  },
  toDOMRange: (t, e) => {
    var {
      anchor: n,
      focus: r
    } = e, o = re.isBackward(e), i = ie.toDOMPoint(t, n), a = re.isCollapsed(e) ? i : ie.toDOMPoint(t, r), s = ie.getWindow(t), l = s.document.createRange(), [u, c] = o ? a : i, [d, f] = o ? i : a, v = kn(u) ? u : u.parentElement, h = !!v.getAttribute("data-slate-zero-width"), g = kn(d) ? d : d.parentElement, p = !!g.getAttribute("data-slate-zero-width");
    return l.setStart(u, h ? 1 : c), l.setEnd(d, p ? 1 : f), l;
  },
  toSlateNode: (t, e) => {
    var n = kn(e) ? e : e.parentElement;
    n && !n.hasAttribute("data-slate-node") && (n = n.closest("[data-slate-node]"));
    var r = n ? ii.get(n) : null;
    if (!r)
      throw new Error("Cannot resolve a Slate node from DOM node: ".concat(n));
    return r;
  },
  toSlatePoint: (t, e, n) => {
    var {
      exactMatch: r,
      suppressThrow: o,
      searchDirection: i = "backward"
    } = n, [a, s] = r ? e : BA(e), l = a.parentNode, u = null, c = 0;
    if (l) {
      var d, f, v = ie.toDOMNode(t, t), h = l.closest('[data-slate-void="true"]'), g = h && v.contains(h) ? h : null, p = l.closest('[contenteditable="false"]'), w = p && v.contains(p) ? p : null, b = l.closest("[data-slate-leaf]"), k = null;
      if (b) {
        if (u = b.closest('[data-slate-node="text"]'), u) {
          var E = ie.getWindow(t), m = E.document.createRange();
          m.setStart(u, 0), m.setEnd(a, s);
          var O = m.cloneContents(), S = [...Array.prototype.slice.call(O.querySelectorAll("[data-slate-zero-width]")), ...Array.prototype.slice.call(O.querySelectorAll("[contenteditable=false]"))];
          S.forEach((F) => {
            if (tn && !r && F.hasAttribute("data-slate-zero-width") && F.textContent.length > 0 && F.textContext !== "\uFEFF") {
              F.textContent.startsWith("\uFEFF") && (F.textContent = F.textContent.slice(1));
              return;
            }
            F.parentNode.removeChild(F);
          }), c = O.textContent.length, k = u;
        }
      } else if (g) {
        for (var W = g.querySelectorAll("[data-slate-leaf]"), P = 0; P < W.length; P++) {
          var $ = W[P];
          if (ie.hasDOMNode(t, $)) {
            b = $;
            break;
          }
        }
        b ? (u = b.closest('[data-slate-node="text"]'), k = b, c = k.textContent.length, k.querySelectorAll("[data-slate-zero-width]").forEach((F) => {
          c -= F.textContent.length;
        })) : c = 1;
      } else if (w) {
        var j = (F) => F ? F.querySelectorAll(
          // Exclude leaf nodes in nested editors
          "[data-slate-leaf]:not(:scope [data-slate-editor] [data-slate-leaf])"
        ) : [], _ = w.closest('[data-slate-node="element"]');
        if (i === "forward") {
          var I, R = [...j(_), ...j(_ == null ? void 0 : _.nextElementSibling)];
          b = (I = R.find((F) => IA(w, F))) !== null && I !== void 0 ? I : null;
        } else {
          var V, J = [...j(_ == null ? void 0 : _.previousElementSibling), ...j(_)];
          b = (V = J.findLast((F) => Ag(w, F))) !== null && V !== void 0 ? V : null;
        }
        b && (u = b.closest('[data-slate-node="text"]'), k = b, i === "forward" ? c = 0 : (c = k.textContent.length, k.querySelectorAll("[data-slate-zero-width]").forEach((F) => {
          c -= F.textContent.length;
        })));
      }
      k && c === k.textContent.length && // COMPAT: Android IMEs might remove the zero width space while composing,
      // and we don't add it for line-breaks.
      tn && k.getAttribute("data-slate-zero-width") === "z" && (d = k.textContent) !== null && d !== void 0 && d.startsWith("\uFEFF") && // COMPAT: If the parent node is a Slate zero-width space, editor is
      // because the text node should have no characters. However, during IME
      // composition the ASCII characters will be prepended to the zero-width
      // space, so subtract 1 from the offset to account for the zero-width
      // space character.
      (l.hasAttribute("data-slate-zero-width") || // COMPAT: In Firefox, `range.cloneContents()` returns an extra trailing '\n'
      // when the document ends with a new-line character. This results in the offset
      // length being off by one, so we need to subtract one to account for this.
      no && (f = k.textContent) !== null && f !== void 0 && f.endsWith(`

`)) && c--;
    }
    if (tn && !u && !r) {
      var G = l.hasAttribute("data-slate-node") ? l : l.closest("[data-slate-node]");
      if (G && ie.hasDOMNode(t, G, {
        editable: !0
      })) {
        var te = ie.toSlateNode(t, G), {
          path: Q,
          offset: T
        } = D.start(t, ie.findPath(t, te));
        return G.querySelector("[data-slate-leaf]") || (T = s), {
          path: Q,
          offset: T
        };
      }
    }
    if (!u) {
      if (o)
        return null;
      throw new Error("Cannot resolve a Slate point from DOM point: ".concat(e));
    }
    var N = ie.toSlateNode(t, u), Y = ie.findPath(t, N);
    return {
      path: Y,
      offset: c
    };
  },
  toSlateRange: (t, e, n) => {
    var r, {
      exactMatch: o,
      suppressThrow: i
    } = n, a = Ru(e) ? e.anchorNode : e.startContainer, s, l, u, c, d;
    if (a)
      if (Ru(e)) {
        if (no && e.rangeCount > 1) {
          u = e.focusNode;
          var f = e.getRangeAt(0), v = e.getRangeAt(e.rangeCount - 1);
          if (u instanceof HTMLTableRowElement && f.startContainer instanceof HTMLTableRowElement && v.startContainer instanceof HTMLTableRowElement) {
            let O = function(S) {
              return S.childElementCount > 0 ? O(S.children[0]) : S;
            };
            var h = f.startContainer, g = v.startContainer, p = O(h.children[f.startOffset]), w = O(g.children[v.startOffset]);
            c = 0, w.childNodes.length > 0 ? s = w.childNodes[0] : s = w, p.childNodes.length > 0 ? u = p.childNodes[0] : u = p, w instanceof HTMLElement ? l = w.innerHTML.length : l = 0;
          } else
            f.startContainer === u ? (s = v.endContainer, l = v.endOffset, c = f.startOffset) : (s = f.startContainer, l = f.endOffset, c = v.startOffset);
        } else
          s = e.anchorNode, l = e.anchorOffset, u = e.focusNode, c = e.focusOffset;
        M0 && TA(s) || no ? d = e.anchorNode === e.focusNode && e.anchorOffset === e.focusOffset : d = e.isCollapsed;
      } else
        s = e.startContainer, l = e.startOffset, u = e.endContainer, c = e.endOffset, d = e.collapsed;
    if (s == null || u == null || l == null || c == null)
      throw new Error("Cannot resolve a Slate range from DOM range: ".concat(e));
    no && (r = u.textContent) !== null && r !== void 0 && r.endsWith(`

`) && c === u.textContent.length && c--;
    var b = ie.toSlatePoint(t, [s, l], {
      exactMatch: o,
      suppressThrow: i
    });
    if (!b)
      return null;
    var k = Ag(s, u) || s === u && c < l, E = d ? b : ie.toSlatePoint(t, [u, c], {
      exactMatch: o,
      suppressThrow: i,
      searchDirection: k ? "forward" : "backward"
    });
    if (!E)
      return null;
    var m = {
      anchor: b,
      focus: E
    };
    return re.isExpanded(m) && re.isForward(m) && kn(u) && D.void(t, {
      at: m.focus,
      mode: "highest"
    }) && (m = D.unhangRange(t, m, {
      voids: !0
    })), m;
  }
};
function $A(t, e) {
  var {
    path: n,
    diff: r
  } = e;
  if (!D.hasPath(t, n))
    return !1;
  var o = fe.get(t, n);
  if (!ye.isText(o))
    return !1;
  if (r.start !== o.text.length || r.text.length === 0)
    return o.text.slice(r.start, r.start + r.text.length) === r.text;
  var i = q.next(n);
  if (!D.hasPath(t, i))
    return !1;
  var a = fe.get(t, i);
  return ye.isText(a) && a.text.startsWith(r.text);
}
function R0(t) {
  for (var e = arguments.length, n = new Array(e > 1 ? e - 1 : 0), r = 1; r < e; r++)
    n[r - 1] = arguments[r];
  return n.reduce((o, i) => o.slice(0, i.start) + i.text + o.slice(i.end), t);
}
function zA(t, e) {
  for (var n = Math.min(t.length, e.length), r = 0; r < n; r++)
    if (t.charAt(r) !== e.charAt(r))
      return r;
  return n;
}
function UA(t, e, n) {
  for (var r = Math.min(t.length, e.length, n), o = 0; o < r; o++)
    if (t.charAt(t.length - o - 1) !== e.charAt(e.length - o - 1))
      return o;
  return r;
}
function N0(t, e) {
  var {
    start: n,
    end: r,
    text: o
  } = e, i = t.slice(n, r), a = zA(i, o), s = Math.min(i.length - a, o.length - a), l = UA(i, o, s), u = {
    start: n + a,
    end: r - l,
    text: o.slice(a, o.length - l)
  };
  return u.start === u.end && u.text.length === 0 ? null : u;
}
function WA(t, e, n) {
  var r = Math.min(e.start, n.start), o = Math.max(0, Math.min(e.start + e.text.length, n.end) - n.start), i = R0(t, e, n), a = Math.max(n.start + n.text.length, e.start + e.text.length + (e.start + e.text.length > n.start ? n.text.length : 0) - o), s = i.slice(r, a), l = Math.max(e.end, n.end - e.text.length + (e.end - e.start));
  return N0(t, {
    start: r,
    end: l,
    text: s
  });
}
function HA(t) {
  var {
    path: e,
    diff: n
  } = t;
  return {
    anchor: {
      path: e,
      offset: n.start
    },
    focus: {
      path: e,
      offset: n.end
    }
  };
}
function Nu(t, e) {
  var {
    path: n,
    offset: r
  } = e;
  if (!D.hasPath(t, n))
    return null;
  var o = fe.get(t, n);
  if (!ye.isText(o))
    return null;
  var i = D.above(t, {
    match: (s) => me.isElement(s) && D.isBlock(t, s),
    at: n
  });
  if (!i)
    return null;
  for (; r > o.text.length; ) {
    var a = D.next(t, {
      at: n,
      match: ye.isText
    });
    if (!a || !q.isDescendant(a[1], i[1]))
      return null;
    r -= o.text.length, o = a[0], n = a[1];
  }
  return {
    path: n,
    offset: r
  };
}
function jg(t, e) {
  var n = Nu(t, e.anchor);
  if (!n)
    return null;
  if (re.isCollapsed(e))
    return {
      anchor: n,
      focus: n
    };
  var r = Nu(t, e.focus);
  return r ? {
    anchor: n,
    focus: r
  } : null;
}
function $u(t, e, n) {
  var r = an.get(t), o = r == null ? void 0 : r.find((c) => {
    var {
      path: d
    } = c;
    return q.equals(d, e.path);
  });
  if (!o || e.offset <= o.diff.start)
    return _e.transform(e, n, {
      affinity: "backward"
    });
  var {
    diff: i
  } = o;
  if (e.offset <= i.start + i.text.length) {
    var a = {
      path: e.path,
      offset: i.start
    }, s = _e.transform(a, n, {
      affinity: "backward"
    });
    return s ? {
      path: s.path,
      offset: s.offset + e.offset - i.start
    } : null;
  }
  var l = {
    path: e.path,
    offset: e.offset - i.text.length + i.end - i.start
  }, u = _e.transform(l, n, {
    affinity: "backward"
  });
  return u ? n.type === "split_node" && q.equals(n.path, e.path) && l.offset < n.position && i.start < n.position ? u : {
    path: u.path,
    offset: u.offset + i.text.length - i.end + i.start
  } : null;
}
function Fg(t, e, n) {
  var r = $u(t, e.anchor, n);
  if (!r)
    return null;
  if (re.isCollapsed(e))
    return {
      anchor: r,
      focus: r
    };
  var o = $u(t, e.focus, n);
  return o ? {
    anchor: r,
    focus: o
  } : null;
}
function VA(t, e) {
  var {
    path: n,
    diff: r,
    id: o
  } = t;
  switch (e.type) {
    case "insert_text":
      return !q.equals(e.path, n) || e.offset >= r.end ? t : e.offset <= r.start ? {
        diff: {
          start: e.text.length + r.start,
          end: e.text.length + r.end,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end + e.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "remove_text":
      return !q.equals(e.path, n) || e.offset >= r.end ? t : e.offset + e.text.length <= r.start ? {
        diff: {
          start: r.start - e.text.length,
          end: r.end - e.text.length,
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start,
          end: r.end - e.text.length,
          text: r.text
        },
        id: o,
        path: n
      };
    case "split_node":
      return !q.equals(e.path, n) || e.position >= r.end ? {
        diff: r,
        id: o,
        path: q.transform(n, e, {
          affinity: "backward"
        })
      } : e.position > r.start ? {
        diff: {
          start: r.start,
          end: Math.min(e.position, r.end),
          text: r.text
        },
        id: o,
        path: n
      } : {
        diff: {
          start: r.start - e.position,
          end: r.end - e.position,
          text: r.text
        },
        id: o,
        path: q.transform(n, e, {
          affinity: "forward"
        })
      };
    case "merge_node":
      return q.equals(e.path, n) ? {
        diff: {
          start: r.start + e.position,
          end: r.end + e.position,
          text: r.text
        },
        id: o,
        path: q.transform(n, e)
      } : {
        diff: r,
        id: o,
        path: q.transform(n, e)
      };
  }
  var i = q.transform(n, e);
  return i ? {
    diff: r,
    path: i,
    id: o
  } : null;
}
function _g(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Yi(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? _g(Object(n), !0).forEach(function(r) {
      Mn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : _g(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var qA = 25, GA = 200, ZA = function() {
}, KA = (t) => (t == null ? void 0 : t.constructor.name) === "DataTransfer";
function YA(t) {
  var {
    editor: e,
    scheduleOnDOMSelectionChange: n,
    onDOMSelectionChange: r
  } = t, o = !1, i = null, a = null, s = null, l = 0, u = !1, c = () => {
    var _ = fr.get(e);
    if (fr.delete(e), _) {
      var {
        selection: I
      } = e, R = jg(e, _);
      R && (!I || !re.equals(R, I)) && se.select(e, R);
    }
  }, d = () => {
    var _ = dr.get(e);
    if (dr.delete(e), !!_) {
      if (_.at) {
        var I = _e.isPoint(_.at) ? Nu(e, _.at) : jg(e, _.at);
        if (!I)
          return;
        var R = D.range(e, I);
        (!e.selection || !re.equals(e.selection, R)) && se.select(e, I);
      }
      _.run();
    }
  }, f = () => {
    if (a && (clearTimeout(a), a = null), s && (clearTimeout(s), s = null), !E() && !k()) {
      c();
      return;
    }
    o || (o = !0, setTimeout(() => o = !1)), k() && (o = "action");
    var _ = e.selection && D.rangeRef(e, e.selection, {
      affinity: "forward"
    });
    Xn.set(e, e.marks), ZA("flush", dr.get(e), an.get(e));
    for (var I = E(), R; R = (V = an.get(e)) === null || V === void 0 ? void 0 : V[0]; ) {
      var V, J, G = jn.get(e);
      G !== void 0 && (jn.delete(e), e.marks = G), G && u === !1 && (u = null);
      var te = HA(R);
      (!e.selection || !re.equals(e.selection, te)) && se.select(e, te), R.diff.text ? D.insertText(e, R.diff.text) : D.deleteFragment(e), an.set(e, (J = an.get(e)) === null || J === void 0 ? void 0 : J.filter((N) => {
        var {
          id: Y
        } = N;
        return Y !== R.id;
      })), $A(e, R) || (I = !1, dr.delete(e), Xn.delete(e), o = "action", fr.delete(e), n.cancel(), r.cancel(), _ == null || _.unref());
    }
    var Q = _ == null ? void 0 : _.unref();
    if (Q && !fr.get(e) && (!e.selection || !re.equals(Q, e.selection)) && se.select(e, Q), k()) {
      d();
      return;
    }
    I && n(), n.flush(), r.flush(), c();
    var T = Xn.get(e);
    Xn.delete(e), T !== void 0 && (e.marks = T, e.onChange());
  }, v = (_) => {
    i && clearTimeout(i), i = setTimeout(() => {
      Ur.set(e, !1), f();
    }, qA);
  }, h = (_) => {
    Ur.set(e, !0), i && (clearTimeout(i), i = null);
  }, g = function() {
    var I = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : !1, R = Fu.get(e);
    if (R) {
      if (E() || I) {
        R.style.display = "none";
        return;
      }
      R.style.removeProperty("display");
    }
  }, p = (_, I) => {
    var R, V = (R = an.get(e)) !== null && R !== void 0 ? R : [];
    an.set(e, V);
    var J = fe.leaf(e, _), G = V.findIndex((T) => q.equals(T.path, _));
    if (G < 0) {
      var te = N0(J.text, I);
      te && V.push({
        path: _,
        diff: I,
        id: l++
      }), g();
      return;
    }
    var Q = WA(J.text, V[G].diff, I);
    if (!Q) {
      V.splice(G, 1), g();
      return;
    }
    V[G] = Yi(Yi({}, V[G]), {}, {
      diff: Q
    });
  }, w = function(I) {
    var {
      at: R
    } = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
    u = !1, fr.delete(e), n.cancel(), r.cancel(), k() && f(), dr.set(e, {
      at: R,
      run: I
    }), s = setTimeout(f);
  }, b = (_) => {
    var I;
    if (a && (clearTimeout(a), a = null), !io.get(e)) {
      var {
        inputType: R
      } = _, V = null, J = _.dataTransfer || _.data || void 0;
      u !== !1 && R !== "insertText" && R !== "insertCompositionText" && (u = !1);
      var [G] = _.getTargetRanges();
      G && (V = ie.toSlateRange(e, G, {
        exactMatch: !1,
        suppressThrow: !0
      }));
      var te = ie.getWindow(e), Q = te.getSelection();
      if (!V && Q && (G = Q, V = ie.toSlateRange(e, Q, {
        exactMatch: !1,
        suppressThrow: !0
      })), V = (I = V) !== null && I !== void 0 ? I : e.selection, !!V) {
        var T = !0;
        if (R.startsWith("delete")) {
          if (re.isExpanded(V)) {
            var [N, Y] = re.edges(V), F = fe.leaf(e, N.path);
            if (F.text.length === N.offset && Y.offset === 0) {
              var X = D.next(e, {
                at: N.path,
                match: ye.isText
              });
              X && q.equals(X[1], Y.path) && (V = {
                anchor: Y,
                focus: Y
              });
            }
          }
          var L = R.endsWith("Backward") ? "backward" : "forward", [M, z] = re.edges(V), [A, U] = D.leaf(e, M.path), H = {
            text: "",
            start: M.offset,
            end: z.offset
          }, ee = an.get(e), Z = ee == null ? void 0 : ee.find((Je) => q.equals(Je.path, U)), pe = Z ? [Z.diff, H] : [H], he = R0(A.text, ...pe);
          if (he.length === 0 && (T = !1), re.isExpanded(V)) {
            if (T && q.equals(V.anchor.path, V.focus.path)) {
              var le = {
                path: V.anchor.path,
                offset: M.offset
              }, Le = D.range(e, le, le);
              return S(Le), p(V.anchor.path, {
                text: "",
                end: z.offset,
                start: M.offset
              });
            }
            return w(() => D.deleteFragment(e, {
              direction: L
            }), {
              at: V
            });
          }
        }
        switch (R) {
          case "deleteByComposition":
          case "deleteByCut":
          case "deleteByDrag":
            return w(() => D.deleteFragment(e), {
              at: V
            });
          case "deleteContent":
          case "deleteContentForward": {
            var {
              anchor: Fe
            } = V;
            if (T && re.isCollapsed(V)) {
              var Be = fe.leaf(e, Fe.path);
              if (Fe.offset < Be.text.length)
                return p(Fe.path, {
                  text: "",
                  start: Fe.offset,
                  end: Fe.offset + 1
                });
            }
            return w(() => D.deleteForward(e), {
              at: V
            });
          }
          case "deleteContentBackward": {
            var Ne, {
              anchor: at
            } = V, dt = Ru(G) ? G.isCollapsed : !!((Ne = G) !== null && Ne !== void 0 && Ne.collapsed);
            return T && dt && re.isCollapsed(V) && at.offset > 0 ? p(at.path, {
              text: "",
              start: at.offset - 1,
              end: at.offset
            }) : w(() => D.deleteBackward(e), {
              at: V
            });
          }
          case "deleteEntireSoftLine":
            return w(() => {
              D.deleteBackward(e, {
                unit: "line"
              }), D.deleteForward(e, {
                unit: "line"
              });
            }, {
              at: V
            });
          case "deleteHardLineBackward":
            return w(() => D.deleteBackward(e, {
              unit: "block"
            }), {
              at: V
            });
          case "deleteSoftLineBackward":
            return w(() => D.deleteBackward(e, {
              unit: "line"
            }), {
              at: V
            });
          case "deleteHardLineForward":
            return w(() => D.deleteForward(e, {
              unit: "block"
            }), {
              at: V
            });
          case "deleteSoftLineForward":
            return w(() => D.deleteForward(e, {
              unit: "line"
            }), {
              at: V
            });
          case "deleteWordBackward":
            return w(() => D.deleteBackward(e, {
              unit: "word"
            }), {
              at: V
            });
          case "deleteWordForward":
            return w(() => D.deleteForward(e, {
              unit: "word"
            }), {
              at: V
            });
          case "insertLineBreak":
            return w(() => D.insertSoftBreak(e), {
              at: V
            });
          case "insertParagraph":
            return w(() => D.insertBreak(e), {
              at: V
            });
          case "insertCompositionText":
          case "deleteCompositionText":
          case "insertFromComposition":
          case "insertFromDrop":
          case "insertFromPaste":
          case "insertFromYank":
          case "insertReplacementText":
          case "insertText": {
            if (KA(J))
              return w(() => ie.insertData(e, J), {
                at: V
              });
            var Oe = J ?? "";
            if (jn.get(e) && (Oe = Oe.replace("\uFEFF", "")), R === "insertText" && /.*\n.*\n$/.test(Oe) && (Oe = Oe.slice(0, -1)), Oe.includes(`
`))
              return w(() => {
                var Je = Oe.split(`
`);
                Je.forEach((Qe, Bt) => {
                  Qe && D.insertText(e, Qe), Bt !== Je.length - 1 && D.insertSoftBreak(e);
                });
              }, {
                at: V
              });
            if (q.equals(V.anchor.path, V.focus.path)) {
              var [ft, bt] = re.edges(V), De = {
                start: ft.offset,
                end: bt.offset,
                text: Oe
              };
              if (Oe && u && R === "insertCompositionText") {
                var ke = u.start + u.text.search(/\S|$/), Ke = De.start + De.text.search(/\S|$/);
                Ke === ke + 1 && De.end === u.start + u.text.length ? (De.start -= 1, u = null, $()) : u = !1;
              } else R === "insertText" ? u === null ? u = De : u && re.isCollapsed(V) && u.end + u.text.length === ft.offset ? u = Yi(Yi({}, u), {}, {
                text: u.text + Oe
              }) : u = !1 : u = !1;
              if (T) {
                p(ft.path, De);
                return;
              }
            }
            return w(() => D.insertText(e, Oe), {
              at: V
            });
          }
        }
      }
    }
  }, k = () => !!dr.get(e), E = () => {
    var _;
    return !!((_ = an.get(e)) !== null && _ !== void 0 && _.length);
  }, m = () => k() || E(), O = () => o, S = (_) => {
    fr.set(e, _), a && (clearTimeout(a), a = null);
    var {
      selection: I
    } = e;
    if (_) {
      var R = !I || !q.equals(I.anchor.path, _.anchor.path), V = !I || !q.equals(I.anchor.path.slice(0, -1), _.anchor.path.slice(0, -1));
      (R && u || V) && (u = !1), (R || E()) && (a = setTimeout(f, GA));
    }
  }, W = () => {
    (k() || !E()) && f();
  }, P = (_) => {
    E() || (g(!0), setTimeout(g));
  }, $ = () => {
    k() || (s = setTimeout(f));
  }, j = (_) => {
    if (!(E() || k()) && _.some((R) => ld(e, R, _))) {
      var I;
      (I = T0.get(e)) === null || I === void 0 || I();
    }
  };
  return {
    flush: f,
    scheduleFlush: $,
    hasPendingDiffs: E,
    hasPendingAction: k,
    hasPendingChanges: m,
    isFlushing: O,
    handleUserSelect: S,
    handleCompositionEnd: v,
    handleCompositionStart: h,
    handleDOMBeforeInput: b,
    handleKeyDown: P,
    handleDomMutations: j,
    handleInput: W
  };
}
function XA() {
  var t = qe(!1);
  return y(() => (t.current = !0, () => {
    t.current = !1;
  }), []), t.current;
}
var ai = da ? GC : y;
function JA(t, e, n) {
  var [r] = B(() => new MutationObserver(e));
  ai(() => {
    r.takeRecords();
  }), y(() => {
    if (!t.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    return r.observe(t.current, n), () => r.disconnect();
  }, [r, t, n]);
}
var QA = ["node"];
function Ig(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ej(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Ig(Object(n), !0).forEach(function(r) {
      Mn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Ig(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var tj = {
  subtree: !0,
  childList: !0,
  characterData: !0
}, nj = tn ? (t) => {
  var {
    node: e
  } = t, n = uo(t, QA);
  if (!tn)
    return null;
  var r = Sr(), o = XA(), [i] = B(() => YA(ej({
    editor: r
  }, n)));
  return JA(e, i.handleDomMutations, tj), ad.set(r, i.scheduleFlush), o && i.flush(), i;
} : () => null, rj = ["anchor", "focus"], oj = ["anchor", "focus"], ij = (t, e) => Object.keys(t).length === Object.keys(e).length && Object.keys(t).every((n) => e.hasOwnProperty(n) && t[n] === e[n]), $0 = (t, e) => {
  var n = uo(t, rj), r = uo(e, oj);
  return t[co] === e[co] && ij(n, r);
}, aj = (t, e) => {
  if (t.length !== e.length)
    return !1;
  for (var n = 0; n < t.length; n++) {
    var r = t[n], o = e[n];
    if (!re.equals(r, o) || !$0(r, o))
      return !1;
  }
  return !0;
}, sj = (t, e) => {
  if (t.length !== e.length)
    return !1;
  for (var n = 0; n < t.length; n++) {
    var r = t[n], o = e[n];
    if (r.anchor.offset !== o.anchor.offset || r.focus.offset !== o.focus.offset || !$0(r, o))
      return !1;
  }
  return !0;
};
function Rg(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function lj(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Rg(Object(n), !0).forEach(function(r) {
      Mn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Rg(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var uj = (t) => {
  var {
    isLast: e,
    leaf: n,
    parent: r,
    text: o
  } = t, i = Sr(), a = ie.findPath(i, o), s = q.parent(a), l = !!n[A0];
  return i.isVoid(r) ? /* @__PURE__ */ be.createElement($l, {
    length: fe.string(r).length
  }) : n.text === "" && r.children[r.children.length - 1] === o && !i.isInline(r) && D.string(i, s) === "" ? /* @__PURE__ */ be.createElement($l, {
    isLineBreak: !0,
    isMarkPlaceholder: l
  }) : n.text === "" ? /* @__PURE__ */ be.createElement($l, {
    isMarkPlaceholder: l
  }) : e && n.text.slice(-1) === `
` ? /* @__PURE__ */ be.createElement(Ng, {
    isTrailing: !0,
    text: n.text
  }) : /* @__PURE__ */ be.createElement(Ng, {
    text: n.text
  });
}, Ng = (t) => {
  var {
    text: e,
    isTrailing: n = !1
  } = t, r = qe(null), o = () => "".concat(e ?? "").concat(n ? `
` : ""), [i] = B(o);
  return ai(() => {
    var a = o();
    r.current && r.current.textContent !== a && (r.current.textContent = a);
  }), /* @__PURE__ */ be.createElement(cj, {
    ref: r
  }, i);
}, cj = /* @__PURE__ */ Re(/* @__PURE__ */ es((t, e) => /* @__PURE__ */ be.createElement("span", {
  "data-slate-string": !0,
  ref: e
}, t.children))), $l = (t) => {
  var {
    length: e = 0,
    isLineBreak: n = !1,
    isMarkPlaceholder: r = !1
  } = t, o = {
    "data-slate-zero-width": n ? "n" : "z",
    "data-slate-length": e
  };
  return r && (o["data-slate-mark-placeholder"] = !0), /* @__PURE__ */ be.createElement("span", lj({}, o), !(tn || k0) || !n ? "\uFEFF" : null, n ? /* @__PURE__ */ be.createElement("br", null) : null);
};
function $g(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function z0(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? $g(Object(n), !0).forEach(function(r) {
      Mn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : $g(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var dj = tn ? 300 : 0;
function fj(t, e) {
  t.current && (t.current.disconnect(), e && (t.current = null));
}
function zg(t) {
  t.current && (clearTimeout(t.current), t.current = null);
}
var pj = (t) => {
  var {
    leaf: e,
    isLast: n,
    text: r,
    parent: o,
    renderPlaceholder: i,
    renderLeaf: a = (b) => /* @__PURE__ */ be.createElement(gj, z0({}, b))
  } = t, s = Sr(), l = qe(null), u = qe(null), [c, d] = B(!1), f = qe(null), v = it((b) => {
    if (fj(l, b == null), b == null) {
      var k;
      Fu.delete(s), (k = e.onPlaceholderResize) === null || k === void 0 || k.call(e, null);
    } else {
      if (Fu.set(s, b), !l.current) {
        var E = window.ResizeObserver || yA;
        l.current = new E(() => {
          var m;
          (m = e.onPlaceholderResize) === null || m === void 0 || m.call(e, b);
        });
      }
      l.current.observe(b), u.current = b;
    }
  }, [u, e, s]), h = /* @__PURE__ */ be.createElement(uj, {
    isLast: n,
    leaf: e,
    parent: o,
    text: r
  }), g = !!e[co];
  if (y(() => (g ? f.current || (f.current = setTimeout(() => {
    d(!0), f.current = null;
  }, dj)) : (zg(f), d(!1)), () => zg(f)), [g, d]), g && c) {
    var p = {
      children: e.placeholder,
      attributes: {
        "data-slate-placeholder": !0,
        style: {
          position: "absolute",
          top: 0,
          pointerEvents: "none",
          width: "100%",
          maxWidth: "100%",
          display: "block",
          opacity: "0.333",
          userSelect: "none",
          textDecoration: "none",
          // Fixes https://github.com/udecode/plate/issues/2315
          WebkitUserModify: Ir ? "inherit" : void 0
        },
        contentEditable: !1,
        ref: v
      }
    };
    h = /* @__PURE__ */ be.createElement(be.Fragment, null, i(p), h);
  }
  var w = {
    "data-slate-leaf": !0
  };
  return a({
    attributes: w,
    children: h,
    leaf: e,
    text: r
  });
}, hj = /* @__PURE__ */ be.memo(pj, (t, e) => e.parent === t.parent && e.isLast === t.isLast && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && e.text === t.text && ye.equals(e.leaf, t.leaf) && e.leaf[co] === t.leaf[co]), gj = (t) => {
  var {
    attributes: e,
    children: n
  } = t;
  return /* @__PURE__ */ be.createElement("span", z0({}, e), n);
}, vj = (t) => {
  for (var {
    decorations: e,
    isLast: n,
    parent: r,
    renderPlaceholder: o,
    renderLeaf: i,
    text: a
  } = t, s = Sr(), l = qe(null), u = ye.decorations(a, e), c = ie.findKey(s, a), d = [], f = 0; f < u.length; f++) {
    var v = u[f];
    d.push(/* @__PURE__ */ be.createElement(hj, {
      isLast: n && f === u.length - 1,
      key: "".concat(c.id, "-").concat(f),
      renderPlaceholder: o,
      leaf: v,
      text: a,
      parent: r,
      renderLeaf: i
    }));
  }
  var h = it((g) => {
    var p = $s.get(s);
    g ? (p == null || p.set(c, g), qr.set(a, g), ii.set(g, a)) : (p == null || p.delete(c), qr.delete(a), l.current && ii.delete(l.current)), l.current = g;
  }, [l, s, c, a]);
  return /* @__PURE__ */ be.createElement("span", {
    "data-slate-node": "text",
    ref: h
  }, d);
}, U0 = /* @__PURE__ */ be.memo(vj, (t, e) => e.parent === t.parent && e.isLast === t.isLast && e.renderLeaf === t.renderLeaf && e.renderPlaceholder === t.renderPlaceholder && e.text === t.text && sj(e.decorations, t.decorations));
function Ug(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function zu(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Ug(Object(n), !0).forEach(function(r) {
      Mn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Ug(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var mj = (t) => {
  var {
    decorations: e,
    element: n,
    renderElement: r = (b) => /* @__PURE__ */ be.createElement(bj, zu({}, b)),
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = t, s = Sr(), l = Ej(), u = s.isInline(n), c = ie.findKey(s, n), d = it((b) => {
    var k = $s.get(s);
    b ? (k == null || k.set(c, b), qr.set(n, b), ii.set(b, n)) : (k == null || k.delete(c), qr.delete(n));
  }, [s, c, n]), f = H0({
    decorations: e,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  }), v = {
    "data-slate-node": "element",
    ref: d
  };
  if (u && (v["data-slate-inline"] = !0), !u && D.hasInlines(s, n)) {
    var h = fe.string(n), g = m0(h);
    g === "rtl" && (v.dir = g);
  }
  if (D.isVoid(s, n)) {
    v["data-slate-void"] = !0, !l && u && (v.contentEditable = !1);
    var p = u ? "span" : "div", [[w]] = fe.texts(n);
    f = /* @__PURE__ */ be.createElement(p, {
      "data-slate-spacer": !0,
      style: {
        height: "0",
        color: "transparent",
        outline: "none",
        position: "absolute"
      }
    }, /* @__PURE__ */ be.createElement(U0, {
      renderPlaceholder: o,
      decorations: [],
      isLast: !1,
      parent: n,
      text: w
    })), od.set(w, 0), id.set(w, n);
  }
  return r({
    attributes: v,
    children: f,
    element: n
  });
}, yj = /* @__PURE__ */ be.memo(mj, (t, e) => t.element === e.element && t.renderElement === e.renderElement && t.renderLeaf === e.renderLeaf && t.renderPlaceholder === e.renderPlaceholder && aj(t.decorations, e.decorations) && (t.selection === e.selection || !!t.selection && !!e.selection && re.equals(t.selection, e.selection))), bj = (t) => {
  var {
    attributes: e,
    children: n,
    element: r
  } = t, o = Sr(), i = o.isInline(r) ? "span" : "div";
  return /* @__PURE__ */ be.createElement(i, zu(zu({}, e), {}, {
    style: {
      position: "relative"
    }
  }), n);
}, W0 = /* @__PURE__ */ ct(() => []), Cj = () => Ee(W0), wj = /* @__PURE__ */ ct(!1), H0 = (t) => {
  var {
    decorations: e,
    node: n,
    renderElement: r,
    renderPlaceholder: o,
    renderLeaf: i,
    selection: a
  } = t, s = Cj(), l = Sr();
  io.set(l, !1);
  for (var u = ie.findPath(l, n), c = [], d = me.isElement(n) && !l.isInline(n) && D.hasInlines(l, n), f = 0; f < n.children.length; f++) {
    var v = u.concat(f), h = n.children[f], g = ie.findKey(l, h), p = D.range(l, v), w = a && re.intersection(p, a), b = s([h, v]);
    for (var k of e) {
      var E = re.intersection(k, p);
      E && b.push(E);
    }
    me.isElement(h) ? c.push(/* @__PURE__ */ be.createElement(wj.Provider, {
      key: "provider-".concat(g.id),
      value: !!w
    }, /* @__PURE__ */ be.createElement(yj, {
      decorations: b,
      element: h,
      key: g.id,
      renderElement: r,
      renderPlaceholder: o,
      renderLeaf: i,
      selection: w
    }))) : c.push(/* @__PURE__ */ be.createElement(U0, {
      decorations: b,
      key: g.id,
      isLast: d && f === n.children.length - 1,
      parent: n,
      renderPlaceholder: o,
      renderLeaf: i,
      text: h
    })), od.set(h, f), id.set(h, n);
  }
  return c;
}, V0 = /* @__PURE__ */ ct(!1), Ej = () => Ee(V0), q0 = /* @__PURE__ */ ct(null), zs = () => {
  var t = Ee(q0);
  if (!t)
    throw new Error("The `useSlate` hook must be used inside the <Slate> component's context.");
  var {
    editor: e
  } = t;
  return e;
};
function Dj() {
  var t = Sr(), e = qe(!1), n = qe(0), r = it(() => {
    if (!e.current) {
      e.current = !0;
      var o = ie.getWindow(t);
      o.cancelAnimationFrame(n.current), n.current = o.requestAnimationFrame(() => {
        e.current = !1;
      });
    }
  }, [t]);
  return y(() => () => cancelAnimationFrame(n.current), []), {
    receivedUserInput: e,
    onUserInput: r
  };
}
var Oj = 3, xj = {
  bold: "mod+b",
  compose: ["down", "left", "right", "up", "backspace", "enter"],
  moveBackward: "left",
  moveForward: "right",
  moveWordBackward: "ctrl+left",
  moveWordForward: "ctrl+right",
  deleteBackward: "shift?+backspace",
  deleteForward: "shift?+delete",
  extendBackward: "shift+left",
  extendForward: "shift+right",
  italic: "mod+i",
  insertSoftBreak: "shift+enter",
  splitBlock: "enter",
  undo: "mod+z"
}, Lj = {
  moveLineBackward: "opt+up",
  moveLineForward: "opt+down",
  moveWordBackward: "opt+left",
  moveWordForward: "opt+right",
  deleteBackward: ["ctrl+backspace", "ctrl+h"],
  deleteForward: ["ctrl+delete", "ctrl+d"],
  deleteLineBackward: "cmd+shift?+backspace",
  deleteLineForward: ["cmd+shift?+delete", "ctrl+k"],
  deleteWordBackward: "opt+shift?+backspace",
  deleteWordForward: "opt+shift?+delete",
  extendLineBackward: "opt+shift+up",
  extendLineForward: "opt+shift+down",
  redo: "cmd+shift+z",
  transposeCharacter: "ctrl+t"
}, Sj = {
  deleteWordBackward: "ctrl+shift?+backspace",
  deleteWordForward: "ctrl+shift?+delete",
  redo: ["ctrl+y", "ctrl+shift+z"]
}, Ot = (t) => {
  var e = xj[t], n = Lj[t], r = Sj[t], o = e && Tl(e), i = n && Tl(n), a = r && Tl(r);
  return (s) => !!(o && o(s) || Tg && i && i(s) || !Tg && a && a(s));
}, Lt = {
  isBold: Ot("bold"),
  isCompose: Ot("compose"),
  isMoveBackward: Ot("moveBackward"),
  isMoveForward: Ot("moveForward"),
  isDeleteBackward: Ot("deleteBackward"),
  isDeleteForward: Ot("deleteForward"),
  isDeleteLineBackward: Ot("deleteLineBackward"),
  isDeleteLineForward: Ot("deleteLineForward"),
  isDeleteWordBackward: Ot("deleteWordBackward"),
  isDeleteWordForward: Ot("deleteWordForward"),
  isExtendBackward: Ot("extendBackward"),
  isExtendForward: Ot("extendForward"),
  isExtendLineBackward: Ot("extendLineBackward"),
  isExtendLineForward: Ot("extendLineForward"),
  isItalic: Ot("italic"),
  isMoveLineBackward: Ot("moveLineBackward"),
  isMoveLineForward: Ot("moveLineForward"),
  isMoveWordBackward: Ot("moveWordBackward"),
  isMoveWordForward: Ot("moveWordForward"),
  isRedo: Ot("redo"),
  isSoftBreak: Ot("insertSoftBreak"),
  isSplitBlock: Ot("splitBlock"),
  isTransposeCharacter: Ot("transposeCharacter"),
  isUndo: Ot("undo")
}, Pj = (t, e) => {
  var n = [], r = () => {
    n = [];
  }, o = (a) => {
    if (e.current) {
      var s = a.filter((l) => ld(t, l, a));
      n.push(...s);
    }
  };
  function i() {
    n.length > 0 && (n.reverse().forEach((a) => {
      a.type !== "characterData" && (a.removedNodes.forEach((s) => {
        a.target.insertBefore(s, a.nextSibling);
      }), a.addedNodes.forEach((s) => {
        a.target.removeChild(s);
      }));
    }), r());
  }
  return {
    registerMutations: o,
    restoreDOM: i,
    clear: r
  };
}, kj = {
  subtree: !0,
  childList: !0,
  characterData: !0,
  characterDataOldValue: !0
};
class G0 extends Km {
  constructor() {
    super(...arguments), Mn(this, "context", null), Mn(this, "manager", null), Mn(this, "mutationObserver", null);
  }
  observe() {
    var e, {
      node: n
    } = this.props;
    if (!n.current)
      throw new Error("Failed to attach MutationObserver, `node` is undefined");
    (e = this.mutationObserver) === null || e === void 0 || e.observe(n.current, kj);
  }
  componentDidMount() {
    var {
      receivedUserInput: e
    } = this.props, n = this.context;
    this.manager = Pj(n, e), this.mutationObserver = new MutationObserver(this.manager.registerMutations), this.observe();
  }
  getSnapshotBeforeUpdate() {
    var e, n, r, o = (e = this.mutationObserver) === null || e === void 0 ? void 0 : e.takeRecords();
    if (o != null && o.length) {
      var i;
      (i = this.manager) === null || i === void 0 || i.registerMutations(o);
    }
    return (n = this.mutationObserver) === null || n === void 0 || n.disconnect(), (r = this.manager) === null || r === void 0 || r.restoreDOM(), null;
  }
  componentDidUpdate() {
    var e;
    (e = this.manager) === null || e === void 0 || e.clear(), this.observe();
  }
  componentWillUnmount() {
    var e;
    (e = this.mutationObserver) === null || e === void 0 || e.disconnect();
  }
  render() {
    return this.props.children;
  }
}
Mn(G0, "contextType", rd);
var Mj = tn ? G0 : (t) => {
  var {
    children: e
  } = t;
  return /* @__PURE__ */ be.createElement(be.Fragment, null, e);
}, Bj = /* @__PURE__ */ ct(!1), Tj = ["autoFocus", "decorate", "onDOMBeforeInput", "placeholder", "readOnly", "renderElement", "renderLeaf", "renderPlaceholder", "scrollSelectionIntoView", "style", "as", "disableDefaultStyles"], Aj = ["text"];
function Wg(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Rn(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Wg(Object(n), !0).forEach(function(r) {
      Mn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Wg(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var jj = (t) => /* @__PURE__ */ be.createElement(be.Fragment, null, H0(t)), Fj = /* @__PURE__ */ es((t, e) => {
  var n = it((M) => /* @__PURE__ */ be.createElement(_j, Rn({}, M)), []), {
    autoFocus: r,
    decorate: o = Ij,
    onDOMBeforeInput: i,
    placeholder: a,
    readOnly: s = !1,
    renderElement: l,
    renderLeaf: u,
    renderPlaceholder: c = n,
    scrollSelectionIntoView: d = Rj,
    style: f = {},
    as: v = "div",
    disableDefaultStyles: h = !1
  } = t, g = uo(t, Tj), p = zs(), [w, b] = B(!1), k = qe(null), E = qe([]), [m, O] = B(), S = qe(!1), {
    onUserInput: W,
    receivedUserInput: P
  } = Dj(), [, $] = qC((M) => M + 1, 0);
  T0.set(p, $), _u.set(p, s);
  var j = En(() => ({
    isDraggingInternally: !1,
    isUpdatingSelection: !1,
    latestElement: null,
    hasMarkPlaceholder: !1
  }), []);
  y(() => {
    k.current && r && k.current.focus();
  }, [r]);
  var _ = qe(), I = En(() => ZT(() => {
    if (io.get(p)) {
      I();
      return;
    }
    var M = ie.toDOMNode(p, p), z = M.getRootNode();
    if (!S.current && Ir && z instanceof ShadowRoot) {
      S.current = !0;
      var A = _A();
      A ? document.execCommand("indent") : se.deselect(p), S.current = !1;
      return;
    }
    var U = _.current;
    if ((tn || !ie.isComposing(p)) && (!j.isUpdatingSelection || U != null && U.isFlushing()) && !j.isDraggingInternally) {
      var H = ie.findDocumentOrShadowRoot(p), {
        activeElement: ee
      } = H, Z = ie.toDOMNode(p, p), pe = Vo(H);
      if (ee === Z ? (j.latestElement = ee, mr.set(p, !0)) : mr.delete(p), !pe)
        return se.deselect(p);
      var {
        anchorNode: he,
        focusNode: le
      } = pe, Le = ie.hasEditableTarget(p, he) || ie.isTargetInsideNonReadonlyVoid(p, he), Fe = ie.hasTarget(p, le);
      if (Le && Fe) {
        var Be = ie.toSlateRange(p, pe, {
          exactMatch: !1,
          suppressThrow: !0
        });
        Be && (!ie.isComposing(p) && !(U != null && U.hasPendingChanges()) && !(U != null && U.isFlushing()) ? se.select(p, Be) : U == null || U.handleUserSelect(Be));
      }
      s && (!Le || !Fe) && se.deselect(p);
    }
  }, 100), [p, s, j]), R = En(() => UT(I, 0), [I]);
  _.current = nj({
    node: k,
    onDOMSelectionChange: I,
    scheduleOnDOMSelectionChange: R
  }), ai(() => {
    var M, z, A;
    k.current && (A = sd(k.current)) ? (B0.set(p, A), fa.set(p, k.current), qr.set(p, k.current), ii.set(k.current, p)) : qr.delete(p);
    var {
      selection: U
    } = p, H = ie.findDocumentOrShadowRoot(p), ee = Vo(H);
    if (!(!ee || !ie.isFocused(p) || (M = _.current) !== null && M !== void 0 && M.hasPendingAction())) {
      var Z = (Le) => {
        var Fe = ee.type !== "None";
        if (!(!U && !Fe)) {
          var Be = ee.focusNode, Ne;
          if (no && ee.rangeCount > 1) {
            var at = ee.getRangeAt(0), dt = ee.getRangeAt(ee.rangeCount - 1);
            at.startContainer === Be ? Ne = dt.endContainer : Ne = at.startContainer;
          } else
            Ne = ee.anchorNode;
          var Oe = fa.get(p), ft = !1;
          if (Oe.contains(Ne) && Oe.contains(Be) && (ft = !0), Fe && ft && U && !Le) {
            var bt = ie.toSlateRange(p, ee, {
              exactMatch: !0,
              // domSelection is not necessarily a valid Slate range
              // (e.g. when clicking on contentEditable:false element)
              suppressThrow: !0
            });
            if (bt && re.equals(bt, U)) {
              var De;
              if (!j.hasMarkPlaceholder || (De = Ne) !== null && De !== void 0 && (De = De.parentElement) !== null && De !== void 0 && De.hasAttribute("data-slate-mark-placeholder"))
                return;
            }
          }
          if (U && !ie.hasRange(p, U)) {
            p.selection = ie.toSlateRange(p, ee, {
              exactMatch: !1,
              suppressThrow: !0
            });
            return;
          }
          j.isUpdatingSelection = !0;
          var ke = U && ie.toDOMRange(p, U);
          return ke ? (ie.isComposing(p) && !tn ? ee.collapseToEnd() : re.isBackward(U) ? ee.setBaseAndExtent(ke.endContainer, ke.endOffset, ke.startContainer, ke.startOffset) : ee.setBaseAndExtent(ke.startContainer, ke.startOffset, ke.endContainer, ke.endOffset), d(p, ke)) : ee.removeAllRanges(), ke;
        }
      };
      ee.rangeCount <= 1 && Z();
      var pe = ((z = _.current) === null || z === void 0 ? void 0 : z.isFlushing()) === "action";
      if (!tn || !pe) {
        setTimeout(() => {
          j.isUpdatingSelection = !1;
        });
        return;
      }
      var he = null, le = requestAnimationFrame(() => {
        if (pe) {
          var Le = (Fe) => {
            try {
              var Be = ie.toDOMNode(p, p);
              Be.focus(), Z(Fe);
            } catch {
            }
          };
          Le(), he = setTimeout(() => {
            Le(!0), j.isUpdatingSelection = !1;
          });
        }
      });
      return () => {
        cancelAnimationFrame(le), he && clearTimeout(he);
      };
    }
  });
  var V = it((M) => {
    var z = ie.toDOMNode(p, p), A = z.getRootNode();
    if (S != null && S.current && Ir && A instanceof ShadowRoot) {
      var U = M.getTargetRanges(), H = U[0], ee = new window.Range();
      ee.setStart(H.startContainer, H.startOffset), ee.setEnd(H.endContainer, H.endOffset);
      var Z = ie.toSlateRange(p, ee, {
        exactMatch: !1,
        suppressThrow: !1
      });
      se.select(p, Z), M.preventDefault(), M.stopImmediatePropagation();
      return;
    }
    if (W(), !s && ie.hasEditableTarget(p, M.target) && !Nj(M, i)) {
      var pe;
      if (_.current)
        return _.current.handleDOMBeforeInput(M);
      R.flush(), I.flush();
      var {
        selection: he
      } = p, {
        inputType: le
      } = M, Le = M.dataTransfer || M.data || void 0, Fe = le === "insertCompositionText" || le === "deleteCompositionText";
      if (Fe && ie.isComposing(p))
        return;
      var Be = !1;
      if (le === "insertText" && he && re.isCollapsed(he) && // Only use native character insertion for single characters a-z or space for now.
      // Long-press events (hold a + press 4 = ä) to choose a special character otherwise
      // causes duplicate inserts.
      M.data && M.data.length === 1 && /[a-z ]/i.test(M.data) && // Chrome has issues correctly editing the start of nodes: https://bugs.chromium.org/p/chromium/issues/detail?id=1249405
      // When there is an inline element, e.g. a link, and you select
      // right after it (the start of the next node).
      he.anchor.offset !== 0 && (Be = !0, p.marks && (Be = !1), !io.get(p))) {
        var Ne, at, {
          anchor: dt
        } = he, [Oe, ft] = ie.toDOMPoint(p, dt), bt = (Ne = Oe.parentElement) === null || Ne === void 0 ? void 0 : Ne.closest("a"), De = ie.getWindow(p);
        if (Be && bt && ie.hasDOMNode(p, bt)) {
          var ke, Ke = De == null ? void 0 : De.document.createTreeWalker(bt, NodeFilter.SHOW_TEXT).lastChild();
          Ke === Oe && ((ke = Ke.textContent) === null || ke === void 0 ? void 0 : ke.length) === ft && (Be = !1);
        }
        if (Be && Oe.parentElement && (De == null || (at = De.getComputedStyle(Oe.parentElement)) === null || at === void 0 ? void 0 : at.whiteSpace) === "pre") {
          var Je = D.above(p, {
            at: dt.path,
            match: (It) => me.isElement(It) && D.isBlock(p, It)
          });
          Je && fe.string(Je[0]).includes("	") && (Be = !1);
        }
      }
      if ((!le.startsWith("delete") || le.startsWith("deleteBy")) && !io.get(p)) {
        var [Qe] = M.getTargetRanges();
        if (Qe) {
          var Bt = ie.toSlateRange(p, Qe, {
            exactMatch: !1,
            suppressThrow: !1
          });
          if (!he || !re.equals(he, Bt)) {
            Be = !1;
            var He = !Fe && p.selection && D.rangeRef(p, p.selection);
            se.select(p, Bt), He && Ho.set(p, He);
          }
        }
      }
      if (Fe)
        return;
      if (Be || M.preventDefault(), he && re.isExpanded(he) && le.startsWith("delete")) {
        var Yt = le.endsWith("Backward") ? "backward" : "forward";
        D.deleteFragment(p, {
          direction: Yt
        });
        return;
      }
      switch (le) {
        case "deleteByComposition":
        case "deleteByCut":
        case "deleteByDrag": {
          D.deleteFragment(p);
          break;
        }
        case "deleteContent":
        case "deleteContentForward": {
          D.deleteForward(p);
          break;
        }
        case "deleteContentBackward": {
          D.deleteBackward(p);
          break;
        }
        case "deleteEntireSoftLine": {
          D.deleteBackward(p, {
            unit: "line"
          }), D.deleteForward(p, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineBackward": {
          D.deleteBackward(p, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineBackward": {
          D.deleteBackward(p, {
            unit: "line"
          });
          break;
        }
        case "deleteHardLineForward": {
          D.deleteForward(p, {
            unit: "block"
          });
          break;
        }
        case "deleteSoftLineForward": {
          D.deleteForward(p, {
            unit: "line"
          });
          break;
        }
        case "deleteWordBackward": {
          D.deleteBackward(p, {
            unit: "word"
          });
          break;
        }
        case "deleteWordForward": {
          D.deleteForward(p, {
            unit: "word"
          });
          break;
        }
        case "insertLineBreak":
          D.insertSoftBreak(p);
          break;
        case "insertParagraph": {
          D.insertBreak(p);
          break;
        }
        case "insertFromComposition":
        case "insertFromDrop":
        case "insertFromPaste":
        case "insertFromYank":
        case "insertReplacementText":
        case "insertText": {
          le === "insertFromComposition" && ie.isComposing(p) && (b(!1), Ur.set(p, !1)), (Le == null ? void 0 : Le.constructor.name) === "DataTransfer" ? ie.insertData(p, Le) : typeof Le == "string" && (Be ? E.current.push(() => D.insertText(p, Le)) : D.insertText(p, Le));
          break;
        }
      }
      var Ft = (pe = Ho.get(p)) === null || pe === void 0 ? void 0 : pe.unref();
      Ho.delete(p), Ft && (!p.selection || !re.equals(p.selection, Ft)) && se.select(p, Ft);
    }
  }, [p, I, W, i, s, R]), J = it((M) => {
    M == null ? (I.cancel(), R.cancel(), fa.delete(p), qr.delete(p), k.current && ir && k.current.removeEventListener("beforeinput", V)) : ir && M.addEventListener("beforeinput", V), k.current = M, typeof e == "function" ? e(M) : e && (e.current = M);
  }, [I, R, p, V, e]);
  ai(() => {
    var M = ie.getWindow(p);
    M.document.addEventListener("selectionchange", R);
    var z = () => {
      j.isDraggingInternally = !1;
    };
    return M.document.addEventListener("dragend", z), M.document.addEventListener("drop", z), () => {
      M.document.removeEventListener("selectionchange", R), M.document.removeEventListener("dragend", z), M.document.removeEventListener("drop", z);
    };
  }, [R, j]);
  var G = o([p, []]), te = a && p.children.length === 1 && Array.from(fe.texts(p)).length === 1 && fe.string(p) === "" && !w, Q = it((M) => {
    if (M && te) {
      var z;
      O((z = M.getBoundingClientRect()) === null || z === void 0 ? void 0 : z.height);
    } else
      O(void 0);
  }, [te]);
  if (te) {
    var T = D.start(p, []);
    G.push({
      [co]: !0,
      placeholder: a,
      onPlaceholderResize: Q,
      anchor: T,
      focus: T
    });
  }
  var {
    marks: N
  } = p;
  if (j.hasMarkPlaceholder = !1, p.selection && re.isCollapsed(p.selection) && N) {
    var {
      anchor: Y
    } = p.selection, F = fe.leaf(p, Y.path), X = uo(F, Aj);
    if (!ye.equals(F, N, {
      loose: !0
    })) {
      j.hasMarkPlaceholder = !0;
      var L = Object.fromEntries(Object.keys(X).map((M) => [M, null]));
      G.push(Rn(Rn(Rn({
        [A0]: !0
      }, L), N), {}, {
        anchor: Y,
        focus: Y
      }));
    }
  }
  return y(() => {
    setTimeout(() => {
      var {
        selection: M
      } = p;
      if (M) {
        var {
          anchor: z
        } = M, A = fe.leaf(p, z.path);
        if (N && !ye.equals(A, N, {
          loose: !0
        })) {
          jn.set(p, N);
          return;
        }
      }
      jn.delete(p);
    });
  }), /* @__PURE__ */ be.createElement(V0.Provider, {
    value: s
  }, /* @__PURE__ */ be.createElement(Bj.Provider, {
    value: w
  }, /* @__PURE__ */ be.createElement(W0.Provider, {
    value: o
  }, /* @__PURE__ */ be.createElement(Mj, {
    node: k,
    receivedUserInput: P
  }, /* @__PURE__ */ be.createElement(v, Rn(Rn({
    role: s ? void 0 : "textbox",
    "aria-multiline": s ? void 0 : !0
  }, g), {}, {
    // COMPAT: Certain browsers don't support the `beforeinput` event, so we'd
    // have to use hacks to make these replacement-based features work.
    // For SSR situations HAS_BEFORE_INPUT_SUPPORT is false and results in prop
    // mismatch warning app moves to browser. Pass-through consumer props when
    // not CAN_USE_DOM (SSR) and default to falsy value
    spellCheck: ir || !da ? g.spellCheck : !1,
    autoCorrect: ir || !da ? g.autoCorrect : "false",
    autoCapitalize: ir || !da ? g.autoCapitalize : "false",
    "data-slate-editor": !0,
    "data-slate-node": "value",
    // explicitly set this
    contentEditable: !s,
    // in some cases, a decoration needs access to the range / selection to decorate a text node,
    // then you will select the whole text node when you select part the of text
    // this magic zIndex="-1" will fix it
    zindex: -1,
    suppressContentEditableWarning: !0,
    ref: J,
    style: Rn(Rn({}, h ? {} : Rn({
      // Allow positioning relative to the editable element.
      position: "relative",
      // Preserve adjacent whitespace and new lines.
      whiteSpace: "pre-wrap",
      // Allow words to break if they are too long.
      wordWrap: "break-word"
    }, m ? {
      minHeight: m
    } : {})), f),
    onBeforeInput: it((M) => {
      if (!ir && !s && !en(M, g.onBeforeInput) && ie.hasSelectableTarget(p, M.target) && (M.preventDefault(), !ie.isComposing(p))) {
        var z = M.data;
        D.insertText(p, z);
      }
    }, [g.onBeforeInput, p, s]),
    onInput: it((M) => {
      if (!en(M, g.onInput)) {
        if (_.current) {
          _.current.handleInput();
          return;
        }
        for (var z of E.current)
          z();
        if (E.current = [], !ie.isFocused(p)) {
          var A = M.nativeEvent, U = p;
          if (A.inputType === "historyUndo" && typeof U.undo == "function") {
            U.undo();
            return;
          }
          if (A.inputType === "historyRedo" && typeof U.redo == "function") {
            U.redo();
            return;
          }
        }
      }
    }, [g.onInput, p]),
    onBlur: it((M) => {
      if (!(s || j.isUpdatingSelection || !ie.hasSelectableTarget(p, M.target) || en(M, g.onBlur))) {
        var z = ie.findDocumentOrShadowRoot(p);
        if (j.latestElement !== z.activeElement) {
          var {
            relatedTarget: A
          } = M, U = ie.toDOMNode(p, p);
          if (A !== U && !(kn(A) && A.hasAttribute("data-slate-spacer"))) {
            if (A != null && br(A) && ie.hasDOMNode(p, A)) {
              var H = ie.toSlateNode(p, A);
              if (me.isElement(H) && !p.isVoid(H))
                return;
            }
            if (Ir) {
              var ee = Vo(z);
              ee == null || ee.removeAllRanges();
            }
            mr.delete(p);
          }
        }
      }
    }, [s, j.isUpdatingSelection, j.latestElement, p, g.onBlur]),
    onClick: it((M) => {
      if (ie.hasTarget(p, M.target) && !en(M, g.onClick) && br(M.target)) {
        var z = ie.toSlateNode(p, M.target), A = ie.findPath(p, z);
        if (!D.hasPath(p, A) || fe.get(p, A) !== z)
          return;
        if (M.detail === Oj && A.length >= 1) {
          var U = A;
          if (!(me.isElement(z) && D.isBlock(p, z))) {
            var H, ee = D.above(p, {
              match: (Be) => me.isElement(Be) && D.isBlock(p, Be),
              at: A
            });
            U = (H = ee == null ? void 0 : ee[1]) !== null && H !== void 0 ? H : A.slice(0, 1);
          }
          var Z = D.range(p, U);
          se.select(p, Z);
          return;
        }
        if (s)
          return;
        var pe = D.start(p, A), he = D.end(p, A), le = D.void(p, {
          at: pe
        }), Le = D.void(p, {
          at: he
        });
        if (le && Le && q.equals(le[1], Le[1])) {
          var Fe = D.range(p, pe);
          se.select(p, Fe);
        }
      }
    }, [p, g.onClick, s]),
    onCompositionEnd: it((M) => {
      if (ie.hasSelectableTarget(p, M.target)) {
        var z;
        if (ie.isComposing(p) && Promise.resolve().then(() => {
          b(!1), Ur.set(p, !1);
        }), (z = _.current) === null || z === void 0 || z.handleCompositionEnd(M), en(M, g.onCompositionEnd) || tn)
          return;
        if (!Ir && !xA && !k0 && !SA && !LA && M.data) {
          var A = jn.get(p);
          jn.delete(p), A !== void 0 && (Xn.set(p, p.marks), p.marks = A), D.insertText(p, M.data);
          var U = Xn.get(p);
          Xn.delete(p), U !== void 0 && (p.marks = U);
        }
      }
    }, [g.onCompositionEnd, p]),
    onCompositionUpdate: it((M) => {
      ie.hasSelectableTarget(p, M.target) && !en(M, g.onCompositionUpdate) && (ie.isComposing(p) || (b(!0), Ur.set(p, !0)));
    }, [g.onCompositionUpdate, p]),
    onCompositionStart: it((M) => {
      if (ie.hasSelectableTarget(p, M.target)) {
        var z;
        if ((z = _.current) === null || z === void 0 || z.handleCompositionStart(M), en(M, g.onCompositionStart) || tn)
          return;
        b(!0);
        var {
          selection: A
        } = p;
        if (A && re.isExpanded(A)) {
          D.deleteFragment(p);
          return;
        }
      }
    }, [g.onCompositionStart, p]),
    onCopy: it((M) => {
      ie.hasSelectableTarget(p, M.target) && !en(M, g.onCopy) && !Hg(M) && (M.preventDefault(), ie.setFragmentData(p, M.clipboardData, "copy"));
    }, [g.onCopy, p]),
    onCut: it((M) => {
      if (!s && ie.hasSelectableTarget(p, M.target) && !en(M, g.onCut) && !Hg(M)) {
        M.preventDefault(), ie.setFragmentData(p, M.clipboardData, "cut");
        var {
          selection: z
        } = p;
        if (z)
          if (re.isExpanded(z))
            D.deleteFragment(p);
          else {
            var A = fe.parent(p, z.anchor.path);
            D.isVoid(p, A) && se.delete(p);
          }
      }
    }, [s, p, g.onCut]),
    onDragOver: it((M) => {
      if (ie.hasTarget(p, M.target) && !en(M, g.onDragOver)) {
        var z = ie.toSlateNode(p, M.target);
        me.isElement(z) && D.isVoid(p, z) && M.preventDefault();
      }
    }, [g.onDragOver, p]),
    onDragStart: it((M) => {
      if (!s && ie.hasTarget(p, M.target) && !en(M, g.onDragStart)) {
        var z = ie.toSlateNode(p, M.target), A = ie.findPath(p, z), U = me.isElement(z) && D.isVoid(p, z) || D.void(p, {
          at: A,
          voids: !0
        });
        if (U) {
          var H = D.range(p, A);
          se.select(p, H);
        }
        j.isDraggingInternally = !0, ie.setFragmentData(p, M.dataTransfer, "drag");
      }
    }, [s, p, g.onDragStart, j]),
    onDrop: it((M) => {
      if (!s && ie.hasTarget(p, M.target) && !en(M, g.onDrop)) {
        M.preventDefault();
        var z = p.selection, A = ie.findEventRange(p, M), U = M.dataTransfer;
        se.select(p, A), j.isDraggingInternally && z && !re.equals(z, A) && !D.void(p, {
          at: A,
          voids: !0
        }) && se.delete(p, {
          at: z
        }), ie.insertData(p, U), ie.isFocused(p) || ie.focus(p);
      }
    }, [s, p, g.onDrop, j]),
    onDragEnd: it((M) => {
      !s && j.isDraggingInternally && g.onDragEnd && ie.hasTarget(p, M.target) && g.onDragEnd(M);
    }, [s, j, g, p]),
    onFocus: it((M) => {
      if (!s && !j.isUpdatingSelection && ie.hasEditableTarget(p, M.target) && !en(M, g.onFocus)) {
        var z = ie.toDOMNode(p, p), A = ie.findDocumentOrShadowRoot(p);
        if (j.latestElement = A.activeElement, no && M.target !== z) {
          z.focus();
          return;
        }
        mr.set(p, !0);
      }
    }, [s, j, p, g.onFocus]),
    onKeyDown: it((M) => {
      if (!s && ie.hasEditableTarget(p, M.target)) {
        var z;
        (z = _.current) === null || z === void 0 || z.handleKeyDown(M);
        var {
          nativeEvent: A
        } = M;
        if (ie.isComposing(p) && A.isComposing === !1 && (Ur.set(p, !1), b(!1)), en(M, g.onKeyDown) || ie.isComposing(p))
          return;
        var {
          selection: U
        } = p, H = p.children[U !== null ? U.focus.path[0] : 0], ee = m0(fe.string(H)) === "rtl";
        if (Lt.isRedo(A)) {
          M.preventDefault();
          var Z = p;
          typeof Z.redo == "function" && Z.redo();
          return;
        }
        if (Lt.isUndo(A)) {
          M.preventDefault();
          var pe = p;
          typeof pe.undo == "function" && pe.undo();
          return;
        }
        if (Lt.isMoveLineBackward(A)) {
          M.preventDefault(), se.move(p, {
            unit: "line",
            reverse: !0
          });
          return;
        }
        if (Lt.isMoveLineForward(A)) {
          M.preventDefault(), se.move(p, {
            unit: "line"
          });
          return;
        }
        if (Lt.isExtendLineBackward(A)) {
          M.preventDefault(), se.move(p, {
            unit: "line",
            edge: "focus",
            reverse: !0
          });
          return;
        }
        if (Lt.isExtendLineForward(A)) {
          M.preventDefault(), se.move(p, {
            unit: "line",
            edge: "focus"
          });
          return;
        }
        if (Lt.isMoveBackward(A)) {
          M.preventDefault(), U && re.isCollapsed(U) ? se.move(p, {
            reverse: !ee
          }) : se.collapse(p, {
            edge: ee ? "end" : "start"
          });
          return;
        }
        if (Lt.isMoveForward(A)) {
          M.preventDefault(), U && re.isCollapsed(U) ? se.move(p, {
            reverse: ee
          }) : se.collapse(p, {
            edge: ee ? "start" : "end"
          });
          return;
        }
        if (Lt.isMoveWordBackward(A)) {
          M.preventDefault(), U && re.isExpanded(U) && se.collapse(p, {
            edge: "focus"
          }), se.move(p, {
            unit: "word",
            reverse: !ee
          });
          return;
        }
        if (Lt.isMoveWordForward(A)) {
          M.preventDefault(), U && re.isExpanded(U) && se.collapse(p, {
            edge: "focus"
          }), se.move(p, {
            unit: "word",
            reverse: ee
          });
          return;
        }
        if (ir) {
          if ((M0 || Ir) && U && (Lt.isDeleteBackward(A) || Lt.isDeleteForward(A)) && re.isCollapsed(U)) {
            var he = fe.parent(p, U.anchor.path);
            if (me.isElement(he) && D.isVoid(p, he) && (D.isInline(p, he) || D.isBlock(p, he))) {
              M.preventDefault(), D.deleteBackward(p, {
                unit: "block"
              });
              return;
            }
          }
        } else {
          if (Lt.isBold(A) || Lt.isItalic(A) || Lt.isTransposeCharacter(A)) {
            M.preventDefault();
            return;
          }
          if (Lt.isSoftBreak(A)) {
            M.preventDefault(), D.insertSoftBreak(p);
            return;
          }
          if (Lt.isSplitBlock(A)) {
            M.preventDefault(), D.insertBreak(p);
            return;
          }
          if (Lt.isDeleteBackward(A)) {
            M.preventDefault(), U && re.isExpanded(U) ? D.deleteFragment(p, {
              direction: "backward"
            }) : D.deleteBackward(p);
            return;
          }
          if (Lt.isDeleteForward(A)) {
            M.preventDefault(), U && re.isExpanded(U) ? D.deleteFragment(p, {
              direction: "forward"
            }) : D.deleteForward(p);
            return;
          }
          if (Lt.isDeleteLineBackward(A)) {
            M.preventDefault(), U && re.isExpanded(U) ? D.deleteFragment(p, {
              direction: "backward"
            }) : D.deleteBackward(p, {
              unit: "line"
            });
            return;
          }
          if (Lt.isDeleteLineForward(A)) {
            M.preventDefault(), U && re.isExpanded(U) ? D.deleteFragment(p, {
              direction: "forward"
            }) : D.deleteForward(p, {
              unit: "line"
            });
            return;
          }
          if (Lt.isDeleteWordBackward(A)) {
            M.preventDefault(), U && re.isExpanded(U) ? D.deleteFragment(p, {
              direction: "backward"
            }) : D.deleteBackward(p, {
              unit: "word"
            });
            return;
          }
          if (Lt.isDeleteWordForward(A)) {
            M.preventDefault(), U && re.isExpanded(U) ? D.deleteFragment(p, {
              direction: "forward"
            }) : D.deleteForward(p, {
              unit: "word"
            });
            return;
          }
        }
      }
    }, [s, p, g.onKeyDown]),
    onPaste: it((M) => {
      !s && ie.hasEditableTarget(p, M.target) && !en(M, g.onPaste) && (!ir || MA(M.nativeEvent) || Ir) && (M.preventDefault(), ie.insertData(p, M.clipboardData));
    }, [s, p, g.onPaste])
  }), /* @__PURE__ */ be.createElement(jj, {
    decorations: G,
    node: p,
    renderElement: l,
    renderPlaceholder: c,
    renderLeaf: u,
    selection: p.selection
  }))))));
}), _j = (t) => {
  var {
    attributes: e,
    children: n
  } = t;
  return (
    // COMPAT: Artificially add a line-break to the end on the placeholder element
    // to prevent Android IMEs to pick up its content in autocorrect and to auto-capitalize the first letter
    /* @__PURE__ */ be.createElement("span", Rn({}, e), n, tn && /* @__PURE__ */ be.createElement("br", null))
  );
}, Ij = () => [], Rj = (t, e) => {
  if (e.getBoundingClientRect && (!t.selection || t.selection && re.isCollapsed(t.selection))) {
    var n = e.startContainer.parentElement;
    n.getBoundingClientRect = e.getBoundingClientRect.bind(e), XT(n, {
      scrollMode: "if-needed"
    }), delete n.getBoundingClientRect;
  }
}, en = (t, e) => {
  if (!e)
    return !1;
  var n = e(t);
  return n ?? (t.isDefaultPrevented() || t.isPropagationStopped());
}, Hg = (t) => br(t.target) && (t.target instanceof HTMLInputElement || t.target instanceof HTMLTextAreaElement), Nj = (t, e) => {
  if (!e)
    return !1;
  var n = e(t);
  return n ?? t.defaultPrevented;
}, $j = /* @__PURE__ */ ct(!1), zj = /* @__PURE__ */ ct({});
function Uj(t) {
  var e = qe([]).current, n = qe({
    editor: t
  }).current, r = it((i) => {
    n.editor = i, e.forEach((a) => a(i));
  }, [e, n]), o = En(() => ({
    getSlate: () => n.editor,
    addEventListener: (i) => (e.push(i), () => {
      e.splice(e.indexOf(i), 1);
    })
  }), [e, n]);
  return {
    selectorContext: o,
    onChange: r
  };
}
var Wj = ["editor", "children", "onChange", "onSelectionChange", "onValueChange", "initialValue"], Hj = (t) => {
  var {
    editor: e,
    children: n,
    onChange: r,
    onSelectionChange: o,
    onValueChange: i,
    initialValue: a
  } = t, s = uo(t, Wj), [l, u] = be.useState(() => {
    if (!fe.isNodeList(a))
      throw new Error("[Slate] initialValue is invalid! Expected a list of elements but got: ".concat(Ut.stringify(a)));
    if (!D.isEditor(e))
      throw new Error("[Slate] editor is invalid! You passed: ".concat(Ut.stringify(e)));
    return e.children = a, Object.assign(e, s), {
      v: 0,
      editor: e
    };
  }), {
    selectorContext: c,
    onChange: d
  } = Uj(e), f = it((g) => {
    var p;
    switch (r && r(e.children), g == null || (p = g.operation) === null || p === void 0 ? void 0 : p.type) {
      case "set_selection":
        o == null || o(e.selection);
        break;
      default:
        i == null || i(e.children);
    }
    u((w) => ({
      v: w.v + 1,
      editor: e
    })), d(e);
  }, [e, d, r, o, i]);
  y(() => (Iu.set(e, f), () => {
    Iu.set(e, () => {
    });
  }), [e, f]);
  var [v, h] = B(ie.isFocused(e));
  return y(() => {
    h(ie.isFocused(e));
  }, [e]), ai(() => {
    var g = () => h(ie.isFocused(e));
    return P0 >= 17 ? (document.addEventListener("focusin", g), document.addEventListener("focusout", g), () => {
      document.removeEventListener("focusin", g), document.removeEventListener("focusout", g);
    }) : (document.addEventListener("focus", g, !0), document.addEventListener("blur", g, !0), () => {
      document.removeEventListener("focus", g, !0), document.removeEventListener("blur", g, !0);
    });
  }, []), /* @__PURE__ */ be.createElement(zj.Provider, {
    value: c
  }, /* @__PURE__ */ be.createElement(q0.Provider, {
    value: l
  }, /* @__PURE__ */ be.createElement(rd.Provider, {
    value: l.editor
  }, /* @__PURE__ */ be.createElement($j.Provider, {
    value: v
  }, n))));
}, Vg = (t, e) => {
  var n = (e.top + e.bottom) / 2;
  return t.top <= n && t.bottom >= n;
}, qg = (t, e, n) => {
  var r = ie.toDOMRange(t, e).getBoundingClientRect(), o = ie.toDOMRange(t, n).getBoundingClientRect();
  return Vg(r, o) && Vg(o, r);
}, Vj = (t, e) => {
  var n = D.range(t, re.end(e)), r = Array.from(D.positions(t, {
    at: e
  })), o = 0, i = r.length, a = Math.floor(i / 2);
  if (qg(t, D.range(t, r[o]), n))
    return D.range(t, r[o], n);
  if (r.length < 2)
    return D.range(t, r[r.length - 1], n);
  for (; a !== r.length && a !== o; )
    qg(t, D.range(t, r[a]), n) ? i = a : o = a, a = Math.floor((o + i) / 2);
  return D.range(t, r[i], n);
};
function Gg(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Zg(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Gg(Object(n), !0).forEach(function(r) {
      Mn(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Gg(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var qj = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : "x-slate-fragment", r = e, {
    apply: o,
    onChange: i,
    deleteBackward: a,
    addMark: s,
    removeMark: l
  } = r;
  return $s.set(r, /* @__PURE__ */ new WeakMap()), r.addMark = (u, c) => {
    var d, f;
    (d = ad.get(r)) === null || d === void 0 || d(), !jn.get(r) && (f = an.get(r)) !== null && f !== void 0 && f.length && jn.set(r, null), Xn.delete(r), s(u, c);
  }, r.removeMark = (u) => {
    var c;
    !jn.get(r) && (c = an.get(r)) !== null && c !== void 0 && c.length && jn.set(r, null), Xn.delete(r), l(u);
  }, r.deleteBackward = (u) => {
    if (u !== "line")
      return a(u);
    if (r.selection && re.isCollapsed(r.selection)) {
      var c = D.above(r, {
        match: (h) => me.isElement(h) && D.isBlock(r, h),
        at: r.selection
      });
      if (c) {
        var [, d] = c, f = D.range(r, d, r.selection.anchor), v = Vj(r, f);
        re.isCollapsed(v) || se.delete(r, {
          at: v
        });
      }
    }
  }, r.apply = (u) => {
    var c = [], d = [], f = an.get(r);
    if (f != null && f.length) {
      var v = f.map((R) => VA(R, u)).filter(Boolean);
      an.set(r, v);
    }
    var h = fr.get(r);
    h && fr.set(r, Fg(r, h, u));
    var g = dr.get(r);
    if (g != null && g.at) {
      var p = _e.isPoint(g == null ? void 0 : g.at) ? $u(r, g.at, u) : Fg(r, g.at, u);
      dr.set(r, p ? Zg(Zg({}, g), {}, {
        at: p
      }) : null);
    }
    switch (u.type) {
      case "insert_text":
      case "remove_text":
      case "set_node":
      case "split_node": {
        c.push(...eo(r, u.path));
        break;
      }
      case "set_selection": {
        var w;
        (w = Ho.get(r)) === null || w === void 0 || w.unref(), Ho.delete(r);
        break;
      }
      case "insert_node":
      case "remove_node": {
        c.push(...eo(r, q.parent(u.path)));
        break;
      }
      case "merge_node": {
        var b = q.previous(u.path);
        c.push(...eo(r, b));
        break;
      }
      case "move_node": {
        var k = q.common(q.parent(u.path), q.parent(u.newPath));
        c.push(...eo(r, k));
        var E;
        q.isBefore(u.path, u.newPath) ? (c.push(...eo(r, q.parent(u.path))), E = u.newPath) : (c.push(...eo(r, q.parent(u.newPath))), E = u.path);
        var m = fe.get(e, q.parent(E)), O = ie.findKey(r, m), S = D.pathRef(r, q.parent(E));
        d.push([S, O]);
        break;
      }
    }
    switch (o(u), u.type) {
      case "insert_node":
      case "remove_node":
      case "merge_node":
      case "move_node":
      case "split_node":
        io.set(r, !0);
    }
    for (var [W, P] of c) {
      var [$] = D.node(r, W);
      Ua.set($, P);
    }
    for (var [j, _] of d) {
      if (j.current) {
        var [I] = D.node(r, j.current);
        Ua.set(I, _);
      }
      j.unref();
    }
  }, r.setFragmentData = (u) => {
    var {
      selection: c
    } = r;
    if (c) {
      var [d, f] = re.edges(c), v = D.void(r, {
        at: d.path
      }), h = D.void(r, {
        at: f.path
      });
      if (!(re.isCollapsed(c) && !v)) {
        var g = ie.toDOMRange(r, c), p = g.cloneContents(), w = p.childNodes[0];
        if (p.childNodes.forEach(($) => {
          $.textContent && $.textContent.trim() !== "" && (w = $);
        }), h) {
          var [b] = h, k = g.cloneRange(), E = ie.toDOMNode(r, b);
          k.setEndAfter(E), p = k.cloneContents();
        }
        if (v && (w = p.querySelector("[data-slate-spacer]")), Array.from(p.querySelectorAll("[data-slate-zero-width]")).forEach(($) => {
          var j = $.getAttribute("data-slate-zero-width") === "n";
          $.textContent = j ? `
` : "";
        }), F0(w)) {
          var m = w.ownerDocument.createElement("span");
          m.style.whiteSpace = "pre", m.appendChild(w), p.appendChild(m), w = m;
        }
        var O = r.getFragment(), S = JSON.stringify(O), W = window.btoa(encodeURIComponent(S));
        w.setAttribute("data-slate-fragment", W), u.setData("application/".concat(n), W);
        var P = p.ownerDocument.createElement("div");
        return P.appendChild(p), P.setAttribute("hidden", "true"), p.ownerDocument.body.appendChild(P), u.setData("text/html", P.innerHTML), u.setData("text/plain", I0(P)), p.ownerDocument.body.removeChild(P), u;
      }
    }
  }, r.insertData = (u) => {
    r.insertFragmentData(u) || r.insertTextData(u);
  }, r.insertFragmentData = (u) => {
    var c = u.getData("application/".concat(n)) || FA(u);
    if (c) {
      var d = decodeURIComponent(window.atob(c)), f = JSON.parse(d);
      return r.insertFragment(f), !0;
    }
    return !1;
  }, r.insertTextData = (u) => {
    var c = u.getData("text/plain");
    if (c) {
      var d = c.split(/\r\n|\r|\n/), f = !1;
      for (var v of d)
        f && se.splitNodes(r, {
          always: !0
        }), r.insertText(v), f = !0;
      return !0;
    }
    return !1;
  }, r.onChange = (u) => {
    var c = P0 < 18 ? nc.unstable_batchedUpdates : (d) => d();
    c(() => {
      var d = Iu.get(r);
      d && d(u), i(u);
    });
  }, r;
}, eo = (t, e) => {
  var n = [];
  for (var [r, o] of D.levels(t, {
    at: e
  })) {
    var i = ie.findKey(t, r);
    n.push([o, i]);
  }
  return n;
};
function Z0(t, e, n = "type") {
  const { selection: r } = t;
  if (!r) return !1;
  const [o] = Array.from(
    D.nodes(t, {
      at: D.unhangRange(t, r),
      match: (i) => !D.isEditor(i) && me.isElement(i) && i[n] === e
    })
  );
  return !!o;
}
const Kg = ["listItem", "numberedList"], pa = ["left", "center", "right", "justify"];
function Gj(t, e) {
  const n = pa.includes(e) ? "align" : "type", r = Z0(t, e, n), o = Kg.includes(e);
  se.unwrapNodes(t, {
    match: (a) => !D.isEditor(a) && me.isElement(a) && Kg.includes(a.type) && !pa.includes(e),
    split: !0
  });
  let i;
  if (pa.includes(e) ? i = { align: r ? void 0 : e } : i = {
    type: r ? "paragraph" : o ? "listItem" : e
  }, se.setNodes(t, i), !r && o) {
    const a = { type: e, children: [] };
    se.wrapNodes(t, a);
  }
}
function Tr({ format: t, icon: e }) {
  const n = zs(), r = pa.includes(t) ? "align" : "type", i = Z0(n, t, r) ? "activeTrue" : "activeFalse";
  function a(s) {
    s.preventDefault(), Gj(n, t);
  }
  return /* @__PURE__ */ x.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextBlockButton " + i,
      onMouseDown: a,
      children: /* @__PURE__ */ x.jsx(e, {})
    }
  );
}
function Zj({ attributes: t, children: e, element: n }) {
  const r = { textAlign: n.align };
  switch (n.type) {
    case "blockQuote":
      return /* @__PURE__ */ x.jsx(
        "blockquote",
        {
          className: "arkynElementBlockquote",
          style: r,
          ...t,
          children: e
        }
      );
    case "bulletedList":
      return /* @__PURE__ */ x.jsx("ul", { className: "arkynElementBulletList", style: r, ...t, children: e });
    case "headingOne":
      return /* @__PURE__ */ x.jsx("h1", { className: "arkynElementHeadingOne", style: r, ...t, children: e });
    case "headingTwo":
      return /* @__PURE__ */ x.jsx("h2", { className: "arkynElementHeadingTwo", style: r, ...t, children: e });
    case "listItem":
      return /* @__PURE__ */ x.jsx("li", { className: "arkynElementListItem", style: r, ...t, children: e });
    case "numberedList":
      return /* @__PURE__ */ x.jsx("ol", { className: "arkynElementNumberedList", style: r, ...t, children: e });
    case "image":
      return /* @__PURE__ */ x.jsxs("div", { style: r, ...t, children: [
        /* @__PURE__ */ x.jsx(
          "img",
          {
            className: "arkynElementImage",
            alt: "arkynElementImage",
            src: (n == null ? void 0 : n.src) || ""
          }
        ),
        e
      ] });
    default:
      return /* @__PURE__ */ x.jsx("p", { className: "arkynElementParagraph", style: r, ...t, children: e });
  }
}
const K0 = ct({});
function Kj(t) {
  const {
    isVisibled: e,
    makeInvisible: n,
    children: r,
    className: o = "",
    ...i
  } = t, s = `arkynModalContainer ${e ? "visibleTrue" : "visibleFalse"} ${o}`;
  return /* @__PURE__ */ x.jsx(K0.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ x.jsx(iy, { children: e && /* @__PURE__ */ x.jsxs("aside", { className: s.trim(), ...i, children: [
    /* @__PURE__ */ x.jsx(
      Go.div,
      {
        className: "arkynModalContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ x.jsx(
      Go.div,
      {
        className: "arkynModalContainerContent",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0, scale: 0.75 },
        animate: { opacity: 1, scale: 1 },
        exit: { opacity: 0, scale: 0 },
        children: r
      }
    )
  ] }) }) });
}
function Yj(t) {
  const { alignment: e = "right", className: n, ...r } = t, o = `arkynModalFooter ${e} ${n}`;
  return /* @__PURE__ */ x.jsx("footer", { className: o.trim(), ...r });
}
function Xj(t) {
  const {
    showCloseButton: e = !0,
    className: n,
    children: r,
    ...o
  } = t, { makeInvisible: i } = Ee(K0), a = `arkynModalHeader ${n}`;
  return /* @__PURE__ */ x.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    e && /* @__PURE__ */ x.jsx(
      "button",
      {
        type: "button",
        onClick: i,
        "aria-label": "Close modal button",
        className: "arkynModalHeaderCloseButton",
        children: /* @__PURE__ */ x.jsx(Qu, { size: 24 })
      }
    )
  ] });
}
const Uu = ct({});
function Jj() {
  if (!Uu)
    throw new Error("useTabContext must be used within a TabProvider");
  return Ee(Uu);
}
function Qj(t) {
  const {
    children: e,
    onClick: n,
    defaultActive: r,
    className: o,
    ...i
  } = t, [a, s] = B(r || ""), [l, u] = B(!0), c = qe(null), d = `arkynTabContainer ${o || ""}`, [f, v] = B({
    width: "0px",
    left: "0px",
    transition: "none"
  }), h = (p, w) => {
    const b = p.getBoundingClientRect(), k = c.current.getBoundingClientRect(), E = w ? void 0 : "none";
    u(!1), v({
      transition: E,
      width: `${b.width}px`,
      left: `${b.left - k.left}px`
    });
  };
  y(() => {
    const p = c.current;
    if (!p) return;
    let w = null;
    w = p.querySelector("button.activeTrue"), w && h(w);
  }, []);
  const g = (p) => {
    const w = p.target;
    w && (s(w.value), w.classList.add("activeTrue"), h(w, !0), n && n(w.value));
  };
  return /* @__PURE__ */ x.jsxs("nav", { ref: c, className: d.trim(), ...i, children: [
    /* @__PURE__ */ x.jsx(Uu.Provider, { value: { handleTabClick: g, showInitialTab: l, value: a }, children: e }),
    /* @__PURE__ */ x.jsx("div", { className: "activeLine", style: f })
  ] });
}
function Yg(t) {
  const { children: e, className: n = "", onClick: r, ...o } = t, { value: i, showInitialTab: a, handleTabClick: s } = Jj(), l = i === o.value && i ? "activeTrue" : "activeFalse", c = `arkynTabButton ${i === o.value && a ? "showBorderBottom" : ""} ${l} ${n}`;
  function d(f) {
    s(f), r && r(f);
  }
  return /* @__PURE__ */ x.jsx(
    "button",
    {
      onClick: d,
      className: c.trim(),
      ...o,
      type: "button",
      children: e
    }
  );
}
function eF(t) {
  const {
    action: e,
    tabLabels: n = ["Adicionar URL", "Upload de arquivo"],
    modalCancelButton: r = "Cancelar",
    modalConfirmButton: o = "Confirmar",
    modalInputImageLabel: i = "Imagem:",
    modalInputUrlLabel: a = "URL da imagem:",
    modalTitle: s = "Inserir imagem"
  } = t, l = zs(), [u, c] = B(!1), [d, f] = B(""), [v, h] = B("url");
  function g(p) {
    p.preventDefault(), !(!d || d === "") && (l.insertNodes([
      { type: "paragraph", children: [{ text: "" }] },
      { type: "image", src: d, children: [{ text: "" }] },
      { type: "paragraph", children: [{ text: "" }] }
    ]), c(!1));
  }
  return /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
    /* @__PURE__ */ x.jsx(
      "button",
      {
        type: "button",
        className: "arkynRichTextInsertImage",
        onMouseDown: () => c(!0),
        children: /* @__PURE__ */ x.jsx(JC, {})
      }
    ),
    /* @__PURE__ */ x.jsxs(
      Kj,
      {
        isVisibled: u,
        makeInvisible: () => c(!1),
        children: [
          /* @__PURE__ */ x.jsx(Xj, { children: s }),
          /* @__PURE__ */ x.jsxs("div", { className: "arkynRichTextInsertImageModalContent", children: [
            /* @__PURE__ */ x.jsxs(Qj, { defaultActive: v, onClick: h, children: [
              /* @__PURE__ */ x.jsx(Yg, { value: "url", children: n[0] }),
              /* @__PURE__ */ x.jsx(Yg, { value: "file", children: n[1] })
            ] }),
            v === "url" && /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
              /* @__PURE__ */ x.jsxs(ug, { children: [
                /* @__PURE__ */ x.jsx(cg, { children: a }),
                /* @__PURE__ */ x.jsx(
                  Rs,
                  {
                    type: "text",
                    name: "richTextimageURL",
                    defaultValue: d,
                    onChange: (p) => f(p.target.value)
                  }
                )
              ] }),
              d && /* @__PURE__ */ x.jsx(
                "img",
                {
                  className: "arkynRichTextInsertImageModalPreviewImage",
                  src: d,
                  alt: "preview"
                }
              )
            ] }),
            v === "file" && /* @__PURE__ */ x.jsxs(ug, { children: [
              /* @__PURE__ */ x.jsx(cg, { children: i }),
              /* @__PURE__ */ x.jsx(
                cB,
                {
                  name: "richTextimageURL",
                  action: e,
                  defaultValue: d,
                  onUpload: (p) => f(p || "")
                }
              )
            ] })
          ] }),
          /* @__PURE__ */ x.jsxs(Yj, { children: [
            /* @__PURE__ */ x.jsx(
              za,
              {
                type: "button",
                scheme: "danger",
                variant: "outline",
                onClick: () => c(!1),
                children: r
              }
            ),
            /* @__PURE__ */ x.jsx(za, { type: "button", onClick: g, children: o })
          ] })
        ]
      }
    )
  ] });
}
function tF({ attributes: t, children: e, leaf: n }) {
  return n.bold && (e = /* @__PURE__ */ x.jsx("strong", { children: e })), n.code && (e = /* @__PURE__ */ x.jsx("code", { children: e })), n.italic && (e = /* @__PURE__ */ x.jsx("em", { children: e })), n.underline && (e = /* @__PURE__ */ x.jsx("u", { children: e })), /* @__PURE__ */ x.jsx("span", { ...t, children: e });
}
function Y0(t, e) {
  const n = D.marks(t);
  return n ? n[e] === !0 : !1;
}
function X0(t, e) {
  Y0(t, e) ? D.removeMark(t, e) : D.addMark(t, e, !0);
}
function Xi({ format: t, icon: e }) {
  const n = zs(), o = Y0(n, t) ? "activeTrue" : "activeFalse";
  function i(a) {
    a.preventDefault(), X0(n, t);
  }
  return /* @__PURE__ */ x.jsx(
    "button",
    {
      type: "button",
      className: "arkynRichTextMarkButton " + o,
      onMouseDown: i,
      children: /* @__PURE__ */ x.jsx(e, {})
    }
  );
}
function nF({ children: t }) {
  return /* @__PURE__ */ x.jsx("div", { className: "arkynRichTextToolbar", children: t });
}
function Xg(t) {
  return t.map((e) => fe.string(e)).join("");
}
const Jg = {
  "mod+b": "bold",
  "mod+i": "italic",
  "mod+u": "underline",
  "mod+`": "code"
}, Ji = [
  {
    type: "paragraph",
    children: [{ text: "" }]
  }
];
function E2(t) {
  const {
    name: e,
    hiddenButtons: n,
    imageConfig: r,
    defaultValue: o = "[]",
    enforceCharacterLimit: i = !1,
    onChangeCharactersCount: a,
    maxLimit: s = 2e3,
    onChange: l,
    isError: u
  } = t, c = En(() => IB(qj(KD())), []), { id: d, inputRef: f, error: v } = dn(), h = qe(null);
  function g() {
    try {
      const G = JSON.parse(o);
      return !Array.isArray(G) || G.length <= 0 ? Ji : G.every(
        (Q) => typeof Q == "object" && Q !== null && "type" in Q && "children" in Q
      ) ? G : Ji;
    } catch {
      return Ji;
    }
  }
  const p = Xg(g()), [w, b] = B(p.length), [k, E] = B(
    JSON.stringify(g()) || "[]"
  ), [m, O] = B(!1), S = f || h, W = u || !!v, P = it(tF, []), $ = it(Zj, []);
  function j(G) {
    const te = Xg(G);
    b(te.length), a && a(te.length), !(i && te.length >= s) && (E(JSON.stringify(G)), l && l(G), c.children = G, se.setNodes(c, { children: G }));
  }
  const _ = m ? "focusTrue" : "focusFalse", R = `arkynRichText ${W || s < w ? "errorTrue" : "errorFalse"} ${_}`, V = s - w;
  function J(G) {
    return !(n != null && n.includes(G));
  }
  return /* @__PURE__ */ x.jsxs(
    Hj,
    {
      editor: c,
      initialValue: g(),
      onChange: j,
      onValueChange: j,
      children: [
        /* @__PURE__ */ x.jsxs("div", { className: R, children: [
          /* @__PURE__ */ x.jsxs(nF, { children: [
            J("headingOne") && /* @__PURE__ */ x.jsx(Tr, { format: "headingOne", icon: QC }),
            J("headingTwo") && /* @__PURE__ */ x.jsx(Tr, { format: "headingTwo", icon: ew }),
            J("blockQuote") && /* @__PURE__ */ x.jsx(Tr, { format: "blockQuote", icon: tw }),
            J("bold") && /* @__PURE__ */ x.jsx(Xi, { format: "bold", icon: nw }),
            J("italic") && /* @__PURE__ */ x.jsx(Xi, { format: "italic", icon: rw }),
            J("underline") && /* @__PURE__ */ x.jsx(Xi, { format: "underline", icon: ow }),
            J("code") && /* @__PURE__ */ x.jsx(Xi, { format: "code", icon: iw }),
            J("left") && /* @__PURE__ */ x.jsx(Tr, { format: "left", icon: aw }),
            J("right") && /* @__PURE__ */ x.jsx(Tr, { format: "right", icon: sw }),
            J("center") && /* @__PURE__ */ x.jsx(Tr, { format: "center", icon: lw }),
            J("justify") && /* @__PURE__ */ x.jsx(Tr, { format: "justify", icon: uw }),
            r && J("image") && /* @__PURE__ */ x.jsx(eF, { ...r })
          ] }),
          /* @__PURE__ */ x.jsx(
            Fj,
            {
              className: "editorContainer",
              renderElement: $,
              renderLeaf: P,
              spellCheck: !0,
              id: d,
              onFocus: () => O(!0),
              onBlur: () => O(!1),
              onKeyDown: (G) => {
                for (const te in Jg)
                  if (jB(te, G)) {
                    G.preventDefault();
                    const Q = Jg[te];
                    X0(c, Q);
                  }
              }
            }
          ),
          V < 0 && /* @__PURE__ */ x.jsx("div", { className: "restatesCharacters", children: V })
        ] }),
        /* @__PURE__ */ x.jsx("input", { type: "hidden", ref: S, name: e, value: k }),
        /* @__PURE__ */ x.jsx("input", { type: "hidden", name: `${e}Count`, value: w })
      ]
    }
  );
}
function rF(t, e) {
  const {
    isLoading: n,
    isError: r,
    size: o = "md",
    className: i = "",
    variant: a = "solid",
    prefix: s,
    leftIcon: l,
    disabled: u,
    readOnly: c,
    onFocus: d,
    onBlur: f,
    title: v,
    style: h,
    closeOnSelect: g = !0,
    ...p
  } = t, m = `arkyn_select ${s ? "hasPrefix" : ""} ${a} ${o} ${u || c || n ? "opacity" : ""} ${r ? "errored" : ""} ${e ? "focused" : ""} ${i}`, S = { md: 20, lg: 20 }[o];
  return {
    isLoading: n,
    className: m,
    prefix: Ry(s, S, "prefix"),
    LeftIcon: l,
    disabled: u || n || c,
    onFocus: d,
    onBlur: f,
    title: v,
    closeOnSelect: g,
    style: h,
    iconSize: S,
    Spinner: /* @__PURE__ */ x.jsx(Un, { className: "spinner", size: S, strokeWidth: 2.5 }),
    ...p
  };
}
function D2(t) {
  var M;
  const [e, n] = B(""), [r, o] = B(!1), { inputRef: i, id: a, error: s } = dn(), l = qe(null), u = i || l, c = t.isError || !!s, {
    disabled: d,
    title: f,
    style: v,
    className: h,
    prefix: g,
    iconSize: p,
    isLoading: w,
    LeftIcon: b,
    value: k = null,
    defaultValue: E = "",
    onFocus: m,
    onBlur: O,
    Spinner: S,
    name: W,
    placeholder: P,
    onSelect: $,
    options: j,
    optionMaxHeight: _,
    closeOnSelect: I,
    isSearchable: R,
    onSearch: V,
    ...J
  } = rF({ ...t, id: a, isError: c }, r), [G, te] = B(E);
  function Q() {
    d || !(u != null && u.current) || r || (o(!0), u.current.focus());
  }
  function T(z) {
    r || (o(!0), m && m(z));
  }
  function N() {
    o(!1), O && u.current && u.current.blur();
  }
  function Y(z) {
    const { label: A, value: U } = z;
    te(G !== U ? U : ""), $ && $({ label: A, value: U }), I && N();
  }
  const F = typeof k == "string" ? k : G, X = ((M = j.find((z) => z.value === F)) == null ? void 0 : M.label) || "", L = () => {
    if (!r && X) return !0;
    if (!r && !X) return !1;
    if (r && X) return !0;
    if (r && !X) return !1;
  };
  return /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
    /* @__PURE__ */ x.jsxs(
      "section",
      {
        title: f,
        style: v,
        onClick: Q,
        className: `${h} placeholder_dark_${L()}`,
        children: [
          g,
          b && /* @__PURE__ */ x.jsx(b, { size: p, strokeWidth: 2.5 }),
          /* @__PURE__ */ x.jsx(
            "input",
            {
              disabled: d,
              readOnly: !0,
              placeholder: X || P,
              onFocus: T,
              ...J
            }
          ),
          /* @__PURE__ */ x.jsx(
            "input",
            {
              type: "hidden",
              ref: u,
              name: W,
              value: F || "",
              readOnly: !0
            }
          ),
          r && /* @__PURE__ */ x.jsxs(
            "div",
            {
              className: "arkyn_select_content",
              style: { overflow: "auto", maxHeight: _ },
              children: [
                R && /* @__PURE__ */ x.jsx(
                  Rs,
                  {
                    type: "search",
                    name: "search-select",
                    variant: "underline",
                    leftIcon: ty,
                    onChange: (z) => n(z.target.value)
                  }
                ),
                j.filter((z) => !!(t.onSearch || !t.isSearchable || z.label.toLowerCase().includes(e.toLowerCase()))).map(({ label: z, value: A }) => /* @__PURE__ */ x.jsxs(
                  "div",
                  {
                    onClick: () => Y({ label: z, value: A }),
                    className: F === A ? "arkyn_select_option active" : "arkyn_select_option",
                    children: [
                      z,
                      " ",
                      /* @__PURE__ */ x.jsx(Ju, {})
                    ]
                  },
                  A
                )),
                j.length <= 0 && /* @__PURE__ */ x.jsx("p", { children: "Sem opções disponíveis" })
              ]
            }
          ),
          !w && /* @__PURE__ */ x.jsx(
            ey,
            {
              className: "arkyn_select_arrow",
              size: p,
              strokeWidth: 2.5
            }
          ),
          w && S
        ]
      }
    ),
    r && /* @__PURE__ */ x.jsx("aside", { className: "arkyn_select_overlay", onClick: N })
  ] });
}
function O2(t) {
  const {
    size: e = "lg",
    defaultChecked: n = !1,
    checked: r = null,
    value: o,
    unCheckedValue: i = "",
    name: a,
    className: s = "",
    onCheck: l,
    ...u
  } = t, [c, d] = B(n), { id: f, inputRef: v } = dn(), h = typeof r == "boolean" ? r : c;
  function g() {
    d(!c), l && l(h ? i : o || "checked");
  }
  const w = `arkynSwitch ${h ? "checkedTrue" : "checkedFalse"} ${e} ${s}`;
  return /* @__PURE__ */ x.jsx("button", { type: "button", onClick: g, className: w, ...u, children: /* @__PURE__ */ x.jsx(
    "input",
    {
      id: f,
      type: "hidden",
      name: a,
      ref: v,
      onClick: g,
      value: h ? o || "checked" : i
    }
  ) });
}
function x2(t) {
  const {
    variant: e = "solid",
    size: n = "md",
    className: r,
    disabled: o = !1,
    readOnly: i = !1,
    onFocus: a,
    onBlur: s,
    title: l,
    style: u,
    ...c
  } = t, [d, f] = B(!1), { inputRef: v, id: h, error: g } = dn(), p = qe(null), w = v || p, k = t.isError || !!g ? "errorTrue" : "errorFalse", O = `arkynTextarea ${e} ${n} ${o || i ? "opacityTrue" : "opacityFalse"} ${k} ${d ? "focusedTrue" : "focusedFalse"} ${r}`;
  function S() {
    o || !(w != null && w.current) || (f(!0), w.current.focus());
  }
  function W($) {
    f(!0), a && a($);
  }
  function P($) {
    f(!1), s && s($);
  }
  return /* @__PURE__ */ x.jsx(
    "section",
    {
      title: l,
      style: u,
      onClick: S,
      className: O,
      children: /* @__PURE__ */ x.jsx(
        "textarea",
        {
          id: h,
          disabled: o,
          readOnly: i,
          ref: w,
          onFocus: W,
          onBlur: P,
          ...c
        }
      )
    }
  );
}
function L2(t) {
  const { className: e = "", ...n } = t, r = `arkynBreadcrumbContainer ${e}`;
  return /* @__PURE__ */ x.jsx("nav", { className: r, ...n });
}
function S2(t) {
  const { pathname: e } = tc(), {
    className: n = "",
    disabled: r = !1,
    children: o,
    to: i,
    ...a
  } = t, l = `arkynBreadcrumbLink ${e === i ? "active" : "inactive"} ${n}`;
  return r ? /* @__PURE__ */ x.jsxs("p", { className: l, children: [
    /* @__PURE__ */ x.jsx(ru, { size: 14, strokeWidth: 2.5 }),
    o
  ] }) : /* @__PURE__ */ x.jsxs(fw, { to: i, className: l, ...a, children: [
    /* @__PURE__ */ x.jsx(ru, { size: 14, strokeWidth: 2.5 }),
    o
  ] });
}
function J0(t = "") {
  const e = tc(), n = new URLSearchParams(e.search), r = t ? `${t}:` : "", o = (i) => {
    Object.entries(i).forEach(([a, s]) => {
      s === void 0 ? n.delete(`${r}${a}`) : n.set(`${r}${a}`, String(s));
    });
  };
  return {
    getParam: (i) => n.get(`${r}${i}`),
    getScopedSearch: (i) => {
      o(i);
      let a = n.toString();
      return a && (a = "?" + a), a;
    }
  };
}
function Qg(t, e) {
  return [...new Array(e - t)].map((n, r) => t + r + 1).filter((n) => n > 0);
}
function P2(t) {
  const {
    scope: e,
    totalCountRegisters: n,
    perPageKey: r = "per_page",
    pageKey: o = "page",
    siblingsCount: i = 2,
    currentPage: a = 1,
    registerPerPage: s = 20,
    ...l
  } = t, u = oy(), { getParam: c, getScopedSearch: d } = J0(e), f = Number(c("page")) || a, v = Number(c("per_page")) || s, h = Math.ceil(n / v), g = f > 1 ? Qg(f - 1 - i, f - 1) : [], p = f < h ? Qg(
    f,
    Math.min(f + i, h)
  ) : [];
  function w(b) {
    u(d({ page: b }));
  }
  return /* @__PURE__ */ x.jsxs("div", { className: "arkynPagination", ...l, children: [
    /* @__PURE__ */ x.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: f <= 1,
        onClick: () => w(f - 1),
        children: /* @__PURE__ */ x.jsx(cw, {})
      }
    ),
    f > 1 + i && /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
      /* @__PURE__ */ x.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => w(1),
          children: "1"
        }
      ),
      f > 2 + i && /* @__PURE__ */ x.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ x.jsx(Ed, {}) })
    ] }),
    g.length > 0 && g.map((b, k) => /* @__PURE__ */ x.jsx(
      "button",
      {
        onClick: () => w(b),
        className: "arkynPaginationPageButton",
        children: b
      },
      k
    )),
    /* @__PURE__ */ x.jsx("button", { className: "arkynPaginationCurrent", disabled: !0, children: f }),
    p.length > 0 && p.map((b, k) => /* @__PURE__ */ x.jsx(
      "button",
      {
        onClick: () => w(b),
        className: "arkynPaginationPageButton",
        children: b
      },
      k
    )),
    f + i < h && /* @__PURE__ */ x.jsxs(x.Fragment, { children: [
      f + 1 + i < h && /* @__PURE__ */ x.jsx("button", { disabled: !0, className: "arkynPaginationSpread", children: /* @__PURE__ */ x.jsx(Ed, {}) }),
      /* @__PURE__ */ x.jsx(
        "button",
        {
          className: "arkynPaginationPageButton",
          onClick: () => w(h),
          children: h
        }
      )
    ] }),
    /* @__PURE__ */ x.jsx(
      "button",
      {
        className: "arkynPaginationIconButton",
        disabled: f >= h,
        onClick: () => w(f + 1),
        children: /* @__PURE__ */ x.jsx(ru, {})
      }
    )
  ] });
}
const Q0 = ct({});
function k2(t) {
  const {
    isVisibled: e,
    makeInvisible: n,
    orientation: r = "left",
    children: o,
    className: i,
    ...a
  } = t, s = r === "left" ? "-100%" : "100%", u = `arkynDrawerContainer ${r} ${e ? "visibleTrue" : "visibleFalse"} ${i}`;
  return /* @__PURE__ */ x.jsx(Q0.Provider, { value: { makeInvisible: n }, children: /* @__PURE__ */ x.jsx(iy, { children: e && /* @__PURE__ */ x.jsxs("aside", { className: u.trim(), ...a, children: [
    /* @__PURE__ */ x.jsx(
      Go.div,
      {
        className: "arkynDrawerContainerOverlay",
        transition: { duration: 0.15, ease: "easeOut" },
        initial: { opacity: 0 },
        animate: { opacity: 1 },
        exit: { opacity: 0 },
        onClick: n
      }
    ),
    /* @__PURE__ */ x.jsx(
      Go.div,
      {
        className: "arkynDrawerContainerContent",
        transition: { ease: "easeOut", duration: 0.15 },
        initial: { transform: `translateX(${s})` },
        animate: { transform: "translateX(0px)" },
        exit: { transform: `translateX(${s})` },
        children: o
      }
    )
  ] }) }) });
}
function M2(t) {
  const {
    showCloseButton: e = !0,
    className: n,
    children: r,
    ...o
  } = t, { makeInvisible: i } = Ee(Q0), a = `arkynDrawerHeader ${n}`;
  return /* @__PURE__ */ x.jsxs("header", { className: a.trim(), ...o, children: [
    r,
    e && /* @__PURE__ */ x.jsx(
      "button",
      {
        className: "arkynDrawerHeaderCloseButton",
        type: "button",
        onClick: i,
        "aria-label": "Close drawer",
        children: /* @__PURE__ */ x.jsx(Qu, { size: 24 })
      }
    )
  ] });
}
function B2(t) {
  const { children: e, button: n, closeOnClick: r, orientation: o = "bottomLeft" } = t, [i, a] = B(!1), l = `arkynPopover ${o} ${i ? "visibleTrue" : "visibleFalse"}`;
  function u() {
    i || a(!0);
  }
  return /* @__PURE__ */ x.jsxs("div", { className: l, onClick: u, children: [
    n,
    /* @__PURE__ */ x.jsx(
      Go.div,
      {
        style: { visibility: i ? "visible" : "hidden" },
        transition: { ease: "easeOut", duration: 0 },
        initial: { opacity: 0 },
        animate: { opacity: i ? 1 : 0 },
        exit: { opacity: 0 },
        onClick: () => r && a(!1),
        className: "arkynPopoverContent",
        children: e
      }
    ),
    i && /* @__PURE__ */ x.jsx("div", { onClick: () => a(!1), className: "arkynPopoverOverlay" })
  ] });
}
function T2(t) {
  const { message: e, type: n } = t, r = `arkynToast ${n}}`;
  function o() {
    switch (n) {
      case "success":
        return /* @__PURE__ */ x.jsx(Jm, {});
      case "danger":
        return /* @__PURE__ */ x.jsx(Xm, {});
      default:
        return /* @__PURE__ */ x.jsx(Ym, {});
    }
  }
  return /* @__PURE__ */ x.jsxs("div", { className: r, children: [
    /* @__PURE__ */ x.jsxs("div", { children: [
      /* @__PURE__ */ x.jsx("div", { className: "bg" }),
      /* @__PURE__ */ x.jsx(o, {})
    ] }),
    /* @__PURE__ */ x.jsx("p", { children: /* @__PURE__ */ x.jsx("span", { children: e }) })
  ] });
}
var jt = {}, ud = {}, gi = {}, vi = {}, eC = "Expected a function", ev = NaN, oF = "[object Symbol]", iF = /^\s+|\s+$/g, aF = /^[-+]0x[0-9a-f]+$/i, sF = /^0b[01]+$/i, lF = /^0o[0-7]+$/i, uF = parseInt, cF = typeof ht == "object" && ht && ht.Object === Object && ht, dF = typeof self == "object" && self && self.Object === Object && self, fF = cF || dF || Function("return this")(), pF = Object.prototype, hF = pF.toString, gF = Math.max, vF = Math.min, zl = function() {
  return fF.Date.now();
};
function mF(t, e, n) {
  var r, o, i, a, s, l, u = 0, c = !1, d = !1, f = !0;
  if (typeof t != "function")
    throw new TypeError(eC);
  e = tv(e) || 0, Wa(n) && (c = !!n.leading, d = "maxWait" in n, i = d ? gF(tv(n.maxWait) || 0, e) : i, f = "trailing" in n ? !!n.trailing : f);
  function v(O) {
    var S = r, W = o;
    return r = o = void 0, u = O, a = t.apply(W, S), a;
  }
  function h(O) {
    return u = O, s = setTimeout(w, e), c ? v(O) : a;
  }
  function g(O) {
    var S = O - l, W = O - u, P = e - S;
    return d ? vF(P, i - W) : P;
  }
  function p(O) {
    var S = O - l, W = O - u;
    return l === void 0 || S >= e || S < 0 || d && W >= i;
  }
  function w() {
    var O = zl();
    if (p(O))
      return b(O);
    s = setTimeout(w, g(O));
  }
  function b(O) {
    return s = void 0, f && r ? v(O) : (r = o = void 0, a);
  }
  function k() {
    s !== void 0 && clearTimeout(s), u = 0, r = l = o = s = void 0;
  }
  function E() {
    return s === void 0 ? a : b(zl());
  }
  function m() {
    var O = zl(), S = p(O);
    if (r = arguments, o = this, l = O, S) {
      if (s === void 0)
        return h(l);
      if (d)
        return s = setTimeout(w, e), v(l);
    }
    return s === void 0 && (s = setTimeout(w, e)), a;
  }
  return m.cancel = k, m.flush = E, m;
}
function yF(t, e, n) {
  var r = !0, o = !0;
  if (typeof t != "function")
    throw new TypeError(eC);
  return Wa(n) && (r = "leading" in n ? !!n.leading : r, o = "trailing" in n ? !!n.trailing : o), mF(t, e, {
    leading: r,
    maxWait: e,
    trailing: o
  });
}
function Wa(t) {
  var e = typeof t;
  return !!t && (e == "object" || e == "function");
}
function bF(t) {
  return !!t && typeof t == "object";
}
function CF(t) {
  return typeof t == "symbol" || bF(t) && hF.call(t) == oF;
}
function tv(t) {
  if (typeof t == "number")
    return t;
  if (CF(t))
    return ev;
  if (Wa(t)) {
    var e = typeof t.valueOf == "function" ? t.valueOf() : t;
    t = Wa(e) ? e + "" : e;
  }
  if (typeof t != "string")
    return t === 0 ? t : +t;
  t = t.replace(iF, "");
  var n = sF.test(t);
  return n || lF.test(t) ? uF(t.slice(2), n ? 2 : 8) : aF.test(t) ? ev : +t;
}
var wF = yF, mi = {};
Object.defineProperty(mi, "__esModule", {
  value: !0
});
mi.addPassiveEventListener = function(e, n, r) {
  var o = r.name;
  o || (o = n, console.warn("Listener must be a named function.")), ha.has(n) || ha.set(n, /* @__PURE__ */ new Set());
  var i = ha.get(n);
  if (!i.has(o)) {
    var a = function() {
      var s = !1;
      try {
        var l = Object.defineProperty({}, "passive", {
          get: function() {
            s = !0;
          }
        });
        window.addEventListener("test", null, l);
      } catch {
      }
      return s;
    }();
    e.addEventListener(n, r, a ? { passive: !0 } : !1), i.add(o);
  }
};
mi.removePassiveEventListener = function(e, n, r) {
  e.removeEventListener(n, r), ha.get(n).delete(r.name || n);
};
var ha = /* @__PURE__ */ new Map();
Object.defineProperty(vi, "__esModule", {
  value: !0
});
var EF = wF, DF = xF(EF), OF = mi;
function xF(t) {
  return t && t.__esModule ? t : { default: t };
}
var LF = function(e) {
  var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 66;
  return (0, DF.default)(e, n);
}, Pt = {
  spyCallbacks: [],
  spySetState: [],
  scrollSpyContainers: [],
  mount: function(e, n) {
    if (e) {
      var r = LF(function(o) {
        Pt.scrollHandler(e);
      }, n);
      Pt.scrollSpyContainers.push(e), (0, OF.addPassiveEventListener)(e, "scroll", r);
    }
  },
  isMounted: function(e) {
    return Pt.scrollSpyContainers.indexOf(e) !== -1;
  },
  currentPositionX: function(e) {
    if (e === document) {
      var n = window.pageYOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageXOffset : r ? document.documentElement.scrollLeft : document.body.scrollLeft;
    } else
      return e.scrollLeft;
  },
  currentPositionY: function(e) {
    if (e === document) {
      var n = window.pageXOffset !== void 0, r = (document.compatMode || "") === "CSS1Compat";
      return n ? window.pageYOffset : r ? document.documentElement.scrollTop : document.body.scrollTop;
    } else
      return e.scrollTop;
  },
  scrollHandler: function(e) {
    var n = Pt.scrollSpyContainers[Pt.scrollSpyContainers.indexOf(e)].spyCallbacks || [];
    n.forEach(function(r) {
      return r(Pt.currentPositionX(e), Pt.currentPositionY(e));
    });
  },
  addStateHandler: function(e) {
    Pt.spySetState.push(e);
  },
  addSpyHandler: function(e, n) {
    var r = Pt.scrollSpyContainers[Pt.scrollSpyContainers.indexOf(n)];
    r.spyCallbacks || (r.spyCallbacks = []), r.spyCallbacks.push(e), e(Pt.currentPositionX(n), Pt.currentPositionY(n));
  },
  updateStates: function() {
    Pt.spySetState.forEach(function(e) {
      return e();
    });
  },
  unmount: function(e, n) {
    Pt.scrollSpyContainers.forEach(function(r) {
      return r.spyCallbacks && r.spyCallbacks.length && r.spyCallbacks.indexOf(n) > -1 && r.spyCallbacks.splice(r.spyCallbacks.indexOf(n), 1);
    }), Pt.spySetState && Pt.spySetState.length && Pt.spySetState.indexOf(e) > -1 && Pt.spySetState.splice(Pt.spySetState.indexOf(e), 1), document.removeEventListener("scroll", Pt.scrollHandler);
  },
  update: function() {
    return Pt.scrollSpyContainers.forEach(function(e) {
      return Pt.scrollHandler(e);
    });
  }
};
vi.default = Pt;
var vo = {}, yi = {};
Object.defineProperty(yi, "__esModule", {
  value: !0
});
var SF = function(e, n) {
  var r = e.indexOf("#") === 0 ? e.substring(1) : e, o = r ? "#" + r : "", i = window && window.location, a = o ? i.pathname + i.search + o : i.pathname + i.search;
  n ? history.pushState(history.state, "", a) : history.replaceState(history.state, "", a);
}, PF = function() {
  return window.location.hash.replace(/^#/, "");
}, kF = function(e) {
  return function(n) {
    return e.contains ? e != n && e.contains(n) : !!(e.compareDocumentPosition(n) & 16);
  };
}, MF = function(e) {
  return getComputedStyle(e).position !== "static";
}, Ul = function(e, n) {
  for (var r = e.offsetTop, o = e.offsetParent; o && !n(o); )
    r += o.offsetTop, o = o.offsetParent;
  return { offsetTop: r, offsetParent: o };
}, BF = function(e, n, r) {
  if (r)
    return e === document ? n.getBoundingClientRect().left + (window.scrollX || window.pageXOffset) : getComputedStyle(e).position !== "static" ? n.offsetLeft : n.offsetLeft - e.offsetLeft;
  if (e === document)
    return n.getBoundingClientRect().top + (window.scrollY || window.pageYOffset);
  if (MF(e)) {
    if (n.offsetParent !== e) {
      var o = function(c) {
        return c === e || c === document;
      }, i = Ul(n, o), a = i.offsetTop, s = i.offsetParent;
      if (s !== e)
        throw new Error("Seems containerElement is not an ancestor of the Element");
      return a;
    }
    return n.offsetTop;
  }
  if (n.offsetParent === e.offsetParent)
    return n.offsetTop - e.offsetTop;
  var l = function(c) {
    return c === document;
  };
  return Ul(n, l).offsetTop - Ul(e, l).offsetTop;
};
yi.default = {
  updateHash: SF,
  getHash: PF,
  filterElementInContainer: kF,
  scrollOffset: BF
};
var Us = {}, cd = {};
Object.defineProperty(cd, "__esModule", {
  value: !0
});
cd.default = {
  /*
   * https://github.com/oblador/angular-scroll (duScrollDefaultEasing)
   */
  defaultEasing: function(e) {
    return e < 0.5 ? Math.pow(e * 2, 2) / 2 : 1 - Math.pow((1 - e) * 2, 2) / 2;
  },
  /*
   * https://gist.github.com/gre/1650294
   */
  // no easing, no acceleration
  linear: function(e) {
    return e;
  },
  // accelerating from zero velocity
  easeInQuad: function(e) {
    return e * e;
  },
  // decelerating to zero velocity
  easeOutQuad: function(e) {
    return e * (2 - e);
  },
  // acceleration until halfway, then deceleration
  easeInOutQuad: function(e) {
    return e < 0.5 ? 2 * e * e : -1 + (4 - 2 * e) * e;
  },
  // accelerating from zero velocity 
  easeInCubic: function(e) {
    return e * e * e;
  },
  // decelerating to zero velocity π
  easeOutCubic: function(e) {
    return --e * e * e + 1;
  },
  // acceleration until halfway, then deceleration 
  easeInOutCubic: function(e) {
    return e < 0.5 ? 4 * e * e * e : (e - 1) * (2 * e - 2) * (2 * e - 2) + 1;
  },
  // accelerating from zero velocity 
  easeInQuart: function(e) {
    return e * e * e * e;
  },
  // decelerating to zero velocity 
  easeOutQuart: function(e) {
    return 1 - --e * e * e * e;
  },
  // acceleration until halfway, then deceleration
  easeInOutQuart: function(e) {
    return e < 0.5 ? 8 * e * e * e * e : 1 - 8 * --e * e * e * e;
  },
  // accelerating from zero velocity
  easeInQuint: function(e) {
    return e * e * e * e * e;
  },
  // decelerating to zero velocity
  easeOutQuint: function(e) {
    return 1 + --e * e * e * e * e;
  },
  // acceleration until halfway, then deceleration 
  easeInOutQuint: function(e) {
    return e < 0.5 ? 16 * e * e * e * e * e : 1 + 16 * --e * e * e * e * e;
  }
};
var dd = {};
Object.defineProperty(dd, "__esModule", {
  value: !0
});
var TF = mi, AF = ["mousedown", "mousewheel", "touchmove", "keydown"];
dd.default = {
  subscribe: function(e) {
    return typeof document < "u" && AF.forEach(function(n) {
      return (0, TF.addPassiveEventListener)(document, n, e);
    });
  }
};
var bi = {};
Object.defineProperty(bi, "__esModule", {
  value: !0
});
var Wu = {
  registered: {},
  scrollEvent: {
    register: function(e, n) {
      Wu.registered[e] = n;
    },
    remove: function(e) {
      Wu.registered[e] = null;
    }
  }
};
bi.default = Wu;
Object.defineProperty(Us, "__esModule", {
  value: !0
});
var jF = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
}, FF = yi;
Ws(FF);
var _F = cd, nv = Ws(_F), IF = dd, RF = Ws(IF), NF = bi, $n = Ws(NF);
function Ws(t) {
  return t && t.__esModule ? t : { default: t };
}
var tC = function(e) {
  return nv.default[e.smooth] || nv.default.defaultEasing;
}, $F = function(e) {
  return typeof e == "function" ? e : function() {
    return e;
  };
}, zF = function() {
  if (typeof window < "u")
    return window.requestAnimationFrame || window.webkitRequestAnimationFrame;
}, Hu = function() {
  return zF() || function(t, e, n) {
    window.setTimeout(t, n || 1e3 / 60, (/* @__PURE__ */ new Date()).getTime());
  };
}(), nC = function() {
  return {
    currentPosition: 0,
    startPosition: 0,
    targetPosition: 0,
    progress: 0,
    duration: 0,
    cancel: !1,
    target: null,
    containerElement: null,
    to: null,
    start: null,
    delta: null,
    percent: null,
    delayTimeout: null
  };
}, rC = function(e) {
  var n = e.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollLeft;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageXOffset : o ? document.documentElement.scrollLeft : document.body.scrollLeft;
}, oC = function(e) {
  var n = e.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollTop;
  var r = window.pageXOffset !== void 0, o = (document.compatMode || "") === "CSS1Compat";
  return r ? window.pageYOffset : o ? document.documentElement.scrollTop : document.body.scrollTop;
}, UF = function(e) {
  var n = e.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollWidth - n.offsetWidth;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollWidth, r.offsetWidth, o.clientWidth, o.scrollWidth, o.offsetWidth);
}, WF = function(e) {
  var n = e.data.containerElement;
  if (n && n !== document && n !== document.body)
    return n.scrollHeight - n.offsetHeight;
  var r = document.body, o = document.documentElement;
  return Math.max(r.scrollHeight, r.offsetHeight, o.clientHeight, o.scrollHeight, o.offsetHeight);
}, HF = function t(e, n, r) {
  var o = n.data;
  if (!n.ignoreCancelEvents && o.cancel) {
    $n.default.registered.end && $n.default.registered.end(o.to, o.target, o.currentPositionY);
    return;
  }
  if (o.delta = Math.round(o.targetPosition - o.startPosition), o.start === null && (o.start = r), o.progress = r - o.start, o.percent = o.progress >= o.duration ? 1 : e(o.progress / o.duration), o.currentPosition = o.startPosition + Math.ceil(o.delta * o.percent), o.containerElement && o.containerElement !== document && o.containerElement !== document.body ? n.horizontal ? o.containerElement.scrollLeft = o.currentPosition : o.containerElement.scrollTop = o.currentPosition : n.horizontal ? window.scrollTo(o.currentPosition, 0) : window.scrollTo(0, o.currentPosition), o.percent < 1) {
    var i = t.bind(null, e, n);
    Hu.call(window, i);
    return;
  }
  $n.default.registered.end && $n.default.registered.end(o.to, o.target, o.currentPosition);
}, fd = function(e) {
  e.data.containerElement = e ? e.containerId ? document.getElementById(e.containerId) : e.container && e.container.nodeType ? e.container : document : null;
}, Ci = function(e, n, r, o) {
  n.data = n.data || nC(), window.clearTimeout(n.data.delayTimeout);
  var i = function() {
    n.data.cancel = !0;
  };
  if (RF.default.subscribe(i), fd(n), n.data.start = null, n.data.cancel = !1, n.data.startPosition = n.horizontal ? rC(n) : oC(n), n.data.targetPosition = n.absolute ? e : e + n.data.startPosition, n.data.startPosition === n.data.targetPosition) {
    $n.default.registered.end && $n.default.registered.end(n.data.to, n.data.target, n.data.currentPosition);
    return;
  }
  n.data.delta = Math.round(n.data.targetPosition - n.data.startPosition), n.data.duration = $F(n.duration)(n.data.delta), n.data.duration = isNaN(parseFloat(n.data.duration)) ? 1e3 : parseFloat(n.data.duration), n.data.to = r, n.data.target = o;
  var a = tC(n), s = HF.bind(null, a, n);
  if (n && n.delay > 0) {
    n.data.delayTimeout = window.setTimeout(function() {
      $n.default.registered.begin && $n.default.registered.begin(n.data.to, n.data.target), Hu.call(window, s);
    }, n.delay);
    return;
  }
  $n.default.registered.begin && $n.default.registered.begin(n.data.to, n.data.target), Hu.call(window, s);
}, Hs = function(e) {
  return e = jF({}, e), e.data = e.data || nC(), e.absolute = !0, e;
}, VF = function(e) {
  Ci(0, Hs(e));
}, qF = function(e, n) {
  Ci(e, Hs(n));
}, GF = function(e) {
  e = Hs(e), fd(e), Ci(e.horizontal ? UF(e) : WF(e), e);
}, ZF = function(e, n) {
  n = Hs(n), fd(n);
  var r = n.horizontal ? rC(n) : oC(n);
  Ci(e + r, n);
};
Us.default = {
  animateTopScroll: Ci,
  getAnimationType: tC,
  scrollToTop: VF,
  scrollToBottom: GF,
  scrollTo: qF,
  scrollMore: ZF
};
Object.defineProperty(vo, "__esModule", {
  value: !0
});
var KF = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
}, YF = yi, XF = pd(YF), JF = Us, QF = pd(JF), e_ = bi, Qi = pd(e_);
function pd(t) {
  return t && t.__esModule ? t : { default: t };
}
var ea = {}, rv = void 0;
vo.default = {
  unmount: function() {
    ea = {};
  },
  register: function(e, n) {
    ea[e] = n;
  },
  unregister: function(e) {
    delete ea[e];
  },
  get: function(e) {
    return ea[e] || document.getElementById(e) || document.getElementsByName(e)[0] || document.getElementsByClassName(e)[0];
  },
  setActiveLink: function(e) {
    return rv = e;
  },
  getActiveLink: function() {
    return rv;
  },
  scrollTo: function(e, n) {
    var r = this.get(e);
    if (!r) {
      console.warn("target Element not found");
      return;
    }
    n = KF({}, n, { absolute: !1 });
    var o = n.containerId, i = n.container, a = void 0;
    o ? a = document.getElementById(o) : i && i.nodeType ? a = i : a = document, n.absolute = !0;
    var s = n.horizontal, l = XF.default.scrollOffset(a, r, s) + (n.offset || 0);
    if (!n.smooth) {
      Qi.default.registered.begin && Qi.default.registered.begin(e, r), a === document ? n.horizontal ? window.scrollTo(l, 0) : window.scrollTo(0, l) : a.scrollTop = l, Qi.default.registered.end && Qi.default.registered.end(e, r);
      return;
    }
    QF.default.animateTopScroll(l, n, e, r);
  }
};
var Vu = { exports: {} }, ta = { exports: {} }, rt = {};
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ov;
function t_() {
  if (ov) return rt;
  ov = 1;
  var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, o = t ? Symbol.for("react.strict_mode") : 60108, i = t ? Symbol.for("react.profiler") : 60114, a = t ? Symbol.for("react.provider") : 60109, s = t ? Symbol.for("react.context") : 60110, l = t ? Symbol.for("react.async_mode") : 60111, u = t ? Symbol.for("react.concurrent_mode") : 60111, c = t ? Symbol.for("react.forward_ref") : 60112, d = t ? Symbol.for("react.suspense") : 60113, f = t ? Symbol.for("react.suspense_list") : 60120, v = t ? Symbol.for("react.memo") : 60115, h = t ? Symbol.for("react.lazy") : 60116, g = t ? Symbol.for("react.block") : 60121, p = t ? Symbol.for("react.fundamental") : 60117, w = t ? Symbol.for("react.responder") : 60118, b = t ? Symbol.for("react.scope") : 60119;
  function k(m) {
    if (typeof m == "object" && m !== null) {
      var O = m.$$typeof;
      switch (O) {
        case e:
          switch (m = m.type, m) {
            case l:
            case u:
            case r:
            case i:
            case o:
            case d:
              return m;
            default:
              switch (m = m && m.$$typeof, m) {
                case s:
                case c:
                case h:
                case v:
                case a:
                  return m;
                default:
                  return O;
              }
          }
        case n:
          return O;
      }
    }
  }
  function E(m) {
    return k(m) === u;
  }
  return rt.AsyncMode = l, rt.ConcurrentMode = u, rt.ContextConsumer = s, rt.ContextProvider = a, rt.Element = e, rt.ForwardRef = c, rt.Fragment = r, rt.Lazy = h, rt.Memo = v, rt.Portal = n, rt.Profiler = i, rt.StrictMode = o, rt.Suspense = d, rt.isAsyncMode = function(m) {
    return E(m) || k(m) === l;
  }, rt.isConcurrentMode = E, rt.isContextConsumer = function(m) {
    return k(m) === s;
  }, rt.isContextProvider = function(m) {
    return k(m) === a;
  }, rt.isElement = function(m) {
    return typeof m == "object" && m !== null && m.$$typeof === e;
  }, rt.isForwardRef = function(m) {
    return k(m) === c;
  }, rt.isFragment = function(m) {
    return k(m) === r;
  }, rt.isLazy = function(m) {
    return k(m) === h;
  }, rt.isMemo = function(m) {
    return k(m) === v;
  }, rt.isPortal = function(m) {
    return k(m) === n;
  }, rt.isProfiler = function(m) {
    return k(m) === i;
  }, rt.isStrictMode = function(m) {
    return k(m) === o;
  }, rt.isSuspense = function(m) {
    return k(m) === d;
  }, rt.isValidElementType = function(m) {
    return typeof m == "string" || typeof m == "function" || m === r || m === u || m === i || m === o || m === d || m === f || typeof m == "object" && m !== null && (m.$$typeof === h || m.$$typeof === v || m.$$typeof === a || m.$$typeof === s || m.$$typeof === c || m.$$typeof === p || m.$$typeof === w || m.$$typeof === b || m.$$typeof === g);
  }, rt.typeOf = k, rt;
}
var ot = {};
/** @license React v16.13.1
 * react-is.development.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var iv;
function n_() {
  return iv || (iv = 1, process.env.NODE_ENV !== "production" && function() {
    var t = typeof Symbol == "function" && Symbol.for, e = t ? Symbol.for("react.element") : 60103, n = t ? Symbol.for("react.portal") : 60106, r = t ? Symbol.for("react.fragment") : 60107, o = t ? Symbol.for("react.strict_mode") : 60108, i = t ? Symbol.for("react.profiler") : 60114, a = t ? Symbol.for("react.provider") : 60109, s = t ? Symbol.for("react.context") : 60110, l = t ? Symbol.for("react.async_mode") : 60111, u = t ? Symbol.for("react.concurrent_mode") : 60111, c = t ? Symbol.for("react.forward_ref") : 60112, d = t ? Symbol.for("react.suspense") : 60113, f = t ? Symbol.for("react.suspense_list") : 60120, v = t ? Symbol.for("react.memo") : 60115, h = t ? Symbol.for("react.lazy") : 60116, g = t ? Symbol.for("react.block") : 60121, p = t ? Symbol.for("react.fundamental") : 60117, w = t ? Symbol.for("react.responder") : 60118, b = t ? Symbol.for("react.scope") : 60119;
    function k(Z) {
      return typeof Z == "string" || typeof Z == "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
      Z === r || Z === u || Z === i || Z === o || Z === d || Z === f || typeof Z == "object" && Z !== null && (Z.$$typeof === h || Z.$$typeof === v || Z.$$typeof === a || Z.$$typeof === s || Z.$$typeof === c || Z.$$typeof === p || Z.$$typeof === w || Z.$$typeof === b || Z.$$typeof === g);
    }
    function E(Z) {
      if (typeof Z == "object" && Z !== null) {
        var pe = Z.$$typeof;
        switch (pe) {
          case e:
            var he = Z.type;
            switch (he) {
              case l:
              case u:
              case r:
              case i:
              case o:
              case d:
                return he;
              default:
                var le = he && he.$$typeof;
                switch (le) {
                  case s:
                  case c:
                  case h:
                  case v:
                  case a:
                    return le;
                  default:
                    return pe;
                }
            }
          case n:
            return pe;
        }
      }
    }
    var m = l, O = u, S = s, W = a, P = e, $ = c, j = r, _ = h, I = v, R = n, V = i, J = o, G = d, te = !1;
    function Q(Z) {
      return te || (te = !0, console.warn("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.")), T(Z) || E(Z) === l;
    }
    function T(Z) {
      return E(Z) === u;
    }
    function N(Z) {
      return E(Z) === s;
    }
    function Y(Z) {
      return E(Z) === a;
    }
    function F(Z) {
      return typeof Z == "object" && Z !== null && Z.$$typeof === e;
    }
    function X(Z) {
      return E(Z) === c;
    }
    function L(Z) {
      return E(Z) === r;
    }
    function M(Z) {
      return E(Z) === h;
    }
    function z(Z) {
      return E(Z) === v;
    }
    function A(Z) {
      return E(Z) === n;
    }
    function U(Z) {
      return E(Z) === i;
    }
    function H(Z) {
      return E(Z) === o;
    }
    function ee(Z) {
      return E(Z) === d;
    }
    ot.AsyncMode = m, ot.ConcurrentMode = O, ot.ContextConsumer = S, ot.ContextProvider = W, ot.Element = P, ot.ForwardRef = $, ot.Fragment = j, ot.Lazy = _, ot.Memo = I, ot.Portal = R, ot.Profiler = V, ot.StrictMode = J, ot.Suspense = G, ot.isAsyncMode = Q, ot.isConcurrentMode = T, ot.isContextConsumer = N, ot.isContextProvider = Y, ot.isElement = F, ot.isForwardRef = X, ot.isFragment = L, ot.isLazy = M, ot.isMemo = z, ot.isPortal = A, ot.isProfiler = U, ot.isStrictMode = H, ot.isSuspense = ee, ot.isValidElementType = k, ot.typeOf = E;
  }()), ot;
}
var av;
function iC() {
  return av || (av = 1, process.env.NODE_ENV === "production" ? ta.exports = t_() : ta.exports = n_()), ta.exports;
}
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/
var Wl, sv;
function r_() {
  if (sv) return Wl;
  sv = 1;
  var t = Object.getOwnPropertySymbols, e = Object.prototype.hasOwnProperty, n = Object.prototype.propertyIsEnumerable;
  function r(i) {
    if (i == null)
      throw new TypeError("Object.assign cannot be called with null or undefined");
    return Object(i);
  }
  function o() {
    try {
      if (!Object.assign)
        return !1;
      var i = new String("abc");
      if (i[5] = "de", Object.getOwnPropertyNames(i)[0] === "5")
        return !1;
      for (var a = {}, s = 0; s < 10; s++)
        a["_" + String.fromCharCode(s)] = s;
      var l = Object.getOwnPropertyNames(a).map(function(c) {
        return a[c];
      });
      if (l.join("") !== "0123456789")
        return !1;
      var u = {};
      return "abcdefghijklmnopqrst".split("").forEach(function(c) {
        u[c] = c;
      }), Object.keys(Object.assign({}, u)).join("") === "abcdefghijklmnopqrst";
    } catch {
      return !1;
    }
  }
  return Wl = o() ? Object.assign : function(i, a) {
    for (var s, l = r(i), u, c = 1; c < arguments.length; c++) {
      s = Object(arguments[c]);
      for (var d in s)
        e.call(s, d) && (l[d] = s[d]);
      if (t) {
        u = t(s);
        for (var f = 0; f < u.length; f++)
          n.call(s, u[f]) && (l[u[f]] = s[u[f]]);
      }
    }
    return l;
  }, Wl;
}
var Hl, lv;
function hd() {
  if (lv) return Hl;
  lv = 1;
  var t = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
  return Hl = t, Hl;
}
var Vl, uv;
function aC() {
  return uv || (uv = 1, Vl = Function.call.bind(Object.prototype.hasOwnProperty)), Vl;
}
var ql, cv;
function o_() {
  if (cv) return ql;
  cv = 1;
  var t = function() {
  };
  if (process.env.NODE_ENV !== "production") {
    var e = hd(), n = {}, r = aC();
    t = function(i) {
      var a = "Warning: " + i;
      typeof console < "u" && console.error(a);
      try {
        throw new Error(a);
      } catch {
      }
    };
  }
  function o(i, a, s, l, u) {
    if (process.env.NODE_ENV !== "production") {
      for (var c in i)
        if (r(i, c)) {
          var d;
          try {
            if (typeof i[c] != "function") {
              var f = Error(
                (l || "React class") + ": " + s + " type `" + c + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof i[c] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
              );
              throw f.name = "Invariant Violation", f;
            }
            d = i[c](a, c, l, s, null, e);
          } catch (h) {
            d = h;
          }
          if (d && !(d instanceof Error) && t(
            (l || "React class") + ": type specification of " + s + " `" + c + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof d + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
          ), d instanceof Error && !(d.message in n)) {
            n[d.message] = !0;
            var v = u ? u() : "";
            t(
              "Failed " + s + " type: " + d.message + (v ?? "")
            );
          }
        }
    }
  }
  return o.resetWarningCache = function() {
    process.env.NODE_ENV !== "production" && (n = {});
  }, ql = o, ql;
}
var Gl, dv;
function i_() {
  if (dv) return Gl;
  dv = 1;
  var t = iC(), e = r_(), n = hd(), r = aC(), o = o_(), i = function() {
  };
  process.env.NODE_ENV !== "production" && (i = function(s) {
    var l = "Warning: " + s;
    typeof console < "u" && console.error(l);
    try {
      throw new Error(l);
    } catch {
    }
  });
  function a() {
    return null;
  }
  return Gl = function(s, l) {
    var u = typeof Symbol == "function" && Symbol.iterator, c = "@@iterator";
    function d(T) {
      var N = T && (u && T[u] || T[c]);
      if (typeof N == "function")
        return N;
    }
    var f = "<<anonymous>>", v = {
      array: w("array"),
      bigint: w("bigint"),
      bool: w("boolean"),
      func: w("function"),
      number: w("number"),
      object: w("object"),
      string: w("string"),
      symbol: w("symbol"),
      any: b(),
      arrayOf: k,
      element: E(),
      elementType: m(),
      instanceOf: O,
      node: $(),
      objectOf: W,
      oneOf: S,
      oneOfType: P,
      shape: _,
      exact: I
    };
    function h(T, N) {
      return T === N ? T !== 0 || 1 / T === 1 / N : T !== T && N !== N;
    }
    function g(T, N) {
      this.message = T, this.data = N && typeof N == "object" ? N : {}, this.stack = "";
    }
    g.prototype = Error.prototype;
    function p(T) {
      if (process.env.NODE_ENV !== "production")
        var N = {}, Y = 0;
      function F(L, M, z, A, U, H, ee) {
        if (A = A || f, H = H || z, ee !== n) {
          if (l) {
            var Z = new Error(
              "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
            );
            throw Z.name = "Invariant Violation", Z;
          } else if (process.env.NODE_ENV !== "production" && typeof console < "u") {
            var pe = A + ":" + z;
            !N[pe] && // Avoid spamming the console because they are often not actionable except for lib authors
            Y < 3 && (i(
              "You are manually calling a React.PropTypes validation function for the `" + H + "` prop on `" + A + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
            ), N[pe] = !0, Y++);
          }
        }
        return M[z] == null ? L ? M[z] === null ? new g("The " + U + " `" + H + "` is marked as required " + ("in `" + A + "`, but its value is `null`.")) : new g("The " + U + " `" + H + "` is marked as required in " + ("`" + A + "`, but its value is `undefined`.")) : null : T(M, z, A, U, H);
      }
      var X = F.bind(null, !1);
      return X.isRequired = F.bind(null, !0), X;
    }
    function w(T) {
      function N(Y, F, X, L, M, z) {
        var A = Y[F], U = J(A);
        if (U !== T) {
          var H = G(A);
          return new g(
            "Invalid " + L + " `" + M + "` of type " + ("`" + H + "` supplied to `" + X + "`, expected ") + ("`" + T + "`."),
            { expectedType: T }
          );
        }
        return null;
      }
      return p(N);
    }
    function b() {
      return p(a);
    }
    function k(T) {
      function N(Y, F, X, L, M) {
        if (typeof T != "function")
          return new g("Property `" + M + "` of component `" + X + "` has invalid PropType notation inside arrayOf.");
        var z = Y[F];
        if (!Array.isArray(z)) {
          var A = J(z);
          return new g("Invalid " + L + " `" + M + "` of type " + ("`" + A + "` supplied to `" + X + "`, expected an array."));
        }
        for (var U = 0; U < z.length; U++) {
          var H = T(z, U, X, L, M + "[" + U + "]", n);
          if (H instanceof Error)
            return H;
        }
        return null;
      }
      return p(N);
    }
    function E() {
      function T(N, Y, F, X, L) {
        var M = N[Y];
        if (!s(M)) {
          var z = J(M);
          return new g("Invalid " + X + " `" + L + "` of type " + ("`" + z + "` supplied to `" + F + "`, expected a single ReactElement."));
        }
        return null;
      }
      return p(T);
    }
    function m() {
      function T(N, Y, F, X, L) {
        var M = N[Y];
        if (!t.isValidElementType(M)) {
          var z = J(M);
          return new g("Invalid " + X + " `" + L + "` of type " + ("`" + z + "` supplied to `" + F + "`, expected a single ReactElement type."));
        }
        return null;
      }
      return p(T);
    }
    function O(T) {
      function N(Y, F, X, L, M) {
        if (!(Y[F] instanceof T)) {
          var z = T.name || f, A = Q(Y[F]);
          return new g("Invalid " + L + " `" + M + "` of type " + ("`" + A + "` supplied to `" + X + "`, expected ") + ("instance of `" + z + "`."));
        }
        return null;
      }
      return p(N);
    }
    function S(T) {
      if (!Array.isArray(T))
        return process.env.NODE_ENV !== "production" && (arguments.length > 1 ? i(
          "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
        ) : i("Invalid argument supplied to oneOf, expected an array.")), a;
      function N(Y, F, X, L, M) {
        for (var z = Y[F], A = 0; A < T.length; A++)
          if (h(z, T[A]))
            return null;
        var U = JSON.stringify(T, function(ee, Z) {
          var pe = G(Z);
          return pe === "symbol" ? String(Z) : Z;
        });
        return new g("Invalid " + L + " `" + M + "` of value `" + String(z) + "` " + ("supplied to `" + X + "`, expected one of " + U + "."));
      }
      return p(N);
    }
    function W(T) {
      function N(Y, F, X, L, M) {
        if (typeof T != "function")
          return new g("Property `" + M + "` of component `" + X + "` has invalid PropType notation inside objectOf.");
        var z = Y[F], A = J(z);
        if (A !== "object")
          return new g("Invalid " + L + " `" + M + "` of type " + ("`" + A + "` supplied to `" + X + "`, expected an object."));
        for (var U in z)
          if (r(z, U)) {
            var H = T(z, U, X, L, M + "." + U, n);
            if (H instanceof Error)
              return H;
          }
        return null;
      }
      return p(N);
    }
    function P(T) {
      if (!Array.isArray(T))
        return process.env.NODE_ENV !== "production" && i("Invalid argument supplied to oneOfType, expected an instance of array."), a;
      for (var N = 0; N < T.length; N++) {
        var Y = T[N];
        if (typeof Y != "function")
          return i(
            "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + te(Y) + " at index " + N + "."
          ), a;
      }
      function F(X, L, M, z, A) {
        for (var U = [], H = 0; H < T.length; H++) {
          var ee = T[H], Z = ee(X, L, M, z, A, n);
          if (Z == null)
            return null;
          Z.data && r(Z.data, "expectedType") && U.push(Z.data.expectedType);
        }
        var pe = U.length > 0 ? ", expected one of type [" + U.join(", ") + "]" : "";
        return new g("Invalid " + z + " `" + A + "` supplied to " + ("`" + M + "`" + pe + "."));
      }
      return p(F);
    }
    function $() {
      function T(N, Y, F, X, L) {
        return R(N[Y]) ? null : new g("Invalid " + X + " `" + L + "` supplied to " + ("`" + F + "`, expected a ReactNode."));
      }
      return p(T);
    }
    function j(T, N, Y, F, X) {
      return new g(
        (T || "React class") + ": " + N + " type `" + Y + "." + F + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + X + "`."
      );
    }
    function _(T) {
      function N(Y, F, X, L, M) {
        var z = Y[F], A = J(z);
        if (A !== "object")
          return new g("Invalid " + L + " `" + M + "` of type `" + A + "` " + ("supplied to `" + X + "`, expected `object`."));
        for (var U in T) {
          var H = T[U];
          if (typeof H != "function")
            return j(X, L, M, U, G(H));
          var ee = H(z, U, X, L, M + "." + U, n);
          if (ee)
            return ee;
        }
        return null;
      }
      return p(N);
    }
    function I(T) {
      function N(Y, F, X, L, M) {
        var z = Y[F], A = J(z);
        if (A !== "object")
          return new g("Invalid " + L + " `" + M + "` of type `" + A + "` " + ("supplied to `" + X + "`, expected `object`."));
        var U = e({}, Y[F], T);
        for (var H in U) {
          var ee = T[H];
          if (r(T, H) && typeof ee != "function")
            return j(X, L, M, H, G(ee));
          if (!ee)
            return new g(
              "Invalid " + L + " `" + M + "` key `" + H + "` supplied to `" + X + "`.\nBad object: " + JSON.stringify(Y[F], null, "  ") + `
Valid keys: ` + JSON.stringify(Object.keys(T), null, "  ")
            );
          var Z = ee(z, H, X, L, M + "." + H, n);
          if (Z)
            return Z;
        }
        return null;
      }
      return p(N);
    }
    function R(T) {
      switch (typeof T) {
        case "number":
        case "string":
        case "undefined":
          return !0;
        case "boolean":
          return !T;
        case "object":
          if (Array.isArray(T))
            return T.every(R);
          if (T === null || s(T))
            return !0;
          var N = d(T);
          if (N) {
            var Y = N.call(T), F;
            if (N !== T.entries) {
              for (; !(F = Y.next()).done; )
                if (!R(F.value))
                  return !1;
            } else
              for (; !(F = Y.next()).done; ) {
                var X = F.value;
                if (X && !R(X[1]))
                  return !1;
              }
          } else
            return !1;
          return !0;
        default:
          return !1;
      }
    }
    function V(T, N) {
      return T === "symbol" ? !0 : N ? N["@@toStringTag"] === "Symbol" || typeof Symbol == "function" && N instanceof Symbol : !1;
    }
    function J(T) {
      var N = typeof T;
      return Array.isArray(T) ? "array" : T instanceof RegExp ? "object" : V(N, T) ? "symbol" : N;
    }
    function G(T) {
      if (typeof T > "u" || T === null)
        return "" + T;
      var N = J(T);
      if (N === "object") {
        if (T instanceof Date)
          return "date";
        if (T instanceof RegExp)
          return "regexp";
      }
      return N;
    }
    function te(T) {
      var N = G(T);
      switch (N) {
        case "array":
        case "object":
          return "an " + N;
        case "boolean":
        case "date":
        case "regexp":
          return "a " + N;
        default:
          return N;
      }
    }
    function Q(T) {
      return !T.constructor || !T.constructor.name ? f : T.constructor.name;
    }
    return v.checkPropTypes = o, v.resetWarningCache = o.resetWarningCache, v.PropTypes = v, v;
  }, Gl;
}
var Zl, fv;
function a_() {
  if (fv) return Zl;
  fv = 1;
  var t = hd();
  function e() {
  }
  function n() {
  }
  return n.resetWarningCache = e, Zl = function() {
    function r(a, s, l, u, c, d) {
      if (d !== t) {
        var f = new Error(
          "Calling PropTypes validators directly is not supported by the `prop-types` package. Use PropTypes.checkPropTypes() to call them. Read more at http://fb.me/use-check-prop-types"
        );
        throw f.name = "Invariant Violation", f;
      }
    }
    r.isRequired = r;
    function o() {
      return r;
    }
    var i = {
      array: r,
      bigint: r,
      bool: r,
      func: r,
      number: r,
      object: r,
      string: r,
      symbol: r,
      any: r,
      arrayOf: o,
      element: r,
      elementType: r,
      instanceOf: o,
      node: r,
      objectOf: o,
      oneOf: o,
      oneOfType: o,
      shape: o,
      exact: o,
      checkPropTypes: n,
      resetWarningCache: e
    };
    return i.PropTypes = i, i;
  }, Zl;
}
if (process.env.NODE_ENV !== "production") {
  var s_ = iC(), l_ = !0;
  Vu.exports = i_()(s_.isElement, l_);
} else
  Vu.exports = a_()();
var Vs = Vu.exports, qs = {};
Object.defineProperty(qs, "__esModule", {
  value: !0
});
var u_ = yi, Kl = c_(u_);
function c_(t) {
  return t && t.__esModule ? t : { default: t };
}
var d_ = {
  mountFlag: !1,
  initialized: !1,
  scroller: null,
  containers: {},
  mount: function(e) {
    this.scroller = e, this.handleHashChange = this.handleHashChange.bind(this), window.addEventListener("hashchange", this.handleHashChange), this.initStateFromHash(), this.mountFlag = !0;
  },
  mapContainer: function(e, n) {
    this.containers[e] = n;
  },
  isMounted: function() {
    return this.mountFlag;
  },
  isInitialized: function() {
    return this.initialized;
  },
  initStateFromHash: function() {
    var e = this, n = this.getHash();
    n ? window.setTimeout(function() {
      e.scrollTo(n, !0), e.initialized = !0;
    }, 10) : this.initialized = !0;
  },
  scrollTo: function(e, n) {
    var r = this.scroller, o = r.get(e);
    if (o && (n || e !== r.getActiveLink())) {
      var i = this.containers[e] || document;
      r.scrollTo(e, { container: i });
    }
  },
  getHash: function() {
    return Kl.default.getHash();
  },
  changeHash: function(e, n) {
    this.isInitialized() && Kl.default.getHash() !== e && Kl.default.updateHash(e, n);
  },
  handleHashChange: function() {
    this.scrollTo(this.getHash());
  },
  unmount: function() {
    this.scroller = null, this.containers = null, window.removeEventListener("hashchange", this.handleHashChange);
  }
};
qs.default = d_;
Object.defineProperty(gi, "__esModule", {
  value: !0
});
var na = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
}, f_ = /* @__PURE__ */ function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}(), p_ = be, pv = wi(p_), h_ = vi, ra = wi(h_), g_ = vo, v_ = wi(g_), m_ = Vs, xt = wi(m_), y_ = qs, ar = wi(y_);
function wi(t) {
  return t && t.__esModule ? t : { default: t };
}
function b_(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function C_(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function w_(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
var hv = {
  to: xt.default.string.isRequired,
  containerId: xt.default.string,
  container: xt.default.object,
  activeClass: xt.default.string,
  activeStyle: xt.default.object,
  spy: xt.default.bool,
  horizontal: xt.default.bool,
  smooth: xt.default.oneOfType([xt.default.bool, xt.default.string]),
  offset: xt.default.number,
  delay: xt.default.number,
  isDynamic: xt.default.bool,
  onClick: xt.default.func,
  duration: xt.default.oneOfType([xt.default.number, xt.default.func]),
  absolute: xt.default.bool,
  onSetActive: xt.default.func,
  onSetInactive: xt.default.func,
  ignoreCancelEvents: xt.default.bool,
  hashSpy: xt.default.bool,
  saveHashHistory: xt.default.bool,
  spyThrottle: xt.default.number
};
gi.default = function(t, e) {
  var n = e || v_.default, r = function(i) {
    w_(a, i);
    function a(s) {
      b_(this, a);
      var l = C_(this, (a.__proto__ || Object.getPrototypeOf(a)).call(this, s));
      return o.call(l), l.state = {
        active: !1
      }, l;
    }
    return f_(a, [{
      key: "getScrollSpyContainer",
      value: function() {
        var l = this.props.containerId, u = this.props.container;
        return l && !u ? document.getElementById(l) : u && u.nodeType ? u : document;
      }
    }, {
      key: "componentDidMount",
      value: function() {
        if (this.props.spy || this.props.hashSpy) {
          var l = this.getScrollSpyContainer();
          ra.default.isMounted(l) || ra.default.mount(l, this.props.spyThrottle), this.props.hashSpy && (ar.default.isMounted() || ar.default.mount(n), ar.default.mapContainer(this.props.to, l)), ra.default.addSpyHandler(this.spyHandler, l), this.setState({
            container: l
          });
        }
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        ra.default.unmount(this.stateHandler, this.spyHandler);
      }
    }, {
      key: "render",
      value: function() {
        var l = "";
        this.state && this.state.active ? l = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : l = this.props.className;
        var u = {};
        this.state && this.state.active ? u = na({}, this.props.style, this.props.activeStyle) : u = na({}, this.props.style);
        var c = na({}, this.props);
        for (var d in hv)
          c.hasOwnProperty(d) && delete c[d];
        return c.className = l, c.style = u, c.onClick = this.handleClick, pv.default.createElement(t, c);
      }
    }]), a;
  }(pv.default.PureComponent), o = function() {
    var a = this;
    this.scrollTo = function(s, l) {
      n.scrollTo(s, na({}, a.state, l));
    }, this.handleClick = function(s) {
      a.props.onClick && a.props.onClick(s), s.stopPropagation && s.stopPropagation(), s.preventDefault && s.preventDefault(), a.scrollTo(a.props.to, a.props);
    }, this.spyHandler = function(s, l) {
      var u = a.getScrollSpyContainer();
      if (!(ar.default.isMounted() && !ar.default.isInitialized())) {
        var c = a.props.horizontal, d = a.props.to, f = null, v = void 0, h = void 0;
        if (c) {
          var g = 0, p = 0, w = 0;
          if (u.getBoundingClientRect) {
            var b = u.getBoundingClientRect();
            w = b.left;
          }
          if (!f || a.props.isDynamic) {
            if (f = n.get(d), !f)
              return;
            var k = f.getBoundingClientRect();
            g = k.left - w + s, p = g + k.width;
          }
          var E = s - a.props.offset;
          v = E >= Math.floor(g) && E < Math.floor(p), h = E < Math.floor(g) || E >= Math.floor(p);
        } else {
          var m = 0, O = 0, S = 0;
          if (u.getBoundingClientRect) {
            var W = u.getBoundingClientRect();
            S = W.top;
          }
          if (!f || a.props.isDynamic) {
            if (f = n.get(d), !f)
              return;
            var P = f.getBoundingClientRect();
            m = P.top - S + l, O = m + P.height;
          }
          var $ = l - a.props.offset;
          v = $ >= Math.floor(m) && $ < Math.floor(O), h = $ < Math.floor(m) || $ >= Math.floor(O);
        }
        var j = n.getActiveLink();
        if (h) {
          if (d === j && n.setActiveLink(void 0), a.props.hashSpy && ar.default.getHash() === d) {
            var _ = a.props.saveHashHistory, I = _ === void 0 ? !1 : _;
            ar.default.changeHash("", I);
          }
          a.props.spy && a.state.active && (a.setState({ active: !1 }), a.props.onSetInactive && a.props.onSetInactive(d, f));
        }
        if (v && (j !== d || a.state.active === !1)) {
          n.setActiveLink(d);
          var R = a.props.saveHashHistory, V = R === void 0 ? !1 : R;
          a.props.hashSpy && ar.default.changeHash(d, V), a.props.spy && (a.setState({ active: !0 }), a.props.onSetActive && a.props.onSetActive(d, f));
        }
      }
    };
  };
  return r.propTypes = hv, r.defaultProps = { offset: 0 }, r;
};
Object.defineProperty(ud, "__esModule", {
  value: !0
});
var E_ = be, gv = sC(E_), D_ = gi, O_ = sC(D_);
function sC(t) {
  return t && t.__esModule ? t : { default: t };
}
function x_(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function vv(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function L_(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
var S_ = function(t) {
  L_(e, t);
  function e() {
    var n, r, o, i;
    x_(this, e);
    for (var a = arguments.length, s = Array(a), l = 0; l < a; l++)
      s[l] = arguments[l];
    return i = (r = (o = vv(this, (n = e.__proto__ || Object.getPrototypeOf(e)).call.apply(n, [this].concat(s))), o), o.render = function() {
      return gv.default.createElement(
        "a",
        o.props,
        o.props.children
      );
    }, r), vv(o, i);
  }
  return e;
}(gv.default.Component);
ud.default = (0, O_.default)(S_);
var gd = {};
Object.defineProperty(gd, "__esModule", {
  value: !0
});
var P_ = /* @__PURE__ */ function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}(), k_ = be, mv = lC(k_), M_ = gi, B_ = lC(M_);
function lC(t) {
  return t && t.__esModule ? t : { default: t };
}
function T_(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function A_(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function j_(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
var F_ = function(t) {
  j_(e, t);
  function e() {
    return T_(this, e), A_(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
  }
  return P_(e, [{
    key: "render",
    value: function() {
      return mv.default.createElement(
        "button",
        this.props,
        this.props.children
      );
    }
  }]), e;
}(mv.default.Component);
gd.default = (0, B_.default)(F_);
var vd = {}, Gs = {};
Object.defineProperty(Gs, "__esModule", {
  value: !0
});
var __ = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
}, I_ = /* @__PURE__ */ function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}(), R_ = be, yv = Zs(R_), N_ = nc;
Zs(N_);
var $_ = vo, bv = Zs($_), z_ = Vs, Cv = Zs(z_);
function Zs(t) {
  return t && t.__esModule ? t : { default: t };
}
function U_(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function W_(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function H_(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
Gs.default = function(t) {
  var e = function(n) {
    H_(r, n);
    function r(o) {
      U_(this, r);
      var i = W_(this, (r.__proto__ || Object.getPrototypeOf(r)).call(this, o));
      return i.childBindings = {
        domNode: null
      }, i;
    }
    return I_(r, [{
      key: "componentDidMount",
      value: function() {
        if (typeof window > "u")
          return !1;
        this.registerElems(this.props.name);
      }
    }, {
      key: "componentDidUpdate",
      value: function(i) {
        this.props.name !== i.name && this.registerElems(this.props.name);
      }
    }, {
      key: "componentWillUnmount",
      value: function() {
        if (typeof window > "u")
          return !1;
        bv.default.unregister(this.props.name);
      }
    }, {
      key: "registerElems",
      value: function(i) {
        bv.default.register(i, this.childBindings.domNode);
      }
    }, {
      key: "render",
      value: function() {
        return yv.default.createElement(t, __({}, this.props, { parentBindings: this.childBindings }));
      }
    }]), r;
  }(yv.default.Component);
  return e.propTypes = {
    name: Cv.default.string,
    id: Cv.default.string
  }, e;
};
Object.defineProperty(vd, "__esModule", {
  value: !0
});
var wv = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
}, V_ = /* @__PURE__ */ function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}(), q_ = be, Ev = md(q_), G_ = Gs, Z_ = md(G_), K_ = Vs, Dv = md(K_);
function md(t) {
  return t && t.__esModule ? t : { default: t };
}
function Y_(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function X_(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function J_(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
var uC = function(t) {
  J_(e, t);
  function e() {
    return Y_(this, e), X_(this, (e.__proto__ || Object.getPrototypeOf(e)).apply(this, arguments));
  }
  return V_(e, [{
    key: "render",
    value: function() {
      var r = this, o = wv({}, this.props);
      return delete o.name, o.parentBindings && delete o.parentBindings, Ev.default.createElement(
        "div",
        wv({}, o, { ref: function(a) {
          r.props.parentBindings.domNode = a;
        } }),
        this.props.children
      );
    }
  }]), e;
}(Ev.default.Component);
uC.propTypes = {
  name: Dv.default.string,
  id: Dv.default.string
};
vd.default = (0, Z_.default)(uC);
var Yl = Object.assign || function(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e];
    for (var r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (t[r] = n[r]);
  }
  return t;
}, Ov = /* @__PURE__ */ function() {
  function t(e, n) {
    for (var r = 0; r < n.length; r++) {
      var o = n[r];
      o.enumerable = o.enumerable || !1, o.configurable = !0, "value" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);
    }
  }
  return function(e, n, r) {
    return n && t(e.prototype, n), r && t(e, r), e;
  };
}();
function xv(t, e) {
  if (!(t instanceof e))
    throw new TypeError("Cannot call a class as a function");
}
function Lv(t, e) {
  if (!t)
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  return e && (typeof e == "object" || typeof e == "function") ? e : t;
}
function Sv(t, e) {
  if (typeof e != "function" && e !== null)
    throw new TypeError("Super expression must either be null or a function, not " + typeof e);
  t.prototype = Object.create(e && e.prototype, { constructor: { value: t, enumerable: !1, writable: !0, configurable: !0 } }), e && (Object.setPrototypeOf ? Object.setPrototypeOf(t, e) : t.__proto__ = e);
}
var oa = be, Ar = vi, Xl = vo, Mt = Vs, sr = qs, Pv = {
  to: Mt.string.isRequired,
  containerId: Mt.string,
  container: Mt.object,
  activeClass: Mt.string,
  spy: Mt.bool,
  smooth: Mt.oneOfType([Mt.bool, Mt.string]),
  offset: Mt.number,
  delay: Mt.number,
  isDynamic: Mt.bool,
  onClick: Mt.func,
  duration: Mt.oneOfType([Mt.number, Mt.func]),
  absolute: Mt.bool,
  onSetActive: Mt.func,
  onSetInactive: Mt.func,
  ignoreCancelEvents: Mt.bool,
  hashSpy: Mt.bool,
  spyThrottle: Mt.number
}, Q_ = {
  Scroll: function(e, n) {
    console.warn("Helpers.Scroll is deprecated since v1.7.0");
    var r = n || Xl, o = function(a) {
      Sv(s, a);
      function s(l) {
        xv(this, s);
        var u = Lv(this, (s.__proto__ || Object.getPrototypeOf(s)).call(this, l));
        return i.call(u), u.state = {
          active: !1
        }, u;
      }
      return Ov(s, [{
        key: "getScrollSpyContainer",
        value: function() {
          var u = this.props.containerId, c = this.props.container;
          return u ? document.getElementById(u) : c && c.nodeType ? c : document;
        }
      }, {
        key: "componentDidMount",
        value: function() {
          if (this.props.spy || this.props.hashSpy) {
            var u = this.getScrollSpyContainer();
            Ar.isMounted(u) || Ar.mount(u, this.props.spyThrottle), this.props.hashSpy && (sr.isMounted() || sr.mount(r), sr.mapContainer(this.props.to, u)), this.props.spy && Ar.addStateHandler(this.stateHandler), Ar.addSpyHandler(this.spyHandler, u), this.setState({
              container: u
            });
          }
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          Ar.unmount(this.stateHandler, this.spyHandler);
        }
      }, {
        key: "render",
        value: function() {
          var u = "";
          this.state && this.state.active ? u = ((this.props.className || "") + " " + (this.props.activeClass || "active")).trim() : u = this.props.className;
          var c = Yl({}, this.props);
          for (var d in Pv)
            c.hasOwnProperty(d) && delete c[d];
          return c.className = u, c.onClick = this.handleClick, oa.createElement(e, c);
        }
      }]), s;
    }(oa.Component), i = function() {
      var s = this;
      this.scrollTo = function(l, u) {
        r.scrollTo(l, Yl({}, s.state, u));
      }, this.handleClick = function(l) {
        s.props.onClick && s.props.onClick(l), l.stopPropagation && l.stopPropagation(), l.preventDefault && l.preventDefault(), s.scrollTo(s.props.to, s.props);
      }, this.stateHandler = function() {
        r.getActiveLink() !== s.props.to && (s.state !== null && s.state.active && s.props.onSetInactive && s.props.onSetInactive(), s.setState({ active: !1 }));
      }, this.spyHandler = function(l) {
        var u = s.getScrollSpyContainer();
        if (!(sr.isMounted() && !sr.isInitialized())) {
          var c = s.props.to, d = null, f = 0, v = 0, h = 0;
          if (u.getBoundingClientRect) {
            var g = u.getBoundingClientRect();
            h = g.top;
          }
          if (!d || s.props.isDynamic) {
            if (d = r.get(c), !d)
              return;
            var p = d.getBoundingClientRect();
            f = p.top - h + l, v = f + p.height;
          }
          var w = l - s.props.offset, b = w >= Math.floor(f) && w < Math.floor(v), k = w < Math.floor(f) || w >= Math.floor(v), E = r.getActiveLink();
          if (k)
            return c === E && r.setActiveLink(void 0), s.props.hashSpy && sr.getHash() === c && sr.changeHash(), s.props.spy && s.state.active && (s.setState({ active: !1 }), s.props.onSetInactive && s.props.onSetInactive()), Ar.updateStates();
          if (b && E !== c)
            return r.setActiveLink(c), s.props.hashSpy && sr.changeHash(c), s.props.spy && (s.setState({ active: !0 }), s.props.onSetActive && s.props.onSetActive(c)), Ar.updateStates();
        }
      };
    };
    return o.propTypes = Pv, o.defaultProps = { offset: 0 }, o;
  },
  Element: function(e) {
    console.warn("Helpers.Element is deprecated since v1.7.0");
    var n = function(r) {
      Sv(o, r);
      function o(i) {
        xv(this, o);
        var a = Lv(this, (o.__proto__ || Object.getPrototypeOf(o)).call(this, i));
        return a.childBindings = {
          domNode: null
        }, a;
      }
      return Ov(o, [{
        key: "componentDidMount",
        value: function() {
          if (typeof window > "u")
            return !1;
          this.registerElems(this.props.name);
        }
      }, {
        key: "componentDidUpdate",
        value: function(a) {
          this.props.name !== a.name && this.registerElems(this.props.name);
        }
      }, {
        key: "componentWillUnmount",
        value: function() {
          if (typeof window > "u")
            return !1;
          Xl.unregister(this.props.name);
        }
      }, {
        key: "registerElems",
        value: function(a) {
          Xl.register(a, this.childBindings.domNode);
        }
      }, {
        key: "render",
        value: function() {
          return oa.createElement(e, Yl({}, this.props, { parentBindings: this.childBindings }));
        }
      }]), o;
    }(oa.Component);
    return n.propTypes = {
      name: Mt.string,
      id: Mt.string
    }, n;
  }
}, eI = Q_;
Object.defineProperty(jt, "__esModule", {
  value: !0
});
jt.Helpers = jt.ScrollElement = jt.ScrollLink = CC = jt.animateScroll = jt.scrollSpy = jt.Events = jt.scroller = jt.Element = jt.Button = jt.Link = void 0;
var tI = ud, cC = Hn(tI), nI = gd, dC = Hn(nI), rI = vd, fC = Hn(rI), oI = vo, pC = Hn(oI), iI = bi, hC = Hn(iI), aI = vi, gC = Hn(aI), sI = Us, vC = Hn(sI), lI = gi, mC = Hn(lI), uI = Gs, yC = Hn(uI), cI = eI, bC = Hn(cI);
function Hn(t) {
  return t && t.__esModule ? t : { default: t };
}
jt.Link = cC.default;
jt.Button = dC.default;
jt.Element = fC.default;
jt.scroller = pC.default;
jt.Events = hC.default;
jt.scrollSpy = gC.default;
var CC = jt.animateScroll = vC.default;
jt.ScrollLink = mC.default;
jt.ScrollElement = yC.default;
jt.Helpers = bC.default;
jt.default = { Link: cC.default, Button: dC.default, Element: fC.default, scroller: pC.default, Events: hC.default, scrollSpy: gC.default, animateScroll: vC.default, ScrollLink: mC.default, ScrollElement: yC.default, Helpers: bC.default };
const yd = ct({}), wC = ct({});
function dI() {
  const t = Ee(wC);
  if (Object.entries(t).length === 0)
    throw new Error("useToast must be used within a Provider");
  return t;
}
function kv(t) {
  return t && typeof t.title == "string" && typeof t.message == "string" && (t.size === void 0 || t.size === "md" || t.size === "lg") && (t.type === "success" || t.type === "danger");
}
function A2() {
  const t = ec(), { closeModal: e, closeAll: n } = Ee(yd), { showToast: r } = dI(), { getParam: o } = J0(), { pathname: i } = tc(), a = oy(), s = o("closeAllModals");
  y(() => {
    s === "true" && (n(), a(i));
  }, [s]), y(() => {
    const l = t == null ? void 0 : t.closeModalKey;
    l && e(l);
  }, [t]), y(() => {
    const l = t == null ? void 0 : t.closeAllModals;
    typeof l == "boolean" && l && n();
  }, [t]), y(() => {
    const l = t == null ? void 0 : t.toast, u = t == null ? void 0 : t.message;
    kv(l) && r(l), !kv(l) && u && r({ message: u, type: "danger" });
  }, [t]), y(() => {
    var l, u;
    if (typeof ((l = t == null ? void 0 : t.data) == null ? void 0 : l.scrollTo) == "string") {
      const c = document.getElementById((u = t == null ? void 0 : t.data) == null ? void 0 : u.scrollTo);
      c && CC.scrollTo(c.offsetTop - 200);
    }
  }, [t]);
}
const EC = ct({});
function j2(t) {
  const e = Ee(EC);
  if (Object.entries(e).length === 0)
    throw new Error("useDrawer must be used within a Provider");
  if (t) {
    const {
      drawerData: n,
      drawerIsOpen: r,
      openDrawer: o,
      closeDrawer: i
    } = e, a = r(t), s = n(t);
    return { drawerIsOpen: a, drawerData: s, openDrawer: (c) => o(t, c), closeDrawer: () => i(t) };
  } else
    return e;
}
function fI() {
  return () => {
  };
}
function pI() {
  return ZC(
    fI,
    () => !0,
    () => !1
  );
}
function F2(t) {
  const e = Ee(yd);
  if (Object.entries(e).length === 0)
    throw new Error("useModal must be used within a Provider");
  if (t) {
    const {
      modalData: n,
      modalIsOpen: r,
      openModal: o,
      closeModal: i
    } = e, a = r(t), s = n(t);
    return { modalIsOpen: a, modalData: s, openModal: (c) => o(t, c), closeModal: () => i(t) };
  } else
    return e;
}
function _2(t) {
  const { children: e = !1 } = t, [n, r] = B([]);
  function o(l) {
    return !!n.some((u) => u.key === l);
  }
  function i(l) {
    var u;
    return (u = n.find((c) => c.key === l)) == null ? void 0 : u.data;
  }
  function a(l, u) {
    const c = o(l);
    r(c ? (d) => [...d.filter((v) => v.key !== l), { key: l, data: u }] : [...n, { key: l, data: u }]);
  }
  function s(l) {
    r(n.filter((u) => u.key !== l));
  }
  return /* @__PURE__ */ x.jsx(
    EC.Provider,
    {
      value: { drawerIsOpen: o, drawerData: i, openDrawer: a, closeDrawer: s },
      children: e
    }
  );
}
function si(t) {
  "@babel/helpers - typeof";
  return si = typeof Symbol == "function" && typeof Symbol.iterator == "symbol" ? function(e) {
    return typeof e;
  } : function(e) {
    return e && typeof Symbol == "function" && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
  }, si(t);
}
function hI(t, e) {
  if (si(t) != "object" || !t) return t;
  var n = t[Symbol.toPrimitive];
  if (n !== void 0) {
    var r = n.call(t, e || "default");
    if (si(r) != "object") return r;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return (e === "string" ? String : Number)(t);
}
function gI(t) {
  var e = hI(t, "string");
  return si(e) == "symbol" ? e : e + "";
}
function oe(t, e, n) {
  return (e = gI(e)) in t ? Object.defineProperty(t, e, {
    value: n,
    enumerable: !0,
    configurable: !0,
    writable: !0
  }) : t[e] = n, t;
}
function DC(t) {
  return t && t.__esModule && Object.prototype.hasOwnProperty.call(t, "default") ? t.default : t;
}
var Jl, Mv;
function vI() {
  if (Mv) return Jl;
  Mv = 1;
  var t = process.env.NODE_ENV, e = function(r, o, i, a, s, l, u, c) {
    if (t !== "production" && o === void 0)
      throw new Error("invariant requires an error message argument");
    if (!r) {
      var d;
      if (o === void 0)
        d = new Error("Minified exception occurred; use the non-minified dev environment for the full error message and additional helpful warnings.");
      else {
        var f = [i, a, s, l, u, c], v = 0;
        d = new Error(o.replace(/%s/g, function() {
          return f[v++];
        })), d.name = "Invariant Violation";
      }
      throw d.framesToPop = 1, d;
    }
  };
  return Jl = e, Jl;
}
var mI = vI(), $t = /* @__PURE__ */ DC(mI), Ae = ct(null);
function yI() {
  $t(!!Ee, "useGoogleMap is React hook and requires React version 16.8+");
  var t = Ee(Ae);
  return $t(!!t, "useGoogleMap needs a GoogleMap available up in the tree"), t;
}
function bI(t, e, n) {
  return Object.keys(t).reduce(function(o, i) {
    return e(o, t[i], i);
  }, n);
}
function CI(t, e) {
  Object.keys(t).forEach((n) => e(t[n], n));
}
function wI(t, e, n, r) {
  var o = {}, i = (a, s) => {
    var l = n[s];
    l !== e[s] && (o[s] = l, a(r, l));
  };
  return CI(t, i), o;
}
function EI(t, e, n) {
  var r = bI(n, function(i, a, s) {
    return typeof t[s] == "function" && i.push(google.maps.event.addListener(e, a, t[s])), i;
  }, []);
  return r;
}
function DI(t) {
  google.maps.event.removeListener(t);
}
function We() {
  var t = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : [];
  t.forEach(DI);
}
function $e(t) {
  var {
    updaterMap: e,
    eventMap: n,
    prevProps: r,
    nextProps: o,
    instance: i
  } = t, a = EI(o, i, n);
  return wI(e, r, o, i), a;
}
var Bv = {
  onDblClick: "dblclick",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMapTypeIdChanged: "maptypeid_changed",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseDown: "mousedown",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onTilesLoaded: "tilesloaded",
  onBoundsChanged: "bounds_changed",
  onCenterChanged: "center_changed",
  onClick: "click",
  onDrag: "drag",
  onHeadingChanged: "heading_changed",
  onIdle: "idle",
  onProjectionChanged: "projection_changed",
  onResize: "resize",
  onTiltChanged: "tilt_changed",
  onZoomChanged: "zoom_changed"
}, Tv = {
  extraMapTypes(t, e) {
    e.forEach(function(r, o) {
      t.mapTypes.set(String(o), r);
    });
  },
  center(t, e) {
    t.setCenter(e);
  },
  clickableIcons(t, e) {
    t.setClickableIcons(e);
  },
  heading(t, e) {
    t.setHeading(e);
  },
  mapTypeId(t, e) {
    t.setMapTypeId(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  streetView(t, e) {
    t.setStreetView(e);
  },
  tilt(t, e) {
    t.setTilt(e);
  },
  zoom(t, e) {
    t.setZoom(e);
  }
};
function OI(t) {
  var {
    children: e,
    options: n,
    id: r,
    mapContainerStyle: o,
    mapContainerClassName: i,
    center: a,
    // clickableIcons,
    // extraMapTypes,
    // heading,
    // mapTypeId,
    onClick: s,
    onDblClick: l,
    onDrag: u,
    onDragEnd: c,
    onDragStart: d,
    onMouseMove: f,
    onMouseOut: v,
    onMouseOver: h,
    onMouseDown: g,
    onMouseUp: p,
    onRightClick: w,
    // onMapTypeIdChanged,
    // onTilesLoaded,
    // onBoundsChanged,
    onCenterChanged: b,
    // onHeadingChanged,
    // onIdle,
    // onProjectionChanged,
    // onResize,
    // onTiltChanged,
    // onZoomChanged,
    onLoad: k,
    onUnmount: E
  } = t, [m, O] = B(null), S = qe(null), [W, P] = B(null), [$, j] = B(null), [_, I] = B(null), [R, V] = B(null), [J, G] = B(null), [te, Q] = B(null), [T, N] = B(null), [Y, F] = B(null), [X, L] = B(null), [M, z] = B(null), [A, U] = B(null), [H, ee] = B(null);
  return y(() => {
    n && m !== null && m.setOptions(n);
  }, [m, n]), y(() => {
    m !== null && typeof a < "u" && m.setCenter(a);
  }, [m, a]), y(() => {
    m && l && ($ !== null && google.maps.event.removeListener($), j(google.maps.event.addListener(m, "dblclick", l)));
  }, [l]), y(() => {
    m && c && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(m, "dragend", c)));
  }, [c]), y(() => {
    m && d && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(m, "dragstart", d)));
  }, [d]), y(() => {
    m && g && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(m, "mousedown", g)));
  }, [g]), y(() => {
    m && f && (te !== null && google.maps.event.removeListener(te), Q(google.maps.event.addListener(m, "mousemove", f)));
  }, [f]), y(() => {
    m && v && (T !== null && google.maps.event.removeListener(T), N(google.maps.event.addListener(m, "mouseout", v)));
  }, [v]), y(() => {
    m && h && (Y !== null && google.maps.event.removeListener(Y), F(google.maps.event.addListener(m, "mouseover", h)));
  }, [h]), y(() => {
    m && p && (X !== null && google.maps.event.removeListener(X), L(google.maps.event.addListener(m, "mouseup", p)));
  }, [p]), y(() => {
    m && w && (M !== null && google.maps.event.removeListener(M), z(google.maps.event.addListener(m, "rightclick", w)));
  }, [w]), y(() => {
    m && s && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(m, "click", s)));
  }, [s]), y(() => {
    m && u && (H !== null && google.maps.event.removeListener(H), ee(google.maps.event.addListener(m, "drag", u)));
  }, [u]), y(() => {
    m && b && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(m, "center_changed", b)));
  }, [s]), y(() => {
    var Z = S.current === null ? null : new google.maps.Map(S.current, n);
    return O(Z), Z !== null && k && k(Z), () => {
      Z !== null && E && E(Z);
    };
  }, []), x.jsx("div", {
    id: r,
    ref: S,
    style: o,
    className: i,
    children: x.jsx(Ae.Provider, {
      value: m,
      children: m !== null ? e : null
    })
  });
}
Re(OI);
let xI = class extends xe {
  constructor() {
    super(...arguments), oe(this, "state", {
      map: null
    }), oe(this, "registeredEvents", []), oe(this, "mapRef", null), oe(this, "getInstance", () => this.mapRef === null ? null : new google.maps.Map(this.mapRef, this.props.options)), oe(this, "panTo", (e) => {
      var n = this.getInstance();
      n && n.panTo(e);
    }), oe(this, "setMapCallback", () => {
      this.state.map !== null && this.props.onLoad && this.props.onLoad(this.state.map);
    }), oe(this, "getRef", (e) => {
      this.mapRef = e;
    });
  }
  componentDidMount() {
    var e = this.getInstance();
    this.registeredEvents = $e({
      updaterMap: Tv,
      eventMap: Bv,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        map: e
      };
    }, this.setMapCallback);
  }
  componentDidUpdate(e) {
    this.state.map !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: Tv,
      eventMap: Bv,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.map
    }));
  }
  componentWillUnmount() {
    this.state.map !== null && (this.props.onUnmount && this.props.onUnmount(this.state.map), We(this.registeredEvents));
  }
  render() {
    return x.jsx("div", {
      id: this.props.id,
      ref: this.getRef,
      style: this.props.mapContainerStyle,
      className: this.props.mapContainerClassName,
      children: x.jsx(Ae.Provider, {
        value: this.state.map,
        children: this.state.map !== null ? this.props.children : null
      })
    });
  }
};
function Av(t, e, n, r, o, i, a) {
  try {
    var s = t[i](a), l = s.value;
  } catch (u) {
    return void n(u);
  }
  s.done ? e(l) : Promise.resolve(l).then(r, o);
}
function OC(t) {
  return function() {
    var e = this, n = arguments;
    return new Promise(function(r, o) {
      var i = t.apply(e, n);
      function a(l) {
        Av(i, r, o, a, s, "next", l);
      }
      function s(l) {
        Av(i, r, o, a, s, "throw", l);
      }
      a(void 0);
    });
  };
}
function xC(t) {
  var {
    googleMapsApiKey: e,
    googleMapsClientId: n,
    version: r = "weekly",
    language: o,
    region: i,
    libraries: a,
    channel: s,
    mapIds: l,
    authReferrerPolicy: u
  } = t, c = [];
  return $t(e && n || !(e && n), "You need to specify either googleMapsApiKey or googleMapsClientId for @react-google-maps/api load script to work. You cannot use both at the same time."), e ? c.push("key=".concat(e)) : n && c.push("client=".concat(n)), r && c.push("v=".concat(r)), o && c.push("language=".concat(o)), i && c.push("region=".concat(i)), a && a.length && c.push("libraries=".concat(a.sort().join(","))), s && c.push("channel=".concat(s)), l && l.length && c.push("map_ids=".concat(l.join(","))), u && c.push("auth_referrer_policy=".concat(u)), c.push("loading=async"), c.push("callback=initMap"), "https://maps.googleapis.com/maps/api/js?".concat(c.join("&"));
}
var Wr = typeof document < "u";
function LC(t) {
  var {
    url: e,
    id: n,
    nonce: r
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
  } = t;
  return Wr ? new Promise(function(i, a) {
    var s = document.getElementById(n), l = window;
    if (s) {
      var u = s.getAttribute("data-state");
      if (s.src === e && u !== "error") {
        if (u === "ready")
          return i(n);
        var c = l.initMap, d = s.onerror;
        l.initMap = function() {
          c && c(), i(n);
        }, s.onerror = function(v) {
          d && d(v), a(v);
        };
        return;
      } else
        s.remove();
    }
    var f = document.createElement("script");
    f.type = "text/javascript", f.src = e, f.id = n, f.async = !0, f.nonce = r || "", f.onerror = function(h) {
      f.setAttribute("data-state", "error"), a(h);
    }, l.initMap = function() {
      f.setAttribute("data-state", "ready"), i(n);
    }, document.head.appendChild(f);
  }).catch((o) => {
    throw console.error("injectScript error: ", o), o;
  }) : Promise.reject(new Error("document is undefined"));
}
function jv(t) {
  var e = t.href;
  return e && (e.indexOf("https://fonts.googleapis.com/css?family=Roboto") === 0 || e.indexOf("https://fonts.googleapis.com/css?family=Google+Sans+Text") === 0) ? !0 : (
    // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    t.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    t.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    t.styleSheet.cssText && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
    // @ts-ignore
    t.styleSheet.cssText.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (t.styleSheet.cssText = "", !0) : (
      // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      t.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      t.innerHTML && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
      // @ts-ignore
      t.innerHTML.replace(`\r
`, "").indexOf(".gm-style") === 0 ? (t.innerHTML = "", !0) : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        t.tagName.toLowerCase() === "style" && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !t.styleSheet && // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        !t.innerHTML
      )
    )
  );
}
function SC() {
  var t = document.getElementsByTagName("head")[0];
  if (t) {
    var e = t.insertBefore.bind(t);
    t.insertBefore = function(o, i) {
      return jv(o) || Reflect.apply(e, t, [o, i]), o;
    };
    var n = t.appendChild.bind(t);
    t.appendChild = function(o) {
      return jv(o) || Reflect.apply(n, t, [o]), o;
    };
  }
}
var Mo = !1;
function PC() {
  return x.jsx("div", {
    children: "Loading..."
  });
}
var qu = {
  id: "script-loader",
  version: "weekly"
};
class kC extends xe {
  constructor() {
    super(...arguments), oe(this, "check", Cr()), oe(this, "state", {
      loaded: !1
    }), oe(this, "cleanupCallback", () => {
      delete window.google.maps, this.injectScript();
    }), oe(this, "isCleaningUp", /* @__PURE__ */ OC(function* () {
      function e(n) {
        if (!Mo)
          n();
        else if (Wr)
          var r = window.setInterval(function() {
            Mo || (window.clearInterval(r), n());
          }, 1);
      }
      return new Promise(e);
    })), oe(this, "cleanup", () => {
      Mo = !0;
      var e = document.getElementById(this.props.id);
      e && e.parentNode && e.parentNode.removeChild(e), Array.prototype.slice.call(document.getElementsByTagName("script")).filter(function(r) {
        return typeof r.src == "string" && r.src.includes("maps.googleapis");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("link")).filter(function(r) {
        return r.href === "https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Google+Sans";
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      }), Array.prototype.slice.call(document.getElementsByTagName("style")).filter(function(r) {
        return r.innerText !== void 0 && r.innerText.length > 0 && r.innerText.includes(".gm-");
      }).forEach(function(r) {
        r.parentNode && r.parentNode.removeChild(r);
      });
    }), oe(this, "injectScript", () => {
      this.props.preventGoogleFontsLoading && SC(), $t(!!this.props.id, 'LoadScript requires "id" prop to be a string: %s', this.props.id);
      var e = {
        id: this.props.id,
        nonce: this.props.nonce,
        url: xC(this.props)
      };
      LC(e).then(() => {
        this.props.onLoad && this.props.onLoad(), this.setState(function() {
          return {
            loaded: !0
          };
        });
      }).catch((n) => {
        this.props.onError && this.props.onError(n), console.error(`
          There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(this.props.googleMapsApiKey || "-", ") or Client ID (").concat(this.props.googleMapsClientId || "-", `) to <LoadScript />
          Otherwise it is a Network issue.
        `));
      });
    });
  }
  componentDidMount() {
    if (Wr) {
      if (window.google && window.google.maps && !Mo) {
        console.error("google api is already presented");
        return;
      }
      this.isCleaningUp().then(this.injectScript).catch(function(n) {
        console.error("Error at injecting script after cleaning up: ", n);
      });
    }
  }
  componentDidUpdate(e) {
    this.props.libraries !== e.libraries && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), Wr && e.language !== this.props.language && (this.cleanup(), this.setState(function() {
      return {
        loaded: !1
      };
    }, this.cleanupCallback));
  }
  componentWillUnmount() {
    if (Wr) {
      this.cleanup();
      var e = () => {
        this.check.current || (delete window.google, Mo = !1);
      };
      window.setTimeout(e, 1), this.props.onUnmount && this.props.onUnmount();
    }
  }
  render() {
    return x.jsxs(x.Fragment, {
      children: [x.jsx("div", {
        ref: this.check
      }), this.state.loaded ? this.props.children : this.props.loadingElement || x.jsx(PC, {})]
    });
  }
}
oe(kC, "defaultProps", qu);
function LI(t, e) {
  if (t == null) return {};
  var n = {};
  for (var r in t) if ({}.hasOwnProperty.call(t, r)) {
    if (e.includes(r)) continue;
    n[r] = t[r];
  }
  return n;
}
function bd(t, e) {
  if (t == null) return {};
  var n, r, o = LI(t, e);
  if (Object.getOwnPropertySymbols) {
    var i = Object.getOwnPropertySymbols(t);
    for (r = 0; r < i.length; r++) n = i[r], e.includes(n) || {}.propertyIsEnumerable.call(t, n) && (o[n] = t[n]);
  }
  return o;
}
var Fv;
function SI(t) {
  var {
    id: e = qu.id,
    version: n = qu.version,
    nonce: r,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    preventGoogleFontsLoading: u,
    channel: c,
    mapIds: d,
    authReferrerPolicy: f
  } = t, v = qe(!1), [h, g] = B(!1), [p, w] = B(void 0);
  y(function() {
    return v.current = !0, () => {
      v.current = !1;
    };
  }, []), y(function() {
    Wr && u && SC();
  }, [u]), y(function() {
    h && $t(!!window.google, "useLoadScript was marked as loaded, but window.google is not present. Something went wrong.");
  }, [h]);
  var b = xC({
    version: n,
    googleMapsApiKey: o,
    googleMapsClientId: i,
    language: a,
    region: s,
    libraries: l,
    channel: c,
    mapIds: d,
    authReferrerPolicy: f
  });
  y(function() {
    if (!Wr)
      return;
    function m() {
      v.current && (g(!0), Fv = b);
    }
    if (window.google && window.google.maps && Fv === b) {
      m();
      return;
    }
    LC({
      id: e,
      url: b,
      nonce: r
    }).then(m).catch(function(S) {
      v.current && w(S), console.warn(`
        There has been an Error with loading Google Maps API script, please check that you provided correct google API key (`.concat(o || "-", ") or Client ID (").concat(i || "-", `)
        Otherwise it is a Network issue.
      `)), console.error(S);
    });
  }, [e, b, r]);
  var k = qe();
  return y(function() {
    k.current && l !== k.current && console.warn("Performance warning! LoadScript has been reloaded unintentionally! You should not pass `libraries` prop as new array. Please keep an array of libraries as static class property for Components and PureComponents, or just a const variable outside of component, or somewhere in config files or ENV variables"), k.current = l;
  }, [l]), {
    isLoaded: h,
    loadError: p,
    url: b
  };
}
var PI = ["loadingElement", "onLoad", "onError", "onUnmount", "children"], kI = x.jsx(PC, {});
function MI(t) {
  var {
    loadingElement: e,
    onLoad: n,
    onError: r,
    onUnmount: o,
    children: i
  } = t, a = bd(t, PI), {
    isLoaded: s,
    loadError: l
  } = SI(a);
  return y(function() {
    s && typeof n == "function" && n();
  }, [s, n]), y(function() {
    l && typeof r == "function" && r(l);
  }, [l, r]), y(function() {
    return () => {
      o && o();
    };
  }, [o]), s ? i : e || kI;
}
Re(MI);
var _v;
(function(t) {
  t[t.INITIALIZED = 0] = "INITIALIZED", t[t.LOADING = 1] = "LOADING", t[t.SUCCESS = 2] = "SUCCESS", t[t.FAILURE = 3] = "FAILURE";
})(_v || (_v = {}));
function Iv(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ha(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Iv(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Iv(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Rv = {}, Nv = {
  options(t, e) {
    t.setOptions(e);
  }
};
function BI(t) {
  var {
    options: e,
    onLoad: n,
    onUnmount: r
  } = t, o = Ee(Ae), [i, a] = B(null);
  return y(() => {
    i !== null && i.setMap(o);
  }, [o]), y(() => {
    e && i !== null && i.setOptions(e);
  }, [i, e]), y(() => {
    var s = new google.maps.TrafficLayer(Ha(Ha({}, e), {}, {
      map: o
    }));
    return a(s), n && n(s), () => {
      i !== null && (r && r(i), i.setMap(null));
    };
  }, []), null;
}
Re(BI);
class TI extends xe {
  constructor() {
    super(...arguments), oe(this, "state", {
      trafficLayer: null
    }), oe(this, "setTrafficLayerCallback", () => {
      this.state.trafficLayer !== null && this.props.onLoad && this.props.onLoad(this.state.trafficLayer);
    }), oe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var e = new google.maps.TrafficLayer(Ha(Ha({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $e({
      updaterMap: Nv,
      eventMap: Rv,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        trafficLayer: e
      };
    }, this.setTrafficLayerCallback);
  }
  componentDidUpdate(e) {
    this.state.trafficLayer !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: Nv,
      eventMap: Rv,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.trafficLayer
    }));
  }
  componentWillUnmount() {
    this.state.trafficLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.trafficLayer), We(this.registeredEvents), this.state.trafficLayer.setMap(null));
  }
  render() {
    return null;
  }
}
oe(TI, "contextType", Ae);
function AI(t) {
  var {
    onLoad: e,
    onUnmount: n
  } = t, r = Ee(Ae), [o, i] = B(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var a = new google.maps.BicyclingLayer();
    return i(a), a.setMap(r), e && e(a), () => {
      a !== null && (n && n(a), a.setMap(null));
    };
  }, []), null;
}
Re(AI);
class jI extends xe {
  constructor() {
    super(...arguments), oe(this, "state", {
      bicyclingLayer: null
    }), oe(this, "setBicyclingLayerCallback", () => {
      this.state.bicyclingLayer !== null && (this.state.bicyclingLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.bicyclingLayer));
    });
  }
  componentDidMount() {
    var e = new google.maps.BicyclingLayer();
    this.setState(() => ({
      bicyclingLayer: e
    }), this.setBicyclingLayerCallback);
  }
  componentWillUnmount() {
    this.state.bicyclingLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.bicyclingLayer), this.state.bicyclingLayer.setMap(null));
  }
  render() {
    return null;
  }
}
oe(jI, "contextType", Ae);
function FI(t) {
  var {
    onLoad: e,
    onUnmount: n
  } = t, r = Ee(Ae), [o, i] = B(null);
  return y(() => {
    o !== null && o.setMap(r);
  }, [r]), y(() => {
    var a = new google.maps.TransitLayer();
    return i(a), a.setMap(r), e && e(a), () => {
      o !== null && (n && n(o), o.setMap(null));
    };
  }, []), null;
}
Re(FI);
class _I extends xe {
  constructor() {
    super(...arguments), oe(this, "state", {
      transitLayer: null
    }), oe(this, "setTransitLayerCallback", () => {
      this.state.transitLayer !== null && (this.state.transitLayer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.transitLayer));
    });
  }
  componentDidMount() {
    var e = new google.maps.TransitLayer();
    this.setState(function() {
      return {
        transitLayer: e
      };
    }, this.setTransitLayerCallback);
  }
  componentWillUnmount() {
    this.state.transitLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.transitLayer), this.state.transitLayer.setMap(null));
  }
  render() {
    return null;
  }
}
oe(_I, "contextType", Ae);
function $v(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Va(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? $v(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : $v(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var zv = {
  onCircleComplete: "circlecomplete",
  onMarkerComplete: "markercomplete",
  onOverlayComplete: "overlaycomplete",
  onPolygonComplete: "polygoncomplete",
  onPolylineComplete: "polylinecomplete",
  onRectangleComplete: "rectanglecomplete"
}, Uv = {
  drawingMode(t, e) {
    t.setDrawingMode(e);
  },
  options(t, e) {
    t.setOptions(e);
  }
};
function II(t) {
  var {
    options: e,
    drawingMode: n,
    onCircleComplete: r,
    onMarkerComplete: o,
    onOverlayComplete: i,
    onPolygonComplete: a,
    onPolylineComplete: s,
    onRectangleComplete: l,
    onLoad: u,
    onUnmount: c
  } = t, d = Ee(Ae), [f, v] = B(null), [h, g] = B(null), [p, w] = B(null), [b, k] = B(null), [E, m] = B(null), [O, S] = B(null), [W, P] = B(null);
  return y(() => {
    f !== null && f.setMap(d);
  }, [d]), y(() => {
    e && f !== null && f.setOptions(e);
  }, [f, e]), y(() => {
    f !== null && f.setDrawingMode(n ?? null);
  }, [f, n]), y(() => {
    f && r && (h !== null && google.maps.event.removeListener(h), g(google.maps.event.addListener(f, "circlecomplete", r)));
  }, [f, r]), y(() => {
    f && o && (p !== null && google.maps.event.removeListener(p), w(google.maps.event.addListener(f, "markercomplete", o)));
  }, [f, o]), y(() => {
    f && i && (b !== null && google.maps.event.removeListener(b), k(google.maps.event.addListener(f, "overlaycomplete", i)));
  }, [f, i]), y(() => {
    f && a && (E !== null && google.maps.event.removeListener(E), m(google.maps.event.addListener(f, "polygoncomplete", a)));
  }, [f, a]), y(() => {
    f && s && (O !== null && google.maps.event.removeListener(O), S(google.maps.event.addListener(f, "polylinecomplete", s)));
  }, [f, s]), y(() => {
    f && l && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(f, "rectanglecomplete", l)));
  }, [f, l]), y(() => {
    $t(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
    var $ = new google.maps.drawing.DrawingManager(Va(Va({}, e), {}, {
      map: d
    }));
    return n && $.setDrawingMode(n), r && g(google.maps.event.addListener($, "circlecomplete", r)), o && w(google.maps.event.addListener($, "markercomplete", o)), i && k(google.maps.event.addListener($, "overlaycomplete", i)), a && m(google.maps.event.addListener($, "polygoncomplete", a)), s && S(google.maps.event.addListener($, "polylinecomplete", s)), l && P(google.maps.event.addListener($, "rectanglecomplete", l)), v($), u && u($), () => {
      f !== null && (h && google.maps.event.removeListener(h), p && google.maps.event.removeListener(p), b && google.maps.event.removeListener(b), E && google.maps.event.removeListener(E), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), c && c(f), f.setMap(null));
    };
  }, []), null;
}
Re(II);
class RI extends xe {
  constructor(e) {
    super(e), oe(this, "registeredEvents", []), oe(this, "state", {
      drawingManager: null
    }), oe(this, "setDrawingManagerCallback", () => {
      this.state.drawingManager !== null && this.props.onLoad && this.props.onLoad(this.state.drawingManager);
    }), $t(!!google.maps.drawing, "Did you include prop libraries={['drawing']} in the URL? %s", google.maps.drawing);
  }
  componentDidMount() {
    var e = new google.maps.drawing.DrawingManager(Va(Va({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $e({
      updaterMap: Uv,
      eventMap: zv,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        drawingManager: e
      };
    }, this.setDrawingManagerCallback);
  }
  componentDidUpdate(e) {
    this.state.drawingManager !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: Uv,
      eventMap: zv,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.drawingManager
    }));
  }
  componentWillUnmount() {
    this.state.drawingManager !== null && (this.props.onUnmount && this.props.onUnmount(this.state.drawingManager), We(this.registeredEvents), this.state.drawingManager.setMap(null));
  }
  render() {
    return null;
  }
}
oe(RI, "contextType", Ae);
function Wv(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function ao(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Wv(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Wv(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Hv = {
  onAnimationChanged: "animation_changed",
  onClick: "click",
  onClickableChanged: "clickable_changed",
  onCursorChanged: "cursor_changed",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDraggableChanged: "draggable_changed",
  onDragStart: "dragstart",
  onFlatChanged: "flat_changed",
  onIconChanged: "icon_changed",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onPositionChanged: "position_changed",
  onRightClick: "rightclick",
  onShapeChanged: "shape_changed",
  onTitleChanged: "title_changed",
  onVisibleChanged: "visible_changed",
  onZindexChanged: "zindex_changed"
}, Vv = {
  animation(t, e) {
    t.setAnimation(e);
  },
  clickable(t, e) {
    t.setClickable(e);
  },
  cursor(t, e) {
    t.setCursor(e);
  },
  draggable(t, e) {
    t.setDraggable(e);
  },
  icon(t, e) {
    t.setIcon(e);
  },
  label(t, e) {
    t.setLabel(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  opacity(t, e) {
    t.setOpacity(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  position(t, e) {
    t.setPosition(e);
  },
  shape(t, e) {
    t.setShape(e);
  },
  title(t, e) {
    t.setTitle(e);
  },
  visible(t, e) {
    t.setVisible(e);
  },
  zIndex(t, e) {
    t.setZIndex(e);
  }
}, qa = {};
function NI(t) {
  var {
    position: e,
    options: n,
    clusterer: r,
    noClustererRedraw: o,
    children: i,
    draggable: a,
    visible: s,
    animation: l,
    clickable: u,
    cursor: c,
    icon: d,
    label: f,
    opacity: v,
    shape: h,
    title: g,
    zIndex: p,
    onClick: w,
    onDblClick: b,
    onDrag: k,
    onDragEnd: E,
    onDragStart: m,
    onMouseOut: O,
    onMouseOver: S,
    onMouseUp: W,
    onMouseDown: P,
    onRightClick: $,
    onClickableChanged: j,
    onCursorChanged: _,
    onAnimationChanged: I,
    onDraggableChanged: R,
    onFlatChanged: V,
    onIconChanged: J,
    onPositionChanged: G,
    onShapeChanged: te,
    onTitleChanged: Q,
    onVisibleChanged: T,
    onZindexChanged: N,
    onLoad: Y,
    onUnmount: F
  } = t, X = Ee(Ae), [L, M] = B(null), [z, A] = B(null), [U, H] = B(null), [ee, Z] = B(null), [pe, he] = B(null), [le, Le] = B(null), [Fe, Be] = B(null), [Ne, at] = B(null), [dt, Oe] = B(null), [ft, bt] = B(null), [De, ke] = B(null), [Ke, Je] = B(null), [Qe, Bt] = B(null), [He, Yt] = B(null), [Ft, It] = B(null), [Wt, fn] = B(null), [Ht, pn] = B(null), [_t, Xt] = B(null), [Rt, hn] = B(null), [Vt, Bn] = B(null), [gn, Tn] = B(null), [vn, An] = B(null);
  y(() => {
    L !== null && L.setMap(X);
  }, [X]), y(() => {
    typeof n < "u" && L !== null && L.setOptions(n);
  }, [L, n]), y(() => {
    typeof a < "u" && L !== null && L.setDraggable(a);
  }, [L, a]), y(() => {
    e && L !== null && L.setPosition(e);
  }, [L, e]), y(() => {
    typeof s < "u" && L !== null && L.setVisible(s);
  }, [L, s]), y(() => {
    L == null || L.setAnimation(l);
  }, [L, l]), y(() => {
    L && u !== void 0 && L.setClickable(u);
  }, [L, u]), y(() => {
    L && c !== void 0 && L.setCursor(c);
  }, [L, c]), y(() => {
    L && d !== void 0 && L.setIcon(d);
  }, [L, d]), y(() => {
    L && f !== void 0 && L.setLabel(f);
  }, [L, f]), y(() => {
    L && v !== void 0 && L.setOpacity(v);
  }, [L, v]), y(() => {
    L && h !== void 0 && L.setShape(h);
  }, [L, h]), y(() => {
    L && g !== void 0 && L.setTitle(g);
  }, [L, g]), y(() => {
    L && p !== void 0 && L.setZIndex(p);
  }, [L, p]), y(() => {
    L && b && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(L, "dblclick", b)));
  }, [b]), y(() => {
    L && E && (U !== null && google.maps.event.removeListener(U), H(google.maps.event.addListener(L, "dragend", E)));
  }, [E]), y(() => {
    L && m && (ee !== null && google.maps.event.removeListener(ee), Z(google.maps.event.addListener(L, "dragstart", m)));
  }, [m]), y(() => {
    L && P && (pe !== null && google.maps.event.removeListener(pe), he(google.maps.event.addListener(L, "mousedown", P)));
  }, [P]), y(() => {
    L && O && (le !== null && google.maps.event.removeListener(le), Le(google.maps.event.addListener(L, "mouseout", O)));
  }, [O]), y(() => {
    L && S && (Fe !== null && google.maps.event.removeListener(Fe), Be(google.maps.event.addListener(L, "mouseover", S)));
  }, [S]), y(() => {
    L && W && (Ne !== null && google.maps.event.removeListener(Ne), at(google.maps.event.addListener(L, "mouseup", W)));
  }, [W]), y(() => {
    L && $ && (dt !== null && google.maps.event.removeListener(dt), Oe(google.maps.event.addListener(L, "rightclick", $)));
  }, [$]), y(() => {
    L && w && (ft !== null && google.maps.event.removeListener(ft), bt(google.maps.event.addListener(L, "click", w)));
  }, [w]), y(() => {
    L && k && (De !== null && google.maps.event.removeListener(De), ke(google.maps.event.addListener(L, "drag", k)));
  }, [k]), y(() => {
    L && j && (Ke !== null && google.maps.event.removeListener(Ke), Je(google.maps.event.addListener(L, "clickable_changed", j)));
  }, [j]), y(() => {
    L && _ && (Qe !== null && google.maps.event.removeListener(Qe), Bt(google.maps.event.addListener(L, "cursor_changed", _)));
  }, [_]), y(() => {
    L && I && (He !== null && google.maps.event.removeListener(He), Yt(google.maps.event.addListener(L, "animation_changed", I)));
  }, [I]), y(() => {
    L && R && (Ft !== null && google.maps.event.removeListener(Ft), It(google.maps.event.addListener(L, "draggable_changed", R)));
  }, [R]), y(() => {
    L && V && (Wt !== null && google.maps.event.removeListener(Wt), fn(google.maps.event.addListener(L, "flat_changed", V)));
  }, [V]), y(() => {
    L && J && (Ht !== null && google.maps.event.removeListener(Ht), pn(google.maps.event.addListener(L, "icon_changed", J)));
  }, [J]), y(() => {
    L && G && (_t !== null && google.maps.event.removeListener(_t), Xt(google.maps.event.addListener(L, "position_changed", G)));
  }, [G]), y(() => {
    L && te && (Rt !== null && google.maps.event.removeListener(Rt), hn(google.maps.event.addListener(L, "shape_changed", te)));
  }, [te]), y(() => {
    L && Q && (Vt !== null && google.maps.event.removeListener(Vt), Bn(google.maps.event.addListener(L, "title_changed", Q)));
  }, [Q]), y(() => {
    L && T && (gn !== null && google.maps.event.removeListener(gn), Tn(google.maps.event.addListener(L, "visible_changed", T)));
  }, [T]), y(() => {
    L && N && (vn !== null && google.maps.event.removeListener(vn), An(google.maps.event.addListener(L, "zindex_changed", N)));
  }, [N]), y(() => {
    var Jt = ao(ao(ao({}, n || qa), r ? qa : {
      map: X
    }), {}, {
      position: e
    }), de = new google.maps.Marker(Jt);
    return r ? r.addMarker(de, !!o) : de.setMap(X), e && de.setPosition(e), typeof s < "u" && de.setVisible(s), typeof a < "u" && de.setDraggable(a), typeof u < "u" && de.setClickable(u), typeof c == "string" && de.setCursor(c), d && de.setIcon(d), typeof f < "u" && de.setLabel(f), typeof v < "u" && de.setOpacity(v), h && de.setShape(h), typeof g == "string" && de.setTitle(g), typeof p == "number" && de.setZIndex(p), b && A(google.maps.event.addListener(de, "dblclick", b)), E && H(google.maps.event.addListener(de, "dragend", E)), m && Z(google.maps.event.addListener(de, "dragstart", m)), P && he(google.maps.event.addListener(de, "mousedown", P)), O && Le(google.maps.event.addListener(de, "mouseout", O)), S && Be(google.maps.event.addListener(de, "mouseover", S)), W && at(google.maps.event.addListener(de, "mouseup", W)), $ && Oe(google.maps.event.addListener(de, "rightclick", $)), w && bt(google.maps.event.addListener(de, "click", w)), k && ke(google.maps.event.addListener(de, "drag", k)), j && Je(google.maps.event.addListener(de, "clickable_changed", j)), _ && Bt(google.maps.event.addListener(de, "cursor_changed", _)), I && Yt(google.maps.event.addListener(de, "animation_changed", I)), R && It(google.maps.event.addListener(de, "draggable_changed", R)), V && fn(google.maps.event.addListener(de, "flat_changed", V)), J && pn(google.maps.event.addListener(de, "icon_changed", J)), G && Xt(google.maps.event.addListener(de, "position_changed", G)), te && hn(google.maps.event.addListener(de, "shape_changed", te)), Q && Bn(google.maps.event.addListener(de, "title_changed", Q)), T && Tn(google.maps.event.addListener(de, "visible_changed", T)), N && An(google.maps.event.addListener(de, "zindex_changed", N)), M(de), Y && Y(de), () => {
      z !== null && google.maps.event.removeListener(z), U !== null && google.maps.event.removeListener(U), ee !== null && google.maps.event.removeListener(ee), pe !== null && google.maps.event.removeListener(pe), le !== null && google.maps.event.removeListener(le), Fe !== null && google.maps.event.removeListener(Fe), Ne !== null && google.maps.event.removeListener(Ne), dt !== null && google.maps.event.removeListener(dt), ft !== null && google.maps.event.removeListener(ft), Ke !== null && google.maps.event.removeListener(Ke), Qe !== null && google.maps.event.removeListener(Qe), He !== null && google.maps.event.removeListener(He), Ft !== null && google.maps.event.removeListener(Ft), Wt !== null && google.maps.event.removeListener(Wt), Ht !== null && google.maps.event.removeListener(Ht), _t !== null && google.maps.event.removeListener(_t), Vt !== null && google.maps.event.removeListener(Vt), gn !== null && google.maps.event.removeListener(gn), vn !== null && google.maps.event.removeListener(vn), F && F(de), r ? r.removeMarker(de, !!o) : de && de.setMap(null);
    };
  }, []);
  var Vn = En(() => i ? zt.map(i, (Jt) => {
    if (!ts(Jt))
      return Jt;
    var de = Jt;
    return ns(de, {
      anchor: L
    });
  }) : null, [i, L]);
  return x.jsx(x.Fragment, {
    children: Vn
  }) || null;
}
Re(NI);
class MC extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var e = this;
    return OC(function* () {
      var n = ao(ao(ao({}, e.props.options || qa), e.props.clusterer ? qa : {
        map: e.context
      }), {}, {
        position: e.props.position
      });
      e.marker = new google.maps.Marker(n), e.props.clusterer ? e.props.clusterer.addMarker(e.marker, !!e.props.noClustererRedraw) : e.marker.setMap(e.context), e.registeredEvents = $e({
        updaterMap: Vv,
        eventMap: Hv,
        prevProps: {},
        nextProps: e.props,
        instance: e.marker
      }), e.props.onLoad && e.props.onLoad(e.marker);
    })();
  }
  componentDidUpdate(e) {
    this.marker && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: Vv,
      eventMap: Hv,
      prevProps: e,
      nextProps: this.props,
      instance: this.marker
    }));
  }
  componentWillUnmount() {
    this.marker && (this.props.onUnmount && this.props.onUnmount(this.marker), We(this.registeredEvents), this.props.clusterer ? this.props.clusterer.removeMarker(this.marker, !!this.props.noClustererRedraw) : this.marker && this.marker.setMap(null));
  }
  render() {
    var e = this.props.children ? zt.map(this.props.children, (n) => {
      if (!ts(n))
        return n;
      var r = n;
      return ns(r, {
        anchor: this.marker
      });
    }) : null;
    return e || null;
  }
}
oe(MC, "contextType", Ae);
var $I = (
  /** @class */
  function() {
    function t(e, n) {
      e.getClusterer().extend(t, google.maps.OverlayView), this.cluster = e, this.clusterClassName = this.cluster.getClusterer().getClusterClass(), this.className = this.clusterClassName, this.styles = n, this.center = void 0, this.div = null, this.sums = null, this.visible = !1, this.boundsChangedListener = null, this.url = "", this.height = 0, this.width = 0, this.anchorText = [0, 0], this.anchorIcon = [0, 0], this.textColor = "black", this.textSize = 11, this.textDecoration = "none", this.fontWeight = "bold", this.fontStyle = "normal", this.fontFamily = "Arial,sans-serif", this.backgroundPosition = "0 0", this.cMouseDownInCluster = null, this.cDraggingMapByCluster = null, this.timeOut = null, this.setMap(e.getMap()), this.onBoundsChanged = this.onBoundsChanged.bind(this), this.onMouseDown = this.onMouseDown.bind(this), this.onClick = this.onClick.bind(this), this.onMouseOver = this.onMouseOver.bind(this), this.onMouseOut = this.onMouseOut.bind(this), this.onAdd = this.onAdd.bind(this), this.onRemove = this.onRemove.bind(this), this.draw = this.draw.bind(this), this.hide = this.hide.bind(this), this.show = this.show.bind(this), this.useStyle = this.useStyle.bind(this), this.setCenter = this.setCenter.bind(this), this.getPosFromLatLng = this.getPosFromLatLng.bind(this);
    }
    return t.prototype.onBoundsChanged = function() {
      this.cDraggingMapByCluster = this.cMouseDownInCluster;
    }, t.prototype.onMouseDown = function() {
      this.cMouseDownInCluster = !0, this.cDraggingMapByCluster = !1;
    }, t.prototype.onClick = function(e) {
      if (this.cMouseDownInCluster = !1, !this.cDraggingMapByCluster) {
        var n = this.cluster.getClusterer();
        if (google.maps.event.trigger(n, "click", this.cluster), google.maps.event.trigger(n, "clusterclick", this.cluster), n.getZoomOnClick()) {
          var r = n.getMaxZoom(), o = this.cluster.getBounds(), i = n.getMap();
          i !== null && "fitBounds" in i && i.fitBounds(o), this.timeOut = window.setTimeout(function() {
            var a = n.getMap();
            if (a !== null) {
              "fitBounds" in a && a.fitBounds(o);
              var s = a.getZoom() || 0;
              r !== null && s > r && a.setZoom(r + 1);
            }
          }, 100);
        }
        e.cancelBubble = !0, e.stopPropagation && e.stopPropagation();
      }
    }, t.prototype.onMouseOver = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseover", this.cluster);
    }, t.prototype.onMouseOut = function() {
      google.maps.event.trigger(this.cluster.getClusterer(), "mouseout", this.cluster);
    }, t.prototype.onAdd = function() {
      var e;
      this.div = document.createElement("div"), this.div.className = this.className, this.visible && this.show(), (e = this.getPanes()) === null || e === void 0 || e.overlayMouseTarget.appendChild(this.div);
      var n = this.getMap();
      n !== null && (this.boundsChangedListener = google.maps.event.addListener(n, "bounds_changed", this.onBoundsChanged), this.div.addEventListener("mousedown", this.onMouseDown), this.div.addEventListener("click", this.onClick), this.div.addEventListener("mouseover", this.onMouseOver), this.div.addEventListener("mouseout", this.onMouseOut));
    }, t.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.hide(), this.boundsChangedListener !== null && google.maps.event.removeListener(this.boundsChangedListener), this.div.removeEventListener("mousedown", this.onMouseDown), this.div.removeEventListener("click", this.onClick), this.div.removeEventListener("mouseover", this.onMouseOver), this.div.removeEventListener("mouseout", this.onMouseOut), this.div.parentNode.removeChild(this.div), this.timeOut !== null && (window.clearTimeout(this.timeOut), this.timeOut = null), this.div = null);
    }, t.prototype.draw = function() {
      if (this.visible && this.div !== null && this.center) {
        var e = this.getPosFromLatLng(this.center);
        this.div.style.top = e !== null ? "".concat(e.y, "px") : "0", this.div.style.left = e !== null ? "".concat(e.x, "px") : "0";
      }
    }, t.prototype.hide = function() {
      this.div && (this.div.style.display = "none"), this.visible = !1;
    }, t.prototype.show = function() {
      var e, n, r, o, i, a;
      if (this.div && this.center) {
        var s = this.sums === null || typeof this.sums.title > "u" || this.sums.title === "" ? this.cluster.getClusterer().getTitle() : this.sums.title, l = this.backgroundPosition.split(" "), u = parseInt(((e = l[0]) === null || e === void 0 ? void 0 : e.replace(/^\s+|\s+$/g, "")) || "0", 10), c = parseInt(((n = l[1]) === null || n === void 0 ? void 0 : n.replace(/^\s+|\s+$/g, "")) || "0", 10), d = this.getPosFromLatLng(this.center);
        this.div.className = this.className, this.div.setAttribute("style", "cursor: pointer; position: absolute; top: ".concat(d !== null ? "".concat(d.y, "px") : "0", "; left: ").concat(d !== null ? "".concat(d.x, "px") : "0", "; width: ").concat(this.width, "px; height: ").concat(this.height, "px; "));
        var f = document.createElement("img");
        f.alt = s, f.src = this.url, f.width = this.width, f.height = this.height, f.setAttribute("style", "position: absolute; top: ".concat(c, "px; left: ").concat(u, "px")), this.cluster.getClusterer().enableRetinaIcons || (f.style.clip = "rect(-".concat(c, "px, -").concat(u + this.width, "px, -").concat(c + this.height, ", -").concat(u, ")"));
        var v = document.createElement("div");
        v.setAttribute("style", "position: absolute; top: ".concat(this.anchorText[0], "px; left: ").concat(this.anchorText[1], "px; color: ").concat(this.textColor, "; font-size: ").concat(this.textSize, "px; font-family: ").concat(this.fontFamily, "; font-weight: ").concat(this.fontWeight, "; fontStyle: ").concat(this.fontStyle, "; text-decoration: ").concat(this.textDecoration, "; text-align: center; width: ").concat(this.width, "px; line-height: ").concat(this.height, "px")), !((r = this.sums) === null || r === void 0) && r.text && (v.innerText = "".concat((o = this.sums) === null || o === void 0 ? void 0 : o.text)), !((i = this.sums) === null || i === void 0) && i.html && (v.innerHTML = "".concat((a = this.sums) === null || a === void 0 ? void 0 : a.html)), this.div.innerHTML = "", this.div.appendChild(f), this.div.appendChild(v), this.div.title = s, this.div.style.display = "";
      }
      this.visible = !0;
    }, t.prototype.useStyle = function(e) {
      this.sums = e;
      var n = this.cluster.getClusterer().getStyles(), r = n[Math.min(n.length - 1, Math.max(0, e.index - 1))];
      r && (this.url = r.url, this.height = r.height, this.width = r.width, r.className && (this.className = "".concat(this.clusterClassName, " ").concat(r.className)), this.anchorText = r.anchorText || [0, 0], this.anchorIcon = r.anchorIcon || [this.height / 2, this.width / 2], this.textColor = r.textColor || "black", this.textSize = r.textSize || 11, this.textDecoration = r.textDecoration || "none", this.fontWeight = r.fontWeight || "bold", this.fontStyle = r.fontStyle || "normal", this.fontFamily = r.fontFamily || "Arial,sans-serif", this.backgroundPosition = r.backgroundPosition || "0 0");
    }, t.prototype.setCenter = function(e) {
      this.center = e;
    }, t.prototype.getPosFromLatLng = function(e) {
      var n = this.getProjection().fromLatLngToDivPixel(e);
      return n !== null && (n.x -= this.anchorIcon[1], n.y -= this.anchorIcon[0]), n;
    }, t;
  }()
), zI = (
  /** @class */
  function() {
    function t(e) {
      this.markerClusterer = e, this.map = this.markerClusterer.getMap(), this.gridSize = this.markerClusterer.getGridSize(), this.minClusterSize = this.markerClusterer.getMinimumClusterSize(), this.averageCenter = this.markerClusterer.getAverageCenter(), this.markers = [], this.center = void 0, this.bounds = null, this.clusterIcon = new $I(this, this.markerClusterer.getStyles()), this.getSize = this.getSize.bind(this), this.getMarkers = this.getMarkers.bind(this), this.getCenter = this.getCenter.bind(this), this.getMap = this.getMap.bind(this), this.getClusterer = this.getClusterer.bind(this), this.getBounds = this.getBounds.bind(this), this.remove = this.remove.bind(this), this.addMarker = this.addMarker.bind(this), this.isMarkerInClusterBounds = this.isMarkerInClusterBounds.bind(this), this.calculateBounds = this.calculateBounds.bind(this), this.updateIcon = this.updateIcon.bind(this), this.isMarkerAlreadyAdded = this.isMarkerAlreadyAdded.bind(this);
    }
    return t.prototype.getSize = function() {
      return this.markers.length;
    }, t.prototype.getMarkers = function() {
      return this.markers;
    }, t.prototype.getCenter = function() {
      return this.center;
    }, t.prototype.getMap = function() {
      return this.map;
    }, t.prototype.getClusterer = function() {
      return this.markerClusterer;
    }, t.prototype.getBounds = function() {
      for (var e = new google.maps.LatLngBounds(this.center, this.center), n = this.getMarkers(), r = 0, o = n; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && e.extend(a);
      }
      return e;
    }, t.prototype.remove = function() {
      this.clusterIcon.setMap(null), this.markers = [], delete this.markers;
    }, t.prototype.addMarker = function(e) {
      var n;
      if (this.isMarkerAlreadyAdded(e))
        return !1;
      if (this.center) {
        if (this.averageCenter) {
          var r = e.getPosition();
          if (r) {
            var o = this.markers.length + 1;
            this.center = new google.maps.LatLng((this.center.lat() * (o - 1) + r.lat()) / o, (this.center.lng() * (o - 1) + r.lng()) / o), this.calculateBounds();
          }
        }
      } else {
        var r = e.getPosition();
        r && (this.center = r, this.calculateBounds());
      }
      e.isAdded = !0, this.markers.push(e);
      var i = this.markers.length, a = this.markerClusterer.getMaxZoom(), s = (n = this.map) === null || n === void 0 ? void 0 : n.getZoom();
      if (a !== null && typeof s < "u" && s > a)
        e.getMap() !== this.map && e.setMap(this.map);
      else if (i < this.minClusterSize)
        e.getMap() !== this.map && e.setMap(this.map);
      else if (i === this.minClusterSize)
        for (var l = 0, u = this.markers; l < u.length; l++) {
          var c = u[l];
          c.setMap(null);
        }
      else
        e.setMap(null);
      return !0;
    }, t.prototype.isMarkerInClusterBounds = function(e) {
      if (this.bounds !== null) {
        var n = e.getPosition();
        if (n)
          return this.bounds.contains(n);
      }
      return !1;
    }, t.prototype.calculateBounds = function() {
      this.bounds = this.markerClusterer.getExtendedBounds(new google.maps.LatLngBounds(this.center, this.center));
    }, t.prototype.updateIcon = function() {
      var e, n = this.markers.length, r = this.markerClusterer.getMaxZoom(), o = (e = this.map) === null || e === void 0 ? void 0 : e.getZoom();
      if (r !== null && typeof o < "u" && o > r) {
        this.clusterIcon.hide();
        return;
      }
      if (n < this.minClusterSize) {
        this.clusterIcon.hide();
        return;
      }
      this.center && this.clusterIcon.setCenter(this.center), this.clusterIcon.useStyle(this.markerClusterer.getCalculator()(this.markers, this.markerClusterer.getStyles().length)), this.clusterIcon.show();
    }, t.prototype.isMarkerAlreadyAdded = function(e) {
      if (this.markers.includes)
        return this.markers.includes(e);
      for (var n = 0; n < this.markers.length; n++)
        if (e === this.markers[n])
          return !0;
      return !1;
    }, t;
  }()
);
function UI(t, e) {
  var n = t.length, r = n.toString().length, o = Math.min(r, e);
  return {
    text: n.toString(),
    index: o,
    title: ""
  };
}
var WI = 2e3, HI = 500, VI = "https://developers.google.com/maps/documentation/javascript/examples/markerclusterer/m", qI = "png", GI = [53, 56, 66, 78, 90], ZI = "cluster", BC = (
  /** @class */
  function() {
    function t(e, n, r) {
      n === void 0 && (n = []), r === void 0 && (r = {}), this.getMinimumClusterSize = this.getMinimumClusterSize.bind(this), this.setMinimumClusterSize = this.setMinimumClusterSize.bind(this), this.getEnableRetinaIcons = this.getEnableRetinaIcons.bind(this), this.setEnableRetinaIcons = this.setEnableRetinaIcons.bind(this), this.addToClosestCluster = this.addToClosestCluster.bind(this), this.getImageExtension = this.getImageExtension.bind(this), this.setImageExtension = this.setImageExtension.bind(this), this.getExtendedBounds = this.getExtendedBounds.bind(this), this.getAverageCenter = this.getAverageCenter.bind(this), this.setAverageCenter = this.setAverageCenter.bind(this), this.getTotalClusters = this.getTotalClusters.bind(this), this.fitMapToMarkers = this.fitMapToMarkers.bind(this), this.getIgnoreHidden = this.getIgnoreHidden.bind(this), this.setIgnoreHidden = this.setIgnoreHidden.bind(this), this.getClusterClass = this.getClusterClass.bind(this), this.setClusterClass = this.setClusterClass.bind(this), this.getTotalMarkers = this.getTotalMarkers.bind(this), this.getZoomOnClick = this.getZoomOnClick.bind(this), this.setZoomOnClick = this.setZoomOnClick.bind(this), this.getBatchSizeIE = this.getBatchSizeIE.bind(this), this.setBatchSizeIE = this.setBatchSizeIE.bind(this), this.createClusters = this.createClusters.bind(this), this.onZoomChanged = this.onZoomChanged.bind(this), this.getImageSizes = this.getImageSizes.bind(this), this.setImageSizes = this.setImageSizes.bind(this), this.getCalculator = this.getCalculator.bind(this), this.setCalculator = this.setCalculator.bind(this), this.removeMarkers = this.removeMarkers.bind(this), this.resetViewport = this.resetViewport.bind(this), this.getImagePath = this.getImagePath.bind(this), this.setImagePath = this.setImagePath.bind(this), this.pushMarkerTo = this.pushMarkerTo.bind(this), this.removeMarker = this.removeMarker.bind(this), this.clearMarkers = this.clearMarkers.bind(this), this.setupStyles = this.setupStyles.bind(this), this.getGridSize = this.getGridSize.bind(this), this.setGridSize = this.setGridSize.bind(this), this.getClusters = this.getClusters.bind(this), this.getMaxZoom = this.getMaxZoom.bind(this), this.setMaxZoom = this.setMaxZoom.bind(this), this.getMarkers = this.getMarkers.bind(this), this.addMarkers = this.addMarkers.bind(this), this.getStyles = this.getStyles.bind(this), this.setStyles = this.setStyles.bind(this), this.addMarker = this.addMarker.bind(this), this.onRemove = this.onRemove.bind(this), this.getTitle = this.getTitle.bind(this), this.setTitle = this.setTitle.bind(this), this.repaint = this.repaint.bind(this), this.onIdle = this.onIdle.bind(this), this.redraw = this.redraw.bind(this), this.onAdd = this.onAdd.bind(this), this.draw = this.draw.bind(this), this.extend = this.extend.bind(this), this.extend(t, google.maps.OverlayView), this.markers = [], this.clusters = [], this.listeners = [], this.activeMap = null, this.ready = !1, this.gridSize = r.gridSize || 60, this.minClusterSize = r.minimumClusterSize || 2, this.maxZoom = r.maxZoom || null, this.styles = r.styles || [], this.title = r.title || "", this.zoomOnClick = !0, r.zoomOnClick !== void 0 && (this.zoomOnClick = r.zoomOnClick), this.averageCenter = !1, r.averageCenter !== void 0 && (this.averageCenter = r.averageCenter), this.ignoreHidden = !1, r.ignoreHidden !== void 0 && (this.ignoreHidden = r.ignoreHidden), this.enableRetinaIcons = !1, r.enableRetinaIcons !== void 0 && (this.enableRetinaIcons = r.enableRetinaIcons), this.imagePath = r.imagePath || VI, this.imageExtension = r.imageExtension || qI, this.imageSizes = r.imageSizes || GI, this.calculator = r.calculator || UI, this.batchSize = r.batchSize || WI, this.batchSizeIE = r.batchSizeIE || HI, this.clusterClass = r.clusterClass || ZI, navigator.userAgent.toLowerCase().indexOf("msie") !== -1 && (this.batchSize = this.batchSizeIE), this.timerRefStatic = null, this.setupStyles(), this.addMarkers(n, !0), this.setMap(e);
    }
    return t.prototype.onZoomChanged = function() {
      var e, n;
      this.resetViewport(!1), (((e = this.getMap()) === null || e === void 0 ? void 0 : e.getZoom()) === (this.get("minZoom") || 0) || ((n = this.getMap()) === null || n === void 0 ? void 0 : n.getZoom()) === this.get("maxZoom")) && google.maps.event.trigger(this, "idle");
    }, t.prototype.onIdle = function() {
      this.redraw();
    }, t.prototype.onAdd = function() {
      var e = this.getMap();
      this.activeMap = e, this.ready = !0, this.repaint(), e !== null && (this.listeners = [google.maps.event.addListener(e, "zoom_changed", this.onZoomChanged), google.maps.event.addListener(e, "idle", this.onIdle)]);
    }, t.prototype.onRemove = function() {
      for (var e = 0, n = this.markers; e < n.length; e++) {
        var r = n[e];
        r.getMap() !== this.activeMap && r.setMap(this.activeMap);
      }
      for (var o = 0, i = this.clusters; o < i.length; o++) {
        var a = i[o];
        a.remove();
      }
      this.clusters = [];
      for (var s = 0, l = this.listeners; s < l.length; s++) {
        var u = l[s];
        google.maps.event.removeListener(u);
      }
      this.listeners = [], this.activeMap = null, this.ready = !1;
    }, t.prototype.draw = function() {
    }, t.prototype.getMap = function() {
      return null;
    }, t.prototype.getPanes = function() {
      return null;
    }, t.prototype.getProjection = function() {
      return {
        fromContainerPixelToLatLng: function() {
          return null;
        },
        fromDivPixelToLatLng: function() {
          return null;
        },
        fromLatLngToContainerPixel: function() {
          return null;
        },
        fromLatLngToDivPixel: function() {
          return null;
        },
        getVisibleRegion: function() {
          return null;
        },
        getWorldWidth: function() {
          return 0;
        }
      };
    }, t.prototype.setMap = function() {
    }, t.prototype.addListener = function() {
      return {
        remove: function() {
        }
      };
    }, t.prototype.bindTo = function() {
    }, t.prototype.get = function() {
    }, t.prototype.notify = function() {
    }, t.prototype.set = function() {
    }, t.prototype.setValues = function() {
    }, t.prototype.unbind = function() {
    }, t.prototype.unbindAll = function() {
    }, t.prototype.setupStyles = function() {
      if (!(this.styles.length > 0))
        for (var e = 0; e < this.imageSizes.length; e++)
          this.styles.push({
            url: "".concat(this.imagePath + (e + 1), ".").concat(this.imageExtension),
            height: this.imageSizes[e] || 0,
            width: this.imageSizes[e] || 0
          });
    }, t.prototype.fitMapToMarkers = function() {
      for (var e = this.getMarkers(), n = new google.maps.LatLngBounds(), r = 0, o = e; r < o.length; r++) {
        var i = o[r], a = i.getPosition();
        a && n.extend(a);
      }
      var s = this.getMap();
      s !== null && "fitBounds" in s && s.fitBounds(n);
    }, t.prototype.getGridSize = function() {
      return this.gridSize;
    }, t.prototype.setGridSize = function(e) {
      this.gridSize = e;
    }, t.prototype.getMinimumClusterSize = function() {
      return this.minClusterSize;
    }, t.prototype.setMinimumClusterSize = function(e) {
      this.minClusterSize = e;
    }, t.prototype.getMaxZoom = function() {
      return this.maxZoom;
    }, t.prototype.setMaxZoom = function(e) {
      this.maxZoom = e;
    }, t.prototype.getStyles = function() {
      return this.styles;
    }, t.prototype.setStyles = function(e) {
      this.styles = e;
    }, t.prototype.getTitle = function() {
      return this.title;
    }, t.prototype.setTitle = function(e) {
      this.title = e;
    }, t.prototype.getZoomOnClick = function() {
      return this.zoomOnClick;
    }, t.prototype.setZoomOnClick = function(e) {
      this.zoomOnClick = e;
    }, t.prototype.getAverageCenter = function() {
      return this.averageCenter;
    }, t.prototype.setAverageCenter = function(e) {
      this.averageCenter = e;
    }, t.prototype.getIgnoreHidden = function() {
      return this.ignoreHidden;
    }, t.prototype.setIgnoreHidden = function(e) {
      this.ignoreHidden = e;
    }, t.prototype.getEnableRetinaIcons = function() {
      return this.enableRetinaIcons;
    }, t.prototype.setEnableRetinaIcons = function(e) {
      this.enableRetinaIcons = e;
    }, t.prototype.getImageExtension = function() {
      return this.imageExtension;
    }, t.prototype.setImageExtension = function(e) {
      this.imageExtension = e;
    }, t.prototype.getImagePath = function() {
      return this.imagePath;
    }, t.prototype.setImagePath = function(e) {
      this.imagePath = e;
    }, t.prototype.getImageSizes = function() {
      return this.imageSizes;
    }, t.prototype.setImageSizes = function(e) {
      this.imageSizes = e;
    }, t.prototype.getCalculator = function() {
      return this.calculator;
    }, t.prototype.setCalculator = function(e) {
      this.calculator = e;
    }, t.prototype.getBatchSizeIE = function() {
      return this.batchSizeIE;
    }, t.prototype.setBatchSizeIE = function(e) {
      this.batchSizeIE = e;
    }, t.prototype.getClusterClass = function() {
      return this.clusterClass;
    }, t.prototype.setClusterClass = function(e) {
      this.clusterClass = e;
    }, t.prototype.getMarkers = function() {
      return this.markers;
    }, t.prototype.getTotalMarkers = function() {
      return this.markers.length;
    }, t.prototype.getClusters = function() {
      return this.clusters;
    }, t.prototype.getTotalClusters = function() {
      return this.clusters.length;
    }, t.prototype.addMarker = function(e, n) {
      this.pushMarkerTo(e), n || this.redraw();
    }, t.prototype.addMarkers = function(e, n) {
      for (var r in e)
        if (Object.prototype.hasOwnProperty.call(e, r)) {
          var o = e[r];
          o && this.pushMarkerTo(o);
        }
      n || this.redraw();
    }, t.prototype.pushMarkerTo = function(e) {
      var n = this;
      e.getDraggable() && google.maps.event.addListener(e, "dragend", function() {
        n.ready && (e.isAdded = !1, n.repaint());
      }), e.isAdded = !1, this.markers.push(e);
    }, t.prototype.removeMarker_ = function(e) {
      var n = -1;
      if (this.markers.indexOf)
        n = this.markers.indexOf(e);
      else
        for (var r = 0; r < this.markers.length; r++)
          if (e === this.markers[r]) {
            n = r;
            break;
          }
      return n === -1 ? !1 : (e.setMap(null), this.markers.splice(n, 1), !0);
    }, t.prototype.removeMarker = function(e, n) {
      var r = this.removeMarker_(e);
      return !n && r && this.repaint(), r;
    }, t.prototype.removeMarkers = function(e, n) {
      for (var r = !1, o = 0, i = e; o < i.length; o++) {
        var a = i[o];
        r = r || this.removeMarker_(a);
      }
      return !n && r && this.repaint(), r;
    }, t.prototype.clearMarkers = function() {
      this.resetViewport(!0), this.markers = [];
    }, t.prototype.repaint = function() {
      var e = this.clusters.slice();
      this.clusters = [], this.resetViewport(!1), this.redraw(), setTimeout(function() {
        for (var r = 0, o = e; r < o.length; r++) {
          var i = o[r];
          i.remove();
        }
      }, 0);
    }, t.prototype.getExtendedBounds = function(e) {
      var n = this.getProjection(), r = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(e.getNorthEast().lat(), e.getNorthEast().lng())
      );
      r !== null && (r.x += this.gridSize, r.y -= this.gridSize);
      var o = n.fromLatLngToDivPixel(
        // Turn the bounds into latlng.
        new google.maps.LatLng(e.getSouthWest().lat(), e.getSouthWest().lng())
      );
      if (o !== null && (o.x -= this.gridSize, o.y += this.gridSize), r !== null) {
        var i = n.fromDivPixelToLatLng(r);
        i !== null && e.extend(i);
      }
      if (o !== null) {
        var a = n.fromDivPixelToLatLng(o);
        a !== null && e.extend(a);
      }
      return e;
    }, t.prototype.redraw = function() {
      this.createClusters(0);
    }, t.prototype.resetViewport = function(e) {
      for (var n = 0, r = this.clusters; n < r.length; n++) {
        var o = r[n];
        o.remove();
      }
      this.clusters = [];
      for (var i = 0, a = this.markers; i < a.length; i++) {
        var s = a[i];
        s.isAdded = !1, e && s.setMap(null);
      }
    }, t.prototype.distanceBetweenPoints = function(e, n) {
      var r = 6371, o = (n.lat() - e.lat()) * Math.PI / 180, i = (n.lng() - e.lng()) * Math.PI / 180, a = Math.sin(o / 2) * Math.sin(o / 2) + Math.cos(e.lat() * Math.PI / 180) * Math.cos(n.lat() * Math.PI / 180) * Math.sin(i / 2) * Math.sin(i / 2);
      return r * (2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)));
    }, t.prototype.isMarkerInBounds = function(e, n) {
      var r = e.getPosition();
      return r ? n.contains(r) : !1;
    }, t.prototype.addToClosestCluster = function(e) {
      for (var n, r = 4e4, o = null, i = 0, a = this.clusters; i < a.length; i++) {
        var s = a[i];
        n = s;
        var l = n.getCenter(), u = e.getPosition();
        if (l && u) {
          var c = this.distanceBetweenPoints(l, u);
          c < r && (r = c, o = n);
        }
      }
      o && o.isMarkerInClusterBounds(e) ? o.addMarker(e) : (n = new zI(this), n.addMarker(e), this.clusters.push(n));
    }, t.prototype.createClusters = function(e) {
      var n = this;
      if (this.ready) {
        e === 0 && (google.maps.event.trigger(this, "clusteringbegin", this), this.timerRefStatic !== null && (window.clearTimeout(this.timerRefStatic), delete this.timerRefStatic));
        for (var r = this.getMap(), o = r !== null && ("getBounds" in r) ? r.getBounds() : null, i = (r == null ? void 0 : r.getZoom()) || 0, a = i > 3 ? new google.maps.LatLngBounds(o == null ? void 0 : o.getSouthWest(), o == null ? void 0 : o.getNorthEast()) : new google.maps.LatLngBounds(new google.maps.LatLng(85.02070771743472, -178.48388434375), new google.maps.LatLng(-85.08136444384544, 178.00048865625)), s = this.getExtendedBounds(a), l = Math.min(e + this.batchSize, this.markers.length), u = e; u < l; u++) {
          var c = this.markers[u];
          c && !c.isAdded && this.isMarkerInBounds(c, s) && (!this.ignoreHidden || this.ignoreHidden && c.getVisible()) && this.addToClosestCluster(c);
        }
        if (l < this.markers.length)
          this.timerRefStatic = window.setTimeout(function() {
            n.createClusters(l);
          }, 0);
        else {
          this.timerRefStatic = null, google.maps.event.trigger(this, "clusteringend", this);
          for (var d = 0, f = this.clusters; d < f.length; d++) {
            var v = f[d];
            v.updateIcon();
          }
        }
      }
    }, t.prototype.extend = function(e, n) {
      return (function(o) {
        for (var i in o.prototype) {
          var a = i;
          this.prototype[a] = o.prototype[a];
        }
        return this;
      }).apply(e, [n]);
    }, t;
  }()
);
function qv(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function KI(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? qv(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : qv(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Pn = {
  onClick: "click",
  onClusteringBegin: "clusteringbegin",
  onClusteringEnd: "clusteringend",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover"
}, Xe = {
  averageCenter(t, e) {
    t.setAverageCenter(e);
  },
  batchSizeIE(t, e) {
    t.setBatchSizeIE(e);
  },
  calculator(t, e) {
    t.setCalculator(e);
  },
  clusterClass(t, e) {
    t.setClusterClass(e);
  },
  enableRetinaIcons(t, e) {
    t.setEnableRetinaIcons(e);
  },
  gridSize(t, e) {
    t.setGridSize(e);
  },
  ignoreHidden(t, e) {
    t.setIgnoreHidden(e);
  },
  imageExtension(t, e) {
    t.setImageExtension(e);
  },
  imagePath(t, e) {
    t.setImagePath(e);
  },
  imageSizes(t, e) {
    t.setImageSizes(e);
  },
  maxZoom(t, e) {
    t.setMaxZoom(e);
  },
  minimumClusterSize(t, e) {
    t.setMinimumClusterSize(e);
  },
  styles(t, e) {
    t.setStyles(e);
  },
  title(t, e) {
    t.setTitle(e);
  },
  zoomOnClick(t, e) {
    t.setZoomOnClick(e);
  }
}, YI = {};
function XI(t) {
  var {
    children: e,
    options: n,
    averageCenter: r,
    batchSizeIE: o,
    calculator: i,
    clusterClass: a,
    enableRetinaIcons: s,
    gridSize: l,
    ignoreHidden: u,
    imageExtension: c,
    imagePath: d,
    imageSizes: f,
    maxZoom: v,
    minimumClusterSize: h,
    styles: g,
    title: p,
    zoomOnClick: w,
    onClick: b,
    onClusteringBegin: k,
    onClusteringEnd: E,
    onMouseOver: m,
    onMouseOut: O,
    onLoad: S,
    onUnmount: W
  } = t, [P, $] = B(null), j = Ee(Ae), [_, I] = B(null), [R, V] = B(null), [J, G] = B(null), [te, Q] = B(null), [T, N] = B(null);
  return y(() => {
    P && O && (te !== null && google.maps.event.removeListener(te), Q(google.maps.event.addListener(P, Pn.onMouseOut, O)));
  }, [O]), y(() => {
    P && m && (T !== null && google.maps.event.removeListener(T), N(google.maps.event.addListener(P, Pn.onMouseOver, m)));
  }, [m]), y(() => {
    P && b && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(P, Pn.onClick, b)));
  }, [b]), y(() => {
    P && k && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(P, Pn.onClusteringBegin, k)));
  }, [k]), y(() => {
    P && E && (J !== null && google.maps.event.removeListener(J), V(google.maps.event.addListener(P, Pn.onClusteringEnd, E)));
  }, [E]), y(() => {
    typeof r < "u" && P !== null && Xe.averageCenter(P, r);
  }, [P, r]), y(() => {
    typeof o < "u" && P !== null && Xe.batchSizeIE(P, o);
  }, [P, o]), y(() => {
    typeof i < "u" && P !== null && Xe.calculator(P, i);
  }, [P, i]), y(() => {
    typeof a < "u" && P !== null && Xe.clusterClass(P, a);
  }, [P, a]), y(() => {
    typeof s < "u" && P !== null && Xe.enableRetinaIcons(P, s);
  }, [P, s]), y(() => {
    typeof l < "u" && P !== null && Xe.gridSize(P, l);
  }, [P, l]), y(() => {
    typeof u < "u" && P !== null && Xe.ignoreHidden(P, u);
  }, [P, u]), y(() => {
    typeof c < "u" && P !== null && Xe.imageExtension(P, c);
  }, [P, c]), y(() => {
    typeof d < "u" && P !== null && Xe.imagePath(P, d);
  }, [P, d]), y(() => {
    typeof f < "u" && P !== null && Xe.imageSizes(P, f);
  }, [P, f]), y(() => {
    typeof v < "u" && P !== null && Xe.maxZoom(P, v);
  }, [P, v]), y(() => {
    typeof h < "u" && P !== null && Xe.minimumClusterSize(P, h);
  }, [P, h]), y(() => {
    typeof g < "u" && P !== null && Xe.styles(P, g);
  }, [P, g]), y(() => {
    typeof p < "u" && P !== null && Xe.title(P, p);
  }, [P, p]), y(() => {
    typeof w < "u" && P !== null && Xe.zoomOnClick(P, w);
  }, [P, w]), y(() => {
    if (j) {
      var Y = KI({}, n || YI), F = new BC(j, [], Y);
      return r && Xe.averageCenter(F, r), o && Xe.batchSizeIE(F, o), i && Xe.calculator(F, i), a && Xe.clusterClass(F, a), s && Xe.enableRetinaIcons(F, s), l && Xe.gridSize(F, l), u && Xe.ignoreHidden(F, u), c && Xe.imageExtension(F, c), d && Xe.imagePath(F, d), f && Xe.imageSizes(F, f), v && Xe.maxZoom(F, v), h && Xe.minimumClusterSize(F, h), g && Xe.styles(F, g), p && Xe.title(F, p), w && Xe.zoomOnClick(F, w), O && Q(google.maps.event.addListener(F, Pn.onMouseOut, O)), m && N(google.maps.event.addListener(F, Pn.onMouseOver, m)), b && I(google.maps.event.addListener(F, Pn.onClick, b)), k && V(google.maps.event.addListener(F, Pn.onClusteringBegin, k)), E && G(google.maps.event.addListener(F, Pn.onClusteringEnd, E)), $(F), S && S(F), () => {
        te !== null && google.maps.event.removeListener(te), T !== null && google.maps.event.removeListener(T), _ !== null && google.maps.event.removeListener(_), R !== null && google.maps.event.removeListener(R), J !== null && google.maps.event.removeListener(J), W && W(F);
      };
    }
  }, []), P !== null && e(P) || null;
}
Re(XI);
class JI extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "state", {
      markerClusterer: null
    }), oe(this, "setClustererCallback", () => {
      this.state.markerClusterer !== null && this.props.onLoad && this.props.onLoad(this.state.markerClusterer);
    });
  }
  componentDidMount() {
    if (this.context) {
      var e = new BC(this.context, [], this.props.options);
      this.registeredEvents = $e({
        updaterMap: Xe,
        eventMap: Pn,
        prevProps: {},
        nextProps: this.props,
        instance: e
      }), this.setState(() => ({
        markerClusterer: e
      }), this.setClustererCallback);
    }
  }
  componentDidUpdate(e) {
    this.state.markerClusterer && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: Xe,
      eventMap: Pn,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.markerClusterer
    }));
  }
  componentWillUnmount() {
    this.state.markerClusterer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.markerClusterer), We(this.registeredEvents), this.state.markerClusterer.setMap(null));
  }
  render() {
    return this.state.markerClusterer !== null ? this.props.children(this.state.markerClusterer) : null;
  }
}
oe(JI, "contextType", Ae);
function Gv(t) {
  t.cancelBubble = !0, t.stopPropagation && t.stopPropagation();
}
var TC = (
  /** @class */
  function() {
    function t(e) {
      e === void 0 && (e = {}), this.getCloseClickHandler = this.getCloseClickHandler.bind(this), this.closeClickHandler = this.closeClickHandler.bind(this), this.createInfoBoxDiv = this.createInfoBoxDiv.bind(this), this.addClickHandler = this.addClickHandler.bind(this), this.getCloseBoxImg = this.getCloseBoxImg.bind(this), this.getBoxWidths = this.getBoxWidths.bind(this), this.setBoxStyle = this.setBoxStyle.bind(this), this.setPosition = this.setPosition.bind(this), this.getPosition = this.getPosition.bind(this), this.setOptions = this.setOptions.bind(this), this.setContent = this.setContent.bind(this), this.setVisible = this.setVisible.bind(this), this.getContent = this.getContent.bind(this), this.getVisible = this.getVisible.bind(this), this.setZIndex = this.setZIndex.bind(this), this.getZIndex = this.getZIndex.bind(this), this.onRemove = this.onRemove.bind(this), this.panBox = this.panBox.bind(this), this.extend = this.extend.bind(this), this.close = this.close.bind(this), this.draw = this.draw.bind(this), this.show = this.show.bind(this), this.hide = this.hide.bind(this), this.open = this.open.bind(this), this.extend(t, google.maps.OverlayView), this.content = e.content || "", this.disableAutoPan = e.disableAutoPan || !1, this.maxWidth = e.maxWidth || 0, this.pixelOffset = e.pixelOffset || new google.maps.Size(0, 0), this.position = e.position || new google.maps.LatLng(0, 0), this.zIndex = e.zIndex || null, this.boxClass = e.boxClass || "infoBox", this.boxStyle = e.boxStyle || {}, this.closeBoxMargin = e.closeBoxMargin || "2px", this.closeBoxURL = e.closeBoxURL || "http://www.google.com/intl/en_us/mapfiles/close.gif", e.closeBoxURL === "" && (this.closeBoxURL = ""), this.infoBoxClearance = e.infoBoxClearance || new google.maps.Size(1, 1), typeof e.visible > "u" && (typeof e.isHidden > "u" ? e.visible = !0 : e.visible = !e.isHidden), this.isHidden = !e.visible, this.alignBottom = e.alignBottom || !1, this.pane = e.pane || "floatPane", this.enableEventPropagation = e.enableEventPropagation || !1, this.div = null, this.closeListener = null, this.moveListener = null, this.mapListener = null, this.contextListener = null, this.eventListeners = null, this.fixedWidthSet = null;
    }
    return t.prototype.createInfoBoxDiv = function() {
      var e = this, n = function(c) {
        c.returnValue = !1, c.preventDefault && c.preventDefault(), e.enableEventPropagation || Gv(c);
      };
      if (!this.div) {
        this.div = document.createElement("div"), this.setBoxStyle(), typeof this.content == "string" ? this.div.innerHTML = this.getCloseBoxImg() + this.content : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(this.content));
        var r = this.getPanes();
        if (r !== null && r[this.pane].appendChild(this.div), this.addClickHandler(), this.div.style.width)
          this.fixedWidthSet = !0;
        else if (this.maxWidth !== 0 && this.div.offsetWidth > this.maxWidth)
          this.div.style.width = this.maxWidth + "px", this.fixedWidthSet = !0;
        else {
          var o = this.getBoxWidths();
          this.div.style.width = this.div.offsetWidth - o.left - o.right + "px", this.fixedWidthSet = !1;
        }
        if (this.panBox(this.disableAutoPan), !this.enableEventPropagation) {
          this.eventListeners = [];
          for (var i = ["mousedown", "mouseover", "mouseout", "mouseup", "click", "dblclick", "touchstart", "touchend", "touchmove"], a = 0, s = i; a < s.length; a++) {
            var l = s[a];
            this.eventListeners.push(google.maps.event.addListener(this.div, l, Gv));
          }
          this.eventListeners.push(google.maps.event.addListener(this.div, "mouseover", function() {
            e.div && (e.div.style.cursor = "default");
          }));
        }
        this.contextListener = google.maps.event.addListener(this.div, "contextmenu", n), google.maps.event.trigger(this, "domready");
      }
    }, t.prototype.getCloseBoxImg = function() {
      var e = "";
      return this.closeBoxURL !== "" && (e = '<img alt=""', e += ' aria-hidden="true"', e += " src='" + this.closeBoxURL + "'", e += " align=right", e += " style='", e += " position: relative;", e += " cursor: pointer;", e += " margin: " + this.closeBoxMargin + ";", e += "'>"), e;
    }, t.prototype.addClickHandler = function() {
      this.closeListener = this.div && this.div.firstChild && this.closeBoxURL !== "" ? google.maps.event.addListener(this.div.firstChild, "click", this.getCloseClickHandler()) : null;
    }, t.prototype.closeClickHandler = function(e) {
      e.cancelBubble = !0, e.stopPropagation && e.stopPropagation(), google.maps.event.trigger(this, "closeclick"), this.close();
    }, t.prototype.getCloseClickHandler = function() {
      return this.closeClickHandler;
    }, t.prototype.panBox = function(e) {
      if (this.div && !e) {
        var n = this.getMap();
        if (n instanceof google.maps.Map) {
          var r = 0, o = 0, i = n.getBounds();
          i && !i.contains(this.position) && n.setCenter(this.position);
          var a = n.getDiv(), s = a.offsetWidth, l = a.offsetHeight, u = this.pixelOffset.width, c = this.pixelOffset.height, d = this.div.offsetWidth, f = this.div.offsetHeight, v = this.infoBoxClearance.width, h = this.infoBoxClearance.height, g = this.getProjection(), p = g.fromLatLngToContainerPixel(this.position);
          p !== null && (p.x < -u + v ? r = p.x + u - v : p.x + d + u + v > s && (r = p.x + d + u + v - s), this.alignBottom ? p.y < -c + h + f ? o = p.y + c - h - f : p.y + c + h > l && (o = p.y + c + h - l) : p.y < -c + h ? o = p.y + c - h : p.y + f + c + h > l && (o = p.y + f + c + h - l)), r === 0 && o === 0 || n.panBy(r, o);
        }
      }
    }, t.prototype.setBoxStyle = function() {
      if (this.div) {
        this.div.className = this.boxClass, this.div.style.cssText = "";
        var e = this.boxStyle;
        for (var n in e)
          Object.prototype.hasOwnProperty.call(e, n) && (this.div.style[n] = e[n]);
        if (this.div.style.webkitTransform = "translateZ(0)", typeof this.div.style.opacity < "u" && this.div.style.opacity !== "") {
          var r = parseFloat(this.div.style.opacity || "");
          this.div.style.msFilter = '"progid:DXImageTransform.Microsoft.Alpha(Opacity=' + r * 100 + ')"', this.div.style.filter = "alpha(opacity=" + r * 100 + ")";
        }
        this.div.style.position = "absolute", this.div.style.visibility = "hidden", this.zIndex !== null && (this.div.style.zIndex = this.zIndex + ""), this.div.style.overflow || (this.div.style.overflow = "auto");
      }
    }, t.prototype.getBoxWidths = function() {
      var e = {
        top: 0,
        bottom: 0,
        left: 0,
        right: 0
      };
      if (!this.div)
        return e;
      if (document.defaultView) {
        var n = this.div.ownerDocument, r = n && n.defaultView ? n.defaultView.getComputedStyle(this.div, "") : null;
        r && (e.top = parseInt(r.borderTopWidth || "", 10) || 0, e.bottom = parseInt(r.borderBottomWidth || "", 10) || 0, e.left = parseInt(r.borderLeftWidth || "", 10) || 0, e.right = parseInt(r.borderRightWidth || "", 10) || 0);
      } else if (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        document.documentElement.currentStyle
      ) {
        var o = this.div.currentStyle;
        o && (e.top = parseInt(o.borderTopWidth || "", 10) || 0, e.bottom = parseInt(o.borderBottomWidth || "", 10) || 0, e.left = parseInt(o.borderLeftWidth || "", 10) || 0, e.right = parseInt(o.borderRightWidth || "", 10) || 0);
      }
      return e;
    }, t.prototype.onRemove = function() {
      this.div && this.div.parentNode && (this.div.parentNode.removeChild(this.div), this.div = null);
    }, t.prototype.draw = function() {
      if (this.createInfoBoxDiv(), this.div) {
        var e = this.getProjection(), n = e.fromLatLngToDivPixel(this.position);
        n !== null && (this.div.style.left = n.x + this.pixelOffset.width + "px", this.alignBottom ? this.div.style.bottom = -(n.y + this.pixelOffset.height) + "px" : this.div.style.top = n.y + this.pixelOffset.height + "px"), this.isHidden ? this.div.style.visibility = "hidden" : this.div.style.visibility = "visible";
      }
    }, t.prototype.setOptions = function(e) {
      e === void 0 && (e = {}), typeof e.boxClass < "u" && (this.boxClass = e.boxClass, this.setBoxStyle()), typeof e.boxStyle < "u" && (this.boxStyle = e.boxStyle, this.setBoxStyle()), typeof e.content < "u" && this.setContent(e.content), typeof e.disableAutoPan < "u" && (this.disableAutoPan = e.disableAutoPan), typeof e.maxWidth < "u" && (this.maxWidth = e.maxWidth), typeof e.pixelOffset < "u" && (this.pixelOffset = e.pixelOffset), typeof e.alignBottom < "u" && (this.alignBottom = e.alignBottom), typeof e.position < "u" && this.setPosition(e.position), typeof e.zIndex < "u" && this.setZIndex(e.zIndex), typeof e.closeBoxMargin < "u" && (this.closeBoxMargin = e.closeBoxMargin), typeof e.closeBoxURL < "u" && (this.closeBoxURL = e.closeBoxURL), typeof e.infoBoxClearance < "u" && (this.infoBoxClearance = e.infoBoxClearance), typeof e.isHidden < "u" && (this.isHidden = e.isHidden), typeof e.visible < "u" && (this.isHidden = !e.visible), typeof e.enableEventPropagation < "u" && (this.enableEventPropagation = e.enableEventPropagation), this.div && this.draw();
    }, t.prototype.setContent = function(e) {
      this.content = e, this.div && (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.fixedWidthSet || (this.div.style.width = ""), typeof e == "string" ? this.div.innerHTML = this.getCloseBoxImg() + e : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(e)), this.fixedWidthSet || (this.div.style.width = this.div.offsetWidth + "px", typeof e == "string" ? this.div.innerHTML = this.getCloseBoxImg() + e : (this.div.innerHTML = this.getCloseBoxImg(), this.div.appendChild(e))), this.addClickHandler()), google.maps.event.trigger(this, "content_changed");
    }, t.prototype.setPosition = function(e) {
      this.position = e, this.div && this.draw(), google.maps.event.trigger(this, "position_changed");
    }, t.prototype.setVisible = function(e) {
      this.isHidden = !e, this.div && (this.div.style.visibility = this.isHidden ? "hidden" : "visible");
    }, t.prototype.setZIndex = function(e) {
      this.zIndex = e, this.div && (this.div.style.zIndex = e + ""), google.maps.event.trigger(this, "zindex_changed");
    }, t.prototype.getContent = function() {
      return this.content;
    }, t.prototype.getPosition = function() {
      return this.position;
    }, t.prototype.getZIndex = function() {
      return this.zIndex;
    }, t.prototype.getVisible = function() {
      var e = this.getMap();
      return typeof e > "u" || e === null ? !1 : !this.isHidden;
    }, t.prototype.show = function() {
      this.isHidden = !1, this.div && (this.div.style.visibility = "visible");
    }, t.prototype.hide = function() {
      this.isHidden = !0, this.div && (this.div.style.visibility = "hidden");
    }, t.prototype.open = function(e, n) {
      var r = this;
      n && (this.position = n.getPosition(), this.moveListener = google.maps.event.addListener(n, "position_changed", function() {
        var o = n.getPosition();
        r.setPosition(o);
      }), this.mapListener = google.maps.event.addListener(n, "map_changed", function() {
        r.setMap(n.map);
      })), this.setMap(e), this.div && this.panBox();
    }, t.prototype.close = function() {
      if (this.closeListener && (google.maps.event.removeListener(this.closeListener), this.closeListener = null), this.eventListeners) {
        for (var e = 0, n = this.eventListeners; e < n.length; e++) {
          var r = n[e];
          google.maps.event.removeListener(r);
        }
        this.eventListeners = null;
      }
      this.moveListener && (google.maps.event.removeListener(this.moveListener), this.moveListener = null), this.mapListener && (google.maps.event.removeListener(this.mapListener), this.mapListener = null), this.contextListener && (google.maps.event.removeListener(this.contextListener), this.contextListener = null), this.setMap(null);
    }, t.prototype.extend = function(e, n) {
      return (function(o) {
        for (var i in o.prototype)
          Object.prototype.hasOwnProperty.call(this, i) || (this.prototype[i] = o.prototype[i]);
        return this;
      }).apply(e, [n]);
    }, t;
  }()
), QI = ["position"], eR = ["position"];
function Zv(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ga(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Zv(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Zv(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Kv = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, Yv = {
  options(t, e) {
    t.setOptions(e);
  },
  position(t, e) {
    e instanceof google.maps.LatLng ? t.setPosition(e) : t.setPosition(new google.maps.LatLng(e.lat, e.lng));
  },
  visible(t, e) {
    t.setVisible(e);
  },
  zIndex(t, e) {
    t.setZIndex(e);
  }
}, tR = {};
function nR(t) {
  var {
    children: e,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: f
  } = t, v = Ee(Ae), [h, g] = B(null), [p, w] = B(null), [b, k] = B(null), [E, m] = B(null), [O, S] = B(null), [W, P] = B(null), $ = qe(null);
  return y(() => {
    v && h !== null && (h.close(), n ? h.open(v, n) : h.getPosition() && h.open(v));
  }, [v, h, n]), y(() => {
    r && h !== null && h.setOptions(r);
  }, [h, r]), y(() => {
    if (o && h !== null) {
      var j = o instanceof google.maps.LatLng ? o : (
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        new google.maps.LatLng(o.lat, o.lng)
      );
      h.setPosition(j);
    }
  }, [o]), y(() => {
    typeof i == "number" && h !== null && h.setZIndex(i);
  }, [i]), y(() => {
    h && a && (p !== null && google.maps.event.removeListener(p), w(google.maps.event.addListener(h, "closeclick", a)));
  }, [a]), y(() => {
    h && s && (b !== null && google.maps.event.removeListener(b), k(google.maps.event.addListener(h, "domready", s)));
  }, [s]), y(() => {
    h && l && (E !== null && google.maps.event.removeListener(E), m(google.maps.event.addListener(h, "content_changed", l)));
  }, [l]), y(() => {
    h && u && (O !== null && google.maps.event.removeListener(O), S(google.maps.event.addListener(h, "position_changed", u)));
  }, [u]), y(() => {
    h && c && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(h, "zindex_changed", c)));
  }, [c]), y(() => {
    if (v) {
      var j = r || tR, {
        position: _
      } = j, I = bd(j, QI), R;
      _ && !(_ instanceof google.maps.LatLng) && (R = new google.maps.LatLng(_.lat, _.lng));
      var V = new TC(Ga(Ga({}, I), R ? {
        position: R
      } : {}));
      $.current = document.createElement("div"), g(V), a && w(google.maps.event.addListener(V, "closeclick", a)), s && k(google.maps.event.addListener(V, "domready", s)), l && m(google.maps.event.addListener(V, "content_changed", l)), u && S(google.maps.event.addListener(V, "position_changed", u)), c && P(google.maps.event.addListener(V, "zindex_changed", c)), V.setContent($.current), n ? V.open(v, n) : V.getPosition() ? V.open(v) : $t(!1, "You must provide either an anchor or a position prop for <InfoBox>."), d && d(V);
    }
    return () => {
      h !== null && (p && google.maps.event.removeListener(p), E && google.maps.event.removeListener(E), b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), f && f(h), h.close());
    };
  }, []), $.current ? wr(zt.only(e), $.current) : null;
}
Re(nR);
class rR extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "containerElement", null), oe(this, "state", {
      infoBox: null
    }), oe(this, "open", (e, n) => {
      n ? this.context !== null && e.open(this.context, n) : e.getPosition() ? this.context !== null && e.open(this.context) : $t(!1, "You must provide either an anchor or a position prop for <InfoBox>.");
    }), oe(this, "setInfoBoxCallback", () => {
      this.state.infoBox !== null && this.containerElement !== null && (this.state.infoBox.setContent(this.containerElement), this.open(this.state.infoBox, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoBox));
    });
  }
  componentDidMount() {
    var e = this.props.options || {}, {
      position: n
    } = e, r = bd(e, eR), o;
    n && !(n instanceof google.maps.LatLng) && (o = new google.maps.LatLng(n.lat, n.lng));
    var i = new TC(Ga(Ga({}, r), o ? {
      position: o
    } : {}));
    this.containerElement = document.createElement("div"), this.registeredEvents = $e({
      updaterMap: Yv,
      eventMap: Kv,
      prevProps: {},
      nextProps: this.props,
      instance: i
    }), this.setState({
      infoBox: i
    }, this.setInfoBoxCallback);
  }
  componentDidUpdate(e) {
    var {
      infoBox: n
    } = this.state;
    n !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: Yv,
      eventMap: Kv,
      prevProps: e,
      nextProps: this.props,
      instance: n
    }));
  }
  componentWillUnmount() {
    var {
      onUnmount: e
    } = this.props, {
      infoBox: n
    } = this.state;
    n !== null && (e && e(n), We(this.registeredEvents), n.close());
  }
  render() {
    return this.containerElement ? wr(zt.only(this.props.children), this.containerElement) : null;
  }
}
oe(rR, "contextType", Ae);
var Ql, Xv;
function oR() {
  return Xv || (Xv = 1, Ql = function t(e, n) {
    if (e === n) return !0;
    if (e && n && typeof e == "object" && typeof n == "object") {
      if (e.constructor !== n.constructor) return !1;
      var r, o, i;
      if (Array.isArray(e)) {
        if (r = e.length, r != n.length) return !1;
        for (o = r; o-- !== 0; ) if (!t(e[o], n[o])) return !1;
        return !0;
      }
      if (e.constructor === RegExp) return e.source === n.source && e.flags === n.flags;
      if (e.valueOf !== Object.prototype.valueOf) return e.valueOf() === n.valueOf();
      if (e.toString !== Object.prototype.toString) return e.toString() === n.toString();
      if (i = Object.keys(e), r = i.length, r !== Object.keys(n).length) return !1;
      for (o = r; o-- !== 0; ) if (!Object.prototype.hasOwnProperty.call(n, i[o])) return !1;
      for (o = r; o-- !== 0; ) {
        var a = i[o];
        if (!t(e[a], n[a])) return !1;
      }
      return !0;
    }
    return e !== e && n !== n;
  }), Ql;
}
var iR = oR(), Jv = /* @__PURE__ */ DC(iR), Qv = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array], eu = 1, Bo = 8;
class Cd {
  /**
   * Creates an index from raw `ArrayBuffer` data.
   * @param {ArrayBuffer} data
   */
  static from(e) {
    if (!(e instanceof ArrayBuffer))
      throw new Error("Data must be an instance of ArrayBuffer.");
    var [n, r] = new Uint8Array(e, 0, 2);
    if (n !== 219)
      throw new Error("Data does not appear to be in a KDBush format.");
    var o = r >> 4;
    if (o !== eu)
      throw new Error("Got v".concat(o, " data when expected v").concat(eu, "."));
    var i = Qv[r & 15];
    if (!i)
      throw new Error("Unrecognized array type.");
    var [a] = new Uint16Array(e, 2, 1), [s] = new Uint32Array(e, 4, 1);
    return new Cd(s, a, i, e);
  }
  /**
   * Creates an index that will hold a given number of items.
   * @param {number} numItems
   * @param {number} [nodeSize=64] Size of the KD-tree node (64 by default).
   * @param {TypedArrayConstructor} [ArrayType=Float64Array] The array type used for coordinates storage (`Float64Array` by default).
   * @param {ArrayBuffer} [data] (For internal use only)
   */
  constructor(e) {
    var n = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 64, r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : Float64Array, o = arguments.length > 3 ? arguments[3] : void 0;
    if (isNaN(e) || e < 0) throw new Error("Unpexpected numItems value: ".concat(e, "."));
    this.numItems = +e, this.nodeSize = Math.min(Math.max(+n, 2), 65535), this.ArrayType = r, this.IndexArrayType = e < 65536 ? Uint16Array : Uint32Array;
    var i = Qv.indexOf(this.ArrayType), a = e * 2 * this.ArrayType.BYTES_PER_ELEMENT, s = e * this.IndexArrayType.BYTES_PER_ELEMENT, l = (8 - s % 8) % 8;
    if (i < 0)
      throw new Error("Unexpected typed array class: ".concat(r, "."));
    o && o instanceof ArrayBuffer ? (this.data = o, this.ids = new this.IndexArrayType(this.data, Bo, e), this.coords = new this.ArrayType(this.data, Bo + s + l, e * 2), this._pos = e * 2, this._finished = !0) : (this.data = new ArrayBuffer(Bo + a + s + l), this.ids = new this.IndexArrayType(this.data, Bo, e), this.coords = new this.ArrayType(this.data, Bo + s + l, e * 2), this._pos = 0, this._finished = !1, new Uint8Array(this.data, 0, 2).set([219, (eu << 4) + i]), new Uint16Array(this.data, 2, 1)[0] = n, new Uint32Array(this.data, 4, 1)[0] = e);
  }
  /**
   * Add a point to the index.
   * @param {number} x
   * @param {number} y
   * @returns {number} An incremental index associated with the added item (starting from `0`).
   */
  add(e, n) {
    var r = this._pos >> 1;
    return this.ids[r] = r, this.coords[this._pos++] = e, this.coords[this._pos++] = n, r;
  }
  /**
   * Perform indexing of the added points.
   */
  finish() {
    var e = this._pos >> 1;
    if (e !== this.numItems)
      throw new Error("Added ".concat(e, " items when expected ").concat(this.numItems, "."));
    return Gu(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0), this._finished = !0, this;
  }
  /**
   * Search the index for items within a given bounding box.
   * @param {number} minX
   * @param {number} minY
   * @param {number} maxX
   * @param {number} maxY
   * @returns {number[]} An array of indices correponding to the found items.
   */
  range(e, n, r, o) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: i,
      coords: a,
      nodeSize: s
    } = this, l = [0, i.length - 1, 0], u = []; l.length; ) {
      var c = l.pop() || 0, d = l.pop() || 0, f = l.pop() || 0;
      if (d - f <= s) {
        for (var v = f; v <= d; v++) {
          var h = a[2 * v], g = a[2 * v + 1];
          h >= e && h <= r && g >= n && g <= o && u.push(i[v]);
        }
        continue;
      }
      var p = f + d >> 1, w = a[2 * p], b = a[2 * p + 1];
      w >= e && w <= r && b >= n && b <= o && u.push(i[p]), (c === 0 ? e <= w : n <= b) && (l.push(f), l.push(p - 1), l.push(1 - c)), (c === 0 ? r >= w : o >= b) && (l.push(p + 1), l.push(d), l.push(1 - c));
    }
    return u;
  }
  /**
   * Search the index for items within a given radius.
   * @param {number} qx
   * @param {number} qy
   * @param {number} r Query radius.
   * @returns {number[]} An array of indices correponding to the found items.
   */
  within(e, n, r) {
    if (!this._finished) throw new Error("Data not yet indexed - call index.finish().");
    for (var {
      ids: o,
      coords: i,
      nodeSize: a
    } = this, s = [0, o.length - 1, 0], l = [], u = r * r; s.length; ) {
      var c = s.pop() || 0, d = s.pop() || 0, f = s.pop() || 0;
      if (d - f <= a) {
        for (var v = f; v <= d; v++)
          em(i[2 * v], i[2 * v + 1], e, n) <= u && l.push(o[v]);
        continue;
      }
      var h = f + d >> 1, g = i[2 * h], p = i[2 * h + 1];
      em(g, p, e, n) <= u && l.push(o[h]), (c === 0 ? e - r <= g : n - r <= p) && (s.push(f), s.push(h - 1), s.push(1 - c)), (c === 0 ? e + r >= g : n + r >= p) && (s.push(h + 1), s.push(d), s.push(1 - c));
    }
    return l;
  }
}
function Gu(t, e, n, r, o, i) {
  if (!(o - r <= n)) {
    var a = r + o >> 1;
    AC(t, e, a, r, o, i), Gu(t, e, n, r, a - 1, 1 - i), Gu(t, e, n, a + 1, o, 1 - i);
  }
}
function AC(t, e, n, r, o, i) {
  for (; o > r; ) {
    if (o - r > 600) {
      var a = o - r + 1, s = n - r + 1, l = Math.log(a), u = 0.5 * Math.exp(2 * l / 3), c = 0.5 * Math.sqrt(l * u * (a - u) / a) * (s - a / 2 < 0 ? -1 : 1), d = Math.max(r, Math.floor(n - s * u / a + c)), f = Math.min(o, Math.floor(n + (a - s) * u / a + c));
      AC(t, e, n, d, f, i);
    }
    var v = e[2 * n + i], h = r, g = o;
    for (To(t, e, r, n), e[2 * o + i] > v && To(t, e, r, o); h < g; ) {
      for (To(t, e, h, g), h++, g--; e[2 * h + i] < v; ) h++;
      for (; e[2 * g + i] > v; ) g--;
    }
    e[2 * r + i] === v ? To(t, e, r, g) : (g++, To(t, e, g, o)), g <= n && (r = g + 1), n <= g && (o = g - 1);
  }
}
function To(t, e, n, r) {
  tu(t, n, r), tu(e, 2 * n, 2 * r), tu(e, 2 * n + 1, 2 * r + 1);
}
function tu(t, e, n) {
  var r = t[e];
  t[e] = t[n], t[n] = r;
}
function em(t, e, n, r) {
  var o = t - n, i = e - r;
  return o * o + i * i;
}
var aR = {
  minZoom: 0,
  // min zoom to generate clusters on
  maxZoom: 16,
  // max zoom level to cluster the points on
  minPoints: 2,
  // minimum points to form a cluster
  radius: 40,
  // cluster radius in pixels
  extent: 512,
  // tile extent (radius is calculated relative to it)
  nodeSize: 64,
  // size of the KD-tree leaf node, affects performance
  log: !1,
  // whether to log timing info
  // whether to generate numeric ids for input features (in vector tiles)
  generateId: !1,
  // a reduce function for calculating custom cluster properties
  reduce: null,
  // (accumulated, props) => { accumulated.sum += props.sum; }
  // properties to use for individual points when running the reducer
  map: (t) => t
  // props => ({sum: props.my_value})
}, tm = Math.fround || /* @__PURE__ */ ((t) => (e) => (t[0] = +e, t[0]))(new Float32Array(1)), jr = 2, pr = 3, nu = 4, ur = 5, jC = 6;
class sR {
  constructor(e) {
    this.options = Object.assign(Object.create(aR), e), this.trees = new Array(this.options.maxZoom + 1), this.stride = this.options.reduce ? 7 : 6, this.clusterProps = [];
  }
  load(e) {
    var {
      log: n,
      minZoom: r,
      maxZoom: o
    } = this.options;
    n && console.time("total time");
    var i = "prepare ".concat(e.length, " points");
    n && console.time(i), this.points = e;
    for (var a = [], s = 0; s < e.length; s++) {
      var l = e[s];
      if (l.geometry) {
        var [u, c] = l.geometry.coordinates, d = tm(ia(u)), f = tm(aa(c));
        a.push(
          d,
          f,
          // projected point coordinates
          1 / 0,
          // the last zoom the point was processed at
          s,
          // index of the source feature in the original input array
          -1,
          // parent cluster id
          1
          // number of points in a cluster
        ), this.options.reduce && a.push(0);
      }
    }
    var v = this.trees[o + 1] = this._createTree(a);
    n && console.timeEnd(i);
    for (var h = o; h >= r; h--) {
      var g = +Date.now();
      v = this.trees[h] = this._createTree(this._cluster(v, h)), n && console.log("z%d: %d clusters in %dms", h, v.numItems, +Date.now() - g);
    }
    return n && console.timeEnd("total time"), this;
  }
  getClusters(e, n) {
    var r = ((e[0] + 180) % 360 + 360) % 360 - 180, o = Math.max(-90, Math.min(90, e[1])), i = e[2] === 180 ? 180 : ((e[2] + 180) % 360 + 360) % 360 - 180, a = Math.max(-90, Math.min(90, e[3]));
    if (e[2] - e[0] >= 360)
      r = -180, i = 180;
    else if (r > i) {
      var s = this.getClusters([r, o, 180, a], n), l = this.getClusters([-180, o, i, a], n);
      return s.concat(l);
    }
    var u = this.trees[this._limitZoom(n)], c = u.range(ia(r), aa(a), ia(i), aa(o)), d = u.data, f = [];
    for (var v of c) {
      var h = this.stride * v;
      f.push(d[h + ur] > 1 ? nm(d, h, this.clusterProps) : this.points[d[h + pr]]);
    }
    return f;
  }
  getChildren(e) {
    var n = this._getOriginId(e), r = this._getOriginZoom(e), o = "No cluster with the specified id.", i = this.trees[r];
    if (!i) throw new Error(o);
    var a = i.data;
    if (n * this.stride >= a.length) throw new Error(o);
    var s = this.options.radius / (this.options.extent * Math.pow(2, r - 1)), l = a[n * this.stride], u = a[n * this.stride + 1], c = i.within(l, u, s), d = [];
    for (var f of c) {
      var v = f * this.stride;
      a[v + nu] === e && d.push(a[v + ur] > 1 ? nm(a, v, this.clusterProps) : this.points[a[v + pr]]);
    }
    if (d.length === 0) throw new Error(o);
    return d;
  }
  getLeaves(e, n, r) {
    n = n || 10, r = r || 0;
    var o = [];
    return this._appendLeaves(o, e, n, r, 0), o;
  }
  getTile(e, n, r) {
    var o = this.trees[this._limitZoom(e)], i = Math.pow(2, e), {
      extent: a,
      radius: s
    } = this.options, l = s / a, u = (r - l) / i, c = (r + 1 + l) / i, d = {
      features: []
    };
    return this._addTileFeatures(o.range((n - l) / i, u, (n + 1 + l) / i, c), o.data, n, r, i, d), n === 0 && this._addTileFeatures(o.range(1 - l / i, u, 1, c), o.data, i, r, i, d), n === i - 1 && this._addTileFeatures(o.range(0, u, l / i, c), o.data, -1, r, i, d), d.features.length ? d : null;
  }
  getClusterExpansionZoom(e) {
    for (var n = this._getOriginZoom(e) - 1; n <= this.options.maxZoom; ) {
      var r = this.getChildren(e);
      if (n++, r.length !== 1) break;
      e = r[0].properties.cluster_id;
    }
    return n;
  }
  _appendLeaves(e, n, r, o, i) {
    var a = this.getChildren(n);
    for (var s of a) {
      var l = s.properties;
      if (l && l.cluster ? i + l.point_count <= o ? i += l.point_count : i = this._appendLeaves(e, l.cluster_id, r, o, i) : i < o ? i++ : e.push(s), e.length === r) break;
    }
    return i;
  }
  _createTree(e) {
    for (var n = new Cd(e.length / this.stride | 0, this.options.nodeSize, Float32Array), r = 0; r < e.length; r += this.stride) n.add(e[r], e[r + 1]);
    return n.finish(), n.data = e, n;
  }
  _addTileFeatures(e, n, r, o, i, a) {
    for (var s of e) {
      var l = s * this.stride, u = n[l + ur] > 1, c = void 0, d = void 0, f = void 0;
      if (u)
        c = FC(n, l, this.clusterProps), d = n[l], f = n[l + 1];
      else {
        var v = this.points[n[l + pr]];
        c = v.properties;
        var [h, g] = v.geometry.coordinates;
        d = ia(h), f = aa(g);
      }
      var p = {
        type: 1,
        geometry: [[Math.round(this.options.extent * (d * i - r)), Math.round(this.options.extent * (f * i - o))]],
        tags: c
      }, w = void 0;
      u || this.options.generateId ? w = n[l + pr] : w = this.points[n[l + pr]].id, w !== void 0 && (p.id = w), a.features.push(p);
    }
  }
  _limitZoom(e) {
    return Math.max(this.options.minZoom, Math.min(Math.floor(+e), this.options.maxZoom + 1));
  }
  _cluster(e, n) {
    for (var {
      radius: r,
      extent: o,
      reduce: i,
      minPoints: a
    } = this.options, s = r / (o * Math.pow(2, n)), l = e.data, u = [], c = this.stride, d = 0; d < l.length; d += c)
      if (!(l[d + jr] <= n)) {
        l[d + jr] = n;
        var f = l[d], v = l[d + 1], h = e.within(l[d], l[d + 1], s), g = l[d + ur], p = g;
        for (var w of h) {
          var b = w * c;
          l[b + jr] > n && (p += l[b + ur]);
        }
        if (p > g && p >= a) {
          var k = f * g, E = v * g, m = void 0, O = -1, S = ((d / c | 0) << 5) + (n + 1) + this.points.length;
          for (var W of h) {
            var P = W * c;
            if (!(l[P + jr] <= n)) {
              l[P + jr] = n;
              var $ = l[P + ur];
              k += l[P] * $, E += l[P + 1] * $, l[P + nu] = S, i && (m || (m = this._map(l, d, !0), O = this.clusterProps.length, this.clusterProps.push(m)), i(m, this._map(l, P)));
            }
          }
          l[d + nu] = S, u.push(k / p, E / p, 1 / 0, S, -1, p), i && u.push(O);
        } else {
          for (var j = 0; j < c; j++) u.push(l[d + j]);
          if (p > 1)
            for (var _ of h) {
              var I = _ * c;
              if (!(l[I + jr] <= n)) {
                l[I + jr] = n;
                for (var R = 0; R < c; R++) u.push(l[I + R]);
              }
            }
        }
      }
    return u;
  }
  // get index of the point from which the cluster originated
  _getOriginId(e) {
    return e - this.points.length >> 5;
  }
  // get zoom of the point from which the cluster originated
  _getOriginZoom(e) {
    return (e - this.points.length) % 32;
  }
  _map(e, n, r) {
    if (e[n + ur] > 1) {
      var o = this.clusterProps[e[n + jC]];
      return r ? Object.assign({}, o) : o;
    }
    var i = this.points[e[n + pr]].properties, a = this.options.map(i);
    return r && a === i ? Object.assign({}, a) : a;
  }
}
function nm(t, e, n) {
  return {
    type: "Feature",
    id: t[e + pr],
    properties: FC(t, e, n),
    geometry: {
      type: "Point",
      coordinates: [lR(t[e]), uR(t[e + 1])]
    }
  };
}
function FC(t, e, n) {
  var r = t[e + ur], o = r >= 1e4 ? "".concat(Math.round(r / 1e3), "k") : r >= 1e3 ? "".concat(Math.round(r / 100) / 10, "k") : r, i = t[e + jC], a = i === -1 ? {} : Object.assign({}, n[i]);
  return Object.assign(a, {
    cluster: !0,
    cluster_id: t[e + pr],
    point_count: r,
    point_count_abbreviated: o
  });
}
function ia(t) {
  return t / 360 + 0.5;
}
function aa(t) {
  var e = Math.sin(t * Math.PI / 180), n = 0.5 - 0.25 * Math.log((1 + e) / (1 - e)) / Math.PI;
  return n < 0 ? 0 : n > 1 ? 1 : n;
}
function lR(t) {
  return (t - 0.5) * 360;
}
function uR(t) {
  var e = (180 - t * 360) * Math.PI / 180;
  return 360 * Math.atan(Math.exp(e)) / Math.PI - 90;
}
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
function cR(t, e) {
  var n = {};
  for (var r in t) Object.prototype.hasOwnProperty.call(t, r) && e.indexOf(r) < 0 && (n[r] = t[r]);
  if (t != null && typeof Object.getOwnPropertySymbols == "function") for (var o = 0, r = Object.getOwnPropertySymbols(t); o < r.length; o++)
    e.indexOf(r[o]) < 0 && Object.prototype.propertyIsEnumerable.call(t, r[o]) && (n[r[o]] = t[r[o]]);
  return n;
}
class Cn {
  static isAdvancedMarkerAvailable(e) {
    return google.maps.marker && e.getMapCapabilities().isAdvancedMarkersAvailable === !0;
  }
  static isAdvancedMarker(e) {
    return google.maps.marker && e instanceof google.maps.marker.AdvancedMarkerElement;
  }
  static setMap(e, n) {
    this.isAdvancedMarker(e) ? e.map = n : e.setMap(n);
  }
  static getPosition(e) {
    if (this.isAdvancedMarker(e)) {
      if (e.position) {
        if (e.position instanceof google.maps.LatLng)
          return e.position;
        if (e.position.lat && e.position.lng)
          return new google.maps.LatLng(e.position.lat, e.position.lng);
      }
      return new google.maps.LatLng(null);
    }
    return e.getPosition();
  }
  static getVisible(e) {
    return this.isAdvancedMarker(e) ? !0 : e.getVisible();
  }
}
class Zu {
  constructor(e) {
    var {
      markers: n,
      position: r
    } = e;
    this.markers = n, r && (r instanceof google.maps.LatLng ? this._position = r : this._position = new google.maps.LatLng(r));
  }
  get bounds() {
    if (!(this.markers.length === 0 && !this._position)) {
      var e = new google.maps.LatLngBounds(this._position, this._position);
      for (var n of this.markers)
        e.extend(Cn.getPosition(n));
      return e;
    }
  }
  get position() {
    return this._position || this.bounds.getCenter();
  }
  /**
   * Get the count of **visible** markers.
   */
  get count() {
    return this.markers.filter((e) => Cn.getVisible(e)).length;
  }
  /**
   * Add a marker to the cluster.
   */
  push(e) {
    this.markers.push(e);
  }
  /**
   * Cleanup references and remove marker from map.
   */
  delete() {
    this.marker && (Cn.setMap(this.marker, null), this.marker = void 0), this.markers.length = 0;
  }
}
class dR {
  constructor(e) {
    var {
      maxZoom: n = 16
    } = e;
    this.maxZoom = n;
  }
  /**
   * Helper function to bypass clustering based upon some map state such as
   * zoom, number of markers, etc.
   *
   * ```typescript
   *  cluster({markers, map}: AlgorithmInput): Cluster[] {
   *    if (shouldBypassClustering(map)) {
   *      return this.noop({markers})
   *    }
   * }
   * ```
   */
  noop(e) {
    var {
      markers: n
    } = e;
    return fR(n);
  }
}
var fR = (t) => {
  var e = t.map((n) => new Zu({
    position: Cn.getPosition(n),
    markers: [n]
  }));
  return e;
};
class pR extends dR {
  constructor(e) {
    var {
      maxZoom: n,
      radius: r = 60
    } = e, o = cR(e, ["maxZoom", "radius"]);
    super({
      maxZoom: n
    }), this.state = {
      zoom: -1
    }, this.superCluster = new sR(Object.assign({
      maxZoom: this.maxZoom,
      radius: r
    }, o));
  }
  calculate(e) {
    var n = !1, r = {
      zoom: e.map.getZoom()
    };
    if (!Jv(e.markers, this.markers)) {
      n = !0, this.markers = [...e.markers];
      var o = this.markers.map((i) => {
        var a = Cn.getPosition(i), s = [a.lng(), a.lat()];
        return {
          type: "Feature",
          geometry: {
            type: "Point",
            coordinates: s
          },
          properties: {
            marker: i
          }
        };
      });
      this.superCluster.load(o);
    }
    return n || (this.state.zoom <= this.maxZoom || r.zoom <= this.maxZoom) && (n = !Jv(this.state, r)), this.state = r, n && (this.clusters = this.cluster(e)), {
      clusters: this.clusters,
      changed: n
    };
  }
  cluster(e) {
    var {
      map: n
    } = e;
    return this.superCluster.getClusters([-180, -90, 180, 90], Math.round(n.getZoom())).map((r) => this.transformCluster(r));
  }
  transformCluster(e) {
    var {
      geometry: {
        coordinates: [n, r]
      },
      properties: o
    } = e;
    if (o.cluster)
      return new Zu({
        markers: this.superCluster.getLeaves(o.cluster_id, 1 / 0).map((a) => a.properties.marker),
        position: {
          lat: r,
          lng: n
        }
      });
    var i = o.marker;
    return new Zu({
      markers: [i],
      position: Cn.getPosition(i)
    });
  }
}
class hR {
  constructor(e, n) {
    this.markers = {
      sum: e.length
    };
    var r = n.map((i) => i.count), o = r.reduce((i, a) => i + a, 0);
    this.clusters = {
      count: n.length,
      markers: {
        mean: o / n.length,
        sum: o,
        min: Math.min(...r),
        max: Math.max(...r)
      }
    };
  }
}
class gR {
  /**
   * The default render function for the library used by {@link MarkerClusterer}.
   *
   * Currently set to use the following:
   *
   * ```typescript
   * // change color if this cluster has more markers than the mean cluster
   * const color =
   *   count > Math.max(10, stats.clusters.markers.mean)
   *     ? "#ff0000"
   *     : "#0000ff";
   *
   * // create svg url with fill color
   * const svg = window.btoa(`
   * <svg fill="${color}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240">
   *   <circle cx="120" cy="120" opacity=".6" r="70" />
   *   <circle cx="120" cy="120" opacity=".3" r="90" />
   *   <circle cx="120" cy="120" opacity=".2" r="110" />
   *   <circle cx="120" cy="120" opacity=".1" r="130" />
   * </svg>`);
   *
   * // create marker using svg icon
   * return new google.maps.Marker({
   *   position,
   *   icon: {
   *     url: `data:image/svg+xml;base64,${svg}`,
   *     scaledSize: new google.maps.Size(45, 45),
   *   },
   *   label: {
   *     text: String(count),
   *     color: "rgba(255,255,255,0.9)",
   *     fontSize: "12px",
   *   },
   *   // adjust zIndex to be above other markers
   *   zIndex: 1000 + count,
   * });
   * ```
   */
  render(e, n, r) {
    var {
      count: o,
      position: i
    } = e, a = o > Math.max(10, n.clusters.markers.mean) ? "#ff0000" : "#0000ff", s = '<svg fill="'.concat(a, `" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">`).concat(o, `</text>
</svg>`), l = "Cluster of ".concat(o, " markers"), u = Number(google.maps.Marker.MAX_ZINDEX) + o;
    if (Cn.isAdvancedMarkerAvailable(r)) {
      var c = new DOMParser(), d = c.parseFromString(s, "image/svg+xml").documentElement;
      d.setAttribute("transform", "translate(0 25)");
      var f = {
        map: r,
        position: i,
        zIndex: u,
        title: l,
        content: d
      };
      return new google.maps.marker.AdvancedMarkerElement(f);
    }
    var v = {
      position: i,
      zIndex: u,
      title: l,
      icon: {
        url: "data:image/svg+xml;base64,".concat(btoa(s)),
        anchor: new google.maps.Point(25, 25)
      }
    };
    return new google.maps.Marker(v);
  }
}
function vR(t, e) {
  for (var n in e.prototype)
    t.prototype[n] = e.prototype[n];
}
class wd {
  constructor() {
    vR(wd, google.maps.OverlayView);
  }
}
var qo;
(function(t) {
  t.CLUSTERING_BEGIN = "clusteringbegin", t.CLUSTERING_END = "clusteringend", t.CLUSTER_CLICK = "click";
})(qo || (qo = {}));
var mR = (t, e, n) => {
  n.fitBounds(e.bounds);
};
class yR extends wd {
  constructor(e) {
    var {
      map: n,
      markers: r = [],
      algorithmOptions: o = {},
      algorithm: i = new pR(o),
      renderer: a = new gR(),
      onClusterClick: s = mR
    } = e;
    super(), this.markers = [...r], this.clusters = [], this.algorithm = i, this.renderer = a, this.onClusterClick = s, n && this.setMap(n);
  }
  addMarker(e, n) {
    this.markers.includes(e) || (this.markers.push(e), n || this.render());
  }
  addMarkers(e, n) {
    e.forEach((r) => {
      this.addMarker(r, !0);
    }), n || this.render();
  }
  removeMarker(e, n) {
    var r = this.markers.indexOf(e);
    return r === -1 ? !1 : (Cn.setMap(e, null), this.markers.splice(r, 1), n || this.render(), !0);
  }
  removeMarkers(e, n) {
    var r = !1;
    return e.forEach((o) => {
      r = this.removeMarker(o, !0) || r;
    }), r && !n && this.render(), r;
  }
  clearMarkers(e) {
    this.markers.length = 0, e || this.render();
  }
  /**
   * Recalculates and draws all the marker clusters.
   */
  render() {
    var e = this.getMap();
    if (e instanceof google.maps.Map && e.getProjection()) {
      google.maps.event.trigger(this, qo.CLUSTERING_BEGIN, this);
      var {
        clusters: n,
        changed: r
      } = this.algorithm.calculate({
        markers: this.markers,
        map: e,
        mapCanvasProjection: this.getProjection()
      });
      if (r || r == null) {
        var o = /* @__PURE__ */ new Set();
        for (var i of n)
          i.markers.length == 1 && o.add(i.markers[0]);
        var a = [];
        for (var s of this.clusters)
          s.marker != null && (s.markers.length == 1 ? o.has(s.marker) || Cn.setMap(s.marker, null) : a.push(s.marker));
        this.clusters = n, this.renderClusters(), requestAnimationFrame(() => a.forEach((l) => Cn.setMap(l, null)));
      }
      google.maps.event.trigger(this, qo.CLUSTERING_END, this);
    }
  }
  onAdd() {
    this.idleListener = this.getMap().addListener("idle", this.render.bind(this)), this.render();
  }
  onRemove() {
    google.maps.event.removeListener(this.idleListener), this.reset();
  }
  reset() {
    this.markers.forEach((e) => Cn.setMap(e, null)), this.clusters.forEach((e) => e.delete()), this.clusters = [];
  }
  renderClusters() {
    var e = new hR(this.markers, this.clusters), n = this.getMap();
    this.clusters.forEach((r) => {
      r.markers.length === 1 ? r.marker = r.markers[0] : (r.marker = this.renderer.render(r, e, n), r.markers.forEach((o) => Cn.setMap(o, null)), this.onClusterClick && r.marker.addListener(
        "click",
        /* istanbul ignore next */
        (o) => {
          google.maps.event.trigger(this, qo.CLUSTER_CLICK, r), this.onClusterClick(o, r, n);
        }
      )), Cn.setMap(r.marker, n);
    });
  }
}
function rm(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function om(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? rm(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : rm(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function bR(t) {
  var e = yI(), [n, r] = B(null);
  return y(() => {
    if (e && n === null) {
      var o = new yR(om(om({}, t), {}, {
        map: e
      }));
      r(o);
    }
  }, [e]), n;
}
function CR(t) {
  var {
    children: e,
    options: n
  } = t, r = bR(n);
  return r !== null ? e(r) : null;
}
Re(CR);
var im = {
  onCloseClick: "closeclick",
  onContentChanged: "content_changed",
  onDomReady: "domready",
  onPositionChanged: "position_changed",
  onZindexChanged: "zindex_changed"
}, am = {
  options(t, e) {
    t.setOptions(e);
  },
  position(t, e) {
    t.setPosition(e);
  },
  zIndex(t, e) {
    t.setZIndex(e);
  }
};
function wR(t) {
  var {
    children: e,
    anchor: n,
    options: r,
    position: o,
    zIndex: i,
    onCloseClick: a,
    onDomReady: s,
    onContentChanged: l,
    onPositionChanged: u,
    onZindexChanged: c,
    onLoad: d,
    onUnmount: f
  } = t, v = Ee(Ae), [h, g] = B(null), [p, w] = B(null), [b, k] = B(null), [E, m] = B(null), [O, S] = B(null), [W, P] = B(null), $ = qe(null);
  return y(() => {
    h !== null && (h.close(), n ? h.open(v, n) : h.getPosition() && h.open(v));
  }, [v, h, n]), y(() => {
    r && h !== null && h.setOptions(r);
  }, [h, r]), y(() => {
    o && h !== null && h.setPosition(o);
  }, [o]), y(() => {
    typeof i == "number" && h !== null && h.setZIndex(i);
  }, [i]), y(() => {
    h && a && (p !== null && google.maps.event.removeListener(p), w(google.maps.event.addListener(h, "closeclick", a)));
  }, [a]), y(() => {
    h && s && (b !== null && google.maps.event.removeListener(b), k(google.maps.event.addListener(h, "domready", s)));
  }, [s]), y(() => {
    h && l && (E !== null && google.maps.event.removeListener(E), m(google.maps.event.addListener(h, "content_changed", l)));
  }, [l]), y(() => {
    h && u && (O !== null && google.maps.event.removeListener(O), S(google.maps.event.addListener(h, "position_changed", u)));
  }, [u]), y(() => {
    h && c && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(h, "zindex_changed", c)));
  }, [c]), y(() => {
    var j = new google.maps.InfoWindow(r);
    return g(j), $.current = document.createElement("div"), a && w(google.maps.event.addListener(j, "closeclick", a)), s && k(google.maps.event.addListener(j, "domready", s)), l && m(google.maps.event.addListener(j, "content_changed", l)), u && S(google.maps.event.addListener(j, "position_changed", u)), c && P(google.maps.event.addListener(j, "zindex_changed", c)), j.setContent($.current), o && j.setPosition(o), i && j.setZIndex(i), n ? j.open(v, n) : j.getPosition() ? j.open(v) : $t(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>."), d && d(j), () => {
      p && google.maps.event.removeListener(p), E && google.maps.event.removeListener(E), b && google.maps.event.removeListener(b), O && google.maps.event.removeListener(O), W && google.maps.event.removeListener(W), f && f(j), j.close();
    };
  }, []), $.current ? wr(zt.only(e), $.current) : null;
}
Re(wR);
class ER extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "containerElement", null), oe(this, "state", {
      infoWindow: null
    }), oe(this, "open", (e, n) => {
      n ? e.open(this.context, n) : e.getPosition() ? e.open(this.context) : $t(!1, "You must provide either an anchor (typically render it inside a <Marker>) or a position props for <InfoWindow>.");
    }), oe(this, "setInfoWindowCallback", () => {
      this.state.infoWindow !== null && this.containerElement !== null && (this.state.infoWindow.setContent(this.containerElement), this.open(this.state.infoWindow, this.props.anchor), this.props.onLoad && this.props.onLoad(this.state.infoWindow));
    });
  }
  componentDidMount() {
    var e = new google.maps.InfoWindow(this.props.options);
    this.containerElement = document.createElement("div"), this.registeredEvents = $e({
      updaterMap: am,
      eventMap: im,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(() => ({
      infoWindow: e
    }), this.setInfoWindowCallback);
  }
  componentDidUpdate(e) {
    this.state.infoWindow !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: am,
      eventMap: im,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.infoWindow
    }));
  }
  componentWillUnmount() {
    this.state.infoWindow !== null && (We(this.registeredEvents), this.props.onUnmount && this.props.onUnmount(this.state.infoWindow), this.state.infoWindow.close());
  }
  render() {
    return this.containerElement ? wr(zt.only(this.props.children), this.containerElement) : null;
  }
}
oe(ER, "contextType", Ae);
function sm(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Za(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? sm(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : sm(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var lm = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, um = {
  draggable(t, e) {
    t.setDraggable(e);
  },
  editable(t, e) {
    t.setEditable(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  path(t, e) {
    t.setPath(e);
  },
  visible(t, e) {
    t.setVisible(e);
  }
}, DR = {};
function OR(t) {
  var {
    options: e,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: f,
    onMouseUp: v,
    onRightClick: h,
    onClick: g,
    onDrag: p,
    onLoad: w,
    onUnmount: b
  } = t, k = Ee(Ae), [E, m] = B(null), [O, S] = B(null), [W, P] = B(null), [$, j] = B(null), [_, I] = B(null), [R, V] = B(null), [J, G] = B(null), [te, Q] = B(null), [T, N] = B(null), [Y, F] = B(null), [X, L] = B(null), [M, z] = B(null);
  return y(() => {
    E !== null && E.setMap(k);
  }, [k]), y(() => {
    typeof e < "u" && E !== null && E.setOptions(e);
  }, [E, e]), y(() => {
    typeof n < "u" && E !== null && E.setDraggable(n);
  }, [E, n]), y(() => {
    typeof r < "u" && E !== null && E.setEditable(r);
  }, [E, r]), y(() => {
    typeof o < "u" && E !== null && E.setVisible(o);
  }, [E, o]), y(() => {
    typeof i < "u" && E !== null && E.setPath(i);
  }, [E, i]), y(() => {
    E && a && (O !== null && google.maps.event.removeListener(O), S(google.maps.event.addListener(E, "dblclick", a)));
  }, [a]), y(() => {
    E && s && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(E, "dragend", s)));
  }, [s]), y(() => {
    E && l && ($ !== null && google.maps.event.removeListener($), j(google.maps.event.addListener(E, "dragstart", l)));
  }, [l]), y(() => {
    E && u && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(E, "mousedown", u)));
  }, [u]), y(() => {
    E && c && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(E, "mousemove", c)));
  }, [c]), y(() => {
    E && d && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(E, "mouseout", d)));
  }, [d]), y(() => {
    E && f && (te !== null && google.maps.event.removeListener(te), Q(google.maps.event.addListener(E, "mouseover", f)));
  }, [f]), y(() => {
    E && v && (T !== null && google.maps.event.removeListener(T), N(google.maps.event.addListener(E, "mouseup", v)));
  }, [v]), y(() => {
    E && h && (Y !== null && google.maps.event.removeListener(Y), F(google.maps.event.addListener(E, "rightclick", h)));
  }, [h]), y(() => {
    E && g && (X !== null && google.maps.event.removeListener(X), L(google.maps.event.addListener(E, "click", g)));
  }, [g]), y(() => {
    E && p && (M !== null && google.maps.event.removeListener(M), z(google.maps.event.addListener(E, "drag", p)));
  }, [p]), y(() => {
    var A = new google.maps.Polyline(Za(Za({}, e || DR), {}, {
      map: k
    }));
    return i && A.setPath(i), typeof o < "u" && A.setVisible(o), typeof r < "u" && A.setEditable(r), typeof n < "u" && A.setDraggable(n), a && S(google.maps.event.addListener(A, "dblclick", a)), s && P(google.maps.event.addListener(A, "dragend", s)), l && j(google.maps.event.addListener(A, "dragstart", l)), u && I(google.maps.event.addListener(A, "mousedown", u)), c && V(google.maps.event.addListener(A, "mousemove", c)), d && G(google.maps.event.addListener(A, "mouseout", d)), f && Q(google.maps.event.addListener(A, "mouseover", f)), v && N(google.maps.event.addListener(A, "mouseup", v)), h && F(google.maps.event.addListener(A, "rightclick", h)), g && L(google.maps.event.addListener(A, "click", g)), p && z(google.maps.event.addListener(A, "drag", p)), m(A), w && w(A), () => {
      O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), $ !== null && google.maps.event.removeListener($), _ !== null && google.maps.event.removeListener(_), R !== null && google.maps.event.removeListener(R), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), T !== null && google.maps.event.removeListener(T), Y !== null && google.maps.event.removeListener(Y), X !== null && google.maps.event.removeListener(X), b && b(A), A.setMap(null);
    };
  }, []), null;
}
Re(OR);
class xR extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "state", {
      polyline: null
    }), oe(this, "setPolylineCallback", () => {
      this.state.polyline !== null && this.props.onLoad && this.props.onLoad(this.state.polyline);
    });
  }
  componentDidMount() {
    var e = new google.maps.Polyline(Za(Za({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $e({
      updaterMap: um,
      eventMap: lm,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        polyline: e
      };
    }, this.setPolylineCallback);
  }
  componentDidUpdate(e) {
    this.state.polyline !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: um,
      eventMap: lm,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.polyline
    }));
  }
  componentWillUnmount() {
    this.state.polyline !== null && (this.props.onUnmount && this.props.onUnmount(this.state.polyline), We(this.registeredEvents), this.state.polyline.setMap(null));
  }
  render() {
    return null;
  }
}
oe(xR, "contextType", Ae);
function cm(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function dm(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? cm(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : cm(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var fm = {
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, pm = {
  draggable(t, e) {
    t.setDraggable(e);
  },
  editable(t, e) {
    t.setEditable(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  path(t, e) {
    t.setPath(e);
  },
  paths(t, e) {
    t.setPaths(e);
  },
  visible(t, e) {
    t.setVisible(e);
  }
};
function LR(t) {
  var {
    options: e,
    draggable: n,
    editable: r,
    visible: o,
    path: i,
    paths: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: f,
    onMouseOver: v,
    onMouseUp: h,
    onRightClick: g,
    onClick: p,
    onDrag: w,
    onLoad: b,
    onUnmount: k,
    onEdit: E
  } = t, m = Ee(Ae), [O, S] = B(null), [W, P] = B(null), [$, j] = B(null), [_, I] = B(null), [R, V] = B(null), [J, G] = B(null), [te, Q] = B(null), [T, N] = B(null), [Y, F] = B(null), [X, L] = B(null), [M, z] = B(null), [A, U] = B(null);
  return y(() => {
    O !== null && O.setMap(m);
  }, [m]), y(() => {
    typeof e < "u" && O !== null && O.setOptions(e);
  }, [O, e]), y(() => {
    typeof n < "u" && O !== null && O.setDraggable(n);
  }, [O, n]), y(() => {
    typeof r < "u" && O !== null && O.setEditable(r);
  }, [O, r]), y(() => {
    typeof o < "u" && O !== null && O.setVisible(o);
  }, [O, o]), y(() => {
    typeof i < "u" && O !== null && O.setPath(i);
  }, [O, i]), y(() => {
    typeof a < "u" && O !== null && O.setPaths(a);
  }, [O, a]), y(() => {
    O && typeof s == "function" && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(O, "dblclick", s)));
  }, [s]), y(() => {
    O && (google.maps.event.addListener(O.getPath(), "insert_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "set_at", () => {
      E == null || E(O);
    }), google.maps.event.addListener(O.getPath(), "remove_at", () => {
      E == null || E(O);
    }));
  }, [O, E]), y(() => {
    O && typeof l == "function" && ($ !== null && google.maps.event.removeListener($), j(google.maps.event.addListener(O, "dragend", l)));
  }, [l]), y(() => {
    O && typeof u == "function" && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(O, "dragstart", u)));
  }, [u]), y(() => {
    O && typeof c == "function" && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(O, "mousedown", c)));
  }, [c]), y(() => {
    O && typeof d == "function" && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(O, "mousemove", d)));
  }, [d]), y(() => {
    O && typeof f == "function" && (te !== null && google.maps.event.removeListener(te), Q(google.maps.event.addListener(O, "mouseout", f)));
  }, [f]), y(() => {
    O && typeof v == "function" && (T !== null && google.maps.event.removeListener(T), N(google.maps.event.addListener(O, "mouseover", v)));
  }, [v]), y(() => {
    O && typeof h == "function" && (Y !== null && google.maps.event.removeListener(Y), F(google.maps.event.addListener(O, "mouseup", h)));
  }, [h]), y(() => {
    O && typeof g == "function" && (X !== null && google.maps.event.removeListener(X), L(google.maps.event.addListener(O, "rightclick", g)));
  }, [g]), y(() => {
    O && typeof p == "function" && (M !== null && google.maps.event.removeListener(M), z(google.maps.event.addListener(O, "click", p)));
  }, [p]), y(() => {
    O && typeof w == "function" && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(O, "drag", w)));
  }, [w]), y(() => {
    var H = new google.maps.Polygon(dm(dm({}, e), {}, {
      map: m
    }));
    return i && H.setPath(i), a && H.setPaths(a), typeof o < "u" && H.setVisible(o), typeof r < "u" && H.setEditable(r), typeof n < "u" && H.setDraggable(n), s && P(google.maps.event.addListener(H, "dblclick", s)), l && j(google.maps.event.addListener(H, "dragend", l)), u && I(google.maps.event.addListener(H, "dragstart", u)), c && V(google.maps.event.addListener(H, "mousedown", c)), d && G(google.maps.event.addListener(H, "mousemove", d)), f && Q(google.maps.event.addListener(H, "mouseout", f)), v && N(google.maps.event.addListener(H, "mouseover", v)), h && F(google.maps.event.addListener(H, "mouseup", h)), g && L(google.maps.event.addListener(H, "rightclick", g)), p && z(google.maps.event.addListener(H, "click", p)), w && U(google.maps.event.addListener(H, "drag", w)), S(H), b && b(H), () => {
      W !== null && google.maps.event.removeListener(W), $ !== null && google.maps.event.removeListener($), _ !== null && google.maps.event.removeListener(_), R !== null && google.maps.event.removeListener(R), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), T !== null && google.maps.event.removeListener(T), Y !== null && google.maps.event.removeListener(Y), X !== null && google.maps.event.removeListener(X), M !== null && google.maps.event.removeListener(M), k && k(H), H.setMap(null);
    };
  }, []), null;
}
Re(LR);
class SR extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []);
  }
  componentDidMount() {
    var e = this.props.options || {};
    this.polygon = new google.maps.Polygon(e), this.polygon.setMap(this.context), this.registeredEvents = $e({
      updaterMap: pm,
      eventMap: fm,
      prevProps: {},
      nextProps: this.props,
      instance: this.polygon
    }), this.props.onLoad && this.props.onLoad(this.polygon);
  }
  componentDidUpdate(e) {
    this.polygon && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: pm,
      eventMap: fm,
      prevProps: e,
      nextProps: this.props,
      instance: this.polygon
    }));
  }
  componentWillUnmount() {
    this.polygon && (this.props.onUnmount && this.props.onUnmount(this.polygon), We(this.registeredEvents), this.polygon && this.polygon.setMap(null));
  }
  render() {
    return null;
  }
}
oe(SR, "contextType", Ae);
function hm(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ka(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? hm(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : hm(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var gm = {
  onBoundsChanged: "bounds_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, vm = {
  bounds(t, e) {
    t.setBounds(e);
  },
  draggable(t, e) {
    t.setDraggable(e);
  },
  editable(t, e) {
    t.setEditable(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  visible(t, e) {
    t.setVisible(e);
  }
};
function PR(t) {
  var {
    options: e,
    bounds: n,
    draggable: r,
    editable: o,
    visible: i,
    onDblClick: a,
    onDragEnd: s,
    onDragStart: l,
    onMouseDown: u,
    onMouseMove: c,
    onMouseOut: d,
    onMouseOver: f,
    onMouseUp: v,
    onRightClick: h,
    onClick: g,
    onDrag: p,
    onBoundsChanged: w,
    onLoad: b,
    onUnmount: k
  } = t, E = Ee(Ae), [m, O] = B(null), [S, W] = B(null), [P, $] = B(null), [j, _] = B(null), [I, R] = B(null), [V, J] = B(null), [G, te] = B(null), [Q, T] = B(null), [N, Y] = B(null), [F, X] = B(null), [L, M] = B(null), [z, A] = B(null), [U, H] = B(null);
  return y(() => {
    m !== null && m.setMap(E);
  }, [E]), y(() => {
    typeof e < "u" && m !== null && m.setOptions(e);
  }, [m, e]), y(() => {
    typeof r < "u" && m !== null && m.setDraggable(r);
  }, [m, r]), y(() => {
    typeof o < "u" && m !== null && m.setEditable(o);
  }, [m, o]), y(() => {
    typeof i < "u" && m !== null && m.setVisible(i);
  }, [m, i]), y(() => {
    typeof n < "u" && m !== null && m.setBounds(n);
  }, [m, n]), y(() => {
    m && a && (S !== null && google.maps.event.removeListener(S), W(google.maps.event.addListener(m, "dblclick", a)));
  }, [a]), y(() => {
    m && s && (P !== null && google.maps.event.removeListener(P), $(google.maps.event.addListener(m, "dragend", s)));
  }, [s]), y(() => {
    m && l && (j !== null && google.maps.event.removeListener(j), _(google.maps.event.addListener(m, "dragstart", l)));
  }, [l]), y(() => {
    m && u && (I !== null && google.maps.event.removeListener(I), R(google.maps.event.addListener(m, "mousedown", u)));
  }, [u]), y(() => {
    m && c && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(m, "mousemove", c)));
  }, [c]), y(() => {
    m && d && (G !== null && google.maps.event.removeListener(G), te(google.maps.event.addListener(m, "mouseout", d)));
  }, [d]), y(() => {
    m && f && (Q !== null && google.maps.event.removeListener(Q), T(google.maps.event.addListener(m, "mouseover", f)));
  }, [f]), y(() => {
    m && v && (N !== null && google.maps.event.removeListener(N), Y(google.maps.event.addListener(m, "mouseup", v)));
  }, [v]), y(() => {
    m && h && (F !== null && google.maps.event.removeListener(F), X(google.maps.event.addListener(m, "rightclick", h)));
  }, [h]), y(() => {
    m && g && (L !== null && google.maps.event.removeListener(L), M(google.maps.event.addListener(m, "click", g)));
  }, [g]), y(() => {
    m && p && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(m, "drag", p)));
  }, [p]), y(() => {
    m && w && (U !== null && google.maps.event.removeListener(U), H(google.maps.event.addListener(m, "bounds_changed", w)));
  }, [w]), y(() => {
    var ee = new google.maps.Rectangle(Ka(Ka({}, e), {}, {
      map: E
    }));
    return typeof i < "u" && ee.setVisible(i), typeof o < "u" && ee.setEditable(o), typeof r < "u" && ee.setDraggable(r), typeof n < "u" && ee.setBounds(n), a && W(google.maps.event.addListener(ee, "dblclick", a)), s && $(google.maps.event.addListener(ee, "dragend", s)), l && _(google.maps.event.addListener(ee, "dragstart", l)), u && R(google.maps.event.addListener(ee, "mousedown", u)), c && J(google.maps.event.addListener(ee, "mousemove", c)), d && te(google.maps.event.addListener(ee, "mouseout", d)), f && T(google.maps.event.addListener(ee, "mouseover", f)), v && Y(google.maps.event.addListener(ee, "mouseup", v)), h && X(google.maps.event.addListener(ee, "rightclick", h)), g && M(google.maps.event.addListener(ee, "click", g)), p && A(google.maps.event.addListener(ee, "drag", p)), w && H(google.maps.event.addListener(ee, "bounds_changed", w)), O(ee), b && b(ee), () => {
      S !== null && google.maps.event.removeListener(S), P !== null && google.maps.event.removeListener(P), j !== null && google.maps.event.removeListener(j), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), N !== null && google.maps.event.removeListener(N), F !== null && google.maps.event.removeListener(F), L !== null && google.maps.event.removeListener(L), z !== null && google.maps.event.removeListener(z), U !== null && google.maps.event.removeListener(U), k && k(ee), ee.setMap(null);
    };
  }, []), null;
}
Re(PR);
class kR extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "state", {
      rectangle: null
    }), oe(this, "setRectangleCallback", () => {
      this.state.rectangle !== null && this.props.onLoad && this.props.onLoad(this.state.rectangle);
    });
  }
  componentDidMount() {
    var e = new google.maps.Rectangle(Ka(Ka({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $e({
      updaterMap: vm,
      eventMap: gm,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        rectangle: e
      };
    }, this.setRectangleCallback);
  }
  componentDidUpdate(e) {
    this.state.rectangle !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: vm,
      eventMap: gm,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.rectangle
    }));
  }
  componentWillUnmount() {
    this.state.rectangle !== null && (this.props.onUnmount && this.props.onUnmount(this.state.rectangle), We(this.registeredEvents), this.state.rectangle.setMap(null));
  }
  render() {
    return null;
  }
}
oe(kR, "contextType", Ae);
function mm(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ya(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? mm(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : mm(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var ym = {
  onCenterChanged: "center_changed",
  onRadiusChanged: "radius_changed",
  onClick: "click",
  onDblClick: "dblclick",
  onDrag: "drag",
  onDragEnd: "dragend",
  onDragStart: "dragstart",
  onMouseDown: "mousedown",
  onMouseMove: "mousemove",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick"
}, bm = {
  center(t, e) {
    t.setCenter(e);
  },
  draggable(t, e) {
    t.setDraggable(e);
  },
  editable(t, e) {
    t.setEditable(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  radius(t, e) {
    t.setRadius(e);
  },
  visible(t, e) {
    t.setVisible(e);
  }
}, MR = {};
function BR(t) {
  var {
    options: e,
    center: n,
    radius: r,
    draggable: o,
    editable: i,
    visible: a,
    onDblClick: s,
    onDragEnd: l,
    onDragStart: u,
    onMouseDown: c,
    onMouseMove: d,
    onMouseOut: f,
    onMouseOver: v,
    onMouseUp: h,
    onRightClick: g,
    onClick: p,
    onDrag: w,
    onCenterChanged: b,
    onRadiusChanged: k,
    onLoad: E,
    onUnmount: m
  } = t, O = Ee(Ae), [S, W] = B(null), [P, $] = B(null), [j, _] = B(null), [I, R] = B(null), [V, J] = B(null), [G, te] = B(null), [Q, T] = B(null), [N, Y] = B(null), [F, X] = B(null), [L, M] = B(null), [z, A] = B(null), [U, H] = B(null), [ee, Z] = B(null), [pe, he] = B(null);
  return y(() => {
    S !== null && S.setMap(O);
  }, [O]), y(() => {
    typeof e < "u" && S !== null && S.setOptions(e);
  }, [S, e]), y(() => {
    typeof o < "u" && S !== null && S.setDraggable(o);
  }, [S, o]), y(() => {
    typeof i < "u" && S !== null && S.setEditable(i);
  }, [S, i]), y(() => {
    typeof a < "u" && S !== null && S.setVisible(a);
  }, [S, a]), y(() => {
    typeof r == "number" && S !== null && S.setRadius(r);
  }, [S, r]), y(() => {
    typeof n < "u" && S !== null && S.setCenter(n);
  }, [S, n]), y(() => {
    S && s && (P !== null && google.maps.event.removeListener(P), $(google.maps.event.addListener(S, "dblclick", s)));
  }, [s]), y(() => {
    S && l && (j !== null && google.maps.event.removeListener(j), _(google.maps.event.addListener(S, "dragend", l)));
  }, [l]), y(() => {
    S && u && (I !== null && google.maps.event.removeListener(I), R(google.maps.event.addListener(S, "dragstart", u)));
  }, [u]), y(() => {
    S && c && (V !== null && google.maps.event.removeListener(V), J(google.maps.event.addListener(S, "mousedown", c)));
  }, [c]), y(() => {
    S && d && (G !== null && google.maps.event.removeListener(G), te(google.maps.event.addListener(S, "mousemove", d)));
  }, [d]), y(() => {
    S && f && (Q !== null && google.maps.event.removeListener(Q), T(google.maps.event.addListener(S, "mouseout", f)));
  }, [f]), y(() => {
    S && v && (N !== null && google.maps.event.removeListener(N), Y(google.maps.event.addListener(S, "mouseover", v)));
  }, [v]), y(() => {
    S && h && (F !== null && google.maps.event.removeListener(F), X(google.maps.event.addListener(S, "mouseup", h)));
  }, [h]), y(() => {
    S && g && (L !== null && google.maps.event.removeListener(L), M(google.maps.event.addListener(S, "rightclick", g)));
  }, [g]), y(() => {
    S && p && (z !== null && google.maps.event.removeListener(z), A(google.maps.event.addListener(S, "click", p)));
  }, [p]), y(() => {
    S && w && (U !== null && google.maps.event.removeListener(U), H(google.maps.event.addListener(S, "drag", w)));
  }, [w]), y(() => {
    S && b && (ee !== null && google.maps.event.removeListener(ee), Z(google.maps.event.addListener(S, "center_changed", b)));
  }, [p]), y(() => {
    S && k && (pe !== null && google.maps.event.removeListener(pe), he(google.maps.event.addListener(S, "radius_changed", k)));
  }, [k]), y(() => {
    var le = new google.maps.Circle(Ya(Ya({}, e || MR), {}, {
      map: O
    }));
    return typeof r == "number" && le.setRadius(r), typeof n < "u" && le.setCenter(n), typeof r == "number" && le.setRadius(r), typeof a < "u" && le.setVisible(a), typeof i < "u" && le.setEditable(i), typeof o < "u" && le.setDraggable(o), s && $(google.maps.event.addListener(le, "dblclick", s)), l && _(google.maps.event.addListener(le, "dragend", l)), u && R(google.maps.event.addListener(le, "dragstart", u)), c && J(google.maps.event.addListener(le, "mousedown", c)), d && te(google.maps.event.addListener(le, "mousemove", d)), f && T(google.maps.event.addListener(le, "mouseout", f)), v && Y(google.maps.event.addListener(le, "mouseover", v)), h && X(google.maps.event.addListener(le, "mouseup", h)), g && M(google.maps.event.addListener(le, "rightclick", g)), p && A(google.maps.event.addListener(le, "click", p)), w && H(google.maps.event.addListener(le, "drag", w)), b && Z(google.maps.event.addListener(le, "center_changed", b)), k && he(google.maps.event.addListener(le, "radius_changed", k)), W(le), E && E(le), () => {
      P !== null && google.maps.event.removeListener(P), j !== null && google.maps.event.removeListener(j), I !== null && google.maps.event.removeListener(I), V !== null && google.maps.event.removeListener(V), G !== null && google.maps.event.removeListener(G), Q !== null && google.maps.event.removeListener(Q), N !== null && google.maps.event.removeListener(N), F !== null && google.maps.event.removeListener(F), L !== null && google.maps.event.removeListener(L), z !== null && google.maps.event.removeListener(z), ee !== null && google.maps.event.removeListener(ee), pe !== null && google.maps.event.removeListener(pe), m && m(le), le.setMap(null);
    };
  }, []), null;
}
Re(BR);
class TR extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "state", {
      circle: null
    }), oe(this, "setCircleCallback", () => {
      this.state.circle !== null && this.props.onLoad && this.props.onLoad(this.state.circle);
    });
  }
  componentDidMount() {
    var e = new google.maps.Circle(Ya(Ya({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $e({
      updaterMap: bm,
      eventMap: ym,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        circle: e
      };
    }, this.setCircleCallback);
  }
  componentDidUpdate(e) {
    this.state.circle !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: bm,
      eventMap: ym,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.circle
    }));
  }
  componentWillUnmount() {
    if (this.state.circle !== null) {
      var e;
      this.props.onUnmount && this.props.onUnmount(this.state.circle), We(this.registeredEvents), (e = this.state.circle) === null || e === void 0 || e.setMap(null);
    }
  }
  render() {
    return null;
  }
}
oe(TR, "contextType", Ae);
function Cm(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Xa(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Cm(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Cm(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var wm = {
  onClick: "click",
  onDblClick: "dblclick",
  onMouseDown: "mousedown",
  onMouseOut: "mouseout",
  onMouseOver: "mouseover",
  onMouseUp: "mouseup",
  onRightClick: "rightclick",
  onAddFeature: "addfeature",
  onRemoveFeature: "removefeature",
  onRemoveProperty: "removeproperty",
  onSetGeometry: "setgeometry",
  onSetProperty: "setproperty"
}, Em = {
  add(t, e) {
    t.add(e);
  },
  addgeojson(t, e, n) {
    t.addGeoJson(e, n);
  },
  contains(t, e) {
    t.contains(e);
  },
  foreach(t, e) {
    t.forEach(e);
  },
  loadgeojson(t, e, n, r) {
    t.loadGeoJson(e, n, r);
  },
  overridestyle(t, e, n) {
    t.overrideStyle(e, n);
  },
  remove(t, e) {
    t.remove(e);
  },
  revertstyle(t, e) {
    t.revertStyle(e);
  },
  controlposition(t, e) {
    t.setControlPosition(e);
  },
  controls(t, e) {
    t.setControls(e);
  },
  drawingmode(t, e) {
    t.setDrawingMode(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  style(t, e) {
    t.setStyle(e);
  },
  togeojson(t, e) {
    t.toGeoJson(e);
  }
};
function AR(t) {
  var {
    options: e,
    onClick: n,
    onDblClick: r,
    onMouseDown: o,
    onMouseMove: i,
    onMouseOut: a,
    onMouseOver: s,
    onMouseUp: l,
    onRightClick: u,
    onAddFeature: c,
    onRemoveFeature: d,
    onRemoveProperty: f,
    onSetGeometry: v,
    onSetProperty: h,
    onLoad: g,
    onUnmount: p
  } = t, w = Ee(Ae), [b, k] = B(null), [E, m] = B(null), [O, S] = B(null), [W, P] = B(null), [$, j] = B(null), [_, I] = B(null), [R, V] = B(null), [J, G] = B(null), [te, Q] = B(null), [T, N] = B(null), [Y, F] = B(null), [X, L] = B(null), [M, z] = B(null), [A, U] = B(null);
  return y(() => {
    b !== null && b.setMap(w);
  }, [w]), y(() => {
    b && r && (E !== null && google.maps.event.removeListener(E), m(google.maps.event.addListener(b, "dblclick", r)));
  }, [r]), y(() => {
    b && o && (O !== null && google.maps.event.removeListener(O), S(google.maps.event.addListener(b, "mousedown", o)));
  }, [o]), y(() => {
    b && i && (W !== null && google.maps.event.removeListener(W), P(google.maps.event.addListener(b, "mousemove", i)));
  }, [i]), y(() => {
    b && a && ($ !== null && google.maps.event.removeListener($), j(google.maps.event.addListener(b, "mouseout", a)));
  }, [a]), y(() => {
    b && s && (_ !== null && google.maps.event.removeListener(_), I(google.maps.event.addListener(b, "mouseover", s)));
  }, [s]), y(() => {
    b && l && (R !== null && google.maps.event.removeListener(R), V(google.maps.event.addListener(b, "mouseup", l)));
  }, [l]), y(() => {
    b && u && (J !== null && google.maps.event.removeListener(J), G(google.maps.event.addListener(b, "rightclick", u)));
  }, [u]), y(() => {
    b && n && (te !== null && google.maps.event.removeListener(te), Q(google.maps.event.addListener(b, "click", n)));
  }, [n]), y(() => {
    b && c && (T !== null && google.maps.event.removeListener(T), N(google.maps.event.addListener(b, "addfeature", c)));
  }, [c]), y(() => {
    b && d && (Y !== null && google.maps.event.removeListener(Y), F(google.maps.event.addListener(b, "removefeature", d)));
  }, [d]), y(() => {
    b && f && (X !== null && google.maps.event.removeListener(X), L(google.maps.event.addListener(b, "removeproperty", f)));
  }, [f]), y(() => {
    b && v && (M !== null && google.maps.event.removeListener(M), z(google.maps.event.addListener(b, "setgeometry", v)));
  }, [v]), y(() => {
    b && h && (A !== null && google.maps.event.removeListener(A), U(google.maps.event.addListener(b, "setproperty", h)));
  }, [h]), y(() => {
    if (w !== null) {
      var H = new google.maps.Data(Xa(Xa({}, e), {}, {
        map: w
      }));
      r && m(google.maps.event.addListener(H, "dblclick", r)), o && S(google.maps.event.addListener(H, "mousedown", o)), i && P(google.maps.event.addListener(H, "mousemove", i)), a && j(google.maps.event.addListener(H, "mouseout", a)), s && I(google.maps.event.addListener(H, "mouseover", s)), l && V(google.maps.event.addListener(H, "mouseup", l)), u && G(google.maps.event.addListener(H, "rightclick", u)), n && Q(google.maps.event.addListener(H, "click", n)), c && N(google.maps.event.addListener(H, "addfeature", c)), d && F(google.maps.event.addListener(H, "removefeature", d)), f && L(google.maps.event.addListener(H, "removeproperty", f)), v && z(google.maps.event.addListener(H, "setgeometry", v)), h && U(google.maps.event.addListener(H, "setproperty", h)), k(H), g && g(H);
    }
    return () => {
      b && (E !== null && google.maps.event.removeListener(E), O !== null && google.maps.event.removeListener(O), W !== null && google.maps.event.removeListener(W), $ !== null && google.maps.event.removeListener($), _ !== null && google.maps.event.removeListener(_), R !== null && google.maps.event.removeListener(R), J !== null && google.maps.event.removeListener(J), te !== null && google.maps.event.removeListener(te), T !== null && google.maps.event.removeListener(T), Y !== null && google.maps.event.removeListener(Y), X !== null && google.maps.event.removeListener(X), M !== null && google.maps.event.removeListener(M), A !== null && google.maps.event.removeListener(A), p && p(b), b.setMap(null));
    };
  }, []), null;
}
Re(AR);
class jR extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "state", {
      data: null
    }), oe(this, "setDataCallback", () => {
      this.state.data !== null && this.props.onLoad && this.props.onLoad(this.state.data);
    });
  }
  componentDidMount() {
    if (this.context !== null) {
      var e = new google.maps.Data(Xa(Xa({}, this.props.options), {}, {
        map: this.context
      }));
      this.registeredEvents = $e({
        updaterMap: Em,
        eventMap: wm,
        prevProps: {},
        nextProps: this.props,
        instance: e
      }), this.setState(() => ({
        data: e
      }), this.setDataCallback);
    }
  }
  componentDidUpdate(e) {
    this.state.data !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: Em,
      eventMap: wm,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.data
    }));
  }
  componentWillUnmount() {
    this.state.data !== null && (this.props.onUnmount && this.props.onUnmount(this.state.data), We(this.registeredEvents), this.state.data && this.state.data.setMap(null));
  }
  render() {
    return null;
  }
}
oe(jR, "contextType", Ae);
function Dm(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Om(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Dm(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Dm(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var xm = {
  onClick: "click",
  onDefaultViewportChanged: "defaultviewport_changed",
  onStatusChanged: "status_changed"
}, Lm = {
  options(t, e) {
    t.setOptions(e);
  },
  url(t, e) {
    t.setUrl(e);
  },
  zIndex(t, e) {
    t.setZIndex(e);
  }
};
class FR extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "state", {
      kmlLayer: null
    }), oe(this, "setKmlLayerCallback", () => {
      this.state.kmlLayer !== null && this.props.onLoad && this.props.onLoad(this.state.kmlLayer);
    });
  }
  componentDidMount() {
    var e = new google.maps.KmlLayer(Om(Om({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $e({
      updaterMap: Lm,
      eventMap: xm,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        kmlLayer: e
      };
    }, this.setKmlLayerCallback);
  }
  componentDidUpdate(e) {
    this.state.kmlLayer !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: Lm,
      eventMap: xm,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.kmlLayer
    }));
  }
  componentWillUnmount() {
    this.state.kmlLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.kmlLayer), We(this.registeredEvents), this.state.kmlLayer.setMap(null));
  }
  render() {
    return null;
  }
}
oe(FR, "contextType", Ae);
function _C(t, e) {
  return typeof e == "function" ? e(t.offsetWidth, t.offsetHeight) : {
    x: 0,
    y: 0
  };
}
function _R(t, e) {
  return new e(t.lat, t.lng);
}
function IR(t, e) {
  return new e(new google.maps.LatLng(t.ne.lat, t.ne.lng), new google.maps.LatLng(t.sw.lat, t.sw.lng));
}
function RR(t, e, n) {
  return t instanceof e ? t : n(t, e);
}
function NR(t, e, n) {
  return t instanceof e ? t : n(t, e);
}
function $R(t, e, n) {
  var r = t && t.fromLatLngToDivPixel(n.getNorthEast()), o = t && t.fromLatLngToDivPixel(n.getSouthWest());
  return r && o ? {
    left: "".concat(o.x + e.x, "px"),
    top: "".concat(r.y + e.y, "px"),
    width: "".concat(r.x - o.x - e.x, "px"),
    height: "".concat(o.y - r.y - e.y, "px")
  } : {
    left: "-9999px",
    top: "-9999px"
  };
}
function zR(t, e, n) {
  var r = t && t.fromLatLngToDivPixel(n);
  if (r) {
    var {
      x: o,
      y: i
    } = r;
    return {
      left: "".concat(o + e.x, "px"),
      top: "".concat(i + e.y, "px")
    };
  }
  return {
    left: "-9999px",
    top: "-9999px"
  };
}
function IC(t, e, n, r) {
  return n !== void 0 ? $R(t, e, NR(n, google.maps.LatLngBounds, IR)) : zR(t, e, RR(r, google.maps.LatLng, _R));
}
function UR(t, e) {
  return t.left === e.left && t.top === e.top && t.width === e.height && t.height === e.height;
}
function Sm(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function WR(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Sm(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Sm(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function HR(t, e, n, r, o) {
  class i extends google.maps.OverlayView {
    constructor(s, l, u, c) {
      super(), this.container = s, this.pane = l, this.position = u, this.bounds = c;
    }
    onAdd() {
      var s, l = (s = this.getPanes()) === null || s === void 0 ? void 0 : s[this.pane];
      l == null || l.appendChild(this.container);
    }
    draw() {
      var s = this.getProjection(), l = WR({}, this.container ? _C(this.container, o) : {
        x: 0,
        y: 0
      }), u = IC(s, l, this.bounds, this.position);
      for (var [c, d] of Object.entries(u))
        this.container.style[c] = d;
    }
    onRemove() {
      this.container.parentNode !== null && this.container.parentNode.removeChild(this.container);
    }
  }
  return new i(t, e, n, r);
}
function Pm(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function VR(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Pm(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Pm(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
function km(t) {
  if (!t)
    return "";
  var e = t instanceof google.maps.LatLng ? t : new google.maps.LatLng(t.lat, t.lng);
  return e + "";
}
function Mm(t) {
  if (!t)
    return "";
  var e = t instanceof google.maps.LatLngBounds ? t : new google.maps.LatLngBounds(new google.maps.LatLng(t.south, t.east), new google.maps.LatLng(t.north, t.west));
  return e + "";
}
function qR(t) {
  var {
    position: e,
    bounds: n,
    mapPaneName: r,
    zIndex: o,
    onLoad: i,
    onUnmount: a,
    getPixelPositionOffset: s,
    children: l
  } = t, u = Ee(Ae), c = En(() => {
    var f = document.createElement("div");
    return f.style.position = "absolute", f;
  }, []), d = En(() => HR(c, r, e, n, s), [c, r, e, n]);
  return y(() => (i == null || i(d), d == null || d.setMap(u), () => {
    a == null || a(d), d == null || d.setMap(null);
  }), [u, d]), y(() => {
    c.style.zIndex = "".concat(o);
  }, [o, c]), rs.createPortal(l, c);
}
Re(qR);
class mo extends xe {
  constructor(e) {
    super(e), oe(this, "state", {
      paneEl: null,
      containerStyle: {
        // set initial position
        position: "absolute"
      }
    }), oe(this, "updatePane", () => {
      var r = this.props.mapPaneName, o = this.overlayView.getPanes();
      $t(!!r, "OverlayView requires props.mapPaneName but got %s", r), o ? this.setState({
        paneEl: o[r]
      }) : this.setState({
        paneEl: null
      });
    }), oe(this, "onAdd", () => {
      var r, o;
      this.updatePane(), (r = (o = this.props).onLoad) === null || r === void 0 || r.call(o, this.overlayView);
    }), oe(this, "onPositionElement", () => {
      var r = this.overlayView.getProjection(), o = VR({
        x: 0,
        y: 0
      }, this.containerRef.current ? _C(this.containerRef.current, this.props.getPixelPositionOffset) : {}), i = IC(r, o, this.props.bounds, this.props.position);
      if (!UR(i, {
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        left: this.state.containerStyle.left,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        top: this.state.containerStyle.top,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        width: this.state.containerStyle.width,
        // eslint-disable-next-line @typescript-eslint/ban-ts-comment
        // @ts-ignore
        height: this.state.containerStyle.height
      })) {
        var a, s, l, u;
        this.setState({
          containerStyle: {
            top: (a = i.top) !== null && a !== void 0 ? a : 0,
            left: (s = i.left) !== null && s !== void 0 ? s : 0,
            width: (l = i.width) !== null && l !== void 0 ? l : 0,
            height: (u = i.height) !== null && u !== void 0 ? u : 0,
            position: "absolute"
          }
        });
      }
    }), oe(this, "draw", () => {
      this.onPositionElement();
    }), oe(this, "onRemove", () => {
      var r, o;
      this.setState(() => ({
        paneEl: null
      })), (r = (o = this.props).onUnmount) === null || r === void 0 || r.call(o, this.overlayView);
    }), this.containerRef = Cr();
    var n = new google.maps.OverlayView();
    n.onAdd = this.onAdd, n.draw = this.draw, n.onRemove = this.onRemove, this.overlayView = n;
  }
  componentDidMount() {
    this.overlayView.setMap(this.context);
  }
  componentDidUpdate(e) {
    var n = km(e.position), r = km(this.props.position), o = Mm(e.bounds), i = Mm(this.props.bounds);
    (n !== r || o !== i) && this.overlayView.draw(), e.mapPaneName !== this.props.mapPaneName && this.updatePane();
  }
  componentWillUnmount() {
    this.overlayView.setMap(null);
  }
  render() {
    var e = this.state.paneEl;
    return e ? rs.createPortal(x.jsx("div", {
      ref: this.containerRef,
      style: this.state.containerStyle,
      children: zt.only(this.props.children)
    }), e) : null;
  }
}
oe(mo, "FLOAT_PANE", "floatPane");
oe(mo, "MAP_PANE", "mapPane");
oe(mo, "MARKER_LAYER", "markerLayer");
oe(mo, "OVERLAY_LAYER", "overlayLayer");
oe(mo, "OVERLAY_MOUSE_TARGET", "overlayMouseTarget");
oe(mo, "contextType", Ae);
function GR() {
}
function Bm(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Tm(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Bm(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Bm(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var Am = {
  onDblClick: "dblclick",
  onClick: "click"
}, jm = {
  opacity(t, e) {
    t.setOpacity(e);
  }
};
function ZR(t) {
  var {
    url: e,
    bounds: n,
    options: r,
    visible: o
  } = t, i = Ee(Ae), a = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east)), s = En(() => new google.maps.GroundOverlay(e, a, r), []);
  return y(() => {
    s !== null && s.setMap(i);
  }, [i]), y(() => {
    typeof e < "u" && s !== null && (s.set("url", e), s.setMap(i));
  }, [s, e]), y(() => {
    typeof o < "u" && s !== null && s.setOpacity(o ? 1 : 0);
  }, [s, o]), y(() => {
    var l = new google.maps.LatLngBounds(new google.maps.LatLng(n.south, n.west), new google.maps.LatLng(n.north, n.east));
    typeof n < "u" && s !== null && (s.set("bounds", l), s.setMap(i));
  }, [s, n]), null;
}
Re(ZR);
class RC extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "state", {
      groundOverlay: null
    }), oe(this, "setGroundOverlayCallback", () => {
      this.state.groundOverlay !== null && this.props.onLoad && this.props.onLoad(this.state.groundOverlay);
    });
  }
  componentDidMount() {
    $t(!!this.props.url || !!this.props.bounds, "For GroundOverlay, url and bounds are passed in to constructor and are immutable after instantiated. This is the behavior of Google Maps JavaScript API v3 ( See https://developers.google.com/maps/documentation/javascript/reference#GroundOverlay) Hence, use the corresponding two props provided by `react-google-maps-api`, url and bounds. In some cases, you'll need the GroundOverlay component to reflect the changes of url and bounds. You can leverage the React's key property to remount the component. Typically, just `key={url}` would serve your need. See https://github.com/tomchentw/react-google-maps/issues/655");
    var e = new google.maps.GroundOverlay(this.props.url, this.props.bounds, Tm(Tm({}, this.props.options), {}, {
      map: this.context
    }));
    this.registeredEvents = $e({
      updaterMap: jm,
      eventMap: Am,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        groundOverlay: e
      };
    }, this.setGroundOverlayCallback);
  }
  componentDidUpdate(e) {
    this.state.groundOverlay !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: jm,
      eventMap: Am,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.groundOverlay
    }));
  }
  componentWillUnmount() {
    this.state.groundOverlay && (this.props.onUnmount && this.props.onUnmount(this.state.groundOverlay), this.state.groundOverlay.setMap(null));
  }
  render() {
    return null;
  }
}
oe(RC, "defaultProps", {
  onLoad: GR
});
oe(RC, "contextType", Ae);
function Fm(t, e) {
  var n = Object.keys(t);
  if (Object.getOwnPropertySymbols) {
    var r = Object.getOwnPropertySymbols(t);
    e && (r = r.filter(function(o) {
      return Object.getOwnPropertyDescriptor(t, o).enumerable;
    })), n.push.apply(n, r);
  }
  return n;
}
function Ja(t) {
  for (var e = 1; e < arguments.length; e++) {
    var n = arguments[e] != null ? arguments[e] : {};
    e % 2 ? Fm(Object(n), !0).forEach(function(r) {
      oe(t, r, n[r]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(t, Object.getOwnPropertyDescriptors(n)) : Fm(Object(n)).forEach(function(r) {
      Object.defineProperty(t, r, Object.getOwnPropertyDescriptor(n, r));
    });
  }
  return t;
}
var _m = {}, Im = {
  data(t, e) {
    t.setData(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  options(t, e) {
    t.setOptions(e);
  }
};
function KR(t) {
  var {
    data: e,
    onLoad: n,
    onUnmount: r,
    options: o
  } = t, i = Ee(Ae), [a, s] = B(null);
  return y(() => {
    google.maps.visualization || $t(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} in useJsApiScript? %s', google.maps.visualization);
  }, []), y(() => {
    $t(!!e, "data property is required in HeatmapLayer %s", e);
  }, [e]), y(() => {
    a !== null && a.setMap(i);
  }, [i]), y(() => {
    o && a !== null && a.setOptions(o);
  }, [a, o]), y(() => {
    var l = new google.maps.visualization.HeatmapLayer(Ja(Ja({}, o), {}, {
      data: e,
      map: i
    }));
    return s(l), n && n(l), () => {
      a !== null && (r && r(a), a.setMap(null));
    };
  }, []), null;
}
Re(KR);
class YR extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "state", {
      heatmapLayer: null
    }), oe(this, "setHeatmapLayerCallback", () => {
      this.state.heatmapLayer !== null && this.props.onLoad && this.props.onLoad(this.state.heatmapLayer);
    });
  }
  componentDidMount() {
    $t(!!google.maps.visualization, 'Did you include prop libraries={["visualization"]} to <LoadScript />? %s', google.maps.visualization), $t(!!this.props.data, "data property is required in HeatmapLayer %s", this.props.data);
    var e = new google.maps.visualization.HeatmapLayer(Ja(Ja({}, this.props.options), {}, {
      data: this.props.data,
      map: this.context
    }));
    this.registeredEvents = $e({
      updaterMap: Im,
      eventMap: _m,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        heatmapLayer: e
      };
    }, this.setHeatmapLayerCallback);
  }
  componentDidUpdate(e) {
    We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: Im,
      eventMap: _m,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.heatmapLayer
    });
  }
  componentWillUnmount() {
    this.state.heatmapLayer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.heatmapLayer), We(this.registeredEvents), this.state.heatmapLayer.setMap(null));
  }
  render() {
    return null;
  }
}
oe(YR, "contextType", Ae);
var Rm = {
  onCloseClick: "closeclick",
  onPanoChanged: "pano_changed",
  onPositionChanged: "position_changed",
  onPovChanged: "pov_changed",
  onResize: "resize",
  onStatusChanged: "status_changed",
  onVisibleChanged: "visible_changed",
  onZoomChanged: "zoom_changed"
}, Nm = {
  register(t, e, n) {
    t.registerPanoProvider(e, n);
  },
  links(t, e) {
    t.setLinks(e);
  },
  motionTracking(t, e) {
    t.setMotionTracking(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  pano(t, e) {
    t.setPano(e);
  },
  position(t, e) {
    t.setPosition(e);
  },
  pov(t, e) {
    t.setPov(e);
  },
  visible(t, e) {
    t.setVisible(e);
  },
  zoom(t, e) {
    t.setZoom(e);
  }
};
class XR extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "state", {
      streetViewPanorama: null
    }), oe(this, "setStreetViewPanoramaCallback", () => {
      this.state.streetViewPanorama !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewPanorama);
    });
  }
  componentDidMount() {
    var e, n, r = (e = (n = this.context) === null || n === void 0 ? void 0 : n.getStreetView()) !== null && e !== void 0 ? e : null;
    this.registeredEvents = $e({
      updaterMap: Nm,
      eventMap: Rm,
      prevProps: {},
      nextProps: this.props,
      instance: r
    }), this.setState(() => ({
      streetViewPanorama: r
    }), this.setStreetViewPanoramaCallback);
  }
  componentDidUpdate(e) {
    this.state.streetViewPanorama !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: Nm,
      eventMap: Rm,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.streetViewPanorama
    }));
  }
  componentWillUnmount() {
    this.state.streetViewPanorama !== null && (this.props.onUnmount && this.props.onUnmount(this.state.streetViewPanorama), We(this.registeredEvents), this.state.streetViewPanorama.setVisible(!1));
  }
  render() {
    return null;
  }
}
oe(XR, "contextType", Ae);
class JR extends xe {
  constructor() {
    super(...arguments), oe(this, "state", {
      streetViewService: null
    }), oe(this, "setStreetViewServiceCallback", () => {
      this.state.streetViewService !== null && this.props.onLoad && this.props.onLoad(this.state.streetViewService);
    });
  }
  componentDidMount() {
    var e = new google.maps.StreetViewService();
    this.setState(function() {
      return {
        streetViewService: e
      };
    }, this.setStreetViewServiceCallback);
  }
  componentWillUnmount() {
    this.state.streetViewService !== null && this.props.onUnmount && this.props.onUnmount(this.state.streetViewService);
  }
  render() {
    return null;
  }
}
oe(JR, "contextType", Ae);
var $m = {
  onDirectionsChanged: "directions_changed"
}, zm = {
  directions(t, e) {
    t.setDirections(e);
  },
  map(t, e) {
    t.setMap(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  panel(t, e) {
    t.setPanel(e);
  },
  routeIndex(t, e) {
    t.setRouteIndex(e);
  }
};
class QR extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "state", {
      directionsRenderer: null
    }), oe(this, "setDirectionsRendererCallback", () => {
      this.state.directionsRenderer !== null && (this.state.directionsRenderer.setMap(this.context), this.props.onLoad && this.props.onLoad(this.state.directionsRenderer));
    });
  }
  componentDidMount() {
    var e = new google.maps.DirectionsRenderer(this.props.options);
    this.registeredEvents = $e({
      updaterMap: zm,
      eventMap: $m,
      prevProps: {},
      nextProps: this.props,
      instance: e
    }), this.setState(function() {
      return {
        directionsRenderer: e
      };
    }, this.setDirectionsRendererCallback);
  }
  componentDidUpdate(e) {
    this.state.directionsRenderer !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: zm,
      eventMap: $m,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.directionsRenderer
    }));
  }
  componentWillUnmount() {
    this.state.directionsRenderer !== null && (this.props.onUnmount && this.props.onUnmount(this.state.directionsRenderer), We(this.registeredEvents), this.state.directionsRenderer && this.state.directionsRenderer.setMap(null));
  }
  render() {
    return null;
  }
}
oe(QR, "contextType", Ae);
var Um = {
  onPlacesChanged: "places_changed"
}, Wm = {
  bounds(t, e) {
    t.setBounds(e);
  }
};
class NC extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "containerElement", Cr()), oe(this, "state", {
      searchBox: null
    }), oe(this, "setSearchBoxCallback", () => {
      this.state.searchBox !== null && this.props.onLoad && this.props.onLoad(this.state.searchBox);
    });
  }
  componentDidMount() {
    if ($t(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places), this.containerElement !== null && this.containerElement.current !== null) {
      var e = this.containerElement.current.querySelector("input");
      if (e !== null) {
        var n = new google.maps.places.SearchBox(e, this.props.options);
        this.registeredEvents = $e({
          updaterMap: Wm,
          eventMap: Um,
          prevProps: {},
          nextProps: this.props,
          instance: n
        }), this.setState(function() {
          return {
            searchBox: n
          };
        }, this.setSearchBoxCallback);
      }
    }
  }
  componentDidUpdate(e) {
    this.state.searchBox !== null && (We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: Wm,
      eventMap: Um,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.searchBox
    }));
  }
  componentWillUnmount() {
    this.state.searchBox !== null && (this.props.onUnmount && this.props.onUnmount(this.state.searchBox), We(this.registeredEvents));
  }
  render() {
    return x.jsx("div", {
      ref: this.containerElement,
      children: zt.only(this.props.children)
    });
  }
}
oe(NC, "contextType", Ae);
var Hm = {
  onPlaceChanged: "place_changed"
}, Vm = {
  bounds(t, e) {
    t.setBounds(e);
  },
  restrictions(t, e) {
    t.setComponentRestrictions(e);
  },
  fields(t, e) {
    t.setFields(e);
  },
  options(t, e) {
    t.setOptions(e);
  },
  types(t, e) {
    t.setTypes(e);
  }
};
class $C extends xe {
  constructor() {
    super(...arguments), oe(this, "registeredEvents", []), oe(this, "containerElement", Cr()), oe(this, "state", {
      autocomplete: null
    }), oe(this, "setAutocompleteCallback", () => {
      this.state.autocomplete !== null && this.props.onLoad && this.props.onLoad(this.state.autocomplete);
    });
  }
  componentDidMount() {
    var e;
    $t(!!google.maps.places, 'You need to provide libraries={["places"]} prop to <LoadScript /> component %s', google.maps.places);
    var n = (e = this.containerElement.current) === null || e === void 0 ? void 0 : e.querySelector("input");
    if (n) {
      var r = new google.maps.places.Autocomplete(n, this.props.options);
      this.registeredEvents = $e({
        updaterMap: Vm,
        eventMap: Hm,
        prevProps: {},
        nextProps: this.props,
        instance: r
      }), this.setState(() => ({
        autocomplete: r
      }), this.setAutocompleteCallback);
    }
  }
  componentDidUpdate(e) {
    We(this.registeredEvents), this.registeredEvents = $e({
      updaterMap: Vm,
      eventMap: Hm,
      prevProps: e,
      nextProps: this.props,
      instance: this.state.autocomplete
    });
  }
  componentWillUnmount() {
    this.state.autocomplete !== null && We(this.registeredEvents);
  }
  render() {
    return x.jsx("div", {
      ref: this.containerElement,
      className: this.props.className,
      children: zt.only(this.props.children)
    });
  }
}
oe($C, "defaultProps", {
  className: ""
});
oe($C, "contextType", Ae);
function R2({
  googleMapsApiKey: t,
  children: e,
  ...n
}) {
  return /* @__PURE__ */ x.jsx(
    kC,
    {
      libraries: ["places", "marker", "maps"],
      googleMapsApiKey: t,
      ...n,
      children: e
    }
  );
}
function N2(t) {
  const { children: e = !1 } = t, [n, r] = B([]);
  function o(u) {
    return !!n.some((c) => c.key === u);
  }
  function i(u) {
    var c;
    return (c = n.find((d) => d.key === u)) == null ? void 0 : c.data;
  }
  function a(u, c) {
    const d = o(u);
    r(d ? (f) => [...f.filter((h) => h.key !== u), { key: u, data: c }] : [...n, { key: u, data: c }]);
  }
  function s(u) {
    r(n.filter((c) => c.key !== u));
  }
  function l() {
    r([]);
  }
  return /* @__PURE__ */ x.jsx(
    yd.Provider,
    {
      value: { modalIsOpen: o, modalData: i, openModal: a, closeModal: s, closeAll: l },
      children: e
    }
  );
}
let eN = { data: "" }, tN = (t) => typeof window == "object" ? ((t ? t.querySelector("#_goober") : window._goober) || Object.assign((t || document.head).appendChild(document.createElement("style")), { innerHTML: " ", id: "_goober" })).firstChild : t || eN, nN = /(?:([\u0080-\uFFFF\w-%@]+) *:? *([^{;]+?);|([^;}{]*?) *{)|(}\s*)/g, rN = /\/\*[^]*?\*\/|  +/g, qm = /\n+/g, gr = (t, e) => {
  let n = "", r = "", o = "";
  for (let i in t) {
    let a = t[i];
    i[0] == "@" ? i[1] == "i" ? n = i + " " + a + ";" : r += i[1] == "f" ? gr(a, i) : i + "{" + gr(a, i[1] == "k" ? "" : e) + "}" : typeof a == "object" ? r += gr(a, e ? e.replace(/([^,])+/g, (s) => i.replace(/(^:.*)|([^,])+/g, (l) => /&/.test(l) ? l.replace(/&/g, s) : s ? s + " " + l : l)) : i) : a != null && (i = /^--/.test(i) ? i : i.replace(/[A-Z]/g, "-$&").toLowerCase(), o += gr.p ? gr.p(i, a) : i + ":" + a + ";");
  }
  return n + (e && o ? e + "{" + o + "}" : o) + r;
}, Kn = {}, zC = (t) => {
  if (typeof t == "object") {
    let e = "";
    for (let n in t) e += n + zC(t[n]);
    return e;
  }
  return t;
}, oN = (t, e, n, r, o) => {
  let i = zC(t), a = Kn[i] || (Kn[i] = ((l) => {
    let u = 0, c = 11;
    for (; u < l.length; ) c = 101 * c + l.charCodeAt(u++) >>> 0;
    return "go" + c;
  })(i));
  if (!Kn[a]) {
    let l = i !== t ? t : ((u) => {
      let c, d, f = [{}];
      for (; c = nN.exec(u.replace(rN, "")); ) c[4] ? f.shift() : c[3] ? (d = c[3].replace(qm, " ").trim(), f.unshift(f[0][d] = f[0][d] || {})) : f[0][c[1]] = c[2].replace(qm, " ").trim();
      return f[0];
    })(t);
    Kn[a] = gr(o ? { ["@keyframes " + a]: l } : l, n ? "" : "." + a);
  }
  let s = n && Kn.g ? Kn.g : null;
  return n && (Kn.g = Kn[a]), ((l, u, c, d) => {
    d ? u.data = u.data.replace(d, l) : u.data.indexOf(l) === -1 && (u.data = c ? l + u.data : u.data + l);
  })(Kn[a], e, r, s), a;
}, iN = (t, e, n) => t.reduce((r, o, i) => {
  let a = e[i];
  if (a && a.call) {
    let s = a(n), l = s && s.props && s.props.className || /^go/.test(s) && s;
    a = l ? "." + l : s && typeof s == "object" ? s.props ? "" : gr(s, "") : s === !1 ? "" : s;
  }
  return r + o + (a ?? "");
}, "");
function Ks(t) {
  let e = this || {}, n = t.call ? t(e.p) : t;
  return oN(n.unshift ? n.raw ? iN(n, [].slice.call(arguments, 1), e.p) : n.reduce((r, o) => Object.assign(r, o && o.call ? o(e.p) : o), {}) : n, tN(e.target), e.g, e.o, e.k);
}
let UC, Ku, Yu;
Ks.bind({ g: 1 });
let er = Ks.bind({ k: 1 });
function aN(t, e, n, r) {
  gr.p = e, UC = t, Ku = n, Yu = r;
}
function Pr(t, e) {
  let n = this || {};
  return function() {
    let r = arguments;
    function o(i, a) {
      let s = Object.assign({}, i), l = s.className || o.className;
      n.p = Object.assign({ theme: Ku && Ku() }, s), n.o = / *go\d+/.test(l), s.className = Ks.apply(n, r) + (l ? " " + l : "");
      let u = t;
      return t[0] && (u = s.as || t, delete s.as), Yu && u[0] && Yu(s), UC(u, s);
    }
    return o;
  };
}
var sN = (t) => typeof t == "function", Qa = (t, e) => sN(t) ? t(e) : t, lN = /* @__PURE__ */ (() => {
  let t = 0;
  return () => (++t).toString();
})(), WC = /* @__PURE__ */ (() => {
  let t;
  return () => {
    if (t === void 0 && typeof window < "u") {
      let e = matchMedia("(prefers-reduced-motion: reduce)");
      t = !e || e.matches;
    }
    return t;
  };
})(), uN = 20, ga = /* @__PURE__ */ new Map(), cN = 1e3, Gm = (t) => {
  if (ga.has(t)) return;
  let e = setTimeout(() => {
    ga.delete(t), Qr({ type: 4, toastId: t });
  }, cN);
  ga.set(t, e);
}, dN = (t) => {
  let e = ga.get(t);
  e && clearTimeout(e);
}, Xu = (t, e) => {
  switch (e.type) {
    case 0:
      return { ...t, toasts: [e.toast, ...t.toasts].slice(0, uN) };
    case 1:
      return e.toast.id && dN(e.toast.id), { ...t, toasts: t.toasts.map((i) => i.id === e.toast.id ? { ...i, ...e.toast } : i) };
    case 2:
      let { toast: n } = e;
      return t.toasts.find((i) => i.id === n.id) ? Xu(t, { type: 1, toast: n }) : Xu(t, { type: 0, toast: n });
    case 3:
      let { toastId: r } = e;
      return r ? Gm(r) : t.toasts.forEach((i) => {
        Gm(i.id);
      }), { ...t, toasts: t.toasts.map((i) => i.id === r || r === void 0 ? { ...i, visible: !1 } : i) };
    case 4:
      return e.toastId === void 0 ? { ...t, toasts: [] } : { ...t, toasts: t.toasts.filter((i) => i.id !== e.toastId) };
    case 5:
      return { ...t, pausedAt: e.time };
    case 6:
      let o = e.time - (t.pausedAt || 0);
      return { ...t, pausedAt: void 0, toasts: t.toasts.map((i) => ({ ...i, pauseDuration: i.pauseDuration + o })) };
  }
}, va = [], ma = { toasts: [], pausedAt: void 0 }, Qr = (t) => {
  ma = Xu(ma, t), va.forEach((e) => {
    e(ma);
  });
}, fN = { blank: 4e3, error: 4e3, success: 2e3, loading: 1 / 0, custom: 4e3 }, pN = (t = {}) => {
  let [e, n] = B(ma);
  y(() => (va.push(n), () => {
    let o = va.indexOf(n);
    o > -1 && va.splice(o, 1);
  }), [e]);
  let r = e.toasts.map((o) => {
    var i, a;
    return { ...t, ...t[o.type], ...o, duration: o.duration || ((i = t[o.type]) == null ? void 0 : i.duration) || (t == null ? void 0 : t.duration) || fN[o.type], style: { ...t.style, ...(a = t[o.type]) == null ? void 0 : a.style, ...o.style } };
  });
  return { ...e, toasts: r };
}, hN = (t, e = "blank", n) => ({ createdAt: Date.now(), visible: !0, type: e, ariaProps: { role: "status", "aria-live": "polite" }, message: t, pauseDuration: 0, ...n, id: (n == null ? void 0 : n.id) || lN() }), Ei = (t) => (e, n) => {
  let r = hN(e, t, n);
  return Qr({ type: 2, toast: r }), r.id;
}, wn = (t, e) => Ei("blank")(t, e);
wn.error = Ei("error");
wn.success = Ei("success");
wn.loading = Ei("loading");
wn.custom = Ei("custom");
wn.dismiss = (t) => {
  Qr({ type: 3, toastId: t });
};
wn.remove = (t) => Qr({ type: 4, toastId: t });
wn.promise = (t, e, n) => {
  let r = wn.loading(e.loading, { ...n, ...n == null ? void 0 : n.loading });
  return t.then((o) => (wn.success(Qa(e.success, o), { id: r, ...n, ...n == null ? void 0 : n.success }), o)).catch((o) => {
    wn.error(Qa(e.error, o), { id: r, ...n, ...n == null ? void 0 : n.error });
  }), t;
};
var gN = (t, e) => {
  Qr({ type: 1, toast: { id: t, height: e } });
}, vN = () => {
  Qr({ type: 5, time: Date.now() });
}, mN = (t) => {
  let { toasts: e, pausedAt: n } = pN(t);
  y(() => {
    if (n) return;
    let i = Date.now(), a = e.map((s) => {
      if (s.duration === 1 / 0) return;
      let l = (s.duration || 0) + s.pauseDuration - (i - s.createdAt);
      if (l < 0) {
        s.visible && wn.dismiss(s.id);
        return;
      }
      return setTimeout(() => wn.dismiss(s.id), l);
    });
    return () => {
      a.forEach((s) => s && clearTimeout(s));
    };
  }, [e, n]);
  let r = it(() => {
    n && Qr({ type: 6, time: Date.now() });
  }, [n]), o = it((i, a) => {
    let { reverseOrder: s = !1, gutter: l = 8, defaultPosition: u } = a || {}, c = e.filter((v) => (v.position || u) === (i.position || u) && v.height), d = c.findIndex((v) => v.id === i.id), f = c.filter((v, h) => h < d && v.visible).length;
    return c.filter((v) => v.visible).slice(...s ? [f + 1] : [0, f]).reduce((v, h) => v + (h.height || 0) + l, 0);
  }, [e]);
  return { toasts: e, handlers: { updateHeight: gN, startPause: vN, endPause: r, calculateOffset: o } };
}, yN = er`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
 transform: scale(1) rotate(45deg);
  opacity: 1;
}`, bN = er`
from {
  transform: scale(0);
  opacity: 0;
}
to {
  transform: scale(1);
  opacity: 1;
}`, CN = er`
from {
  transform: scale(0) rotate(90deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(90deg);
	opacity: 1;
}`, wN = Pr("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(t) => t.primary || "#ff4b4b"};
  position: relative;
  transform: rotate(45deg);

  animation: ${yN} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;

  &:after,
  &:before {
    content: '';
    animation: ${bN} 0.15s ease-out forwards;
    animation-delay: 150ms;
    position: absolute;
    border-radius: 3px;
    opacity: 0;
    background: ${(t) => t.secondary || "#fff"};
    bottom: 9px;
    left: 4px;
    height: 2px;
    width: 12px;
  }

  &:before {
    animation: ${CN} 0.15s ease-out forwards;
    animation-delay: 180ms;
    transform: rotate(90deg);
  }
`, EN = er`
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
`, DN = Pr("div")`
  width: 12px;
  height: 12px;
  box-sizing: border-box;
  border: 2px solid;
  border-radius: 100%;
  border-color: ${(t) => t.secondary || "#e0e0e0"};
  border-right-color: ${(t) => t.primary || "#616161"};
  animation: ${EN} 1s linear infinite;
`, ON = er`
from {
  transform: scale(0) rotate(45deg);
	opacity: 0;
}
to {
  transform: scale(1) rotate(45deg);
	opacity: 1;
}`, xN = er`
0% {
	height: 0;
	width: 0;
	opacity: 0;
}
40% {
  height: 0;
	width: 6px;
	opacity: 1;
}
100% {
  opacity: 1;
  height: 10px;
}`, LN = Pr("div")`
  width: 20px;
  opacity: 0;
  height: 20px;
  border-radius: 10px;
  background: ${(t) => t.primary || "#61d345"};
  position: relative;
  transform: rotate(45deg);

  animation: ${ON} 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
  animation-delay: 100ms;
  &:after {
    content: '';
    box-sizing: border-box;
    animation: ${xN} 0.2s ease-out forwards;
    opacity: 0;
    animation-delay: 200ms;
    position: absolute;
    border-right: 2px solid;
    border-bottom: 2px solid;
    border-color: ${(t) => t.secondary || "#fff"};
    bottom: 6px;
    left: 6px;
    height: 10px;
    width: 6px;
  }
`, SN = Pr("div")`
  position: absolute;
`, PN = Pr("div")`
  position: relative;
  display: flex;
  justify-content: center;
  align-items: center;
  min-width: 20px;
  min-height: 20px;
`, kN = er`
from {
  transform: scale(0.6);
  opacity: 0.4;
}
to {
  transform: scale(1);
  opacity: 1;
}`, MN = Pr("div")`
  position: relative;
  transform: scale(0.6);
  opacity: 0.4;
  min-width: 20px;
  animation: ${kN} 0.3s 0.12s cubic-bezier(0.175, 0.885, 0.32, 1.275)
    forwards;
`, BN = ({ toast: t }) => {
  let { icon: e, type: n, iconTheme: r } = t;
  return e !== void 0 ? typeof e == "string" ? tt.createElement(MN, null, e) : e : n === "blank" ? null : tt.createElement(PN, null, tt.createElement(DN, { ...r }), n !== "loading" && tt.createElement(SN, null, n === "error" ? tt.createElement(wN, { ...r }) : tt.createElement(LN, { ...r })));
}, TN = (t) => `
0% {transform: translate3d(0,${t * -200}%,0) scale(.6); opacity:.5;}
100% {transform: translate3d(0,0,0) scale(1); opacity:1;}
`, AN = (t) => `
0% {transform: translate3d(0,0,-1px) scale(1); opacity:1;}
100% {transform: translate3d(0,${t * -150}%,-1px) scale(.6); opacity:0;}
`, jN = "0%{opacity:0;} 100%{opacity:1;}", FN = "0%{opacity:1;} 100%{opacity:0;}", _N = Pr("div")`
  display: flex;
  align-items: center;
  background: #fff;
  color: #363636;
  line-height: 1.3;
  will-change: transform;
  box-shadow: 0 3px 10px rgba(0, 0, 0, 0.1), 0 3px 3px rgba(0, 0, 0, 0.05);
  max-width: 350px;
  pointer-events: auto;
  padding: 8px 10px;
  border-radius: 8px;
`, IN = Pr("div")`
  display: flex;
  justify-content: center;
  margin: 4px 10px;
  color: inherit;
  flex: 1 1 auto;
  white-space: pre-line;
`, RN = (t, e) => {
  let n = t.includes("top") ? 1 : -1, [r, o] = WC() ? [jN, FN] : [TN(n), AN(n)];
  return { animation: e ? `${er(r)} 0.35s cubic-bezier(.21,1.02,.73,1) forwards` : `${er(o)} 0.4s forwards cubic-bezier(.06,.71,.55,1)` };
}, NN = tt.memo(({ toast: t, position: e, style: n, children: r }) => {
  let o = t.height ? RN(t.position || e || "top-center", t.visible) : { opacity: 0 }, i = tt.createElement(BN, { toast: t }), a = tt.createElement(IN, { ...t.ariaProps }, Qa(t.message, t));
  return tt.createElement(_N, { className: t.className, style: { ...o, ...n, ...t.style } }, typeof r == "function" ? r({ icon: i, message: a }) : tt.createElement(tt.Fragment, null, i, a));
});
aN(tt.createElement);
var $N = ({ id: t, className: e, style: n, onHeightUpdate: r, children: o }) => {
  let i = tt.useCallback((a) => {
    if (a) {
      let s = () => {
        let l = a.getBoundingClientRect().height;
        r(t, l);
      };
      s(), new MutationObserver(s).observe(a, { subtree: !0, childList: !0, characterData: !0 });
    }
  }, [t, r]);
  return tt.createElement("div", { ref: i, className: e, style: n }, o);
}, zN = (t, e) => {
  let n = t.includes("top"), r = n ? { top: 0 } : { bottom: 0 }, o = t.includes("center") ? { justifyContent: "center" } : t.includes("right") ? { justifyContent: "flex-end" } : {};
  return { left: 0, right: 0, display: "flex", position: "absolute", transition: WC() ? void 0 : "all 230ms cubic-bezier(.21,1.02,.73,1)", transform: `translateY(${e * (n ? 1 : -1)}px)`, ...r, ...o };
}, UN = Ks`
  z-index: 9999;
  > * {
    pointer-events: auto;
  }
`, sa = 16, WN = ({ reverseOrder: t, position: e = "top-center", toastOptions: n, gutter: r, children: o, containerStyle: i, containerClassName: a }) => {
  let { toasts: s, handlers: l } = mN(n);
  return tt.createElement("div", { style: { position: "fixed", zIndex: 9999, top: sa, left: sa, right: sa, bottom: sa, pointerEvents: "none", ...i }, className: a, onMouseEnter: l.startPause, onMouseLeave: l.endPause }, s.map((u) => {
    let c = u.position || e, d = l.calculateOffset(u, { reverseOrder: t, gutter: r, defaultPosition: e }), f = zN(c, d);
    return tt.createElement($N, { id: u.id, key: u.id, onHeightUpdate: l.updateHeight, className: u.visible ? UN : "", style: f }, u.type === "custom" ? Qa(u.message, u) : o ? o(u) : tt.createElement(NN, { toast: u, position: c }));
  }));
}, Zm = wn;
function $2({ children: t }) {
  function e(n) {
    switch (n.type) {
      case "success":
        return Zm.success(n.message, {
          style: {
            background: "#10B981",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#059669",
            secondary: "#ffffff"
          }
        });
      case "danger":
        return Zm.error(n.message, {
          style: {
            background: "#E11D48",
            color: "#ffffff",
            padding: "12px 16px",
            fontSize: "14px",
            fontWeight: 600
          },
          iconTheme: {
            primary: "#BE123C",
            secondary: "#ffffff"
          }
        });
    }
  }
  return /* @__PURE__ */ x.jsxs(wC.Provider, { value: { showToast: e }, children: [
    /* @__PURE__ */ x.jsx(
      WN,
      {
        position: "top-right",
        containerStyle: { zIndex: 999999999999999 }
      }
    ),
    t
  ] });
}
function HN({ children: t, fallback: e = null }) {
  return pI() ? /* @__PURE__ */ x.jsx(x.Fragment, { children: t() }) : /* @__PURE__ */ x.jsx(x.Fragment, { children: e });
}
function z2({
  coordinates: t,
  zoom: e = 18,
  draggable: n = !1,
  className: r,
  ...o
}) {
  return t ? /* @__PURE__ */ x.jsx("div", { className: "arkynGoogleMapPinned " + r, ...o, children: /* @__PURE__ */ x.jsx(
    xI,
    {
      zoom: e,
      center: t,
      mapContainerStyle: {
        borderRadius: "var(--rounded-cards)",
        width: "100%",
        height: "100%"
      },
      children: /* @__PURE__ */ x.jsx(MC, { draggable: n, position: t })
    }
  ) }) : /* @__PURE__ */ x.jsx("div", { className: "arkynGoogleMapPinnedEmpty " + r, ...o, children: /* @__PURE__ */ x.jsx(dw, {}) });
}
function U2({
  onChange: t,
  onPlaceChanged: e,
  options: n,
  ...r
}) {
  const [o, i] = B(null), a = (l) => i(l), s = () => {
    var v, h, g, p;
    const u = o.getPlaces()[0], c = u == null ? void 0 : u.address_components;
    function d(w) {
      const b = c.find((k) => k.types[0] === w);
      return b ? b.long_name : "";
    }
    function f(w) {
      const b = c.find((k) => k.types[0] === w);
      return b ? b.short_name : "";
    }
    if (u) {
      const w = d("route"), b = d("street_number"), k = d("sublocality_level_1"), E = d("administrative_area_level_2"), m = d("administrative_area_level_1"), O = f("administrative_area_level_1"), S = d("postal_code"), W = (h = (v = u.geometry) == null ? void 0 : v.location) == null ? void 0 : h.lat(), P = (p = (g = u.geometry) == null ? void 0 : g.location) == null ? void 0 : p.lng();
      e && e({
        street: w,
        city: E,
        state: m,
        district: k,
        cep: S,
        streetNumber: b,
        stateShortName: O,
        coordinates: { lat: W, lng: P }
      });
    }
  };
  return /* @__PURE__ */ x.jsx(
    NC,
    {
      onLoad: a,
      onPlacesChanged: s,
      options: n,
      children: /* @__PURE__ */ x.jsx(Rs, { type: "text", onChange: (l) => t(l.target.value), ...r })
    }
  );
}
function HC(t) {
  const { dataLayer: e, dataLayerName: n } = t;
  return `
  window.${n} = window.${n} || [];
  window.${n}.push(${JSON.stringify(e)})`;
}
function VN(t) {
  const { id: e, events: n, dataLayer: r, dataLayerName: o, preview: i, auth: a } = t, s = `&gtm_auth=${a}`, l = `&gtm_preview=${i}`;
  e || console.warn("GTM Id is required");
  const u = `
    <iframe src="https://www.googletagmanager.com/ns.html?id=${e}${s}${l}&gtm_cookies_win=x"
      height="0" width="0" style="display:none;visibility:hidden" id="tag-manager"></iframe>`, c = `
    (function(w,d,s,l,i){w[l]=w[l]||[];
      w[l].push({'gtm.start': new Date().getTime(),event:'gtm.js', ${JSON.stringify(
    n
  ).slice(1, -1)}});
      var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';
      j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl+'${s}${l}&gtm_cookies_win=x';
      f.parentNode.insertBefore(j,f);
    })(window,document,'script','${o}','${e}');`, d = HC({ dataLayer: r, dataLayerName: o });
  return {
    iframe: u,
    script: c,
    dataLayerVar: d
  };
}
let qN = class {
  initializeDataScript(e) {
    const n = document.createElement("script");
    return n.innerHTML = e, n;
  }
  initializeGTMElements(e) {
    const n = VN(e), r = () => {
      const a = document.createElement("noscript");
      return a.innerHTML = n.iframe, a;
    }, o = () => {
      const a = document.createElement("script");
      return a.innerHTML = n.script, a;
    }, i = this.initializeDataScript(n.dataLayerVar);
    return {
      noScript: r,
      script: o,
      dataScript: i
    };
  }
  initializeDataLayer(e) {
    const { dataLayer: n, dataLayerName: r } = e;
    if (window[r]) return window[r].push(n);
    const o = HC({ dataLayer: n, dataLayerName: r }), i = this.initializeDataScript(o);
    document.head.insertBefore(i, document.head.childNodes[0]);
  }
  initialize(e) {
    const {
      events: n,
      gtmId: r,
      dataLayer: o,
      auth: i = "",
      preview: a = "",
      dataLayerName: s = "dataLayer"
    } = e, l = this.initializeGTMElements({
      id: r,
      events: n,
      dataLayer: o || void 0,
      dataLayerName: s,
      auth: i,
      preview: a
    });
    o && document.head.appendChild(l.dataScript), document.head.insertBefore(l.script(), document.head.childNodes[0]), document.body.insertBefore(l.noScript(), document.body.childNodes[0]);
  }
};
function GN(t) {
  return new qN().initialize(t), /* @__PURE__ */ x.jsx(x.Fragment, {});
}
function H2(t) {
  const {
    gtmId: e,
    auth: n = "",
    preview: r = "",
    dataLayerName: o = "dataLayer",
    events: i = {},
    dataLayer: a = {}
  } = t;
  return /* @__PURE__ */ x.jsx(HN, { children: () => /* @__PURE__ */ x.jsx(
    GN,
    {
      auth: n,
      dataLayer: a,
      dataLayerName: o,
      events: i,
      gtmId: e,
      preview: r
    }
  ) });
}
export {
  e2 as AlertContainer,
  t2 as AlertContent,
  n2 as AlertDescription,
  r2 as AlertIcon,
  vw as AlertTitle,
  v2 as AudioUpload,
  s2 as Badge,
  L2 as BreadcrumbContainer,
  S2 as BreadcrumbLink,
  za as Button,
  l2 as Card,
  m2 as Checkbox,
  HN as ClientOnly,
  u2 as Divider,
  k2 as DrawerContainer,
  M2 as DrawerHeader,
  _2 as DrawerProvider,
  ug as FormController,
  y2 as FormError,
  cg as FormLabel,
  z2 as GoogleMap,
  R2 as GoogleProvider,
  U2 as GoogleSearchPlaces,
  H2 as GoogleTagManager,
  oB as IconButton,
  cB as ImageUpload,
  Rs as Input,
  Kj as ModalContainer,
  Yj as ModalFooter,
  Xj as ModalHeader,
  N2 as ModalProvider,
  b2 as MultiSelect,
  P2 as Pagination,
  B2 as Popover,
  w2 as RadioBox,
  C2 as RadioGroup,
  E2 as RichText,
  D2 as Select,
  c2 as Skeleton,
  tB as Slider,
  O2 as Switch,
  Yg as TabButton,
  Qj as TabContainer,
  d2 as TableBody,
  f2 as TableCaption,
  p2 as TableContainer,
  h2 as TableFooter,
  g2 as TableHeader,
  x2 as Textarea,
  T2 as Toast,
  $2 as ToastProvider,
  iB as Tooltip,
  o2 as getHtmlFromRichTextValue,
  i2 as getRichTextValueFromHtml,
  a2 as isHtml,
  Ry as morpheme,
  A2 as useAutomation,
  j2 as useDrawer,
  i0 as useFieldErrors,
  dn as useFormController,
  pI as useHydrated,
  F2 as useModal,
  J0 as useScopedParams,
  dI as useToast
};
